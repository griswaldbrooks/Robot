   1               		.file	"Axon.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 145               	.global	PWM_Init_timer1_LED
 147               	PWM_Init_timer1_LED:
 149               	.Ltext1:
   1:pwm.c         **** /****************************************************************************
   2:pwm.c         **** *
   3:pwm.c         **** *   Copyright (c) 2008 www.societyofrobots.com
   4:pwm.c         **** *   (please link back if you use this code!)
   5:pwm.c         **** *
   6:pwm.c         **** *   This program is free software; you can redistribute it and/or modify
   7:pwm.c         **** *   it under the terms of the GNU General Public License version 2 as
   8:pwm.c         **** *   published by the Free Software Foundation.
   9:pwm.c         **** *
  10:pwm.c         **** *   Alternatively, this software may be distributed under the terms of BSD
  11:pwm.c         **** *   license.
  12:pwm.c         **** *
  13:pwm.c         **** *	This timerx8.c file has been heavily modified by SoR, but original
  14:pwm.c         **** *	documentation has been left alone
  15:pwm.c         **** *
  16:pwm.c         **** ****************************************************************************/
  17:pwm.c         **** //*****************************************************************************
  18:pwm.c         **** //
  19:pwm.c         **** // File Name	: 'timerx8.c'
  20:pwm.c         **** // Title		: Timer function library for ATmegaXX8 Processors
  21:pwm.c         **** // Author		: Pascal Stang - Copyright (C) 2000-2005
  22:pwm.c         **** // Created		: 11/22/2000
  23:pwm.c         **** // Revised		: 06/15/2005
  24:pwm.c         **** // Version		: 1.0
  25:pwm.c         **** // Target MCU	: Atmel AVR Series
  26:pwm.c         **** // Editor Tabs	: 4
  27:pwm.c         **** //
  28:pwm.c         **** // This code is distributed under the GNU Public License
  29:pwm.c         **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  30:pwm.c         **** //
  31:pwm.c         **** //*****************************************************************************
  32:pwm.c         **** 
  33:pwm.c         **** /*
  34:pwm.c         **** Two 8-bit Timer/Counters with Separate Prescaler and Compare Mode
  35:pwm.c         **** Four 16-bit Timer/Counter with Separate Prescaler, Compare- and Capture Mode
  36:pwm.c         **** */
  37:pwm.c         **** 
  38:pwm.c         **** #include <avr/io.h>
  39:pwm.c         **** #include <avr/interrupt.h>
  40:pwm.c         **** #include <avr/pgmspace.h>
  41:pwm.c         **** #include <avr/sleep.h>
  42:pwm.c         **** 
  43:pwm.c         **** #include "global.h"
  44:pwm.c         **** #include "pwm.h"
  45:pwm.c         **** #include "rprintf.h"
  46:pwm.c         **** 
  47:pwm.c         **** 
  48:pwm.c         **** 
  49:pwm.c         **** /*
  50:pwm.c         **** ATmega640: Four 8-bit PWM Channels, Six/Twelve PWM
  51:pwm.c         **** Channels with Programmable Resolution from 2 to 16 Bits
  52:pwm.c         **** 
  53:pwm.c         **** 
  54:pwm.c         **** PWM pins on Axon:
  55:pwm.c         **** OC0A  B7 (not connected)
  56:pwm.c         **** OC0B  G5 (attached to button)
  57:pwm.c         **** OC1A  B5 (not connected)
  58:pwm.c         **** OC1B  B6 (attached to green LED)
  59:pwm.c         **** OC1C  B7 (not connected)
  60:pwm.c         **** OC2A  B4 (not connected)
  61:pwm.c         **** OC2B  H6
  62:pwm.c         **** OC3A  E3
  63:pwm.c         **** OC3B  E4
  64:pwm.c         **** OC3C  E5
  65:pwm.c         **** OC4A  H3
  66:pwm.c         **** OC4B  H4
  67:pwm.c         **** OC4C  H5
  68:pwm.c         **** OC5A  L3 (not connected)
  69:pwm.c         **** OC5B  L4 (not connected)
  70:pwm.c         **** OC5C  L5 (not connected)
  71:pwm.c         **** 
  72:pwm.c         **** explainations/examples:
  73:pwm.c         **** http://www.societyofrobots.com/robotforum/index.php?topic=1827.0
  74:pwm.c         **** http://www.societyofrobots.com/robotforum/index.php?topic=5590.0
  75:pwm.c         **** 
  76:pwm.c         **** If you use this, then you cannot use the associated timers for other things.
  77:pwm.c         **** H6 	 uses timer2
  78:pwm.c         **** E3-5 uses timer3
  79:pwm.c         **** H3-5 uses timer4
  80:pwm.c         **** Unfortunately, the 3 pins that use timer5 are not connected on the Axon board, so they are
  81:pwm.c         **** not available for PWM. The upside is that timer5 is available for other use without interference.
  82:pwm.c         **** 
  83:pwm.c         **** OCR is the PWM on from 0, while ICR is the total PWM length
  84:pwm.c         **** 
  85:pwm.c         **** |----|___________________
  86:pwm.c         ****   OCR
  87:pwm.c         ****   		  ICR
  88:pwm.c         **** 
  89:pwm.c         **** to calculate PWM: (desired ICR time, seconds)*(clock frequency, 1/seconds)/prescaler = TOP
  90:pwm.c         **** TOP=TOP/2 if using phase and frequency correct mode
  91:pwm.c         **** 
  92:pwm.c         **** adjust the duty cycle of the output pin by setting OCR1A to a value between 0 and ICR1
  93:pwm.c         **** 
  94:pwm.c         **** PWM tutorial: http://www.societyofrobots.com/member_tutorials/node/228
  95:pwm.c         **** */
  96:pwm.c         **** 
  97:pwm.c         **** //tested and working: H3, H6
  98:pwm.c         **** 
  99:pwm.c         **** //OC1B  pin B6 (attached to green LED)
 100:pwm.c         **** void PWM_Init_timer1_LED(u08 bitRes)
 101:pwm.c         **** {
 150               		push __tmp_reg__
 151               		in r28,__SP_L__
 152               		in r29,__SP_H__
 153 0000 DF93      	/* prologue: function */
 154 0002 CF93      	/* frame size = 1 */
 155 0004 0F92      		std Y+1,r24
 157 0008 DEB7      	.LM1:
 158               		ldd r24,Y+1
 159               		cpi r24,lo8(9)
 160 000a 8983      		brne .L2
 102:pwm.c         **** 	// enable timer2 as 8,9,10bit PWM
 103:pwm.c         **** 	if(bitRes == 9)
 161               	0,105,.LM2-.LFBB1
 162               	.LM2:
 163 000c 8981      		ldi r26,lo8(128)
 164 000e 8930      		ldi r27,hi8(128)
 165 0010 01F4      		ldi r30,lo8(128)
 104:pwm.c         **** 	{	// 9bit mode
 105:pwm.c         **** 		sbi(TCCR1A,PWM11);
 166               	r31,hi8(128)
 167               		ld r24,Z
 168 0012 A0E8      		ori r24,lo8(2)
 169 0014 B0E0      		st X,r24
 171 0018 F0E0      	.LM3:
 172 001a 8081      		ldi r26,lo8(128)
 173 001c 8260      		ldi r27,hi8(128)
 174 001e 8C93      		ldi r30,lo8(128)
 106:pwm.c         **** 		cbi(TCCR1A,PWM10);
 175               	hi8(128)
 176               		ld r24,Z
 177 0020 A0E8      		andi r24,lo8(-2)
 178 0022 B0E0      		st X,r24
 179 0024 E0E8      		rjmp .L3
 180 0026 F0E0      	.L2:
 182 002a 8E7F      	.LM4:
 183 002c 8C93      		ldd r24,Y+1
 184 002e 00C0      		cpi r24,lo8(10)
 185               		brne .L4
 107:pwm.c         **** 	}
 108:pwm.c         **** 	else if( bitRes == 10 )
 186               	0,110,.LM5-.LFBB1
 187               	.LM5:
 188 0030 8981      		ldi r26,lo8(128)
 189 0032 8A30      		ldi r27,hi8(128)
 190 0034 01F4      		ldi r30,lo8(128)
 109:pwm.c         **** 	{	// 10bit mode
 110:pwm.c         **** 		sbi(TCCR1A,PWM11);
 191               	r31,hi8(128)
 192               		ld r24,Z
 193 0036 A0E8      		ori r24,lo8(2)
 194 0038 B0E0      		st X,r24
 196 003c F0E0      	.LM6:
 197 003e 8081      		ldi r26,lo8(128)
 198 0040 8260      		ldi r27,hi8(128)
 199 0042 8C93      		ldi r30,lo8(128)
 111:pwm.c         **** 		sbi(TCCR1A,PWM10);
 200               	hi8(128)
 201               		ld r24,Z
 202 0044 A0E8      		ori r24,lo8(1)
 203 0046 B0E0      		st X,r24
 204 0048 E0E8      		rjmp .L3
 205 004a F0E0      	.L4:
 207 004e 8160      	.LM7:
 208 0050 8C93      		ldi r26,lo8(128)
 209 0052 00C0      		ldi r27,hi8(128)
 210               		ldi r30,lo8(128)
 112:pwm.c         **** 	}
 113:pwm.c         **** 	else
 114:pwm.c         **** 	{	// default 8bit mode
 115:pwm.c         **** 		cbi(TCCR1A,PWM11);
 211               	8(128)
 212               		ld r24,Z
 213 0054 A0E8      		andi r24,lo8(-3)
 214 0056 B0E0      		st X,r24
 216 005a F0E0      	.LM8:
 217 005c 8081      		ldi r26,lo8(128)
 218 005e 8D7F      		ldi r27,hi8(128)
 219 0060 8C93      		ldi r30,lo8(128)
 116:pwm.c         **** 		sbi(TCCR1A,PWM10);
 220               	hi8(128)
 221               		ld r24,Z
 222 0062 A0E8      		ori r24,lo8(1)
 223 0064 B0E0      		st X,r24
 224 0066 E0E8      	.L3:
 226 006a 8081      	.LM9:
 227 006c 8160      		ldi r30,lo8(138)
 228 006e 8C93      		ldi r31,hi8(138)
 229               		std Z+1,__zero_reg__
 117:pwm.c         **** 	}
 118:pwm.c         **** 	// clear output compare values
 119:pwm.c         **** 	OCR1B = 0;
 230               	ro_reg__
 231               	/* epilogue start */
 233 0072 F0E0      	.LM10:
 234 0074 1182      		pop __tmp_reg__
 235 0076 1082      		pop r28
 236               		pop r29
 120:pwm.c         **** }
 237               	size	PWM_Init_timer1_LED, .-PWM_Init_timer1_LED
 238               	.Lscope1:
 241 007c DF91      	.global	PWM_Init_timer2_H6
 243               	PWM_Init_timer2_H6:
 245               	.LM11:
 246               	.LFBB2:
 247               		push r29
 248               		push r28
 249               		push __tmp_reg__
 121:pwm.c         **** //pin H6, timer2
 122:pwm.c         **** void PWM_Init_timer2_H6(u08 bitRes)
 123:pwm.c         **** {
 250               	L__
 251               		in r29,__SP_H__
 252               	/* prologue: function */
 253 0080 DF93      	/* frame size = 1 */
 254 0082 CF93      		std Y+1,r24
 256 0086 CDB7      	.LM12:
 257 0088 DEB7      		ldd r24,Y+1
 258               		cpi r24,lo8(9)
 259               		brne .L7
 124:pwm.c         **** 	// enable timer2 as 8,9,10bit PWM
 125:pwm.c         **** 	if(bitRes == 9)
 261               	 r26,lo8(176)
 262               		ldi r27,hi8(176)
 263 008c 8981      		ldi r30,lo8(176)
 264 008e 8930      		ldi r31,hi8(176)
 265 0090 01F4      		ld r24,Z
 126:pwm.c         **** 	{	// 9bit mode
 127:pwm.c         **** 		sbi(TCCR2A,PWM11);
 266               	r24,lo8(2)
 267               		st X,r24
 269 0094 B0E0      	.LM14:
 270 0096 E0EB      		ldi r26,lo8(176)
 271 0098 F0E0      		ldi r27,hi8(176)
 272 009a 8081      		ldi r30,lo8(176)
 273 009c 8260      		ldi r31,hi8(176)
 274 009e 8C93      		ld r24,Z
 128:pwm.c         **** 		cbi(TCCR2A,PWM10);
 275               	,lo8(-2)
 276               		st X,r24
 277 00a0 A0EB      		rjmp .L8
 278 00a2 B0E0      	.L7:
 280 00a6 F0E0      	.LM15:
 281 00a8 8081      		ldd r24,Y+1
 282 00aa 8E7F      		cpi r24,lo8(10)
 283 00ac 8C93      		brne .L9
 285               	.LM16:
 129:pwm.c         **** 	}
 130:pwm.c         **** 	else if( bitRes == 10 )
 286               	8(176)
 287               		ldi r27,hi8(176)
 288 00b0 8981      		ldi r30,lo8(176)
 289 00b2 8A30      		ldi r31,hi8(176)
 290 00b4 01F4      		ld r24,Z
 131:pwm.c         **** 	{	// 10bit mode
 132:pwm.c         **** 		sbi(TCCR2A,PWM11);
 291               	r24,lo8(2)
 292               		st X,r24
 294 00b8 B0E0      	.LM17:
 295 00ba E0EB      		ldi r26,lo8(176)
 296 00bc F0E0      		ldi r27,hi8(176)
 297 00be 8081      		ldi r30,lo8(176)
 298 00c0 8260      		ldi r31,hi8(176)
 299 00c2 8C93      		ld r24,Z
 133:pwm.c         **** 		sbi(TCCR2A,PWM10);
 300               	lo8(1)
 301               		st X,r24
 302 00c4 A0EB      		rjmp .L8
 303 00c6 B0E0      	.L9:
 305 00ca F0E0      	.LM18:
 306 00cc 8081      		ldi r26,lo8(176)
 307 00ce 8160      		ldi r27,hi8(176)
 308 00d0 8C93      		ldi r30,lo8(176)
 309 00d2 00C0      		ldi r31,hi8(176)
 310               		ld r24,Z
 134:pwm.c         **** 	}
 135:pwm.c         **** 	else
 136:pwm.c         **** 	{	// default 8bit mode
 137:pwm.c         **** 		cbi(TCCR2A,PWM11);
 311               	o8(-3)
 312               		st X,r24
 314 00d6 B0E0      	.LM19:
 315 00d8 E0EB      		ldi r26,lo8(176)
 316 00da F0E0      		ldi r27,hi8(176)
 317 00dc 8081      		ldi r30,lo8(176)
 318 00de 8D7F      		ldi r31,hi8(176)
 319 00e0 8C93      		ld r24,Z
 138:pwm.c         **** 		sbi(TCCR2A,PWM10);
 320               	lo8(1)
 321               		st X,r24
 322 00e2 A0EB      	.L8:
 324 00e6 E0EB      	.LM20:
 325 00e8 F0E0      		ldi r30,lo8(180)
 326 00ea 8081      		ldi r31,hi8(180)
 327 00ec 8160      		st Z,__zero_reg__
 328 00ee 8C93      	/* epilogue start */
 139:pwm.c         **** 	}
 140:pwm.c         **** 	// clear output compare values
 141:pwm.c         **** 	OCR2B = 0;
 330               	p __tmp_reg__
 331               		pop r28
 332 00f0 E4EB      		pop r29
 333 00f2 F0E0      		ret
 335               	.Lscope2:
 142:pwm.c         **** }
 336               	s	"PWM_Init_timer3_E3:F(0,15)",36,0,0,PWM_Init_timer3_E3
 338 00f6 0F90      	.global	PWM_Init_timer3_E3
 340 00fa DF91      	PWM_Init_timer3_E3:
 342               	.LM22:
 343               	.LFBB3:
 344               		push r29
 345               		push r28
 346               		push __tmp_reg__
 347               		in r28,__SP_L__
 348               		in r29,__SP_H__
 143:pwm.c         **** //pin E3
 144:pwm.c         **** void PWM_Init_timer3_E3(u08 bitRes)
 145:pwm.c         **** {
 349               	function */
 350               	/* frame size = 1 */
 351               		std Y+1,r24
 353 0100 CF93      	.LM23:
 354 0102 0F92      		ldd r24,Y+1
 355 0104 CDB7      		cpi r24,lo8(9)
 356 0106 DEB7      		brne .L12
 358               	.LM24:
 359 0108 8983      		ldi r26,lo8(144)
 146:pwm.c         **** 	// enable timer3 as 8,9,10bit PWM
 147:pwm.c         **** 	if(bitRes == 9)
 360               	8(144)
 361               		ldi r30,lo8(144)
 362 010a 8981      		ldi r31,hi8(144)
 363 010c 8930      		ld r24,Z
 364 010e 01F4      		ori r24,lo8(2)
 148:pwm.c         **** 	{	// 9bit mode
 149:pwm.c         **** 		sbi(TCCR3A,PWM11);
 365               	,r24
 367 0110 A0E9      	.LM25:
 368 0112 B0E0      		ldi r26,lo8(144)
 369 0114 E0E9      		ldi r27,hi8(144)
 370 0116 F0E0      		ldi r30,lo8(144)
 371 0118 8081      		ldi r31,hi8(144)
 372 011a 8260      		ld r24,Z
 373 011c 8C93      		andi r24,lo8(-2)
 150:pwm.c         **** 		cbi(TCCR3A,PWM10);
 374               	
 375               		rjmp .L13
 376 011e A0E9      	.L12:
 378 0122 E0E9      	.LM26:
 379 0124 F0E0      		ldd r24,Y+1
 380 0126 8081      		cpi r24,lo8(10)
 381 0128 8E7F      		brne .L14
 383 012c 00C0      	.LM27:
 384               		ldi r26,lo8(144)
 151:pwm.c         **** 	}
 152:pwm.c         **** 	else if( bitRes == 10 )
 385               	i8(144)
 386               		ldi r30,lo8(144)
 387 012e 8981      		ldi r31,hi8(144)
 388 0130 8A30      		ld r24,Z
 389 0132 01F4      		ori r24,lo8(2)
 153:pwm.c         **** 	{	// 10bit mode
 154:pwm.c         **** 		sbi(TCCR3A,PWM11);
 390               	,r24
 392 0134 A0E9      	.LM28:
 393 0136 B0E0      		ldi r26,lo8(144)
 394 0138 E0E9      		ldi r27,hi8(144)
 395 013a F0E0      		ldi r30,lo8(144)
 396 013c 8081      		ldi r31,hi8(144)
 397 013e 8260      		ld r24,Z
 398 0140 8C93      		ori r24,lo8(1)
 155:pwm.c         **** 		sbi(TCCR3A,PWM10);
 399               	
 400               		rjmp .L13
 401 0142 A0E9      	.L14:
 403 0146 E0E9      	.LM29:
 404 0148 F0E0      		ldi r26,lo8(144)
 405 014a 8081      		ldi r27,hi8(144)
 406 014c 8160      		ldi r30,lo8(144)
 407 014e 8C93      		ldi r31,hi8(144)
 408 0150 00C0      		ld r24,Z
 409               		andi r24,lo8(-3)
 156:pwm.c         **** 	}
 157:pwm.c         **** 	else
 158:pwm.c         **** 	{	// default 8bit mode
 159:pwm.c         **** 		cbi(TCCR3A,PWM11);
 411               	.LM30:
 412 0152 A0E9      		ldi r26,lo8(144)
 413 0154 B0E0      		ldi r27,hi8(144)
 414 0156 E0E9      		ldi r30,lo8(144)
 415 0158 F0E0      		ldi r31,hi8(144)
 416 015a 8081      		ld r24,Z
 417 015c 8D7F      		ori r24,lo8(1)
 418 015e 8C93      		st X,r24
 160:pwm.c         **** 		sbi(TCCR3A,PWM10);
 419               	tabn	68,0,163,.LM31-.LFBB3
 420               	.LM31:
 421 0160 A0E9      		ldi r30,lo8(152)
 422 0162 B0E0      		ldi r31,hi8(152)
 423 0164 E0E9      		std Z+1,__zero_reg__
 424 0166 F0E0      		st Z,__zero_reg__
 425 0168 8081      	/* epilogue start */
 427 016c 8C93      	.LM32:
 428               		pop __tmp_reg__
 161:pwm.c         **** 	}
 162:pwm.c         **** 	// clear output compare values
 163:pwm.c         **** 	OCR3A = 0;
 429               	pop r29
 430               		ret
 432 0170 F0E0      	.Lscope3:
 435               	.global	PWM_Init_timer3_E4
 164:pwm.c         **** 	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
 165:pwm.c         **** }
 436               	PWM_Init_timer3_E4, @function
 437               	PWM_Init_timer3_E4:
 439 0178 CF91      	.LM33:
 440 017a DF91      	.LFBB4:
 441 017c 0895      		push r29
 442               		push r28
 443               		push __tmp_reg__
 444               		in r28,__SP_L__
 445               		in r29,__SP_H__
 446               	/* prologue: function */
 447               	/* frame size = 1 */
 448               		std Y+1,r24
 166:pwm.c         **** //pin E4
 167:pwm.c         **** void PWM_Init_timer3_E4(u08 bitRes)
 168:pwm.c         **** {
 449               	170,.LM34-.LFBB4
 450               	.LM34:
 451               		ldd r24,Y+1
 452 017e DF93      		cpi r24,lo8(9)
 453 0180 CF93      		brne .L17
 455 0184 CDB7      	.LM35:
 456 0186 DEB7      		ldi r26,lo8(145)
 457               		ldi r27,hi8(145)
 458               		ldi r30,lo8(145)
 459 0188 8983      		ldi r31,hi8(145)
 169:pwm.c         **** 	// enable timer3 as 8,9,10bit PWM
 170:pwm.c         **** 	if(bitRes == 9)
 460               	ori r24,lo8(2)
 461               		st X,r24
 463 018c 8930      	.LM36:
 464 018e 01F4      		ldi r26,lo8(145)
 171:pwm.c         **** 	{	// 9bit mode
 172:pwm.c         **** 		sbi(TCCR3B,PWM11);
 465               	r27,hi8(145)
 466               		ldi r30,lo8(145)
 467 0190 A1E9      		ldi r31,hi8(145)
 468 0192 B0E0      		ld r24,Z
 469 0194 E1E9      		andi r24,lo8(-2)
 470 0196 F0E0      		st X,r24
 471 0198 8081      		rjmp .L18
 472 019a 8260      	.L17:
 173:pwm.c         **** 		cbi(TCCR3B,PWM10);
 474               	dd r24,Y+1
 475               		cpi r24,lo8(10)
 476 019e A1E9      		brne .L19
 478 01a2 E1E9      	.LM38:
 479 01a4 F0E0      		ldi r26,lo8(145)
 480 01a6 8081      		ldi r27,hi8(145)
 481 01a8 8E7F      		ldi r30,lo8(145)
 482 01aa 8C93      		ldi r31,hi8(145)
 483 01ac 00C0      		ld r24,Z
 484               		ori r24,lo8(2)
 174:pwm.c         **** 	}
 175:pwm.c         **** 	else if( bitRes == 10 )
 486               	.LM39:
 487 01ae 8981      		ldi r26,lo8(145)
 488 01b0 8A30      		ldi r27,hi8(145)
 489 01b2 01F4      		ldi r30,lo8(145)
 176:pwm.c         **** 	{	// 10bit mode
 177:pwm.c         **** 		sbi(TCCR3B,PWM11);
 490               	r31,hi8(145)
 491               		ld r24,Z
 492 01b4 A1E9      		ori r24,lo8(1)
 493 01b6 B0E0      		st X,r24
 494 01b8 E1E9      		rjmp .L18
 495 01ba F0E0      	.L19:
 497 01be 8260      	.LM40:
 498 01c0 8C93      		ldi r26,lo8(145)
 178:pwm.c         **** 		sbi(TCCR3B,PWM10);
 499               	hi8(145)
 500               		ldi r30,lo8(145)
 501 01c2 A1E9      		ldi r31,hi8(145)
 502 01c4 B0E0      		ld r24,Z
 503 01c6 E1E9      		andi r24,lo8(-3)
 504 01c8 F0E0      		st X,r24
 506 01cc 8160      	.LM41:
 507 01ce 8C93      		ldi r26,lo8(145)
 508 01d0 00C0      		ldi r27,hi8(145)
 509               		ldi r30,lo8(145)
 179:pwm.c         **** 	}
 180:pwm.c         **** 	else
 181:pwm.c         **** 	{	// default 8bit mode
 182:pwm.c         **** 		cbi(TCCR3B,PWM11);
 510               	8(145)
 511               		ld r24,Z
 512 01d2 A1E9      		ori r24,lo8(1)
 513 01d4 B0E0      		st X,r24
 514 01d6 E1E9      	.L18:
 516 01da 8081      	.LM42:
 517 01dc 8D7F      		ldi r30,lo8(154)
 518 01de 8C93      		ldi r31,hi8(154)
 183:pwm.c         **** 		sbi(TCCR3B,PWM10);
 519               	__zero_reg__
 520               		st Z,__zero_reg__
 521 01e0 A1E9      	/* epilogue start */
 523 01e4 E1E9      	.LM43:
 524 01e6 F0E0      		pop __tmp_reg__
 525 01e8 8081      		pop r28
 526 01ea 8160      		pop r29
 527 01ec 8C93      		ret
 184:pwm.c         **** 	}
 185:pwm.c         **** 	// clear output compare values
 186:pwm.c         **** 	OCR3B = 0;
 531 01ee EAE9      	.global	PWM_Init_timer3_E5
 533 01f2 1182      	PWM_Init_timer3_E5:
 535               	.LM44:
 187:pwm.c         **** 	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
 188:pwm.c         **** }
 536               	
 537               		push r29
 538 01f6 0F90      		push r28
 539 01f8 CF91      		push __tmp_reg__
 540 01fa DF91      		in r28,__SP_L__
 541 01fc 0895      		in r29,__SP_H__
 542               	/* prologue: function */
 543               	/* frame size = 1 */
 544               		std Y+1,r24
 546               	.LM45:
 547               		ldd r24,Y+1
 548               		cpi r24,lo8(9)
 189:pwm.c         **** //pin E5
 190:pwm.c         **** void PWM_Init_timer3_E5(u08 bitRes)
 191:pwm.c         **** {
 550               	.LM46:
 551               		ldi r26,lo8(146)
 552 01fe DF93      		ldi r27,hi8(146)
 553 0200 CF93      		ldi r30,lo8(146)
 554 0202 0F92      		ldi r31,hi8(146)
 555 0204 CDB7      		ld r24,Z
 556 0206 DEB7      		ori r24,lo8(2)
 557               		st X,r24
 559 0208 8983      	.LM47:
 192:pwm.c         **** 	// enable timer3 as 8,9,10bit PWM
 193:pwm.c         **** 	if(bitRes == 9)
 560               	8(146)
 561               		ldi r27,hi8(146)
 562 020a 8981      		ldi r30,lo8(146)
 563 020c 8930      		ldi r31,hi8(146)
 564 020e 01F4      		ld r24,Z
 194:pwm.c         **** 	{	// 9bit mode
 195:pwm.c         **** 		sbi(TCCR3C,PWM11);
 565               	 r24,lo8(-2)
 566               		st X,r24
 567 0210 A2E9      		rjmp .L23
 568 0212 B0E0      	.L22:
 570 0216 F0E0      	.LM48:
 571 0218 8081      		ldd r24,Y+1
 572 021a 8260      		cpi r24,lo8(10)
 573 021c 8C93      		brne .L24
 196:pwm.c         **** 		cbi(TCCR3C,PWM10);
 574               	8,0,200,.LM49-.LFBB5
 575               	.LM49:
 576 021e A2E9      		ldi r26,lo8(146)
 577 0220 B0E0      		ldi r27,hi8(146)
 578 0222 E2E9      		ldi r30,lo8(146)
 579 0224 F0E0      		ldi r31,hi8(146)
 580 0226 8081      		ld r24,Z
 581 0228 8E7F      		ori r24,lo8(2)
 582 022a 8C93      		st X,r24
 584               	.LM50:
 197:pwm.c         **** 	}
 198:pwm.c         **** 	else if( bitRes == 10 )
 585               	8(146)
 586               		ldi r27,hi8(146)
 587 022e 8981      		ldi r30,lo8(146)
 588 0230 8A30      		ldi r31,hi8(146)
 589 0232 01F4      		ld r24,Z
 199:pwm.c         **** 	{	// 10bit mode
 200:pwm.c         **** 		sbi(TCCR3C,PWM11);
 590               	r24,lo8(1)
 591               		st X,r24
 592 0234 A2E9      		rjmp .L23
 593 0236 B0E0      	.L24:
 595 023a F0E0      	.LM51:
 596 023c 8081      		ldi r26,lo8(146)
 597 023e 8260      		ldi r27,hi8(146)
 598 0240 8C93      		ldi r30,lo8(146)
 201:pwm.c         **** 		sbi(TCCR3C,PWM10);
 599               	hi8(146)
 600               		ld r24,Z
 601 0242 A2E9      		andi r24,lo8(-3)
 602 0244 B0E0      		st X,r24
 604 0248 F0E0      	.LM52:
 605 024a 8081      		ldi r26,lo8(146)
 606 024c 8160      		ldi r27,hi8(146)
 607 024e 8C93      		ldi r30,lo8(146)
 608 0250 00C0      		ldi r31,hi8(146)
 609               		ld r24,Z
 202:pwm.c         **** 	}
 203:pwm.c         **** 	else
 204:pwm.c         **** 	{	// default 8bit mode
 205:pwm.c         **** 		cbi(TCCR3C,PWM11);
 610               	8(1)
 611               		st X,r24
 612 0252 A2E9      	.L23:
 614 0256 E2E9      	.LM53:
 615 0258 F0E0      		ldi r30,lo8(156)
 616 025a 8081      		ldi r31,hi8(156)
 617 025c 8D7F      		std Z+1,__zero_reg__
 618 025e 8C93      		st Z,__zero_reg__
 206:pwm.c         **** 		sbi(TCCR3C,PWM10);
 619               	ue start */
 621 0260 A2E9      	.LM54:
 622 0262 B0E0      		pop __tmp_reg__
 623 0264 E2E9      		pop r28
 624 0266 F0E0      		pop r29
 625 0268 8081      		ret
 627 026c 8C93      	.Lscope5:
 207:pwm.c         **** 	}
 208:pwm.c         **** 	// clear output compare values
 209:pwm.c         **** 	OCR3C = 0;
 629               	itRes:p(15,1)",160,0,0,1
 630               	.global	PWM_Init_timer4_H3
 632 0270 F0E0      	PWM_Init_timer4_H3:
 634 0274 1082      	.LM55:
 635               	.LFBB6:
 210:pwm.c         **** 	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
 211:pwm.c         **** }
 636               	29
 637               		push r28
 638 0276 0F90      		push __tmp_reg__
 639 0278 CF91      		in r28,__SP_L__
 640 027a DF91      		in r29,__SP_H__
 641 027c 0895      	/* prologue: function */
 642               	/* frame size = 1 */
 643               		std Y+1,r24
 645               	.LM56:
 646               		ldd r24,Y+1
 647               		cpi r24,lo8(9)
 648               		brne .L27
 212:pwm.c         **** //pin H3, timer4
 213:pwm.c         **** void PWM_Init_timer4_H3(u08 bitRes)
 214:pwm.c         **** {
 649               	218,.LM57-.LFBB6
 650               	.LM57:
 651               		ldi r26,lo8(160)
 652 027e DF93      		ldi r27,hi8(160)
 653 0280 CF93      		ldi r30,lo8(160)
 654 0282 0F92      		ldi r31,hi8(160)
 655 0284 CDB7      		ld r24,Z
 656 0286 DEB7      		ori r24,lo8(2)
 657               		st X,r24
 659 0288 8983      	.LM58:
 215:pwm.c         **** 	// enable timer4 as 8,9,10bit PWM
 216:pwm.c         **** 	if(bitRes == 9)
 660               	8(160)
 661               		ldi r27,hi8(160)
 662 028a 8981      		ldi r30,lo8(160)
 663 028c 8930      		ldi r31,hi8(160)
 664 028e 01F4      		ld r24,Z
 217:pwm.c         **** 	{	// 9bit mode
 218:pwm.c         **** 		sbi(TCCR4A,PWM11);
 665               	 r24,lo8(-2)
 666               		st X,r24
 667 0290 A0EA      		rjmp .L28
 668 0292 B0E0      	.L27:
 670 0296 F0E0      	.LM59:
 671 0298 8081      		ldd r24,Y+1
 672 029a 8260      		cpi r24,lo8(10)
 673 029c 8C93      		brne .L29
 219:pwm.c         **** 		cbi(TCCR4A,PWM10);
 674               	8,0,223,.LM60-.LFBB6
 675               	.LM60:
 676 029e A0EA      		ldi r26,lo8(160)
 677 02a0 B0E0      		ldi r27,hi8(160)
 678 02a2 E0EA      		ldi r30,lo8(160)
 679 02a4 F0E0      		ldi r31,hi8(160)
 680 02a6 8081      		ld r24,Z
 681 02a8 8E7F      		ori r24,lo8(2)
 682 02aa 8C93      		st X,r24
 684               	.LM61:
 220:pwm.c         **** 	}
 221:pwm.c         **** 	else if( bitRes == 10 )
 685               	8(160)
 686               		ldi r27,hi8(160)
 687 02ae 8981      		ldi r30,lo8(160)
 688 02b0 8A30      		ldi r31,hi8(160)
 689 02b2 01F4      		ld r24,Z
 222:pwm.c         **** 	{	// 10bit mode
 223:pwm.c         **** 		sbi(TCCR4A,PWM11);
 690               	r24,lo8(1)
 691               		st X,r24
 692 02b4 A0EA      		rjmp .L28
 693 02b6 B0E0      	.L29:
 695 02ba F0E0      	.LM62:
 696 02bc 8081      		ldi r26,lo8(160)
 697 02be 8260      		ldi r27,hi8(160)
 698 02c0 8C93      		ldi r30,lo8(160)
 224:pwm.c         **** 		sbi(TCCR4A,PWM10);
 699               	hi8(160)
 700               		ld r24,Z
 701 02c2 A0EA      		andi r24,lo8(-3)
 702 02c4 B0E0      		st X,r24
 704 02c8 F0E0      	.LM63:
 705 02ca 8081      		ldi r26,lo8(160)
 706 02cc 8160      		ldi r27,hi8(160)
 707 02ce 8C93      		ldi r30,lo8(160)
 708 02d0 00C0      		ldi r31,hi8(160)
 709               		ld r24,Z
 225:pwm.c         **** 	}
 226:pwm.c         **** 	else
 227:pwm.c         **** 	{	// default 8bit mode
 228:pwm.c         **** 		cbi(TCCR4A,PWM11);
 710               	8(1)
 711               		st X,r24
 712 02d2 A0EA      	.L28:
 714 02d6 E0EA      	.LM64:
 715 02d8 F0E0      		ldi r30,lo8(168)
 716 02da 8081      		ldi r31,hi8(168)
 717 02dc 8D7F      		std Z+1,__zero_reg__
 718 02de 8C93      		st Z,__zero_reg__
 229:pwm.c         **** 		sbi(TCCR4A,PWM10);
 719               	ue start */
 721 02e0 A0EA      	.LM65:
 722 02e2 B0E0      		pop __tmp_reg__
 723 02e4 E0EA      		pop r28
 724 02e6 F0E0      		pop r29
 725 02e8 8081      		ret
 727 02ec 8C93      	.Lscope6:
 230:pwm.c         **** 	}
 231:pwm.c         **** 	// clear output compare values
 232:pwm.c         **** 	OCR4A = 0;
 729               	itRes:p(15,1)",160,0,0,1
 730               	.global	PWM_Init_timer4_H4
 732 02f0 F0E0      	PWM_Init_timer4_H4:
 734 02f4 1082      	.LM66:
 735               	.LFBB7:
 233:pwm.c         **** 	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
 234:pwm.c         **** }
 736               	29
 737               		push r28
 738 02f6 0F90      		push __tmp_reg__
 739 02f8 CF91      		in r28,__SP_L__
 740 02fa DF91      		in r29,__SP_H__
 741 02fc 0895      	/* prologue: function */
 742               	/* frame size = 1 */
 743               		std Y+1,r24
 745               	.LM67:
 746               		ldd r24,Y+1
 747               		cpi r24,lo8(9)
 748               		brne .L32
 235:pwm.c         **** //pin H4, timer4
 236:pwm.c         **** void PWM_Init_timer4_H4(u08 bitRes)
 237:pwm.c         **** {
 749               	241,.LM68-.LFBB7
 750               	.LM68:
 751               		ldi r26,lo8(161)
 752 02fe DF93      		ldi r27,hi8(161)
 753 0300 CF93      		ldi r30,lo8(161)
 754 0302 0F92      		ldi r31,hi8(161)
 755 0304 CDB7      		ld r24,Z
 756 0306 DEB7      		ori r24,lo8(2)
 757               		st X,r24
 759 0308 8983      	.LM69:
 238:pwm.c         **** 	// enable timer4 as 8,9,10bit PWM
 239:pwm.c         **** 	if(bitRes == 9)
 760               	8(161)
 761               		ldi r27,hi8(161)
 762 030a 8981      		ldi r30,lo8(161)
 763 030c 8930      		ldi r31,hi8(161)
 764 030e 01F4      		ld r24,Z
 240:pwm.c         **** 	{	// 9bit mode
 241:pwm.c         **** 		sbi(TCCR4B,PWM11);
 765               	 r24,lo8(-2)
 766               		st X,r24
 767 0310 A1EA      		rjmp .L33
 768 0312 B0E0      	.L32:
 770 0316 F0E0      	.LM70:
 771 0318 8081      		ldd r24,Y+1
 772 031a 8260      		cpi r24,lo8(10)
 773 031c 8C93      		brne .L34
 242:pwm.c         **** 		cbi(TCCR4B,PWM10);
 774               	8,0,246,.LM71-.LFBB7
 775               	.LM71:
 776 031e A1EA      		ldi r26,lo8(161)
 777 0320 B0E0      		ldi r27,hi8(161)
 778 0322 E1EA      		ldi r30,lo8(161)
 779 0324 F0E0      		ldi r31,hi8(161)
 780 0326 8081      		ld r24,Z
 781 0328 8E7F      		ori r24,lo8(2)
 782 032a 8C93      		st X,r24
 784               	.LM72:
 243:pwm.c         **** 	}
 244:pwm.c         **** 	else if( bitRes == 10 )
 785               	8(161)
 786               		ldi r27,hi8(161)
 787 032e 8981      		ldi r30,lo8(161)
 788 0330 8A30      		ldi r31,hi8(161)
 789 0332 01F4      		ld r24,Z
 245:pwm.c         **** 	{	// 10bit mode
 246:pwm.c         **** 		sbi(TCCR4B,PWM11);
 790               	r24,lo8(1)
 791               		st X,r24
 792 0334 A1EA      		rjmp .L33
 793 0336 B0E0      	.L34:
 795 033a F0E0      	.LM73:
 796 033c 8081      		ldi r26,lo8(161)
 797 033e 8260      		ldi r27,hi8(161)
 798 0340 8C93      		ldi r30,lo8(161)
 247:pwm.c         **** 		sbi(TCCR4B,PWM10);
 799               	hi8(161)
 800               		ld r24,Z
 801 0342 A1EA      		andi r24,lo8(-3)
 802 0344 B0E0      		st X,r24
 804 0348 F0E0      	.LM74:
 805 034a 8081      		ldi r26,lo8(161)
 806 034c 8160      		ldi r27,hi8(161)
 807 034e 8C93      		ldi r30,lo8(161)
 808 0350 00C0      		ldi r31,hi8(161)
 809               		ld r24,Z
 248:pwm.c         **** 	}
 249:pwm.c         **** 	else
 250:pwm.c         **** 	{	// default 8bit mode
 251:pwm.c         **** 		cbi(TCCR4B,PWM11);
 810               	8(1)
 811               		st X,r24
 812 0352 A1EA      	.L33:
 814 0356 E1EA      	.LM75:
 815 0358 F0E0      		ldi r30,lo8(170)
 816 035a 8081      		ldi r31,hi8(170)
 817 035c 8D7F      		std Z+1,__zero_reg__
 818 035e 8C93      		st Z,__zero_reg__
 252:pwm.c         **** 		sbi(TCCR4B,PWM10);
 819               	ue start */
 821 0360 A1EA      	.LM76:
 822 0362 B0E0      		pop __tmp_reg__
 823 0364 E1EA      		pop r28
 824 0366 F0E0      		pop r29
 825 0368 8081      		ret
 827 036c 8C93      	.Lscope7:
 253:pwm.c         **** 	}
 254:pwm.c         **** 	// clear output compare values
 255:pwm.c         **** 	OCR4B = 0;
 829               	itRes:p(15,1)",160,0,0,1
 830               	.global	PWM_Init_timer4_H5
 832 0370 F0E0      	PWM_Init_timer4_H5:
 834 0374 1082      	.LM77:
 835               	.LFBB8:
 256:pwm.c         **** 	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
 257:pwm.c         **** }
 836               	29
 837               		push r28
 838 0376 0F90      		push __tmp_reg__
 839 0378 CF91      		in r28,__SP_L__
 840 037a DF91      		in r29,__SP_H__
 841 037c 0895      	/* prologue: function */
 842               	/* frame size = 1 */
 843               		std Y+1,r24
 845               	.LM78:
 846               		ldd r24,Y+1
 847               		cpi r24,lo8(9)
 848               		brne .L37
 258:pwm.c         **** //pin H5, timer4
 259:pwm.c         **** void PWM_Init_timer4_H5(u08 bitRes)
 260:pwm.c         **** {
 849               	264,.LM79-.LFBB8
 850               	.LM79:
 851               		ldi r26,lo8(160)
 852 037e DF93      		ldi r27,hi8(160)
 853 0380 CF93      		ldi r30,lo8(160)
 854 0382 0F92      		ldi r31,hi8(160)
 855 0384 CDB7      		ld r24,Z
 856 0386 DEB7      		ori r24,lo8(2)
 857               		st X,r24
 859 0388 8983      	.LM80:
 261:pwm.c         **** 	// enable timer4 as 8,9,10bit PWM
 262:pwm.c         **** 	if(bitRes == 9)
 860               	8(160)
 861               		ldi r27,hi8(160)
 862 038a 8981      		ldi r30,lo8(160)
 863 038c 8930      		ldi r31,hi8(160)
 864 038e 01F4      		ld r24,Z
 263:pwm.c         **** 	{	// 9bit mode
 264:pwm.c         **** 		sbi(TCCR4A,PWM11);
 865               	 r24,lo8(-2)
 866               		st X,r24
 867 0390 A0EA      		rjmp .L38
 868 0392 B0E0      	.L37:
 870 0396 F0E0      	.LM81:
 871 0398 8081      		ldd r24,Y+1
 872 039a 8260      		cpi r24,lo8(10)
 873 039c 8C93      		brne .L39
 265:pwm.c         **** 		cbi(TCCR4A,PWM10);
 874               	8,0,269,.LM82-.LFBB8
 875               	.LM82:
 876 039e A0EA      		ldi r26,lo8(160)
 877 03a0 B0E0      		ldi r27,hi8(160)
 878 03a2 E0EA      		ldi r30,lo8(160)
 879 03a4 F0E0      		ldi r31,hi8(160)
 880 03a6 8081      		ld r24,Z
 881 03a8 8E7F      		ori r24,lo8(2)
 882 03aa 8C93      		st X,r24
 884               	.LM83:
 266:pwm.c         **** 	}
 267:pwm.c         **** 	else if( bitRes == 10 )
 885               	8(160)
 886               		ldi r27,hi8(160)
 887 03ae 8981      		ldi r30,lo8(160)
 888 03b0 8A30      		ldi r31,hi8(160)
 889 03b2 01F4      		ld r24,Z
 268:pwm.c         **** 	{	// 10bit mode
 269:pwm.c         **** 		sbi(TCCR4A,PWM11);
 890               	r24,lo8(1)
 891               		st X,r24
 892 03b4 A0EA      		rjmp .L38
 893 03b6 B0E0      	.L39:
 895 03ba F0E0      	.LM84:
 896 03bc 8081      		ldi r26,lo8(160)
 897 03be 8260      		ldi r27,hi8(160)
 898 03c0 8C93      		ldi r30,lo8(160)
 270:pwm.c         **** 		sbi(TCCR4A,PWM10);
 899               	hi8(160)
 900               		ld r24,Z
 901 03c2 A0EA      		andi r24,lo8(-3)
 902 03c4 B0E0      		st X,r24
 904 03c8 F0E0      	.LM85:
 905 03ca 8081      		ldi r26,lo8(160)
 906 03cc 8160      		ldi r27,hi8(160)
 907 03ce 8C93      		ldi r30,lo8(160)
 908 03d0 00C0      		ldi r31,hi8(160)
 909               		ld r24,Z
 271:pwm.c         **** 	}
 272:pwm.c         **** 	else
 273:pwm.c         **** 	{	// default 8bit mode
 274:pwm.c         **** 		cbi(TCCR4A,PWM11);
 910               	8(1)
 911               		st X,r24
 912 03d2 A0EA      	.L38:
 914 03d6 E0EA      	.LM86:
 915 03d8 F0E0      		ldi r30,lo8(172)
 916 03da 8081      		ldi r31,hi8(172)
 917 03dc 8D7F      		std Z+1,__zero_reg__
 918 03de 8C93      		st Z,__zero_reg__
 275:pwm.c         **** 		sbi(TCCR4A,PWM10);
 919               	ue start */
 921 03e0 A0EA      	.LM87:
 922 03e2 B0E0      		pop __tmp_reg__
 923 03e4 E0EA      		pop r28
 924 03e6 F0E0      		pop r29
 925 03e8 8081      		ret
 927 03ec 8C93      	.Lscope8:
 276:pwm.c         **** 	}
 277:pwm.c         **** 	// clear output compare values
 278:pwm.c         **** 	OCR4C = 0;
 929               	opcount:p(15,3)",160,0,0,1
 930               	.global	timer1PWMInitICR
 932 03f0 F0E0      	timer1PWMInitICR:
 934 03f4 1082      	.LM88:
 935               	.LFBB9:
 279:pwm.c         **** 	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
 280:pwm.c         **** }
 936               	29
 937               		push r28
 938 03f6 0F90      		rcall .
 939 03f8 CF91      		in r28,__SP_L__
 940 03fa DF91      		in r29,__SP_H__
 941 03fc 0895      	/* prologue: function */
 942               	/* frame size = 2 */
 943               		std Y+2,r25
 944               		std Y+1,r24
 946               	.LM89:
 947               		ldi r26,lo8(128)
 948               		ldi r27,hi8(128)
 281:pwm.c         **** 
 282:pwm.c         **** #ifdef WGM10
 283:pwm.c         **** // include support for arbitrary top-count PWM
 284:pwm.c         **** // on new AVR processors that support it
 285:pwm.c         **** void timer1PWMInitICR(u16 topcount)
 286:pwm.c         **** {
 949               	128)
 950               		ldi r31,hi8(128)
 951               		ld r24,Z
 952 03fe DF93      		andi r24,lo8(-2)
 953 0400 CF93      		st X,r24
 955 0404 CDB7      	.LM90:
 956 0406 DEB7      		ldi r26,lo8(128)
 957               		ldi r27,hi8(128)
 958               		ldi r30,lo8(128)
 959 0408 9A83      		ldi r31,hi8(128)
 960 040a 8983      		ld r24,Z
 287:pwm.c         **** 	// set PWM mode with ICR top-count
 288:pwm.c         **** 	cbi(TCCR1A,WGM10);
 961               	(2)
 962               		st X,r24
 964 040e B0E0      	.LM91:
 965 0410 E0E8      		ldi r26,lo8(129)
 966 0412 F0E0      		ldi r27,hi8(129)
 967 0414 8081      		ldi r30,lo8(129)
 968 0416 8E7F      		ldi r31,hi8(129)
 969 0418 8C93      		ld r24,Z
 289:pwm.c         **** 	sbi(TCCR1A,WGM11);
 970               	lo8(8)
 971               		st X,r24
 973 041c B0E0      	.LM92:
 974 041e E0E8      		ldi r26,lo8(129)
 975 0420 F0E0      		ldi r27,hi8(129)
 976 0422 8081      		ldi r30,lo8(129)
 977 0424 8260      		ldi r31,hi8(129)
 978 0426 8C93      		ld r24,Z
 290:pwm.c         **** 	sbi(TCCR1B,WGM12);
 979               	lo8(16)
 980               		st X,r24
 982 042a B0E0      	.LM93:
 983 042c E1E8      		ldi r30,lo8(134)
 984 042e F0E0      		ldi r31,hi8(134)
 985 0430 8081      		ldd r24,Y+1
 986 0432 8860      		ldd r25,Y+2
 987 0434 8C93      		std Z+1,r25
 291:pwm.c         **** 	sbi(TCCR1B,WGM13);
 988               	
 990 0436 A1E8      	.LM94:
 991 0438 B0E0      		ldi r30,lo8(136)
 992 043a E1E8      		ldi r31,hi8(136)
 993 043c F0E0      		std Z+1,__zero_reg__
 994 043e 8081      		st Z,__zero_reg__
 996 0442 8C93      	.LM95:
 292:pwm.c         **** 	
 293:pwm.c         **** 	// set top count value
 294:pwm.c         **** 	ICR1 = topcount;
 997               	,lo8(138)
 998               		ldi r31,hi8(138)
 999 0444 E6E8      		std Z+1,__zero_reg__
 1000 0446 F0E0      		st Z,__zero_reg__
 1002 044a 9A81      	.LM96:
 1003 044c 9183      		ldi r30,lo8(140)
 1004 044e 8083      		ldi r31,hi8(140)
 295:pwm.c         **** 	
 296:pwm.c         **** 	// clear output compare values
 297:pwm.c         **** 	OCR1A = 0;
 1005               	,__zero_reg__
 1006               		st Z,__zero_reg__
 1007 0450 E8E8      	/* epilogue start */
 1009 0454 1182      	.LM97:
 1010 0456 1082      		pop __tmp_reg__
 298:pwm.c         **** 	OCR1B = 0;
 1011               	_tmp_reg__
 1012               		pop r28
 1013 0458 EAE8      		pop r29
 1014 045a F0E0      		ret
 1016 045e 1082      	.Lscope9:
 299:pwm.c         **** 	OCR1C = 0;
 1017               	s	"timer3PWMInitICR:F(0,15)",36,0,0,timer3PWMInitICR
 1019 0460 ECE8      	.global	timer3PWMInitICR
 1021 0464 1182      	timer3PWMInitICR:
 1023               	.LM98:
 300:pwm.c         **** }
 1024               	:
 1025               		push r29
 1026 0468 0F90      		push r28
 1027 046a 0F90      		rcall .
 1028 046c CF91      		in r28,__SP_L__
 1029 046e DF91      		in r29,__SP_H__
 1030 0470 0895      	/* prologue: function */
 1031               	/* frame size = 2 */
 1032               		std Y+2,r25
 1033               		std Y+1,r24
 1035               	.LM99:
 1036               		ldi r26,lo8(144)
 1037               		ldi r27,hi8(144)
 301:pwm.c         **** void timer3PWMInitICR(u16 topcount)
 302:pwm.c         **** {
 1038               	44)
 1039               		ldi r31,hi8(144)
 1040               		ld r24,Z
 1041 0472 DF93      		andi r24,lo8(-2)
 1042 0474 CF93      		st X,r24
 1044 0478 CDB7      	.LM100:
 1045 047a DEB7      		ldi r26,lo8(144)
 1046               		ldi r27,hi8(144)
 1047               		ldi r30,lo8(144)
 1048 047c 9A83      		ldi r31,hi8(144)
 1049 047e 8983      		ld r24,Z
 303:pwm.c         **** 	// set PWM mode with ICR top-count
 304:pwm.c         **** 	cbi(TCCR3A,WGM10);
 1050               	(2)
 1051               		st X,r24
 1053 0482 B0E0      	.LM101:
 1054 0484 E0E9      		ldi r26,lo8(145)
 1055 0486 F0E0      		ldi r27,hi8(145)
 1056 0488 8081      		ldi r30,lo8(145)
 1057 048a 8E7F      		ldi r31,hi8(145)
 1058 048c 8C93      		ld r24,Z
 305:pwm.c         **** 	sbi(TCCR3A,WGM11);
 1059               	lo8(8)
 1060               		st X,r24
 1062 0490 B0E0      	.LM102:
 1063 0492 E0E9      		ldi r26,lo8(145)
 1064 0494 F0E0      		ldi r27,hi8(145)
 1065 0496 8081      		ldi r30,lo8(145)
 1066 0498 8260      		ldi r31,hi8(145)
 1067 049a 8C93      		ld r24,Z
 306:pwm.c         **** 	sbi(TCCR3B,WGM12);
 1068               	lo8(16)
 1069               		st X,r24
 1071 049e B0E0      	.LM103:
 1072 04a0 E1E9      		ldi r30,lo8(150)
 1073 04a2 F0E0      		ldi r31,hi8(150)
 1074 04a4 8081      		ldd r24,Y+1
 1075 04a6 8860      		ldd r25,Y+2
 1076 04a8 8C93      		std Z+1,r25
 307:pwm.c         **** 	sbi(TCCR3B,WGM13);
 1077               	
 1079 04aa A1E9      	.LM104:
 1080 04ac B0E0      		ldi r30,lo8(152)
 1081 04ae E1E9      		ldi r31,hi8(152)
 1082 04b0 F0E0      		std Z+1,__zero_reg__
 1083 04b2 8081      		st Z,__zero_reg__
 1085 04b6 8C93      	.LM105:
 308:pwm.c         **** 	
 309:pwm.c         **** 	// set top count value
 310:pwm.c         **** 	ICR3 = topcount;
 1086               	,lo8(154)
 1087               		ldi r31,hi8(154)
 1088 04b8 E6E9      		std Z+1,__zero_reg__
 1089 04ba F0E0      		st Z,__zero_reg__
 1091 04be 9A81      	.LM106:
 1092 04c0 9183      		ldi r30,lo8(156)
 1093 04c2 8083      		ldi r31,hi8(156)
 311:pwm.c         **** 	
 312:pwm.c         **** 	// clear output compare values
 313:pwm.c         **** 	OCR3A = 0;
 1094               	,__zero_reg__
 1095               		st Z,__zero_reg__
 1096 04c4 E8E9      	/* epilogue start */
 1098 04c8 1182      	.LM107:
 1099 04ca 1082      		pop __tmp_reg__
 314:pwm.c         **** 	OCR3B = 0;
 1100               	_tmp_reg__
 1101               		pop r28
 1102 04cc EAE9      		pop r29
 1103 04ce F0E0      		ret
 1105 04d2 1082      	.Lscope10:
 315:pwm.c         **** 	OCR3C = 0;
 1106               	s	"timer4PWMInitICR:F(0,15)",36,0,0,timer4PWMInitICR
 1108 04d4 ECE9      	.global	timer4PWMInitICR
 1110 04d8 1182      	timer4PWMInitICR:
 1112               	.LM108:
 316:pwm.c         **** }
 1113               	:
 1114               		push r29
 1115 04dc 0F90      		push r28
 1116 04de 0F90      		rcall .
 1117 04e0 CF91      		in r28,__SP_L__
 1118 04e2 DF91      		in r29,__SP_H__
 1119 04e4 0895      	/* prologue: function */
 1120               	/* frame size = 2 */
 1121               		std Y+2,r25
 1122               		std Y+1,r24
 1124               	.LM109:
 1125               		ldi r26,lo8(160)
 1126               		ldi r27,hi8(160)
 317:pwm.c         **** void timer4PWMInitICR(u16 topcount)
 318:pwm.c         **** {
 1127               	60)
 1128               		ldi r31,hi8(160)
 1129               		ld r24,Z
 1130 04e6 DF93      		andi r24,lo8(-2)
 1131 04e8 CF93      		st X,r24
 1133 04ec CDB7      	.LM110:
 1134 04ee DEB7      		ldi r26,lo8(160)
 1135               		ldi r27,hi8(160)
 1136               		ldi r30,lo8(160)
 1137 04f0 9A83      		ldi r31,hi8(160)
 1138 04f2 8983      		ld r24,Z
 319:pwm.c         **** 	// set PWM mode with ICR top-count
 320:pwm.c         **** 	cbi(TCCR4A,WGM10);
 1139               	(2)
 1140               		st X,r24
 1142 04f6 B0E0      	.LM111:
 1143 04f8 E0EA      		ldi r26,lo8(161)
 1144 04fa F0E0      		ldi r27,hi8(161)
 1145 04fc 8081      		ldi r30,lo8(161)
 1146 04fe 8E7F      		ldi r31,hi8(161)
 1147 0500 8C93      		ld r24,Z
 321:pwm.c         **** 	sbi(TCCR4A,WGM11);
 1148               	lo8(8)
 1149               		st X,r24
 1151 0504 B0E0      	.LM112:
 1152 0506 E0EA      		ldi r26,lo8(161)
 1153 0508 F0E0      		ldi r27,hi8(161)
 1154 050a 8081      		ldi r30,lo8(161)
 1155 050c 8260      		ldi r31,hi8(161)
 1156 050e 8C93      		ld r24,Z
 322:pwm.c         **** 	sbi(TCCR4B,WGM12);
 1157               	lo8(16)
 1158               		st X,r24
 1160 0512 B0E0      	.LM113:
 1161 0514 E1EA      		ldi r30,lo8(166)
 1162 0516 F0E0      		ldi r31,hi8(166)
 1163 0518 8081      		ldd r24,Y+1
 1164 051a 8860      		ldd r25,Y+2
 1165 051c 8C93      		std Z+1,r25
 323:pwm.c         **** 	sbi(TCCR4B,WGM13);
 1166               	
 1168 051e A1EA      	.LM114:
 1169 0520 B0E0      		ldi r30,lo8(168)
 1170 0522 E1EA      		ldi r31,hi8(168)
 1171 0524 F0E0      		std Z+1,__zero_reg__
 1172 0526 8081      		st Z,__zero_reg__
 1174 052a 8C93      	.LM115:
 324:pwm.c         **** 	
 325:pwm.c         **** 	// set top count value
 326:pwm.c         **** 	ICR4 = topcount;
 1175               	,lo8(170)
 1176               		ldi r31,hi8(170)
 1177 052c E6EA      		std Z+1,__zero_reg__
 1178 052e F0E0      		st Z,__zero_reg__
 1180 0532 9A81      	.LM116:
 1181 0534 9183      		ldi r30,lo8(172)
 1182 0536 8083      		ldi r31,hi8(172)
 327:pwm.c         **** 	
 328:pwm.c         **** 	// clear output compare values
 329:pwm.c         **** 	OCR4A = 0;
 1183               	,__zero_reg__
 1184               		st Z,__zero_reg__
 1185 0538 E8EA      	/* epilogue start */
 1187 053c 1182      	.LM117:
 1188 053e 1082      		pop __tmp_reg__
 330:pwm.c         **** 	OCR4B = 0;
 1189               	_tmp_reg__
 1190               		pop r28
 1191 0540 EAEA      		pop r29
 1192 0542 F0E0      		ret
 1194 0546 1082      	.Lscope11:
 331:pwm.c         **** 	OCR4C = 0;
 1195               	s	"PWM_timer1_On_LED:F(0,15)",36,0,0,PWM_timer1_On_LED
 1196               	.global	PWM_timer1_On_LED
 1198 054a F0E0      	PWM_timer1_On_LED:
 1200 054e 1082      	.LM118:
 1201               	.LFBB12:
 332:pwm.c         **** }
 1202               	29
 1203               		push r28
 1204 0550 0F90      		in r28,__SP_L__
 1205 0552 0F90      		in r29,__SP_H__
 1206 0554 CF91      	/* prologue: function */
 1207 0556 DF91      	/* frame size = 0 */
 1209               	.LM119:
 1210               		ldi r26,lo8(128)
 1211               		ldi r27,hi8(128)
 1212               		ldi r30,lo8(128)
 1213               		ldi r31,hi8(128)
 1214               		ld r24,Z
 333:pwm.c         **** #endif
 334:pwm.c         **** 
 335:pwm.c         **** //on commands
 336:pwm.c         **** void PWM_timer1_On_LED(void)
 337:pwm.c         **** {
 1215               	32)
 1216               		st X,r24
 1218 055a DF93      	.LM120:
 1219 055c CF93      		ldi r26,lo8(128)
 1220 055e CDB7      		ldi r27,hi8(128)
 1221 0560 DEB7      		ldi r30,lo8(128)
 1222               		ldi r31,hi8(128)
 1223               		ld r24,Z
 338:pwm.c         **** 	sbi(TCCR1A,COM1B1);
 1224               	,lo8(-17)
 1225               		st X,r24
 1226 0562 A0E8      	/* epilogue start */
 1228 0566 E0E8      	.LM121:
 1229 0568 F0E0      		pop r28
 1230 056a 8081      		pop r29
 1231 056c 8062      		ret
 339:pwm.c         **** 	cbi(TCCR1A,COM1B0);
 1233               	:
 1235 0570 A0E8      	.global	PWM_timer2_On_H6
 1237 0574 E0E8      	PWM_timer2_On_H6:
 1239 0578 8081      	.LM122:
 1240 057a 8F7E      	.LFBB13:
 1241 057c 8C93      		push r29
 1242               		push r28
 340:pwm.c         **** }
 1243               	SP_L__
 1244               		in r29,__SP_H__
 1245 057e CF91      	/* prologue: function */
 1246 0580 DF91      	/* frame size = 0 */
 1248               	.LM123:
 1249               		ldi r26,lo8(176)
 1250               		ldi r27,hi8(176)
 1251               		ldi r30,lo8(176)
 1252               		ldi r31,hi8(176)
 1253               		ld r24,Z
 341:pwm.c         **** void PWM_timer2_On_H6(void)
 342:pwm.c         **** {
 1254               	8(32)
 1255               		st X,r24
 1257 0584 DF93      	.LM124:
 1258 0586 CF93      		ldi r26,lo8(176)
 1259 0588 CDB7      		ldi r27,hi8(176)
 1260 058a DEB7      		ldi r30,lo8(176)
 1261               		ldi r31,hi8(176)
 1262               		ld r24,Z
 343:pwm.c         **** 	sbi(TCCR2A,COM2B1);
 1263               	,lo8(-17)
 1264               		st X,r24
 1265 058c A0EB      	/* epilogue start */
 1267 0590 E0EB      	.LM125:
 1268 0592 F0E0      		pop r28
 1269 0594 8081      		pop r29
 1270 0596 8062      		ret
 344:pwm.c         **** 	cbi(TCCR2A,COM2B0);
 1272               	:
 1274 059a A0EB      	.global	PWM_timer3_On_E3
 1276 059e E0EB      	PWM_timer3_On_E3:
 1278 05a2 8081      	.LM126:
 1279 05a4 8F7E      	.LFBB14:
 1280 05a6 8C93      		push r29
 1281               		push r28
 345:pwm.c         **** }
 1282               	SP_L__
 1283               		in r29,__SP_H__
 1284 05a8 CF91      	/* prologue: function */
 1285 05aa DF91      	/* frame size = 0 */
 1287               	.LM127:
 1288               		ldi r26,lo8(144)
 1289               		ldi r27,hi8(144)
 1290               		ldi r30,lo8(144)
 1291               		ldi r31,hi8(144)
 1292               		ld r24,Z
 346:pwm.c         **** void PWM_timer3_On_E3(void)
 347:pwm.c         **** {
 1293               	8(-128)
 1294               		st X,r24
 1296 05ae DF93      	.LM128:
 1297 05b0 CF93      		ldi r26,lo8(144)
 1298 05b2 CDB7      		ldi r27,hi8(144)
 1299 05b4 DEB7      		ldi r30,lo8(144)
 1300               		ldi r31,hi8(144)
 1301               		ld r24,Z
 348:pwm.c         **** 	sbi(TCCR3A,COM3A1);
 1302               	,lo8(-65)
 1303               		st X,r24
 1304 05b6 A0E9      	/* epilogue start */
 1306 05ba E0E9      	.LM129:
 1307 05bc F0E0      		pop r28
 1308 05be 8081      		pop r29
 1309 05c0 8068      		ret
 349:pwm.c         **** 	cbi(TCCR3A,COM3A0);
 1311               	:
 1313 05c4 A0E9      	.global	PWM_timer3_On_E4
 1315 05c8 E0E9      	PWM_timer3_On_E4:
 1317 05cc 8081      	.LM130:
 1318 05ce 8F7B      	.LFBB15:
 1319 05d0 8C93      		push r29
 1320               		push r28
 350:pwm.c         **** }
 1321               	SP_L__
 1322               		in r29,__SP_H__
 1323 05d2 CF91      	/* prologue: function */
 1324 05d4 DF91      	/* frame size = 0 */
 1326               	.LM131:
 1327               		ldi r26,lo8(144)
 1328               		ldi r27,hi8(144)
 1329               		ldi r30,lo8(144)
 1330               		ldi r31,hi8(144)
 1331               		ld r24,Z
 351:pwm.c         **** void PWM_timer3_On_E4(void)
 352:pwm.c         **** {
 1332               	8(32)
 1333               		st X,r24
 1335 05d8 DF93      	.LM132:
 1336 05da CF93      		ldi r26,lo8(144)
 1337 05dc CDB7      		ldi r27,hi8(144)
 1338 05de DEB7      		ldi r30,lo8(144)
 1339               		ldi r31,hi8(144)
 1340               		ld r24,Z
 353:pwm.c         **** 	sbi(TCCR3A,COM3B1);
 1341               	,lo8(-17)
 1342               		st X,r24
 1343 05e0 A0E9      	/* epilogue start */
 1345 05e4 E0E9      	.LM133:
 1346 05e6 F0E0      		pop r28
 1347 05e8 8081      		pop r29
 1348 05ea 8062      		ret
 354:pwm.c         **** 	cbi(TCCR3A,COM3B0);
 1350               	:
 1352 05ee A0E9      	.global	PWM_timer3_On_E5
 1354 05f2 E0E9      	PWM_timer3_On_E5:
 1356 05f6 8081      	.LM134:
 1357 05f8 8F7E      	.LFBB16:
 1358 05fa 8C93      		push r29
 1359               		push r28
 355:pwm.c         **** }
 1360               	SP_L__
 1361               		in r29,__SP_H__
 1362 05fc CF91      	/* prologue: function */
 1363 05fe DF91      	/* frame size = 0 */
 1365               	.LM135:
 1366               		ldi r26,lo8(144)
 1367               		ldi r27,hi8(144)
 1368               		ldi r30,lo8(144)
 1369               		ldi r31,hi8(144)
 1370               		ld r24,Z
 356:pwm.c         **** void PWM_timer3_On_E5(void)
 357:pwm.c         **** {
 1371               	8(8)
 1372               		st X,r24
 1374 0602 DF93      	.LM136:
 1375 0604 CF93      		ldi r26,lo8(144)
 1376 0606 CDB7      		ldi r27,hi8(144)
 1377 0608 DEB7      		ldi r30,lo8(144)
 1378               		ldi r31,hi8(144)
 1379               		ld r24,Z
 358:pwm.c         **** 	sbi(TCCR3A,COM3C1);
 1380               	,lo8(-5)
 1381               		st X,r24
 1382 060a A0E9      	/* epilogue start */
 1384 060e E0E9      	.LM137:
 1385 0610 F0E0      		pop r28
 1386 0612 8081      		pop r29
 1387 0614 8860      		ret
 359:pwm.c         **** 	cbi(TCCR3A,COM3C0);
 1389               	:
 1391 0618 A0E9      	.global	PWM_timer4_On_H3
 1393 061c E0E9      	PWM_timer4_On_H3:
 1395 0620 8081      	.LM138:
 1396 0622 8B7F      	.LFBB17:
 1397 0624 8C93      		push r29
 1398               		push r28
 360:pwm.c         **** }
 1399               	SP_L__
 1400               		in r29,__SP_H__
 1401 0626 CF91      	/* prologue: function */
 1402 0628 DF91      	/* frame size = 0 */
 1404               	.LM139:
 1405               		ldi r26,lo8(160)
 1406               		ldi r27,hi8(160)
 1407               		ldi r30,lo8(160)
 1408               		ldi r31,hi8(160)
 1409               		ld r24,Z
 361:pwm.c         **** void PWM_timer4_On_H3(void)
 362:pwm.c         **** {
 1410               	8(-128)
 1411               		st X,r24
 1413 062c DF93      	.LM140:
 1414 062e CF93      		ldi r26,lo8(160)
 1415 0630 CDB7      		ldi r27,hi8(160)
 1416 0632 DEB7      		ldi r30,lo8(160)
 1417               		ldi r31,hi8(160)
 1418               		ld r24,Z
 363:pwm.c         **** 	sbi(TCCR4A,COM4A1);
 1419               	,lo8(-65)
 1420               		st X,r24
 1421 0634 A0EA      	/* epilogue start */
 1423 0638 E0EA      	.LM141:
 1424 063a F0E0      		pop r28
 1425 063c 8081      		pop r29
 1426 063e 8068      		ret
 364:pwm.c         **** 	cbi(TCCR4A,COM4A0);
 1428               	:
 1430 0642 A0EA      	.global	PWM_timer4_On_H4
 1432 0646 E0EA      	PWM_timer4_On_H4:
 1434 064a 8081      	.LM142:
 1435 064c 8F7B      	.LFBB18:
 1436 064e 8C93      		push r29
 1437               		push r28
 365:pwm.c         **** }
 1438               	SP_L__
 1439               		in r29,__SP_H__
 1440 0650 CF91      	/* prologue: function */
 1441 0652 DF91      	/* frame size = 0 */
 1443               	.LM143:
 1444               		ldi r26,lo8(160)
 1445               		ldi r27,hi8(160)
 1446               		ldi r30,lo8(160)
 1447               		ldi r31,hi8(160)
 1448               		ld r24,Z
 366:pwm.c         **** void PWM_timer4_On_H4(void)
 367:pwm.c         **** {
 1449               	8(32)
 1450               		st X,r24
 1452 0656 DF93      	.LM144:
 1453 0658 CF93      		ldi r26,lo8(160)
 1454 065a CDB7      		ldi r27,hi8(160)
 1455 065c DEB7      		ldi r30,lo8(160)
 1456               		ldi r31,hi8(160)
 1457               		ld r24,Z
 368:pwm.c         **** 	sbi(TCCR4A,COM4B1);
 1458               	,lo8(-17)
 1459               		st X,r24
 1460 065e A0EA      	/* epilogue start */
 1462 0662 E0EA      	.LM145:
 1463 0664 F0E0      		pop r28
 1464 0666 8081      		pop r29
 1465 0668 8062      		ret
 369:pwm.c         **** 	cbi(TCCR4A,COM4B0);
 1467               	:
 1469 066c A0EA      	.global	PWM_timer4_On_H5
 1471 0670 E0EA      	PWM_timer4_On_H5:
 1473 0674 8081      	.LM146:
 1474 0676 8F7E      	.LFBB19:
 1475 0678 8C93      		push r29
 1476               		push r28
 370:pwm.c         **** }
 1477               	SP_L__
 1478               		in r29,__SP_H__
 1479 067a CF91      	/* prologue: function */
 1480 067c DF91      	/* frame size = 0 */
 1482               	.LM147:
 1483               		ldi r26,lo8(160)
 1484               		ldi r27,hi8(160)
 1485               		ldi r30,lo8(160)
 1486               		ldi r31,hi8(160)
 1487               		ld r24,Z
 371:pwm.c         **** void PWM_timer4_On_H5(void)
 372:pwm.c         **** {
 1488               	8(8)
 1489               		st X,r24
 1491 0680 DF93      	.LM148:
 1492 0682 CF93      		ldi r26,lo8(160)
 1493 0684 CDB7      		ldi r27,hi8(160)
 1494 0686 DEB7      		ldi r30,lo8(160)
 1495               		ldi r31,hi8(160)
 1496               		ld r24,Z
 373:pwm.c         **** 	sbi(TCCR4A,COM4C1);
 1497               	,lo8(-5)
 1498               		st X,r24
 1499 0688 A0EA      	/* epilogue start */
 1501 068c E0EA      	.LM149:
 1502 068e F0E0      		pop r28
 1503 0690 8081      		pop r29
 1504 0692 8860      		ret
 374:pwm.c         **** 	cbi(TCCR4A,COM4C0);
 1506               	:
 1508 0696 A0EA      	.global	PWM_timer1_Off_LED
 1510 069a E0EA      	PWM_timer1_Off_LED:
 1512 069e 8081      	.LM150:
 1513 06a0 8B7F      	.LFBB20:
 1514 06a2 8C93      		push r29
 1515               		push r28
 375:pwm.c         **** }
 1516               	SP_L__
 1517               		in r29,__SP_H__
 1518 06a4 CF91      	/* prologue: function */
 1519 06a6 DF91      	/* frame size = 0 */
 1521               	.LM151:
 1522               		ldi r26,lo8(128)
 1523               		ldi r27,hi8(128)
 1524               		ldi r30,lo8(128)
 1525               		ldi r31,hi8(128)
 1526               		ld r24,Z
 376:pwm.c         **** 
 377:pwm.c         **** //off commands
 378:pwm.c         **** void PWM_timer1_Off_LED(void)
 379:pwm.c         **** {
 1527               	o8(-33)
 1528               		st X,r24
 1530 06aa DF93      	.LM152:
 1531 06ac CF93      		ldi r26,lo8(128)
 1532 06ae CDB7      		ldi r27,hi8(128)
 1533 06b0 DEB7      		ldi r30,lo8(128)
 1534               		ldi r31,hi8(128)
 1535               		ld r24,Z
 380:pwm.c         **** 	cbi(TCCR1A,COM1B1);
 1536               	,lo8(-17)
 1537               		st X,r24
 1538 06b2 A0E8      	/* epilogue start */
 1540 06b6 E0E8      	.LM153:
 1541 06b8 F0E0      		pop r28
 1542 06ba 8081      		pop r29
 1543 06bc 8F7D      		ret
 381:pwm.c         **** 	cbi(TCCR1A,COM1B0);
 1545               	:
 1547 06c0 A0E8      	.global	PWM_timer2_Off_H6
 1549 06c4 E0E8      	PWM_timer2_Off_H6:
 1551 06c8 8081      	.LM154:
 1552 06ca 8F7E      	.LFBB21:
 1553 06cc 8C93      		push r29
 1554               		push r28
 382:pwm.c         **** }
 1555               	SP_L__
 1556               		in r29,__SP_H__
 1557 06ce CF91      	/* prologue: function */
 1558 06d0 DF91      	/* frame size = 0 */
 1560               	.LM155:
 1561               		ldi r26,lo8(176)
 1562               		ldi r27,hi8(176)
 1563               		ldi r30,lo8(176)
 1564               		ldi r31,hi8(176)
 1565               		ld r24,Z
 383:pwm.c         **** void PWM_timer2_Off_H6(void)
 384:pwm.c         **** {
 1566               	o8(-33)
 1567               		st X,r24
 1569 06d4 DF93      	.LM156:
 1570 06d6 CF93      		ldi r26,lo8(176)
 1571 06d8 CDB7      		ldi r27,hi8(176)
 1572 06da DEB7      		ldi r30,lo8(176)
 1573               		ldi r31,hi8(176)
 1574               		ld r24,Z
 385:pwm.c         **** 	cbi(TCCR2A,COM2B1);
 1575               	,lo8(-17)
 1576               		st X,r24
 1577 06dc A0EB      	/* epilogue start */
 1579 06e0 E0EB      	.LM157:
 1580 06e2 F0E0      		pop r28
 1581 06e4 8081      		pop r29
 1582 06e6 8F7D      		ret
 386:pwm.c         **** 	cbi(TCCR2A,COM2B0);
 1584               	:
 1586 06ea A0EB      	.global	PWM_timer3_Off_E3
 1588 06ee E0EB      	PWM_timer3_Off_E3:
 1590 06f2 8081      	.LM158:
 1591 06f4 8F7E      	.LFBB22:
 1592 06f6 8C93      		push r29
 1593               		push r28
 387:pwm.c         **** }
 1594               	SP_L__
 1595               		in r29,__SP_H__
 1596 06f8 CF91      	/* prologue: function */
 1597 06fa DF91      	/* frame size = 0 */
 1599               	.LM159:
 1600               		ldi r26,lo8(144)
 1601               		ldi r27,hi8(144)
 1602               		ldi r30,lo8(144)
 1603               		ldi r31,hi8(144)
 1604               		ld r24,Z
 388:pwm.c         **** void PWM_timer3_Off_E3(void)
 389:pwm.c         **** {
 1605               	o8(127)
 1606               		st X,r24
 1608 06fe DF93      	.LM160:
 1609 0700 CF93      		ldi r26,lo8(144)
 1610 0702 CDB7      		ldi r27,hi8(144)
 1611 0704 DEB7      		ldi r30,lo8(144)
 1612               		ldi r31,hi8(144)
 1613               		ld r24,Z
 390:pwm.c         **** 	cbi(TCCR3A,COM3A1);
 1614               	,lo8(-65)
 1615               		st X,r24
 1616 0706 A0E9      	/* epilogue start */
 1618 070a E0E9      	.LM161:
 1619 070c F0E0      		pop r28
 1620 070e 8081      		pop r29
 1621 0710 8F77      		ret
 391:pwm.c         **** 	cbi(TCCR3A,COM3A0);
 1623               	:
 1625 0714 A0E9      	.global	PWM_timer3_Off_E4
 1627 0718 E0E9      	PWM_timer3_Off_E4:
 1629 071c 8081      	.LM162:
 1630 071e 8F7B      	.LFBB23:
 1631 0720 8C93      		push r29
 1632               		push r28
 392:pwm.c         **** }
 1633               	SP_L__
 1634               		in r29,__SP_H__
 1635 0722 CF91      	/* prologue: function */
 1636 0724 DF91      	/* frame size = 0 */
 1638               	.LM163:
 1639               		ldi r26,lo8(144)
 1640               		ldi r27,hi8(144)
 1641               		ldi r30,lo8(144)
 1642               		ldi r31,hi8(144)
 1643               		ld r24,Z
 393:pwm.c         **** void PWM_timer3_Off_E4(void)
 394:pwm.c         **** {
 1644               	o8(-33)
 1645               		st X,r24
 1647 0728 DF93      	.LM164:
 1648 072a CF93      		ldi r26,lo8(144)
 1649 072c CDB7      		ldi r27,hi8(144)
 1650 072e DEB7      		ldi r30,lo8(144)
 1651               		ldi r31,hi8(144)
 1652               		ld r24,Z
 395:pwm.c         **** 	cbi(TCCR3A,COM3B1);
 1653               	,lo8(-17)
 1654               		st X,r24
 1655 0730 A0E9      	/* epilogue start */
 1657 0734 E0E9      	.LM165:
 1658 0736 F0E0      		pop r28
 1659 0738 8081      		pop r29
 1660 073a 8F7D      		ret
 396:pwm.c         **** 	cbi(TCCR3A,COM3B0);
 1662               	:
 1664 073e A0E9      	.global	PWM_timer3_Off_E5
 1666 0742 E0E9      	PWM_timer3_Off_E5:
 1668 0746 8081      	.LM166:
 1669 0748 8F7E      	.LFBB24:
 1670 074a 8C93      		push r29
 1671               		push r28
 397:pwm.c         **** }
 1672               	SP_L__
 1673               		in r29,__SP_H__
 1674 074c CF91      	/* prologue: function */
 1675 074e DF91      	/* frame size = 0 */
 1677               	.LM167:
 1678               		ldi r26,lo8(144)
 1679               		ldi r27,hi8(144)
 1680               		ldi r30,lo8(144)
 1681               		ldi r31,hi8(144)
 1682               		ld r24,Z
 398:pwm.c         **** void PWM_timer3_Off_E5(void)
 399:pwm.c         **** {
 1683               	o8(-9)
 1684               		st X,r24
 1686 0752 DF93      	.LM168:
 1687 0754 CF93      		ldi r26,lo8(144)
 1688 0756 CDB7      		ldi r27,hi8(144)
 1689 0758 DEB7      		ldi r30,lo8(144)
 1690               		ldi r31,hi8(144)
 1691               		ld r24,Z
 400:pwm.c         **** 	cbi(TCCR3A,COM3C1);
 1692               	,lo8(-5)
 1693               		st X,r24
 1694 075a A0E9      	/* epilogue start */
 1696 075e E0E9      	.LM169:
 1697 0760 F0E0      		pop r28
 1698 0762 8081      		pop r29
 1699 0764 877F      		ret
 401:pwm.c         **** 	cbi(TCCR3A,COM3C0);
 1701               	:
 1703 0768 A0E9      	.global	PWM_timer4_Off_H3
 1705 076c E0E9      	PWM_timer4_Off_H3:
 1707 0770 8081      	.LM170:
 1708 0772 8B7F      	.LFBB25:
 1709 0774 8C93      		push r29
 1710               		push r28
 402:pwm.c         **** }
 1711               	SP_L__
 1712               		in r29,__SP_H__
 1713 0776 CF91      	/* prologue: function */
 1714 0778 DF91      	/* frame size = 0 */
 1716               	.LM171:
 1717               		ldi r26,lo8(160)
 1718               		ldi r27,hi8(160)
 1719               		ldi r30,lo8(160)
 1720               		ldi r31,hi8(160)
 1721               		ld r24,Z
 403:pwm.c         **** void PWM_timer4_Off_H3(void)
 404:pwm.c         **** {
 1722               	o8(127)
 1723               		st X,r24
 1725 077c DF93      	.LM172:
 1726 077e CF93      		ldi r26,lo8(160)
 1727 0780 CDB7      		ldi r27,hi8(160)
 1728 0782 DEB7      		ldi r30,lo8(160)
 1729               		ldi r31,hi8(160)
 1730               		ld r24,Z
 405:pwm.c         **** 	cbi(TCCR4A,COM4A1);
 1731               	,lo8(-65)
 1732               		st X,r24
 1733 0784 A0EA      	/* epilogue start */
 1735 0788 E0EA      	.LM173:
 1736 078a F0E0      		pop r28
 1737 078c 8081      		pop r29
 1738 078e 8F77      		ret
 406:pwm.c         **** 	cbi(TCCR4A,COM4A0);
 1740               	:
 1742 0792 A0EA      	.global	PWM_timer4_Off_H4
 1744 0796 E0EA      	PWM_timer4_Off_H4:
 1746 079a 8081      	.LM174:
 1747 079c 8F7B      	.LFBB26:
 1748 079e 8C93      		push r29
 1749               		push r28
 407:pwm.c         **** }
 1750               	SP_L__
 1751               		in r29,__SP_H__
 1752 07a0 CF91      	/* prologue: function */
 1753 07a2 DF91      	/* frame size = 0 */
 1755               	.LM175:
 1756               		ldi r26,lo8(160)
 1757               		ldi r27,hi8(160)
 1758               		ldi r30,lo8(160)
 1759               		ldi r31,hi8(160)
 1760               		ld r24,Z
 408:pwm.c         **** void PWM_timer4_Off_H4(void)
 409:pwm.c         **** {
 1761               	o8(-33)
 1762               		st X,r24
 1764 07a6 DF93      	.LM176:
 1765 07a8 CF93      		ldi r26,lo8(160)
 1766 07aa CDB7      		ldi r27,hi8(160)
 1767 07ac DEB7      		ldi r30,lo8(160)
 1768               		ldi r31,hi8(160)
 1769               		ld r24,Z
 410:pwm.c         **** 	cbi(TCCR4A,COM4B1);
 1770               	,lo8(-17)
 1771               		st X,r24
 1772 07ae A0EA      	/* epilogue start */
 1774 07b2 E0EA      	.LM177:
 1775 07b4 F0E0      		pop r28
 1776 07b6 8081      		pop r29
 1777 07b8 8F7D      		ret
 411:pwm.c         **** 	cbi(TCCR4A,COM4B0);
 1779               	:
 1781 07bc A0EA      	.global	PWM_timer4_Off_H5
 1783 07c0 E0EA      	PWM_timer4_Off_H5:
 1785 07c4 8081      	.LM178:
 1786 07c6 8F7E      	.LFBB27:
 1787 07c8 8C93      		push r29
 1788               		push r28
 412:pwm.c         **** }
 1789               	SP_L__
 1790               		in r29,__SP_H__
 1791 07ca CF91      	/* prologue: function */
 1792 07cc DF91      	/* frame size = 0 */
 1794               	.LM179:
 1795               		ldi r26,lo8(160)
 1796               		ldi r27,hi8(160)
 1797               		ldi r30,lo8(160)
 1798               		ldi r31,hi8(160)
 1799               		ld r24,Z
 413:pwm.c         **** void PWM_timer4_Off_H5(void)
 414:pwm.c         **** {
 1800               	o8(-9)
 1801               		st X,r24
 1803 07d0 DF93      	.LM180:
 1804 07d2 CF93      		ldi r26,lo8(160)
 1805 07d4 CDB7      		ldi r27,hi8(160)
 1806 07d6 DEB7      		ldi r30,lo8(160)
 1807               		ldi r31,hi8(160)
 1808               		ld r24,Z
 415:pwm.c         **** 	cbi(TCCR4A,COM4C1);
 1809               	,lo8(-5)
 1810               		st X,r24
 1811 07d8 A0EA      	/* epilogue start */
 1813 07dc E0EA      	.LM181:
 1814 07de F0E0      		pop r28
 1815 07e0 8081      		pop r29
 1816 07e2 877F      		ret
 416:pwm.c         **** 	cbi(TCCR4A,COM4C0);
 1818               	:
 1820 07e6 A0EA      	.global	PWM_timer1_Off_All
 1822 07ea E0EA      	PWM_timer1_Off_All:
 1824 07ee 8081      	.LM182:
 1825 07f0 8B7F      	.LFBB28:
 1826 07f2 8C93      		push r29
 1827               		push r28
 417:pwm.c         **** }
 1828               	SP_L__
 1829               		in r29,__SP_H__
 1830 07f4 CF91      	/* prologue: function */
 1831 07f6 DF91      	/* frame size = 0 */
 1833               	.LM183:
 1834               		ldi r26,lo8(128)
 1835               		ldi r27,hi8(128)
 1836               		ldi r30,lo8(128)
 1837               		ldi r31,hi8(128)
 1838               		ld r24,Z
 418:pwm.c         **** 
 419:pwm.c         **** 
 420:pwm.c         **** void PWM_timer1_Off_All(void)
 421:pwm.c         **** {
 1839               	o8(-3)
 1840               		st X,r24
 1842 07fa DF93      	.LM184:
 1843 07fc CF93      		ldi r26,lo8(128)
 1844 07fe CDB7      		ldi r27,hi8(128)
 1845 0800 DEB7      		ldi r30,lo8(128)
 1846               		ldi r31,hi8(128)
 1847               		ld r24,Z
 422:pwm.c         **** 	cbi(TCCR1A,PWM11);
 1848               	,lo8(-2)
 1849               		st X,r24
 1851 0804 B0E0      	.LM185:
 1852 0806 E0E8      		call PWM_timer1_Off_LED
 1853 0808 F0E0      	/* epilogue start */
 1855 080c 8D7F      	.LM186:
 1856 080e 8C93      		pop r28
 423:pwm.c         **** 	cbi(TCCR1A,PWM10);
 1857               		ret
 1859 0810 A0E8      	.Lscope28:
 1861 0814 E0E8      	.global	PWM_timer2_Off_All
 1863 0818 8081      	PWM_timer2_Off_All:
 1865 081c 8C93      	.LM187:
 424:pwm.c         **** 	//timer2PWMAOff();
 425:pwm.c         **** 	PWM_timer1_Off_LED();
 1866               		push r29
 1867               		push r28
 1868 081e 0E94 0000 		in r28,__SP_L__
 1869               		in r29,__SP_H__
 426:pwm.c         **** 	//timer2PWMCOff();
 427:pwm.c         **** }
 1870               	rologue: function */
 1871               	/* frame size = 0 */
 1873 0824 DF91      	.LM188:
 1874 0826 0895      		ldi r26,lo8(176)
 1875               		ldi r27,hi8(176)
 1876               		ldi r30,lo8(176)
 1877               		ldi r31,hi8(176)
 1878               		ld r24,Z
 1879               		andi r24,lo8(-3)
 1880               		st X,r24
 428:pwm.c         **** void PWM_timer2_Off_All(void)
 429:pwm.c         **** {
 1881               	0,431,.LM189-.LFBB29
 1882               	.LM189:
 1883               		ldi r26,lo8(176)
 1884 0828 DF93      		ldi r27,hi8(176)
 1885 082a CF93      		ldi r30,lo8(176)
 1886 082c CDB7      		ldi r31,hi8(176)
 1887 082e DEB7      		ld r24,Z
 1888               		andi r24,lo8(-2)
 1889               		st X,r24
 430:pwm.c         **** 	cbi(TCCR2A,PWM11);
 1890               	8,0,433,.LM190-.LFBB29
 1891               	.LM190:
 1892 0830 A0EB      		call PWM_timer2_Off_H6
 1893 0832 B0E0      	/* epilogue start */
 1895 0836 F0E0      	.LM191:
 1896 0838 8081      		pop r28
 1897 083a 8D7F      		pop r29
 1898 083c 8C93      		ret
 431:pwm.c         **** 	cbi(TCCR2A,PWM10);
 1899               	M_timer2_Off_All, .-PWM_timer2_Off_All
 1900               	.Lscope29:
 1902 0840 B0E0      	.global	PWM_timer3_Off_All
 1904 0844 F0E0      	PWM_timer3_Off_All:
 1906 0848 8E7F      	.LM192:
 1907 084a 8C93      	.LFBB30:
 432:pwm.c         **** 	//timer2PWMAOff();
 433:pwm.c         **** 	PWM_timer2_Off_H6();
 1908               	
 1909               		push r28
 1910 084c 0E94 0000 		in r28,__SP_L__
 1911               		in r29,__SP_H__
 434:pwm.c         **** 	//timer2PWMCOff();
 435:pwm.c         **** }
 1912               	prologue: function */
 1913               	/* frame size = 0 */
 1915 0852 DF91      	.LM193:
 1916 0854 0895      		ldi r26,lo8(144)
 1917               		ldi r27,hi8(144)
 1918               		ldi r30,lo8(144)
 1919               		ldi r31,hi8(144)
 1920               		ld r24,Z
 1921               		andi r24,lo8(-3)
 1922               		st X,r24
 436:pwm.c         **** void PWM_timer3_Off_All(void)
 437:pwm.c         **** {
 1923               	0,439,.LM194-.LFBB30
 1924               	.LM194:
 1925               		ldi r26,lo8(144)
 1926 0856 DF93      		ldi r27,hi8(144)
 1927 0858 CF93      		ldi r30,lo8(144)
 1928 085a CDB7      		ldi r31,hi8(144)
 1929 085c DEB7      		ld r24,Z
 1930               		andi r24,lo8(-2)
 1931               		st X,r24
 438:pwm.c         **** 	cbi(TCCR3A,PWM11);
 1932               	8,0,441,.LM195-.LFBB30
 1933               	.LM195:
 1934 085e A0E9      		call PWM_timer3_Off_E3
 1936 0862 E0E9      	.LM196:
 1937 0864 F0E0      		call PWM_timer3_Off_E4
 1939 0868 8D7F      	.LM197:
 1940 086a 8C93      		call PWM_timer3_Off_E5
 439:pwm.c         **** 	cbi(TCCR3A,PWM10);
 1941               	ue start */
 1943 086c A0E9      	.LM198:
 1944 086e B0E0      		pop r28
 1945 0870 E0E9      		pop r29
 1946 0872 F0E0      		ret
 1948 0876 8E7F      	.Lscope30:
 440:pwm.c         **** 	//timer2PWMAOff();
 441:pwm.c         **** 	PWM_timer3_Off_E3();
 1950               	WM_timer4_Off_All
 1952 087a 0E94 0000 	PWM_timer4_Off_All:
 442:pwm.c         **** 	PWM_timer3_Off_E4();
 1953               	tabn	68,0,447,.LM199-.LFBB31
 1954               	.LM199:
 1955 087e 0E94 0000 	.LFBB31:
 443:pwm.c         **** 	PWM_timer3_Off_E5();
 1956               	sh r29
 1957               		push r28
 1958 0882 0E94 0000 		in r28,__SP_L__
 1959               		in r29,__SP_H__
 444:pwm.c         **** 	//timer2PWMCOff();
 445:pwm.c         **** }
 1960               	rologue: function */
 1961               	/* frame size = 0 */
 1963 0888 DF91      	.LM200:
 1964 088a 0895      		ldi r26,lo8(160)
 1965               		ldi r27,hi8(160)
 1966               		ldi r30,lo8(160)
 1967               		ldi r31,hi8(160)
 1968               		ld r24,Z
 1969               		andi r24,lo8(-3)
 1970               		st X,r24
 446:pwm.c         **** void PWM_timer4_Off_All(void)
 447:pwm.c         **** {
 1971               	0,449,.LM201-.LFBB31
 1972               	.LM201:
 1973               		ldi r26,lo8(160)
 1974 088c DF93      		ldi r27,hi8(160)
 1975 088e CF93      		ldi r30,lo8(160)
 1976 0890 CDB7      		ldi r31,hi8(160)
 1977 0892 DEB7      		ld r24,Z
 1978               		andi r24,lo8(-2)
 1979               		st X,r24
 448:pwm.c         **** 	cbi(TCCR4A,PWM11);
 1980               	8,0,451,.LM202-.LFBB31
 1981               	.LM202:
 1982 0894 A0EA      		call PWM_timer4_Off_H3
 1984 0898 E0EA      	.LM203:
 1985 089a F0E0      		call PWM_timer4_Off_H4
 1987 089e 8D7F      	.LM204:
 1988 08a0 8C93      		call PWM_timer4_Off_H5
 449:pwm.c         **** 	cbi(TCCR4A,PWM10);
 1989               	ue start */
 1991 08a2 A0EA      	.LM205:
 1992 08a4 B0E0      		pop r28
 1993 08a6 E0EA      		pop r29
 1994 08a8 F0E0      		ret
 1996 08ac 8E7F      	.Lscope31:
 450:pwm.c         **** 	//timer2PWMAOff();
 451:pwm.c         **** 	PWM_timer4_Off_H3();
 1998               	pwmDuty:p(15,3)",160,0,0,1
 1999               	.global	PWM_timer1_Set_LED
 452:pwm.c         **** 	PWM_timer4_Off_H4();
 2001               	_timer1_Set_LED:
 2003 08b4 0E94 0000 	.LM206:
 453:pwm.c         **** 	PWM_timer4_Off_H5();
 2004               	BB32:
 2005               		push r29
 2006 08b8 0E94 0000 		push r28
 2007               		rcall .
 454:pwm.c         **** 	//timer2PWMCOff();
 455:pwm.c         **** }
 2008               	r28,__SP_L__
 2009               		in r29,__SP_H__
 2010 08bc CF91      	/* prologue: function */
 2011 08be DF91      	/* frame size = 2 */
 2012 08c0 0895      		std Y+2,r25
 2013               		std Y+1,r24
 2015               	.LM207:
 2016               		ldi r30,lo8(138)
 2017               		ldi r31,hi8(138)
 2018               		ldd r24,Y+1
 2019               		ldd r25,Y+2
 456:pwm.c         **** 
 457:pwm.c         **** 
 458:pwm.c         **** // set PWM (output compare) duty for channel B
 459:pwm.c         **** // this PWM output is generated on OC2B pin
 460:pwm.c         **** // NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 461:pwm.c         **** //			pwmDuty should be in the range 0-511 for 9bit PWM
 462:pwm.c         **** //			pwmDuty should be in the range 0-1023 for 10bit PWM
 463:pwm.c         **** void PWM_timer1_Set_LED(u16 pwmDuty)
 464:pwm.c         **** 	{OCR1B = pwmDuty;}
 2020               	
 2021               		st Z,r24
 2022               	/* epilogue start */
 2023 08c2 DF93      		pop __tmp_reg__
 2024 08c4 CF93      		pop __tmp_reg__
 2025 08c6 00D0      		pop r28
 2026 08c8 CDB7      		pop r29
 2027 08ca DEB7      		ret
 2029               	.Lscope32:
 2032               	.global	PWM_timer2_Set_H6
 2034 08d0 EAE8      	PWM_timer2_Set_H6:
 2036 08d4 8981      	.LM208:
 2037 08d6 9A81      	.LFBB33:
 2038 08d8 9183      		push r29
 2039 08da 8083      		push r28
 2040               		rcall .
 2041 08dc 0F90      		in r28,__SP_L__
 2042 08de 0F90      		in r29,__SP_H__
 2043 08e0 CF91      	/* prologue: function */
 2044 08e2 DF91      	/* frame size = 2 */
 2045 08e4 0895      		std Y+2,r25
 2046               		std Y+1,r24
 2048               	.LM209:
 2049               		ldi r30,lo8(180)
 2050               		ldi r31,hi8(180)
 2051               		ldd r24,Y+1
 2052               		st Z,r24
 465:pwm.c         **** void PWM_timer2_Set_H6(u16 pwmDuty)
 466:pwm.c         **** 	{OCR2B = pwmDuty;}
 2053               	reg__
 2054               		pop __tmp_reg__
 2055               		pop r28
 2056 08e6 DF93      		pop r29
 2057 08e8 CF93      		ret
 2059 08ec CDB7      	.Lscope33:
 2062               	.global	PWM_timer3_Set_E3
 2064 08f2 8983      	PWM_timer3_Set_E3:
 2066               	.LM210:
 2067 08f4 E4EB      	.LFBB34:
 2068 08f6 F0E0      		push r29
 2069 08f8 8981      		push r28
 2070 08fa 8083      		rcall .
 2071               		in r28,__SP_L__
 2072 08fc 0F90      		in r29,__SP_H__
 2073 08fe 0F90      	/* prologue: function */
 2074 0900 CF91      	/* frame size = 2 */
 2075 0902 DF91      		std Y+2,r25
 2076 0904 0895      		std Y+1,r24
 2078               	.LM211:
 2079               		ldi r30,lo8(152)
 2080               		ldi r31,hi8(152)
 2081               		ldd r24,Y+1
 2082               		ldd r25,Y+2
 2083               		std Z+1,r25
 467:pwm.c         **** void PWM_timer3_Set_E3(u16 pwmDuty)
 468:pwm.c         **** 	{OCR3A = pwmDuty;}
 2084               		pop __tmp_reg__
 2085               		pop __tmp_reg__
 2086               		pop r28
 2087 0906 DF93      		pop r29
 2088 0908 CF93      		ret
 2090 090c CDB7      	.Lscope34:
 2093               	.global	PWM_timer3_Set_E4
 2095 0912 8983      	PWM_timer3_Set_E4:
 2097               	.LM212:
 2098 0914 E8E9      	.LFBB35:
 2099 0916 F0E0      		push r29
 2100 0918 8981      		push r28
 2101 091a 9A81      		rcall .
 2102 091c 9183      		in r28,__SP_L__
 2103 091e 8083      		in r29,__SP_H__
 2104               	/* prologue: function */
 2105 0920 0F90      	/* frame size = 2 */
 2106 0922 0F90      		std Y+2,r25
 2107 0924 CF91      		std Y+1,r24
 2109 0928 0895      	.LM213:
 2110               		ldi r30,lo8(154)
 2111               		ldi r31,hi8(154)
 2112               		ldd r24,Y+1
 2113               		ldd r25,Y+2
 2114               		std Z+1,r25
 2115               		st Z,r24
 2116               	/* epilogue start */
 469:pwm.c         **** void PWM_timer3_Set_E4(u16 pwmDuty)
 470:pwm.c         **** 	{OCR3B = pwmDuty;}
 2117               	
 2118               		pop r28
 2119               		pop r29
 2120 092a DF93      		ret
 2122 092e 00D0      	.Lscope35:
 2125               	.global	PWM_timer3_Set_E5
 2127 0934 9A83      	PWM_timer3_Set_E5:
 2129               	.LM214:
 2130               	.LFBB36:
 2131 0938 EAE9      		push r29
 2132 093a F0E0      		push r28
 2133 093c 8981      		rcall .
 2134 093e 9A81      		in r28,__SP_L__
 2135 0940 9183      		in r29,__SP_H__
 2136 0942 8083      	/* prologue: function */
 2137               	/* frame size = 2 */
 2138 0944 0F90      		std Y+2,r25
 2139 0946 0F90      		std Y+1,r24
 2141 094a DF91      	.LM215:
 2142 094c 0895      		ldi r30,lo8(156)
 2143               		ldi r31,hi8(156)
 2144               		ldd r24,Y+1
 2145               		ldd r25,Y+2
 2146               		std Z+1,r25
 2147               		st Z,r24
 2148               	/* epilogue start */
 2149               		pop __tmp_reg__
 471:pwm.c         **** void PWM_timer3_Set_E5(u16 pwmDuty)
 472:pwm.c         **** 	{OCR3C = pwmDuty;}
 2150               	29
 2151               		ret
 2153 094e DF93      	.Lscope36:
 2156 0954 CDB7      	.global	PWM_timer4_Set_H3
 2158               	PWM_timer4_Set_H3:
 2160 0958 9A83      	.LM216:
 2161 095a 8983      	.LFBB37:
 2162               		push r29
 2163               		push r28
 2164 095c ECE9      		rcall .
 2165 095e F0E0      		in r28,__SP_L__
 2166 0960 8981      		in r29,__SP_H__
 2167 0962 9A81      	/* prologue: function */
 2168 0964 9183      	/* frame size = 2 */
 2169 0966 8083      		std Y+2,r25
 2170               		std Y+1,r24
 2172 096a 0F90      	.LM217:
 2173 096c CF91      		ldi r30,lo8(168)
 2174 096e DF91      		ldi r31,hi8(168)
 2175 0970 0895      		ldd r24,Y+1
 2176               		ldd r25,Y+2
 2177               		std Z+1,r25
 2178               		st Z,r24
 2179               	/* epilogue start */
 2180               		pop __tmp_reg__
 2181               		pop __tmp_reg__
 2182               		pop r28
 473:pwm.c         **** void PWM_timer4_Set_H3(u16 pwmDuty)
 474:pwm.c         **** 	{OCR4A = pwmDuty;}
 2183               	et_H3, .-PWM_timer4_Set_H3
 2184               	.Lscope37:
 2187 0974 CF93      	.global	PWM_timer4_Set_H4
 2189 0978 CDB7      	PWM_timer4_Set_H4:
 2191               	.LM218:
 2192               	.LFBB38:
 2193 097c 9A83      		push r29
 2194 097e 8983      		push r28
 2195               		rcall .
 2196               		in r28,__SP_L__
 2197 0980 E8EA      		in r29,__SP_H__
 2198 0982 F0E0      	/* prologue: function */
 2199 0984 8981      	/* frame size = 2 */
 2200 0986 9A81      		std Y+2,r25
 2201 0988 9183      		std Y+1,r24
 2203               	.LM219:
 2204 098c 0F90      		ldi r30,lo8(170)
 2205 098e 0F90      		ldi r31,hi8(170)
 2206 0990 CF91      		ldd r24,Y+1
 2207 0992 DF91      		ldd r25,Y+2
 2208 0994 0895      		std Z+1,r25
 2209               		st Z,r24
 2210               	/* epilogue start */
 2211               		pop __tmp_reg__
 2212               		pop __tmp_reg__
 2213               		pop r28
 2214               		pop r29
 2215               		ret
 475:pwm.c         **** void PWM_timer4_Set_H4(u16 pwmDuty)
 476:pwm.c         **** 	{OCR4B = pwmDuty;}
 2216               	imer4_Set_H4
 2217               	.Lscope38:
 2220 0998 CF93      	.global	PWM_timer4_Set_H5
 2222 099c CDB7      	PWM_timer4_Set_H5:
 2224               	.LM220:
 2225               	.LFBB39:
 2226 09a0 9A83      		push r29
 2227 09a2 8983      		push r28
 2228               		rcall .
 2229               		in r28,__SP_L__
 2230 09a4 EAEA      		in r29,__SP_H__
 2231 09a6 F0E0      	/* prologue: function */
 2232 09a8 8981      	/* frame size = 2 */
 2233 09aa 9A81      		std Y+2,r25
 2234 09ac 9183      		std Y+1,r24
 2236               	.LM221:
 2237 09b0 0F90      		ldi r30,lo8(172)
 2238 09b2 0F90      		ldi r31,hi8(172)
 2239 09b4 CF91      		ldd r24,Y+1
 2240 09b6 DF91      		ldd r25,Y+2
 2241 09b8 0895      		std Z+1,r25
 2242               		st Z,r24
 2243               	/* epilogue start */
 2244               		pop __tmp_reg__
 2245               		pop __tmp_reg__
 2246               		pop r28
 2247               		pop r29
 2248               		ret
 477:pwm.c         **** void PWM_timer4_Set_H5(u16 pwmDuty)
 478:pwm.c         **** 	{OCR4C = pwmDuty;}
 2249               	imer4_Set_H5
 2250               	.Lscope39:
 2257               	.global	configure_ports
 2259 09c4 9A83      	configure_ports:
 2261               	.Ltext2:
 2263 09c8 ECEA      	.LM222:
 2264 09ca F0E0      	.LFBB40:
 2265 09cc 8981      		push r29
 2266 09ce 9A81      		push r28
 2267 09d0 9183      		in r28,__SP_L__
 2268 09d2 8083      		in r29,__SP_H__
 2269               	/* prologue: function */
 2270 09d4 0F90      	/* frame size = 0 */
 2272 09d8 CF91      	.LM223:
 2273 09da DF91      		ldi r30,lo8(48)
 2274 09dc 0895      		ldi r31,hi8(48)
 2275               		st Z,__zero_reg__
 2277               	.LM224:
 2278               		ldi r30,lo8(49)
 2279               		ldi r31,hi8(49)
 2280               		st Z,__zero_reg__
 2282               	.LM225:
 2283               		ldi r30,lo8(263)
 2284               		ldi r31,hi8(263)
 2285               		st Z,__zero_reg__
 2287               	.LM226:
   1:SoR_Utils.h   **** /****************************************************************************
   2:SoR_Utils.h   **** *
   3:SoR_Utils.h   **** *   Copyright (c) 2008 www.societyofrobots.com
   4:SoR_Utils.h   **** *   (please link back if you use this code!)
   5:SoR_Utils.h   **** *
   6:SoR_Utils.h   **** *   This program is free software; you can redistribute it and/or modify
   7:SoR_Utils.h   **** *   it under the terms of the GNU General Public License version 2 as
   8:SoR_Utils.h   **** *   published by the Free Software Foundation.
   9:SoR_Utils.h   **** *
  10:SoR_Utils.h   **** *   Alternatively, this software may be distributed under the terms of BSD
  11:SoR_Utils.h   **** *   license.
  12:SoR_Utils.h   **** *
  13:SoR_Utils.h   **** ****************************************************************************/
  14:SoR_Utils.h   **** 
  15:SoR_Utils.h   **** //AVR includes
  16:SoR_Utils.h   **** #include <avr/io.h>		    // include I/O definitions (port names, pin names, etc)
  17:SoR_Utils.h   **** #include <avr/interrupt.h>	// include interrupt support
  18:SoR_Utils.h   **** #include <stdio.h>			// stuff
  19:SoR_Utils.h   **** #include <stdlib.h>			// stuff
  20:SoR_Utils.h   **** #include <math.h>			// stuff
  21:SoR_Utils.h   **** //#include "libm.a"			// required with math.h
  22:SoR_Utils.h   **** #include <string.h>			// allow strings to be used
  23:SoR_Utils.h   **** #include <avr/eeprom.h>		// adds EEPROM functionality
  24:SoR_Utils.h   **** 
  25:SoR_Utils.h   **** //AVRlib includes
  26:SoR_Utils.h   **** #include "global.h"		// include global settings
  27:SoR_Utils.h   **** #include "uart4.h"		// include uart function library, includes buffer.h
  28:SoR_Utils.h   **** #include "rprintf.h"	// include printf function library
  29:SoR_Utils.h   **** #include "timer640.h"	// include timer function library (timing, PWM, etc)
  30:SoR_Utils.h   **** #include "pwm.c"		// for PWM stuff
  31:SoR_Utils.h   **** #include "a2d.h"		// include A/D converter function library
  32:SoR_Utils.h   **** #include "i2c.h"		// include i2c support
  33:SoR_Utils.h   **** #include "spi.h"		// include spi support
  34:SoR_Utils.h   **** 
  35:SoR_Utils.h   **** //define port functions; example: PORT_ON( PORTD, 6);
  36:SoR_Utils.h   **** #define PORT_ON( port_letter, number )			port_letter |= (1<<number)
  37:SoR_Utils.h   **** #define PORT_OFF( port_letter, number )			port_letter &= ~(1<<number)
  38:SoR_Utils.h   **** //#define PORT_ALL_ON( port_letter, number )		port_letter |= (number)
  39:SoR_Utils.h   **** //#define PORT_ALL_OFF( port_letter, number )		port_letter &= ~(number)
  40:SoR_Utils.h   **** #define FLIP_PORT( port_letter, number )		port_letter ^= (1<<number)
  41:SoR_Utils.h   **** #define PORT_IS_ON( port_letter, number )		( port_letter & (1<<number) )
  42:SoR_Utils.h   **** #define PORT_IS_OFF( port_letter, number )		!( port_letter & (1<<number) )
  43:SoR_Utils.h   **** 
  44:SoR_Utils.h   **** //define the servo function macro
  45:SoR_Utils.h   **** #define servo(port,number,position)   (PORT_ON(port,number), delay_cycles(position), PORT_OFF(port,
  46:SoR_Utils.h   **** 
  47:SoR_Utils.h   **** 
  48:SoR_Utils.h   **** //************CONFIGURE PORTS************
  49:SoR_Utils.h   **** //configure ports for input or output - specific to ATmega2560
  50:SoR_Utils.h   **** void configure_ports(void)
  51:SoR_Utils.h   **** 	{
 2288               	 Z,__zero_reg__
 2290               	.LM227:
 2291 09de DF93      		ldi r30,lo8(33)
 2292 09e0 CF93      		ldi r31,hi8(33)
 2293 09e2 CDB7      		ldi r24,lo8(-1)
 2294 09e4 DEB7      		st Z,r24
 2296               	.LM228:
  52:SoR_Utils.h   **** 	//examples: configure ports for input or output
  53:SoR_Utils.h   **** 	//DDRB = 0x1F;  //configure B ports 0->4 for output (google search '0b00011111 to hex')
  54:SoR_Utils.h   **** 	//DDRC = 0x7F;  //configure all C ports for output, except 7 (0b01111111 to hex)
  55:SoR_Utils.h   **** 	//DDRD = 0xFE;  //configure all D ports for output, except 0 and 1 (RX/TX) FC
  56:SoR_Utils.h   ****     //DDRC = _BV (PC0); //PC0 is digital output
  57:SoR_Utils.h   **** 	//0b76543210 <- port # order, 1 for output, 0 for input
  58:SoR_Utils.h   **** 	//to convert from binary to hex, google search '0b00011111 to hex'
  59:SoR_Utils.h   **** 	//DDRG &= ~_BV(PG5); //make port G5 an input pin
  60:SoR_Utils.h   **** 	//cbi(DDRG, PG5);  //set G5 as input pin
  61:SoR_Utils.h   **** 
  62:SoR_Utils.h   **** 	//ANALOG PORTS
  63:SoR_Utils.h   **** 	//useful for sensors, SharpIR, photoresistors, etc.
  64:SoR_Utils.h   **** 	//analog ports can be configured as digital ports if desired
  65:SoR_Utils.h   **** 	DDRF = 0b00000000;  //configure all F ports for input				0x00
 2297               	lo8(36)
 2298               		ldi r31,hi8(36)
 2299 09e6 E0E3      		ldi r24,lo8(64)
 2300 09e8 F0E0      		st Z,r24
  66:SoR_Utils.h   **** 	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
 2302               	9:
 2303               		ldi r30,lo8(39)
 2304 09ec E1E3      		ldi r31,hi8(39)
 2305 09ee F0E0      		ldi r24,lo8(-1)
 2306 09f0 1082      		st Z,r24
  67:SoR_Utils.h   **** 	DDRK = 0b00000000;  //configure all K ports for input				0x00
 2307               	bn	68,0,94,.LM230-.LFBB40
 2308               	.LM230:
 2309 09f2 E7E0      		ldi r26,lo8(43)
 2310 09f4 F1E0      		ldi r27,hi8(43)
 2311 09f6 1082      		ldi r30,lo8(43)
  68:SoR_Utils.h   **** 	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
 2312               	r31,hi8(43)
 2313               		ld r24,Z
 2314 09f8 E8E0      		ori r24,lo8(1)
 2315 09fa F1E0      		st X,r24
  69:SoR_Utils.h   **** 
  70:SoR_Utils.h   **** 	//DIGITAL PORTS
  71:SoR_Utils.h   **** 	//useful for servos, PWM, LED's, UART, interrupts, timers
  72:SoR_Utils.h   **** 	DDRA = 0b11111111;  //configure ports for output
 2317               	1:
 2318               		ldi r26,lo8(43)
 2319 09fe E1E2      		ldi r27,hi8(43)
 2320 0a00 F0E0      		ldi r30,lo8(43)
 2321 0a02 8FEF      		ldi r31,hi8(43)
 2322 0a04 8083      		ld r24,Z
  73:SoR_Utils.h   **** 	//       ||||||||
  74:SoR_Utils.h   **** 	//       |||||||\___0: 
  75:SoR_Utils.h   **** 	//       ||||||\____1: 
  76:SoR_Utils.h   **** 	//       |||||\_____2: 
  77:SoR_Utils.h   **** 	//       ||||\______3: 
  78:SoR_Utils.h   **** 	//       |||\_______4: 
  79:SoR_Utils.h   **** 	//       ||\________5: 
  80:SoR_Utils.h   **** 	//       |\_________6: 
  81:SoR_Utils.h   **** 	//       \__________7: 
  82:SoR_Utils.h   **** 	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
  83:SoR_Utils.h   **** 	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
 2323               	24,lo8(2)
 2324               		st X,r24
 2326 0a08 F0E0      	.LM232:
 2327 0a0a 80E4      		ldi r30,lo8(42)
 2328 0a0c 8083      		ldi r31,hi8(42)
  84:SoR_Utils.h   **** 	DDRC = 0b11111111;  //configure ports for output
 2329               	24,lo8(-13)
 2330               		st Z,r24
 2332 0a10 F0E0      	.LM233:
 2333 0a12 8FEF      		ldi r30,lo8(45)
 2334 0a14 8083      		ldi r31,hi8(45)
  85:SoR_Utils.h   **** 	//       ||||||||
  86:SoR_Utils.h   **** 	//       |||||||\___0: 
  87:SoR_Utils.h   **** 	//       ||||||\____1: 
  88:SoR_Utils.h   **** 	//       |||||\_____2: 
  89:SoR_Utils.h   **** 	//       ||||\______3: 
  90:SoR_Utils.h   **** 	//       |||\_______4: 
  91:SoR_Utils.h   **** 	//       ||\________5: 
  92:SoR_Utils.h   **** 	//       |\_________6: 
  93:SoR_Utils.h   **** 	//       \__________7: 	
  94:SoR_Utils.h   **** 	sbi(PORTD, PD0); // SCL pull-up
 2335               	24,lo8(-2)
 2336               		st Z,r24
 2338 0a18 B0E0      	.LM234:
 2339 0a1a EBE2      		ldi r26,lo8(52)
 2340 0a1c F0E0      		ldi r27,hi8(52)
 2341 0a1e 8081      		ldi r30,lo8(52)
 2342 0a20 8160      		ldi r31,hi8(52)
 2343 0a22 8C93      		ld r24,Z
  95:SoR_Utils.h   **** 	sbi(PORTD, PD1); // SDA pull-up
 2344               	lo8(32)
 2345               		st X,r24
 2347 0a26 B0E0      	.LM235:
 2348 0a28 EBE2      		ldi r26,lo8(51)
 2349 0a2a F0E0      		ldi r27,hi8(51)
 2350 0a2c 8081      		ldi r30,lo8(51)
 2351 0a2e 8260      		ldi r31,hi8(51)
 2352 0a30 8C93      		ld r24,Z
  96:SoR_Utils.h   **** 	DDRD = 0b11110011;  //configure ports for output
 2353               	,lo8(-33)
 2354               		st X,r24
 2356 0a34 F0E0      	.LM236:
 2357 0a36 83EF      		ldi r30,lo8(257)
 2358 0a38 8083      		ldi r31,hi8(257)
  97:SoR_Utils.h   **** 	//       ||||||||
  98:SoR_Utils.h   **** 	//       |||||||\___0: 
  99:SoR_Utils.h   **** 	//       ||||||\____1: 
 100:SoR_Utils.h   **** 	//       |||||\_____2: serial RXD1, input  -> 0
 101:SoR_Utils.h   **** 	//       ||||\______3: serial TXD1, output -> 1
 102:SoR_Utils.h   **** 	//       |||\_______4: 
 103:SoR_Utils.h   **** 	//       ||\________5: 
 104:SoR_Utils.h   **** 	//       |\_________6: 
 105:SoR_Utils.h   **** 	//       \__________7: timer0
 106:SoR_Utils.h   **** 	DDRE = 0b11111110;  //configure ports for output
 2359               	24,lo8(-2)
 2360               		st Z,r24
 2362 0a3c F0E0      	.LM237:
 2363 0a3e 8EEF      		ldi r30,lo8(260)
 2364 0a40 8083      		ldi r31,hi8(260)
 107:SoR_Utils.h   **** 	//       ||||||||
 108:SoR_Utils.h   **** 	//       |||||||\___0: serial RXD0, input  -> 0
 109:SoR_Utils.h   **** 	//       ||||||\____1: serial TXD0, output -> 1
 110:SoR_Utils.h   **** 	//       |||||\_____2: 
 111:SoR_Utils.h   **** 	//       ||||\______3: 
 112:SoR_Utils.h   **** 	//       |||\_______4: 
 113:SoR_Utils.h   **** 	//       ||\________5: 
 114:SoR_Utils.h   **** 	//       |\_________6: 
 115:SoR_Utils.h   **** 	//       \__________7: 
 116:SoR_Utils.h   **** 	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
 117:SoR_Utils.h   **** 	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
 2365               	24,lo8(-2)
 2366               		st Z,r24
 2367 0a42 A4E3      	/* epilogue start */
 2369 0a46 E4E3      	.LM238:
 2370 0a48 F0E0      		pop r28
 2371 0a4a 8081      		pop r29
 2372 0a4c 8062      		ret
 118:SoR_Utils.h   **** 	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
 2374               	:
 2377 0a52 B0E0      	.global	delay_cycles
 2379 0a56 F0E0      	delay_cycles:
 2381 0a5a 8F7D      	.LM239:
 2382 0a5c 8C93      	.LFBB41:
 119:SoR_Utils.h   **** 	//note that button actions are inverted between both versions!!!
 120:SoR_Utils.h   **** 	DDRH = 0b11111110;  //configure ports for output
 2383               	
 2384               		push r28
 2385 0a5e E1E0      		rcall .
 2386 0a60 F1E0      		rcall .
 2387 0a62 8EEF      		in r28,__SP_L__
 2388 0a64 8083      		in r29,__SP_H__
 121:SoR_Utils.h   **** 	//       ||||||||
 122:SoR_Utils.h   **** 	//       |||||||\___0: serial RXD2, input  -> 0
 123:SoR_Utils.h   **** 	//       ||||||\____1: serial TXD2, output -> 1
 124:SoR_Utils.h   **** 	//       |||||\_____2: 
 125:SoR_Utils.h   **** 	//       ||||\______3: 
 126:SoR_Utils.h   **** 	//       |||\_______4: 
 127:SoR_Utils.h   **** 	//       ||\________5: 
 128:SoR_Utils.h   **** 	//       |\_________6: 
 129:SoR_Utils.h   **** 	//       \__________7: 
 130:SoR_Utils.h   **** 	DDRJ = 0b11111110;  //configure ports for output
 2389               	ologue: function */
 2390               	/* frame size = 4 */
 2391 0a66 E4E0      		std Y+1,r22
 2392 0a68 F1E0      		std Y+2,r23
 2393 0a6a 8EEF      		std Y+3,r24
 2394 0a6c 8083      		std Y+4,r25
 2395               		rjmp .L106
 131:SoR_Utils.h   **** 	//       ||||||||
 132:SoR_Utils.h   **** 	//       |||||||\___0: serial RXD3, input  -> 0
 133:SoR_Utils.h   **** 	//       ||||||\____1: serial TXD3, output -> 1
 134:SoR_Utils.h   **** 	//       |||||\_____2: 
 135:SoR_Utils.h   **** 	//       ||||\______3: 
 136:SoR_Utils.h   **** 	//       |||\_______4: 
 137:SoR_Utils.h   **** 	//       ||\________5: 
 138:SoR_Utils.h   **** 	//       |\_________6: 
 139:SoR_Utils.h   **** 	//       \__________7: 
 140:SoR_Utils.h   **** 	//PORTL has no headers
 141:SoR_Utils.h   **** 	};
 2397               	.LM240:
 2398 0a6e CF91      		ldd r24,Y+1
 2399 0a70 DF91      		ldd r25,Y+2
 2400 0a72 0895      		ldd r26,Y+3
 2401               		ldd r27,Y+4
 2402               		sbiw r24,1
 2403               		sbc r26,__zero_reg__
 2404               		sbc r27,__zero_reg__
 2405               		std Y+1,r24
 2406               		std Y+2,r25
 2407               		std Y+3,r26
 142:SoR_Utils.h   **** //***************************************
 143:SoR_Utils.h   **** 
 144:SoR_Utils.h   **** 
 145:SoR_Utils.h   **** //************DELAY FUNCTIONS************
 146:SoR_Utils.h   **** //wait for X amount of cycles (234 cycles is about 1.003 milliseconds)//incorrect
 147:SoR_Utils.h   **** //to calculate: 234/1.003*(time in milliseconds) = number of cycles
 148:SoR_Utils.h   **** void delay_cycles(unsigned long int cycles)
 149:SoR_Utils.h   **** 	{
 2408               	
 2409               	.L106:
 2411 0a74 DF93      	.LM241:
 2412 0a76 CF93      		ldd r24,Y+1
 2413 0a78 00D0      		ldd r25,Y+2
 2414 0a7a 00D0      		ldd r26,Y+3
 2415 0a7c CDB7      		ldd r27,Y+4
 2416 0a7e DEB7      		sbiw r24,0
 2417               		cpc r26,__zero_reg__
 2418               		cpc r27,__zero_reg__
 2419 0a80 6983      		brne .L107
 2420 0a82 7A83      	/* epilogue start */
 2422 0a86 9C83      	.LM242:
 2423 0a88 00C0      		pop __tmp_reg__
 2424               		pop __tmp_reg__
 150:SoR_Utils.h   **** 	cycles=cycles;//doubled frequency but too lazy to change times
 151:SoR_Utils.h   **** 	while(cycles > 0)
 152:SoR_Utils.h   **** 		cycles--;
 2425               	
 2426               		pop __tmp_reg__
 2427 0a8a 8981      		pop r28
 2428 0a8c 9A81      		pop r29
 2429 0a8e AB81      		ret
 2431 0a92 0197      	.Lscope41:
 2433 0a96 B109      	.global	LED_off
 2435 0a9a 9A83      	LED_off:
 2437 0a9e BC83      	.LM243:
 2438               	.LFBB42:
 2439               		push r29
 2440               		push r28
 2441 0aa0 8981      		in r28,__SP_L__
 2442 0aa2 9A81      		in r29,__SP_H__
 2443 0aa4 AB81      	/* prologue: function */
 2444 0aa6 BC81      	/* frame size = 0 */
 2446 0aaa A105      	.LM244:
 2447 0aac B105      		ldi r26,lo8(37)
 2448 0aae 01F4      		ldi r27,hi8(37)
 2449               		ldi r30,lo8(37)
 153:SoR_Utils.h   **** 	}
 2450               	,Z
 2451               		ori r24,lo8(64)
 2452 0ab0 0F90      		st X,r24
 2453 0ab2 0F90      	/* epilogue start */
 2454 0ab4 0F90      		pop r28
 2455 0ab6 0F90      		pop r29
 2456 0ab8 CF91      		ret
 2458 0abc 0895      	.Lscope42:
 2460               	.global	LED_on
 2462               	LED_on:
 2464               	.LM245:
 154:SoR_Utils.h   **** //***************************************
 155:SoR_Utils.h   **** 
 156:SoR_Utils.h   **** 
 157:SoR_Utils.h   **** //***************STATUS LED**************
 158:SoR_Utils.h   **** //tank test
 159:SoR_Utils.h   **** void LED_off(void)
 160:SoR_Utils.h   **** 	{PORT_ON(PORTB,6);}
 2465               	r29
 2466               		push r28
 2467               		in r28,__SP_L__
 2468 0abe DF93      		in r29,__SP_H__
 2469 0ac0 CF93      	/* prologue: function */
 2470 0ac2 CDB7      	/* frame size = 0 */
 2472               	.LM246:
 2473               		ldi r26,lo8(37)
 2474               		ldi r27,hi8(37)
 2475               		ldi r30,lo8(37)
 2476 0ac6 A5E2      		ldi r31,hi8(37)
 2477 0ac8 B0E0      		ld r24,Z
 2478 0aca E5E2      		andi r24,lo8(-65)
 2479 0acc F0E0      		st X,r24
 2480 0ace 8081      	/* epilogue start */
 2481 0ad0 8064      		pop r28
 2482 0ad2 8C93      		pop r29
 2483               		ret
 2485 0ad6 DF91      	.Lscope43:
 2487               	.global	button_pressed
 2489               	button_pressed:
 2491               	.LM247:
 2492               	.LFBB44:
 161:SoR_Utils.h   **** void LED_on(void)
 162:SoR_Utils.h   **** 	{PORT_OFF(PORTB,6);}
 2493               	
 2494               		in r28,__SP_L__
 2495               		in r29,__SP_H__
 2496 0ada DF93      	/* prologue: function */
 2497 0adc CF93      	/* frame size = 2 */
 2499 0ae0 DEB7      	.LM248:
 2500               		ldi r30,lo8(50)
 2501               		ldi r31,hi8(50)
 2502               		ld r24,Z
 2503               		mov r24,r24
 2504 0ae2 A5E2      		ldi r25,lo8(0)
 2505 0ae4 B0E0      		andi r24,lo8(32)
 2506 0ae6 E5E2      		andi r25,hi8(32)
 2507 0ae8 F0E0      		std Y+2,__zero_reg__
 2508 0aea 8081      		std Y+1,__zero_reg__
 2509 0aec 8F7B      		sbiw r24,0
 2510 0aee 8C93      		brne .L114
 2511               		ldi r24,lo8(1)
 2512 0af0 CF91      		ldi r25,hi8(1)
 2513 0af2 DF91      		std Y+2,r25
 2514 0af4 0895      		std Y+1,r24
 2515               	.L114:
 2516               		ldd r24,Y+1
 2517               		ldd r25,Y+2
 2518               	/* epilogue start */
 2520               	.LM249:
 163:SoR_Utils.h   **** //***************************************
 164:SoR_Utils.h   **** 
 165:SoR_Utils.h   **** 
 166:SoR_Utils.h   **** //*****************BUTTON****************
 167:SoR_Utils.h   **** int button_pressed(void)
 168:SoR_Utils.h   **** 	{
 2521               	_reg__
 2522               		pop r28
 2523               		pop r29
 2524 0af6 DF93      		ret
 2526 0afa 00D0      	.Lscope44:
 2527 0afc CDB7      	.global	angtable
 2528 0afe DEB7      		.data
 169:SoR_Utils.h   **** 	return (bit_is_clear(PING, 5));
 2531               		.word	100
 2532               		.word	100
 2533 0b00 E2E3      		.word	98
 2534 0b02 F0E0      		.word	97
 2535 0b04 8081      		.word	94
 2536 0b06 882F      		.word	91
 2537 0b08 90E0      		.word	87
 2538 0b0a 8072      		.word	82
 2539 0b0c 9070      		.word	77
 2540 0b0e 1A82      		.word	71
 2541 0b10 1982      		.word	64
 2542 0b12 0097      		.word	57
 2543 0b14 01F4      		.word	50
 2544 0b16 81E0      		.word	42
 2545 0b18 90E0      		.word	34
 2546 0b1a 9A83      		.word	26
 2547 0b1c 8983      		.word	17
 2548               		.word	9
 2549 0b1e 8981      		.word	0
 2550 0b20 9A81      		.word	-9
 2551               		.word	-17
 170:SoR_Utils.h   **** 	//return ((PING) & (1<<PG5));//old version, went high when button pushed
 171:SoR_Utils.h   **** 	}
 2552               	
 2553               		.word	-42
 2554 0b22 0F90      		.word	-50
 2555 0b24 0F90      		.word	-57
 2556 0b26 CF91      		.word	-64
 2557 0b28 DF91      		.word	-71
 2558 0b2a 0895      		.word	-77
 2559               		.word	-82
 2560               		.word	-87
 2561               		.word	-91
 2562               		.word	-94
 2563               		.word	-97
 2564               		.word	-98
 2565               		.word	-100
 2566 0000 6400      		.word	-100
 2567 0002 6400      		.word	-100
 2568 0004 6200      		.word	-98
 2569 0006 6100      		.word	-97
 2570 0008 5E00      		.word	-94
 2571 000a 5B00      		.word	-91
 2572 000c 5700      		.word	-87
 2573 000e 5200      		.word	-82
 2574 0010 4D00      		.word	-77
 2575 0012 4700      		.word	-71
 2576 0014 4000      		.word	-64
 2577 0016 3900      		.word	-57
 2578 0018 3200      		.word	-50
 2579 001a 2A00      		.word	-42
 2580 001c 2200      		.word	-34
 2581 001e 1A00      		.word	-26
 2582 0020 1100      		.word	-17
 2583 0022 0900      		.word	-9
 2584 0024 0000      		.word	0
 2585 0026 F7FF      		.word	9
 2586 0028 EFFF      		.word	17
 2587 002a E6FF      		.word	26
 2588 002c DEFF      		.word	34
 2589 002e D6FF      		.word	42
 2590 0030 CEFF      		.word	50
 2591 0032 C7FF      		.word	57
 2592 0034 C0FF      		.word	64
 2593 0036 B9FF      		.word	71
 2594 0038 B3FF      		.word	77
 2595 003a AEFF      		.word	82
 2596 003c A9FF      		.word	87
 2597 003e A5FF      		.word	91
 2598 0040 A2FF      		.word	94
 2599 0042 9FFF      		.word	97
 2600 0044 9EFF      		.word	98
 2601 0046 9CFF      		.word	100
 2602 0048 9CFF      		.word	100
 2603 004a 9CFF      		.text
 2606 0050 A2FF      	.global	cos_SoR
 2608 0054 A9FF      	cos_SoR:
 2610 0058 B3FF      	.LM250:
 2611 005a B9FF      	.LFBB45:
 2612 005c C0FF      		push r29
 2613 005e C7FF      		push r28
 2614 0060 CEFF      		rcall .
 2615 0062 D6FF      		rcall .
 2616 0064 DEFF      		rcall .
 2617 0066 E6FF      		in r28,__SP_L__
 2618 0068 EFFF      		in r29,__SP_H__
 2619 006a F7FF      	/* prologue: function */
 2620 006c 0000      	/* frame size = 6 */
 2621 006e 0900      		std Y+1,r22
 2622 0070 1100      		std Y+2,r23
 2623 0072 1A00      		std Y+3,r24
 2624 0074 2200      		std Y+4,r25
 2626 0078 3200      	.LM251:
 2627 007a 3900      		ldd r24,Y+1
 2628 007c 4000      		ldd r25,Y+2
 2629 007e 4700      		ldd r26,Y+3
 2630 0080 4D00      		ldd r27,Y+4
 2631 0082 5200      		tst r27
 2632 0084 5700      		brlt .L117
 2634 0088 5E00      	.LM252:
 2635 008a 6100      		ldd r24,Y+1
 2636 008c 6200      		ldd r25,Y+2
 2637 008e 6400      		ldd r26,Y+3
 2638 0090 6400      		ldd r27,Y+4
 2639               		ldi r18,lo8(5)
 2640               		ldi r19,hi8(5)
 2641               		ldi r20,hlo8(5)
 2642               		ldi r21,hhi8(5)
 2643               		movw r22,r24
 2644               		movw r24,r26
 172:SoR_Utils.h   **** //***************************************
 173:SoR_Utils.h   **** 
 174:SoR_Utils.h   **** 
 175:SoR_Utils.h   **** //trig tables not yet tested . . .
 176:SoR_Utils.h   **** //***********TRIG LOOKUP TABLES**********
 177:SoR_Utils.h   **** //returns a trig sin or cos calculation value multiplied by 100 (to avoid floating point math)
 178:SoR_Utils.h   **** //returns a trig tan calculation value multiplied by 10 (to avoid floating point math)
 179:SoR_Utils.h   **** //only allows for angles between 0 and 360 degrees
 180:SoR_Utils.h   **** 
 181:SoR_Utils.h   **** //multiplied by 100 so no floating point math
 182:SoR_Utils.h   **** signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-4
 183:SoR_Utils.h   **** 						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,
 184:SoR_Utils.h   **** 
 185:SoR_Utils.h   **** signed int cos_SoR(long signed int degrees)//returns cos*100
 186:SoR_Utils.h   **** 	{
 2645               	-(angtable))
 2646               		sbci r31,hi8(-(angtable))
 2647               		ld r18,Z
 2648 0b2c DF93      		ldd r19,Z+1
 2649 0b2e CF93      		std Y+6,r19
 2650 0b30 00D0      		std Y+5,r18
 2651 0b32 00D0      		rjmp .L118
 2652 0b34 00D0      	.L117:
 2654 0b38 DEB7      	.LM253:
 2655               		ldd r24,Y+1
 2656               		ldd r25,Y+2
 2657 0b3a 6983      		ldd r26,Y+3
 2658 0b3c 7A83      		ldd r27,Y+4
 2659 0b3e 8B83      		com r27
 2660 0b40 9C83      		com r26
 187:SoR_Utils.h   **** 	if (degrees >= 0)//positive angles
 2661               	4
 2662               		sbci r25,lo8(-1)
 2663 0b42 8981      		sbci r26,lo8(-1)
 2664 0b44 9A81      		sbci r27,lo8(-1)
 2665 0b46 AB81      		ldi r18,lo8(5)
 2666 0b48 BC81      		ldi r19,hi8(5)
 2667 0b4a BB23      		ldi r20,hlo8(5)
 2668 0b4c 04F0      		ldi r21,hhi8(5)
 188:SoR_Utils.h   **** 		return angtable[degrees/5];
 2669               	2,r24
 2670               		movw r24,r26
 2671 0b4e 8981      		call __divmodsi4
 2672 0b50 9A81      		movw r26,r20
 2673 0b52 AB81      		movw r24,r18
 2674 0b54 BC81      		movw r18,r24
 2675 0b56 25E0      		movw r20,r26
 2676 0b58 30E0      		ldi r24,lo8(72)
 2677 0b5a 40E0      		ldi r25,hi8(72)
 2678 0b5c 50E0      		ldi r26,hlo8(72)
 2679 0b5e BC01      		ldi r27,hhi8(72)
 2680 0b60 CD01      		sub r24,r18
 2681 0b62 0E94 0000 		sbc r25,r19
 2682 0b66 DA01      		sbc r26,r20
 2683 0b68 C901      		sbc r27,r21
 2684 0b6a 880F      		lsl r24
 2685 0b6c 991F      		rol r25
 2686 0b6e FC01      		movw r30,r24
 2687 0b70 E050      		subi r30,lo8(-(angtable))
 2688 0b72 F040      		sbci r31,hi8(-(angtable))
 2689 0b74 2081      		ld r24,Z
 2690 0b76 3181      		ldd r25,Z+1
 2691 0b78 3E83      		clr r18
 2692 0b7a 2D83      		clr r19
 2693 0b7c 00C0      		sub r18,r24
 2694               		sbc r19,r25
 189:SoR_Utils.h   **** 	else
 190:SoR_Utils.h   **** 		return -angtable[72-(-degrees)/5];
 2695               	.L118:
 2696               		ldd r24,Y+5
 2697 0b7e 8981      		ldd r25,Y+6
 2698 0b80 9A81      	/* epilogue start */
 2700 0b84 BC81      	.LM254:
 2701 0b86 B095      		adiw r28,6
 2702 0b88 A095      		in __tmp_reg__,__SREG__
 2703 0b8a 9095      		cli
 2704 0b8c 8195      		out __SP_H__,r29
 2705 0b8e 9F4F      		out __SREG__,__tmp_reg__
 2706 0b90 AF4F      		out __SP_L__,r28
 2707 0b92 BF4F      		pop r28
 2708 0b94 25E0      		pop r29
 2709 0b96 30E0      		ret
 2711 0b9a 50E0      	.Lscope45:
 2714 0ba0 0E94 0000 	.global	sin_SoR
 2716 0ba6 C901      	sin_SoR:
 2718 0baa AD01      	.LM255:
 2719 0bac 88E4      	.LFBB46:
 2720 0bae 90E0      		push r29
 2721 0bb0 A0E0      		push r28
 2722 0bb2 B0E0      		rcall .
 2723 0bb4 821B      		rcall .
 2724 0bb6 930B      		rcall .
 2725 0bb8 A40B      		in r28,__SP_L__
 2726 0bba B50B      		in r29,__SP_H__
 2727 0bbc 880F      	/* prologue: function */
 2728 0bbe 991F      	/* frame size = 6 */
 2729 0bc0 FC01      		std Y+1,r22
 2730 0bc2 E050      		std Y+2,r23
 2731 0bc4 F040      		std Y+3,r24
 2732 0bc6 8081      		std Y+4,r25
 2734 0bca 2227      	.LM256:
 2735 0bcc 3327      		ldd r24,Y+1
 2736 0bce 281B      		ldd r25,Y+2
 2737 0bd0 390B      		ldd r26,Y+3
 2738 0bd2 3E83      		ldd r27,Y+4
 2739 0bd4 2D83      		subi r24,lo8(-(-90))
 2740               		sbci r25,hi8(-(-90))
 2741 0bd6 8D81      		sbci r26,hlo8(-(-90))
 2742 0bd8 9E81      		sbci r27,hhi8(-(-90))
 2743               		std Y+1,r24
 191:SoR_Utils.h   **** 	}
 2744               	,0,197,.LM257-.LFBB46
 2745               	.LM257:
 2746 0bda 2696      		ldd r24,Y+1
 2747 0bdc 0FB6      		ldd r25,Y+2
 2748 0bde F894      		ldd r26,Y+3
 2749 0be0 DEBF      		ldd r27,Y+4
 2750 0be2 0FBE      		tst r27
 2751 0be4 CDBF      		brlt .L121
 2753 0be8 DF91      	.LM258:
 2754 0bea 0895      		ldd r24,Y+1
 2755               		ldd r25,Y+2
 2756               		ldd r26,Y+3
 2757               		ldd r27,Y+4
 2758               		ldi r18,lo8(5)
 2759               		ldi r19,hi8(5)
 2760               		ldi r20,hlo8(5)
 2761               		ldi r21,hhi8(5)
 192:SoR_Utils.h   **** 
 193:SoR_Utils.h   **** signed int sin_SoR(long signed int degrees)//returns sin*100
 194:SoR_Utils.h   **** 	{
 2762               	w r24,r26
 2763               		call __divmodsi4
 2764               		movw r26,r20
 2765 0bec DF93      		movw r24,r18
 2766 0bee CF93      		lsl r24
 2767 0bf0 00D0      		rol r25
 2768 0bf2 00D0      		movw r30,r24
 2769 0bf4 00D0      		subi r30,lo8(-(angtable))
 2770 0bf6 CDB7      		sbci r31,hi8(-(angtable))
 2771 0bf8 DEB7      		ld r18,Z
 2772               		ldd r19,Z+1
 2773               		std Y+6,r19
 2774 0bfa 6983      		std Y+5,r18
 2775 0bfc 7A83      		rjmp .L122
 2776 0bfe 8B83      	.L121:
 195:SoR_Utils.h   **** 	degrees=degrees - 90;//phase shift 90 degrees
 2778               	,Y+1
 2779               		ldd r25,Y+2
 2780 0c02 8981      		ldd r26,Y+3
 2781 0c04 9A81      		ldd r27,Y+4
 2782 0c06 AB81      		com r27
 2783 0c08 BC81      		com r26
 2784 0c0a 8A55      		com r25
 2785 0c0c 9040      		neg r24
 2786 0c0e A040      		sbci r25,lo8(-1)
 2787 0c10 B040      		sbci r26,lo8(-1)
 2788 0c12 8983      		sbci r27,lo8(-1)
 2789 0c14 9A83      		ldi r18,lo8(5)
 2790 0c16 AB83      		ldi r19,hi8(5)
 2791 0c18 BC83      		ldi r20,hlo8(5)
 196:SoR_Utils.h   **** 
 197:SoR_Utils.h   **** 	if (degrees >= 0)//positive angles
 2792               	5)
 2793               		movw r22,r24
 2794 0c1a 8981      		movw r24,r26
 2795 0c1c 9A81      		call __divmodsi4
 2796 0c1e AB81      		movw r26,r20
 2797 0c20 BC81      		movw r24,r18
 2798 0c22 BB23      		movw r18,r24
 2799 0c24 04F0      		movw r20,r26
 198:SoR_Utils.h   **** 		return angtable[degrees/5];
 2800               	,lo8(72)
 2801               		ldi r25,hi8(72)
 2802 0c26 8981      		ldi r26,hlo8(72)
 2803 0c28 9A81      		ldi r27,hhi8(72)
 2804 0c2a AB81      		sub r24,r18
 2805 0c2c BC81      		sbc r25,r19
 2806 0c2e 25E0      		sbc r26,r20
 2807 0c30 30E0      		sbc r27,r21
 2808 0c32 40E0      		lsl r24
 2809 0c34 50E0      		rol r25
 2810 0c36 BC01      		movw r30,r24
 2811 0c38 CD01      		subi r30,lo8(-(angtable))
 2812 0c3a 0E94 0000 		sbci r31,hi8(-(angtable))
 2813 0c3e DA01      		ld r24,Z
 2814 0c40 C901      		ldd r25,Z+1
 2815 0c42 880F      		clr r18
 2816 0c44 991F      		clr r19
 2817 0c46 FC01      		sub r18,r24
 2818 0c48 E050      		sbc r19,r25
 2819 0c4a F040      		std Y+6,r19
 2820 0c4c 2081      		std Y+5,r18
 2821 0c4e 3181      	.L122:
 2822 0c50 3E83      		ldd r24,Y+5
 2823 0c52 2D83      		ldd r25,Y+6
 2824 0c54 00C0      	/* epilogue start */
 199:SoR_Utils.h   **** 	else
 200:SoR_Utils.h   **** 		return -angtable[72-(-degrees)/5];
 2826               	tmp_reg__,__SREG__
 2827               		cli
 2828 0c56 8981      		out __SP_H__,r29
 2829 0c58 9A81      		out __SREG__,__tmp_reg__
 2830 0c5a AB81      		out __SP_L__,r28
 2831 0c5c BC81      		pop r28
 2832 0c5e B095      		pop r29
 2833 0c60 A095      		ret
 2835 0c64 8195      	.Lscope46:
 2838 0c6a BF4F      	.global	tan_SoR
 2840 0c6e 30E0      	tan_SoR:
 2842 0c72 50E0      	.LM261:
 2843 0c74 BC01      	.LFBB47:
 2844 0c76 CD01      		push r16
 2845 0c78 0E94 0000 		push r17
 2846 0c7c DA01      		push r29
 2847 0c7e C901      		push r28
 2848 0c80 9C01      		rcall .
 2849 0c82 AD01      		rcall .
 2850 0c84 88E4      		rcall .
 2851 0c86 90E0      		in r28,__SP_L__
 2852 0c88 A0E0      		in r29,__SP_H__
 2853 0c8a B0E0      	/* prologue: function */
 2854 0c8c 821B      	/* frame size = 6 */
 2855 0c8e 930B      		std Y+1,r22
 2856 0c90 A40B      		std Y+2,r23
 2857 0c92 B50B      		std Y+3,r24
 2858 0c94 880F      		std Y+4,r25
 2860 0c98 FC01      	.LM262:
 2861 0c9a E050      		ldd r24,Y+1
 2862 0c9c F040      		ldd r25,Y+2
 2863 0c9e 8081      		ldd r26,Y+3
 2864 0ca0 9181      		ldd r27,Y+4
 2865 0ca2 2227      		cpi r24,lo8(90)
 2866 0ca4 3327      		cpc r25,__zero_reg__
 2867 0ca6 281B      		cpc r26,__zero_reg__
 2868 0ca8 390B      		cpc r27,__zero_reg__
 2869 0caa 3E83      		breq .L125
 2870 0cac 2D83      		ldd r24,Y+1
 2871               		ldd r25,Y+2
 2872 0cae 8D81      		ldd r26,Y+3
 2873 0cb0 9E81      		ldd r27,Y+4
 2874               		cpi r24,lo8(-90)
 201:SoR_Utils.h   **** 	}
 2875               	
 2876               		cpc r26,r18
 2877 0cb2 2696      		ldi r18,hhi8(-90)
 2878 0cb4 0FB6      		cpc r27,r18
 2879 0cb6 F894      		breq .L125
 2880 0cb8 DEBF      		ldd r24,Y+1
 2881 0cba 0FBE      		ldd r25,Y+2
 2882 0cbc CDBF      		ldd r26,Y+3
 2883 0cbe CF91      		ldd r27,Y+4
 2884 0cc0 DF91      		cpi r24,lo8(270)
 2885 0cc2 0895      		ldi r20,hi8(270)
 2886               		cpc r25,r20
 2887               		ldi r20,hlo8(270)
 2888               		cpc r26,r20
 2889               		ldi r20,hhi8(270)
 2890               		cpc r27,r20
 2891               		breq .L125
 2892               		ldd r24,Y+1
 202:SoR_Utils.h   **** 
 203:SoR_Utils.h   **** signed int tan_SoR(long signed int degrees)//returns tan * 10
 204:SoR_Utils.h   **** 	{
 2893               	 r26,Y+3
 2894               		ldd r27,Y+4
 2895               		cpi r24,lo8(-270)
 2896 0cc4 0F93      		ldi r21,hi8(-270)
 2897 0cc6 1F93      		cpc r25,r21
 2898 0cc8 DF93      		ldi r21,hlo8(-270)
 2899 0cca CF93      		cpc r26,r21
 2900 0ccc 00D0      		ldi r21,hhi8(-270)
 2901 0cce 00D0      		cpc r27,r21
 2902 0cd0 00D0      		brne .L126
 2903 0cd2 CDB7      	.L125:
 2905               	.LM263:
 2906               		std Y+6,__zero_reg__
 2907 0cd6 6983      		std Y+5,__zero_reg__
 2908 0cd8 7A83      		rjmp .L127
 2909 0cda 8B83      	.L126:
 205:SoR_Utils.h   **** 	//tan(x) = sin(x)/cos(x)
 206:SoR_Utils.h   **** 	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
 2911               	+1
 2912               		ldd r25,Y+2
 2913 0cde 8981      		ldd r26,Y+3
 2914 0ce0 9A81      		ldd r27,Y+4
 2915 0ce2 AB81      		movw r22,r24
 2916 0ce4 BC81      		movw r24,r26
 2917 0ce6 8A35      		call sin_SoR
 2918 0ce8 9105      		movw r16,r24
 2919 0cea A105      		ldd r24,Y+1
 2920 0cec B105      		ldd r25,Y+2
 2921 0cee 01F0      		ldd r26,Y+3
 2922 0cf0 8981      		ldd r27,Y+4
 2923 0cf2 9A81      		movw r22,r24
 2924 0cf4 AB81      		movw r24,r26
 2925 0cf6 BC81      		call cos_SoR
 2926 0cf8 863A      		movw r18,r24
 2927 0cfa 2FEF      		movw r24,r16
 2928 0cfc 9207      		movw r22,r18
 2929 0cfe 2FEF      		call __divmodhi4
 2930 0d00 A207      		movw r24,r22
 2931 0d02 2FEF      		movw r18,r24
 2932 0d04 B207      		lsl r18
 2933 0d06 01F0      		rol r19
 2934 0d08 8981      		movw r24,r18
 2935 0d0a 9A81      		lsl r24
 2936 0d0c AB81      		rol r25
 2937 0d0e BC81      		lsl r24
 2938 0d10 8E30      		rol r25
 2939 0d12 41E0      		movw r20,r18
 2940 0d14 9407      		add r20,r24
 2941 0d16 40E0      		adc r21,r25
 2942 0d18 A407      		std Y+6,r21
 2943 0d1a 40E0      		std Y+5,r20
 2944 0d1c B407      	.L127:
 2945 0d1e 01F0      		ldd r24,Y+5
 2946 0d20 8981      		ldd r25,Y+6
 2947 0d22 9A81      	/* epilogue start */
 2949 0d26 BC81      	.LM265:
 2950 0d28 823F      		adiw r28,6
 2951 0d2a 5EEF      		in __tmp_reg__,__SREG__
 2952 0d2c 9507      		cli
 2953 0d2e 5FEF      		out __SP_H__,r29
 2954 0d30 A507      		out __SREG__,__tmp_reg__
 2955 0d32 5FEF      		out __SP_L__,r28
 2956 0d34 B507      		pop r28
 2957 0d36 01F4      		pop r29
 2958               		pop r17
 207:SoR_Utils.h   **** 		return 0;//what else should I return?!?!?
 2959               	7:
 2964               	.global	sharp_IR_interpret_GP2D12
 208:SoR_Utils.h   **** 	return sin_SoR(degrees)/cos_SoR(degrees)*10;
 2965               		sharp_IR_interpret_GP2D12, @function
 2966               	sharp_IR_interpret_GP2D12:
 2968 0d40 9A81      	.Ltext3:
 2970 0d44 BC81      	.LM266:
 2971 0d46 BC01      	.LFBB48:
 2972 0d48 CD01      		push r29
 2973 0d4a 0E94 0000 		push r28
 2974 0d4e 8C01      		rcall .
 2975 0d50 8981      		in r28,__SP_L__
 2976 0d52 9A81      		in r29,__SP_H__
 2977 0d54 AB81      	/* prologue: function */
 2978 0d56 BC81      	/* frame size = 2 */
 2979 0d58 BC01      		std Y+2,r25
 2980 0d5a CD01      		std Y+1,r24
 2982 0d60 9C01      	.LM267:
 2983 0d62 C801      		ldd r24,Y+1
 2984 0d64 B901      		ldd r25,Y+2
 2985 0d66 0E94 0000 		clr r26
 2986 0d6a CB01      		sbrc r25,7
 2987 0d6c 9C01      		com r26
 2988 0d6e 220F      		mov r27,r26
 2989 0d70 331F      		movw r22,r24
 2990 0d72 C901      		movw r24,r26
 2991 0d74 880F      		call __floatsisf
 2992 0d76 991F      		movw r26,r24
 2993 0d78 880F      		movw r24,r22
 2994 0d7a 991F      		movw r22,r24
 2995 0d7c A901      		movw r24,r26
 2996 0d7e 480F      		ldi r18,lo8(0xbf7fb15b)
 2997 0d80 591F      		ldi r19,hi8(0xbf7fb15b)
 2998 0d82 5E83      		ldi r20,hlo8(0xbf7fb15b)
 2999 0d84 4D83      		ldi r21,hhi8(0xbf7fb15b)
 3000               		call pow
 3001 0d86 8D81      		movw r26,r24
 3002 0d88 9E81      		movw r24,r22
 3003               		movw r22,r24
 209:SoR_Utils.h   **** 	}
 3004               		ldi r19,hi8(0x44ad0ccd)
 3005               		ldi r20,hlo8(0x44ad0ccd)
 3006 0d8a 2696      		ldi r21,hhi8(0x44ad0ccd)
 3007 0d8c 0FB6      		call __mulsf3
 3008 0d8e F894      		movw r26,r24
 3009 0d90 DEBF      		movw r24,r22
 3010 0d92 0FBE      		movw r22,r24
 3011 0d94 CDBF      		movw r24,r26
 3012 0d96 CF91      		call __fixsfsi
 3013 0d98 DF91      		movw r26,r24
 3014 0d9a 1F91      		movw r24,r22
 3015 0d9c 0F91      	/* epilogue start */
 3017               	.LM268:
 3018               		pop __tmp_reg__
 3019               		pop __tmp_reg__
 3020               		pop r28
 3021               		pop r29
 3022               		ret
 3024               	.Lscope48:
 3027               	.global	sharp_IR_interpret_GP2Y0A02YK
   1:sensors.c     **** /****************************************************************************
   2:sensors.c     **** *
   3:sensors.c     **** *   Copyright (c) 2008 www.societyofrobots.com
   4:sensors.c     **** *   (please link back if you use this code!)
   5:sensors.c     **** *
   6:sensors.c     **** *   This program is free software; you can redistribute it and/or modify
   7:sensors.c     **** *   it under the terms of the GNU General Public License version 2 as
   8:sensors.c     **** *   published by the Free Software Foundation.
   9:sensors.c     **** *
  10:sensors.c     **** *   Alternatively, this software may be distributed under the terms of BSD
  11:sensors.c     **** *   license.
  12:sensors.c     **** *
  13:sensors.c     **** ****************************************************************************/
  14:sensors.c     **** 
  15:sensors.c     **** //this file contains code to use with various robot sensors
  16:sensors.c     **** 
  17:sensors.c     **** /***************SHARP IR*******************/
  18:sensors.c     **** //These functions convert ADC 8 bit values to distances in centimeters
  19:sensors.c     **** //Maximum error is about 10%
  20:sensors.c     **** //
  21:sensors.c     **** //to learn more about Sharp IR, please visit:
  22:sensors.c     **** //http://www.societyofrobots.com/sensors_sharpirrange.shtml
  23:sensors.c     **** //
  24:sensors.c     **** //want to post your calibration data?
  25:sensors.c     **** //visit here: http://www.societyofrobots.com/robotforum/index.php?topic=4616.0
  26:sensors.c     **** //
  27:sensors.c     **** //you can power this sensor directly from the Axon's ADC header row
  28:sensors.c     **** 
  29:sensors.c     **** 
  30:sensors.c     **** //Sharp GP2D12 IR Range Sensor -  claims 10cm to 80cm (I got 8cm to 150cm)
  31:sensors.c     **** int sharp_IR_interpret_GP2D12(int value)
  32:sensors.c     **** 	{
 3028               	t_GP2Y0A02YK, @function
 3029               	sharp_IR_interpret_GP2Y0A02YK:
 3031 0da0 DF93      	.LM269:
 3032 0da2 CF93      	.LFBB49:
 3033 0da4 00D0      		push r29
 3034 0da6 CDB7      		push r28
 3035 0da8 DEB7      		rcall .
 3036               		in r28,__SP_L__
 3037               		in r29,__SP_H__
 3038 0daa 9A83      	/* prologue: function */
 3039 0dac 8983      	/* frame size = 2 */
  33:sensors.c     **** 	return 1384.4*pow(value,-.9988);
 3040               	
 3041               		std Y+1,r24
 3043 0db0 9A81      	.LM270:
 3044 0db2 AA27      		ldd r24,Y+1
 3045 0db4 97FD      		ldd r25,Y+2
 3046 0db6 A095      		clr r26
 3047 0db8 BA2F      		sbrc r25,7
 3048 0dba BC01      		com r26
 3049 0dbc CD01      		mov r27,r26
 3050 0dbe 0E94 0000 		movw r22,r24
 3051 0dc2 DC01      		movw r24,r26
 3052 0dc4 CB01      		call __floatsisf
 3053 0dc6 BC01      		movw r26,r24
 3054 0dc8 CD01      		movw r24,r22
 3055 0dca 2BE5      		movw r22,r24
 3056 0dcc 31EB      		movw r24,r26
 3057 0dce 4FE7      		ldi r18,lo8(0xbf63d70a)
 3058 0dd0 5FEB      		ldi r19,hi8(0xbf63d70a)
 3059 0dd2 0E94 0000 		ldi r20,hlo8(0xbf63d70a)
 3060 0dd6 DC01      		ldi r21,hhi8(0xbf63d70a)
 3061 0dd8 CB01      		call pow
 3062 0dda BC01      		movw r26,r24
 3063 0ddc CD01      		movw r24,r22
 3064 0dde 2DEC      		movw r22,r24
 3065 0de0 3CE0      		movw r24,r26
 3066 0de2 4DEA      		ldi r18,lo8(0x44ee1000)
 3067 0de4 54E4      		ldi r19,hi8(0x44ee1000)
 3068 0de6 0E94 0000 		ldi r20,hlo8(0x44ee1000)
 3069 0dea DC01      		ldi r21,hhi8(0x44ee1000)
 3070 0dec CB01      		call __mulsf3
 3071 0dee BC01      		movw r26,r24
 3072 0df0 CD01      		movw r24,r22
 3073 0df2 0E94 0000 		movw r22,r24
 3074 0df6 DC01      		movw r24,r26
 3075 0df8 CB01      		call __fixsfsi
 3076               		movw r26,r24
  34:sensors.c     **** 	}
 3078               	.LM271:
 3079 0dfa 0F90      		pop __tmp_reg__
 3080 0dfc 0F90      		pop __tmp_reg__
 3081 0dfe CF91      		pop r28
 3082 0e00 DF91      		pop r29
 3083 0e02 0895      		ret
 3085               	.Lscope49:
 3088               	.global	sharp_IR_interpret_GP2Y0A21YK
 3090               	sharp_IR_interpret_GP2Y0A21YK:
  35:sensors.c     **** //Sharp GP2Y0A02YK IR Range Sensor - 20 cm to 150 cm
  36:sensors.c     **** int sharp_IR_interpret_GP2Y0A02YK(int value)
  37:sensors.c     **** 	{
 3091               	2,.LM272-.LFBB50
 3092               	.LM272:
 3093               	.LFBB50:
 3094 0e04 DF93      		push r29
 3095 0e06 CF93      		push r28
 3096 0e08 00D0      		rcall .
 3097 0e0a CDB7      		in r28,__SP_L__
 3098 0e0c DEB7      		in r29,__SP_H__
 3099               	/* prologue: function */
 3100               	/* frame size = 2 */
 3101 0e0e 9A83      		std Y+2,r25
 3102 0e10 8983      		std Y+1,r24
  38:sensors.c     **** 	return 1904.5*pow(value,-.89);
 3103               	,43,.LM273-.LFBB50
 3104               	.LM273:
 3105 0e12 8981      		ldd r24,Y+1
 3106 0e14 9A81      		ldd r25,Y+2
 3107 0e16 AA27      		clr r26
 3108 0e18 97FD      		sbrc r25,7
 3109 0e1a A095      		com r26
 3110 0e1c BA2F      		mov r27,r26
 3111 0e1e BC01      		movw r22,r24
 3112 0e20 CD01      		movw r24,r26
 3113 0e22 0E94 0000 		call __floatsisf
 3114 0e26 DC01      		movw r26,r24
 3115 0e28 CB01      		movw r24,r22
 3116 0e2a BC01      		movw r22,r24
 3117 0e2c CD01      		movw r24,r26
 3118 0e2e 2AE0      		ldi r18,lo8(0xbf4f7cee)
 3119 0e30 37ED      		ldi r19,hi8(0xbf4f7cee)
 3120 0e32 43E6      		ldi r20,hlo8(0xbf4f7cee)
 3121 0e34 5FEB      		ldi r21,hhi8(0xbf4f7cee)
 3122 0e36 0E94 0000 		call pow
 3123 0e3a DC01      		movw r26,r24
 3124 0e3c CB01      		movw r24,r22
 3125 0e3e BC01      		movw r22,r24
 3126 0e40 CD01      		movw r24,r26
 3127 0e42 20E0      		ldi r18,lo8(0x4438d852)
 3128 0e44 30E1      		ldi r19,hi8(0x4438d852)
 3129 0e46 4EEE      		ldi r20,hlo8(0x4438d852)
 3130 0e48 54E4      		ldi r21,hhi8(0x4438d852)
 3131 0e4a 0E94 0000 		call __mulsf3
 3132 0e4e DC01      		movw r26,r24
 3133 0e50 CB01      		movw r24,r22
 3134 0e52 BC01      		movw r22,r24
 3135 0e54 CD01      		movw r24,r26
 3136 0e56 0E94 0000 		call __fixsfsi
 3137 0e5a DC01      		movw r26,r24
 3138 0e5c CB01      		movw r24,r22
 3139               	/* epilogue start */
  39:sensors.c     **** 	}
 3140               	:
 3141               		pop __tmp_reg__
 3142 0e5e 0F90      		pop __tmp_reg__
 3143 0e60 0F90      		pop r28
 3144 0e62 CF91      		pop r29
 3145 0e64 DF91      		ret
 3147               	.Lscope50:
 3150               	.global	sharp_IR_interpret_GP2D120
 3152               	sharp_IR_interpret_GP2D120:
  40:sensors.c     **** //Sharp GP2Y0A21YK IR Range Sensor - 4 cm to 30 cm
  41:sensors.c     **** int sharp_IR_interpret_GP2Y0A21YK(int value)
  42:sensors.c     **** 	{
 3154               	1:
 3155               		push r29
 3156               		push r28
 3157 0e68 DF93      		rcall .
 3158 0e6a CF93      		in r28,__SP_L__
 3159 0e6c 00D0      		in r29,__SP_H__
 3160 0e6e CDB7      	/* prologue: function */
 3161 0e70 DEB7      	/* frame size = 2 */
 3162               		std Y+2,r25
 3163               		std Y+1,r24
 3165 0e74 8983      	.LM276:
  43:sensors.c     **** 	return 739.38*pow(value,-.8105);
 3166               	
 3167               		ldd r25,Y+2
 3168 0e76 8981      		clr r26
 3169 0e78 9A81      		sbrc r25,7
 3170 0e7a AA27      		com r26
 3171 0e7c 97FD      		mov r27,r26
 3172 0e7e A095      		movw r22,r24
 3173 0e80 BA2F      		movw r24,r26
 3174 0e82 BC01      		call __floatsisf
 3175 0e84 CD01      		movw r26,r24
 3176 0e86 0E94 0000 		movw r24,r22
 3177 0e8a DC01      		movw r22,r24
 3178 0e8c CB01      		movw r24,r26
 3179 0e8e BC01      		ldi r18,lo8(0xbf6a57a8)
 3180 0e90 CD01      		ldi r19,hi8(0xbf6a57a8)
 3181 0e92 2EEE      		ldi r20,hlo8(0xbf6a57a8)
 3182 0e94 3CE7      		ldi r21,hhi8(0xbf6a57a8)
 3183 0e96 4FE4      		call pow
 3184 0e98 5FEB      		movw r26,r24
 3185 0e9a 0E94 0000 		movw r24,r22
 3186 0e9e DC01      		movw r22,r24
 3187 0ea0 CB01      		movw r24,r26
 3188 0ea2 BC01      		ldi r18,lo8(0x43fef0a4)
 3189 0ea4 CD01      		ldi r19,hi8(0x43fef0a4)
 3190 0ea6 22E5      		ldi r20,hlo8(0x43fef0a4)
 3191 0ea8 38ED      		ldi r21,hhi8(0x43fef0a4)
 3192 0eaa 48E3      		call __mulsf3
 3193 0eac 54E4      		movw r26,r24
 3194 0eae 0E94 0000 		movw r24,r22
 3195 0eb2 DC01      		movw r22,r24
 3196 0eb4 CB01      		movw r24,r26
 3197 0eb6 BC01      		call __fixsfsi
 3198 0eb8 CD01      		movw r26,r24
 3199 0eba 0E94 0000 		movw r24,r22
 3200 0ebe DC01      	/* epilogue start */
 3202               	.LM277:
  44:sensors.c     **** 	}
 3203               	op r28
 3204               		pop r29
 3205 0ec2 0F90      		ret
 3207 0ec6 CF91      	.Lscope51:
 3210               	.global	sharp_IR_interpret_GP2D15
 3212               	sharp_IR_interpret_GP2D15:
 3214               	.LM278:
 3215               	.LFBB52:
 3216               		push r29
  45:sensors.c     **** //Sharp GP2D120 IR Range Sensor - 4 to 30 cm 
  46:sensors.c     **** int sharp_IR_interpret_GP2D120(int value)
  47:sensors.c     **** 	{
 3217               	ll .
 3218               		in r28,__SP_L__
 3219               		in r29,__SP_H__
 3220 0ecc DF93      	/* prologue: function */
 3221 0ece CF93      	/* frame size = 2 */
 3222 0ed0 00D0      		std Y+2,r25
 3223 0ed2 CDB7      		std Y+1,r24
 3225               	.LM279:
 3226               		ldd r24,Y+1
 3227 0ed6 9A83      		ldd r25,Y+2
 3228 0ed8 8983      		clr r26
  48:sensors.c     **** 	return 509.88*pow(value,-.9154);
 3229               		com r26
 3230               		mov r27,r26
 3231 0eda 8981      		movw r22,r24
 3232 0edc 9A81      		movw r24,r26
 3233 0ede AA27      		call __floatsisf
 3234 0ee0 97FD      		movw r26,r24
 3235 0ee2 A095      		movw r24,r22
 3236 0ee4 BA2F      		movw r22,r24
 3237 0ee6 BC01      		movw r24,r26
 3238 0ee8 CD01      		ldi r18,lo8(0xbf4acd9f)
 3239 0eea 0E94 0000 		ldi r19,hi8(0xbf4acd9f)
 3240 0eee DC01      		ldi r20,hlo8(0xbf4acd9f)
 3241 0ef0 CB01      		ldi r21,hhi8(0xbf4acd9f)
 3242 0ef2 BC01      		call pow
 3243 0ef4 CD01      		movw r26,r24
 3244 0ef6 28EA      		movw r24,r22
 3245 0ef8 37E5      		movw r22,r24
 3246 0efa 4AE6      		movw r24,r26
 3247 0efc 5FEB      		ldi r18,lo8(0x44380d71)
 3248 0efe 0E94 0000 		ldi r19,hi8(0x44380d71)
 3249 0f02 DC01      		ldi r20,hlo8(0x44380d71)
 3250 0f04 CB01      		ldi r21,hhi8(0x44380d71)
 3251 0f06 BC01      		call __mulsf3
 3252 0f08 CD01      		movw r26,r24
 3253 0f0a 24EA      		movw r24,r22
 3254 0f0c 30EF      		movw r22,r24
 3255 0f0e 4EEF      		movw r24,r26
 3256 0f10 53E4      		call __fixsfsi
 3257 0f12 0E94 0000 		movw r26,r24
 3258 0f16 DC01      		movw r24,r22
 3259 0f18 CB01      	/* epilogue start */
 3261 0f1c CD01      	.LM280:
 3262 0f1e 0E94 0000 		pop __tmp_reg__
 3263 0f22 DC01      		pop __tmp_reg__
 3264 0f24 CB01      		pop r28
 3265               		pop r29
  49:sensors.c     **** 	}
 3266               	, .-sharp_IR_interpret_GP2D15
 3267               	.Lscope52:
 3270 0f2a CF91      	.global	accelerometer_ACCM3D
 3272 0f2e 0895      	accelerometer_ACCM3D:
 3274               	.LM281:
 3275               	.LFBB53:
 3276               		push r29
 3277               		push r28
 3278               		rcall .
 3279               		in r28,__SP_L__
  50:sensors.c     **** //Sharp GP2D15 IR Range Sensor - 10cm to 80cm  
  51:sensors.c     **** int sharp_IR_interpret_GP2D15(int value)
  52:sensors.c     **** 	{
 3280               	__
 3281               	/* prologue: function */
 3282               	/* frame size = 2 */
 3283 0f30 DF93      		std Y+2,r25
 3284 0f32 CF93      		std Y+1,r24
 3286 0f36 CDB7      	.LM282:
 3287 0f38 DEB7      		ldd r24,Y+1
 3288               		ldd r25,Y+2
 3289               		clr r26
 3290 0f3a 9A83      		sbrc r25,7
 3291 0f3c 8983      		com r26
  53:sensors.c     **** 	return 736.21*pow(value,-.7922);
 3292               	
 3293               		movw r22,r24
 3294 0f3e 8981      		movw r24,r26
 3295 0f40 9A81      		call __floatsisf
 3296 0f42 AA27      		movw r26,r24
 3297 0f44 97FD      		movw r24,r22
 3298 0f46 A095      		movw r22,r24
 3299 0f48 BA2F      		movw r24,r26
 3300 0f4a BC01      		ldi r18,lo8(0x4102e8a7)
 3301 0f4c CD01      		ldi r19,hi8(0x4102e8a7)
 3302 0f4e 0E94 0000 		ldi r20,hlo8(0x4102e8a7)
 3303 0f52 DC01      		ldi r21,hhi8(0x4102e8a7)
 3304 0f54 CB01      		call __mulsf3
 3305 0f56 BC01      		movw r26,r24
 3306 0f58 CD01      		movw r24,r22
 3307 0f5a 2FE9      		movw r22,r24
 3308 0f5c 3DEC      		movw r24,r26
 3309 0f5e 4AE4      		ldi r18,lo8(0x4102e8a7)
 3310 0f60 5FEB      		ldi r19,hi8(0x4102e8a7)
 3311 0f62 0E94 0000 		ldi r20,hlo8(0x4102e8a7)
 3312 0f66 DC01      		ldi r21,hhi8(0x4102e8a7)
 3313 0f68 CB01      		call __subsf3
 3314 0f6a BC01      		movw r26,r24
 3315 0f6c CD01      		movw r24,r22
 3316 0f6e 21E7      		movw r22,r24
 3317 0f70 3DE0      		movw r24,r26
 3318 0f72 48E3      		call __fixsfsi
 3319 0f74 54E4      		movw r26,r24
 3320 0f76 0E94 0000 		movw r24,r22
 3321 0f7a DC01      	/* epilogue start */
 3323 0f7e BC01      	.LM283:
 3324 0f80 CD01      		pop __tmp_reg__
 3325 0f82 0E94 0000 		pop __tmp_reg__
 3326 0f86 DC01      		pop r28
 3327 0f88 CB01      		pop r29
 3328               		ret
  54:sensors.c     **** 	}
 3329               	erometer_ACCM3D
 3330               	.Lscope53:
 3333 0f8e CF91      	.global	accelerometer_SEN00741
 3335 0f92 0895      	accelerometer_SEN00741:
 3337               	.LM284:
 3338               	.LFBB54:
 3339               		push r29
 3340               		push r28
 3341               		rcall .
 3342               		in r28,__SP_L__
  55:sensors.c     **** 
  56:sensors.c     **** 
  57:sensors.c     **** 
  58:sensors.c     **** /************ACCELEROMETER****************/
  59:sensors.c     **** //ACCM3D for more info, see:
  60:sensors.c     **** //http://www.dimensionengineering.com/DE-ACCM3D.htm
  61:sensors.c     **** //you can power this sensor directly from the Axon's 5V ADC header row
  62:sensors.c     **** //converts ADC value to degrees
  63:sensors.c     **** int accelerometer_ACCM3D(int value)
  64:sensors.c     **** 	{
 3343               	__
 3344               	/* prologue: function */
 3345               	/* frame size = 2 */
 3346 0f94 DF93      		std Y+2,r25
 3347 0f96 CF93      		std Y+1,r24
 3349 0f9a CDB7      	.LM285:
 3350 0f9c DEB7      		ldd r24,Y+1
 3351               		ldd r25,Y+2
 3352               		clr r26
 3353 0f9e 9A83      		sbrc r25,7
 3354 0fa0 8983      		com r26
  65:sensors.c     **** 	return (8.1818*value-8.1818);
 3355               	
 3356               		movw r22,r24
 3357 0fa2 8981      		movw r24,r26
 3358 0fa4 9A81      		call __floatsisf
 3359 0fa6 AA27      		movw r26,r24
 3360 0fa8 97FD      		movw r24,r22
 3361 0faa A095      		movw r22,r24
 3362 0fac BA2F      		movw r24,r26
 3363 0fae BC01      		ldi r18,lo8(0x4102e8a7)
 3364 0fb0 CD01      		ldi r19,hi8(0x4102e8a7)
 3365 0fb2 0E94 0000 		ldi r20,hlo8(0x4102e8a7)
 3366 0fb6 DC01      		ldi r21,hhi8(0x4102e8a7)
 3367 0fb8 CB01      		call __mulsf3
 3368 0fba BC01      		movw r26,r24
 3369 0fbc CD01      		movw r24,r22
 3370 0fbe 27EA      		movw r22,r24
 3371 0fc0 38EE      		movw r24,r26
 3372 0fc2 42E0      		ldi r18,lo8(0x4102e8a7)
 3373 0fc4 51E4      		ldi r19,hi8(0x4102e8a7)
 3374 0fc6 0E94 0000 		ldi r20,hlo8(0x4102e8a7)
 3375 0fca DC01      		ldi r21,hhi8(0x4102e8a7)
 3376 0fcc CB01      		call __subsf3
 3377 0fce BC01      		movw r26,r24
 3378 0fd0 CD01      		movw r24,r22
 3379 0fd2 27EA      		movw r22,r24
 3380 0fd4 38EE      		movw r24,r26
 3381 0fd6 42E0      		call __fixsfsi
 3382 0fd8 51E4      		movw r26,r24
 3383 0fda 0E94 0000 		movw r24,r22
 3384 0fde DC01      	/* epilogue start */
 3386 0fe2 BC01      	.LM286:
 3387 0fe4 CD01      		pop __tmp_reg__
 3388 0fe6 0E94 0000 		pop __tmp_reg__
 3389 0fea DC01      		pop r28
 3390 0fec CB01      		pop r29
 3391               		ret
  66:sensors.c     **** 	}
 3392               	elerometer_SEN00741
 3393               	.Lscope54:
 3396 0ff2 CF91      	.global	gyro_SEN00741
 3398 0ff6 0895      	gyro_SEN00741:
 3400               	.LM287:
 3401               	.LFBB55:
 3402               		push r29
 3403               		push r28
 3404               		rcall .
 3405               		in r28,__SP_L__
  67:sensors.c     **** 
  68:sensors.c     **** //SEN-00741 for more info, see:
  69:sensors.c     **** //http://www.sparkfun.com/commerce/product_info.php?products_id=741
  70:sensors.c     **** //http://www.sparkfun.com/datasheets/Components/ADXL330_0.pdf
  71:sensors.c     **** //use the 3.3V output on the Axon to power this sensor (giving it 5V will fry it!)
  72:sensors.c     **** int accelerometer_SEN00741(int value)
  73:sensors.c     **** 	{
 3406               	__
 3407               	/* prologue: function */
 3408               	/* frame size = 2 */
 3409 0ff8 DF93      		std Y+2,r25
 3410 0ffa CF93      		std Y+1,r24
 3412 0ffe CDB7      	.LM288:
 3413 1000 DEB7      		ldd r18,Y+1
 3414               		ldd r19,Y+2
 3415               		movw r24,r18
 3416 1002 9A83      		lsl r24
 3417 1004 8983      		rol r25
  74:sensors.c     **** 	return (8.1818*value-8.1818);
 3418               	
 3419               		adc r25,r19
 3420 1006 8981      		movw r18,r24
 3421 1008 9A81      		lsl r18
 3422 100a AA27      		rol r19
 3423 100c 97FD      		lsl r18
 3424 100e A095      		rol r19
 3425 1010 BA2F      		add r24,r18
 3426 1012 BC01      		adc r25,r19
 3427 1014 CD01      		subi r24,lo8(-(-180))
 3428 1016 0E94 0000 		sbci r25,hi8(-(-180))
 3429 101a DC01      	/* epilogue start */
 3431 101e BC01      	.LM289:
 3432 1020 CD01      		pop __tmp_reg__
 3433 1022 27EA      		pop __tmp_reg__
 3434 1024 38EE      		pop r28
 3435 1026 42E0      		pop r29
 3436 1028 51E4      		ret
 3438 102e DC01      	.Lscope55:
 3441 1034 CD01      	.global	sonar_MaxSonar
 3443 1038 38EE      	sonar_MaxSonar:
 3445 103c 51E4      	.LM290:
 3446 103e 0E94 0000 	.LFBB56:
 3447 1042 DC01      		push r29
 3448 1044 CB01      		push r28
 3449 1046 BC01      		rcall .
 3450 1048 CD01      		in r28,__SP_L__
 3451 104a 0E94 0000 		in r29,__SP_H__
 3452 104e DC01      	/* prologue: function */
 3453 1050 CB01      	/* frame size = 2 */
 3454               		std Y+2,r25
  75:sensors.c     **** 	}
 3455               	.LFBB56
 3456               	.LM291:
 3457 1052 0F90      		ldd r24,Y+1
 3458 1054 0F90      		ldd r25,Y+2
 3459 1056 CF91      		clr r26
 3460 1058 DF91      		sbrc r25,7
 3461 105a 0895      		com r26
 3462               		mov r27,r26
 3463               		movw r22,r24
 3464               		movw r24,r26
 3465               		call __floatsisf
 3466               		movw r26,r24
 3467               		movw r24,r22
 3468               		movw r22,r24
  76:sensors.c     **** 
  77:sensors.c     **** 
  78:sensors.c     **** 
  79:sensors.c     **** /*******************GYRO******************/
  80:sensors.c     **** //SEN-00741 for more info, see:
  81:sensors.c     **** //http://www.sparkfun.com/commerce/product_info.php?products_id=741
  82:sensors.c     **** //http://www.sparkfun.com/datasheets/Components/IDG-300_Datasheet.pdf
  83:sensors.c     **** //use the 3.3V output on the Axon to power this sensor (giving it 5V will fry it!)
  84:sensors.c     **** //converts ADC value to degrees
  85:sensors.c     **** //2 mV/deg/second, effectively linear at 1%
  86:sensors.c     **** int gyro_SEN00741(int value)
  87:sensors.c     **** 	{
 3469               		ldi r18,lo8(0x42480a3d)
 3470               		ldi r19,hi8(0x42480a3d)
 3471               		ldi r20,hlo8(0x42480a3d)
 3472 105c DF93      		ldi r21,hhi8(0x42480a3d)
 3473 105e CF93      		call __mulsf3
 3474 1060 00D0      		movw r26,r24
 3475 1062 CDB7      		movw r24,r22
 3476 1064 DEB7      		movw r22,r24
 3477               		movw r24,r26
 3478               		ldi r18,lo8(0x424c147b)
 3479 1066 9A83      		ldi r19,hi8(0x424c147b)
 3480 1068 8983      		ldi r20,hlo8(0x424c147b)
  88:sensors.c     **** 	return (15*value-180);
 3481               	8(0x424c147b)
 3482               		call __subsf3
 3483 106a 2981      		movw r26,r24
 3484 106c 3A81      		movw r24,r22
 3485 106e C901      		movw r22,r24
 3486 1070 880F      		movw r24,r26
 3487 1072 991F      		call __fixsfsi
 3488 1074 820F      		movw r26,r24
 3489 1076 931F      		movw r24,r22
 3490 1078 9C01      	/* epilogue start */
 3492 107c 331F      	.LM292:
 3493 107e 220F      		pop __tmp_reg__
 3494 1080 331F      		pop __tmp_reg__
 3495 1082 820F      		pop r28
 3496 1084 931F      		pop r29
 3497 1086 845B      		ret
 3499               	.Lscope56:
  89:sensors.c     **** 	}
 3500               	:F(0,1)",36,0,0,sonar_Ping
 3501               	.global	sonar_Ping
 3503 108c 0F90      	sonar_Ping:
 3505 1090 DF91      	.LM293:
 3506 1092 0895      	.LFBB57:
 3507               		push r29
 3508               		push r28
 3509               		in r28,__SP_L__
 3510               		in r29,__SP_H__
 3511               	/* prologue: function */
 3512               	/* frame size = 0 */
  90:sensors.c     **** 
  91:sensors.c     **** 
  92:sensors.c     **** 
  93:sensors.c     **** /******************SONAR******************/
  94:sensors.c     **** //LV_MaxSonar_EZ1: http://www.maxbotix.com/uploads/LV-MaxSonar-EZ1-Datasheet.pdf
  95:sensors.c     **** //you can power these sensors directly from the Axon's 5V ADC header row
  96:sensors.c     **** //A supply of 5V yields ~9.8mV/in for all EZ versions
  97:sensors.c     **** int sonar_MaxSonar(int value)
  98:sensors.c     **** 	{
 3514               	26,lo8(33)
 3515               		ldi r27,hi8(33)
 3516               		ldi r30,lo8(33)
 3517 1094 DF93      		ldi r31,hi8(33)
 3518 1096 CF93      		ld r24,Z
 3519 1098 00D0      		ori r24,lo8(8)
 3520 109a CDB7      		st X,r24
 3522               	.LM295:
 3523               		ldi r26,lo8(34)
 3524 109e 9A83      		ldi r27,hi8(34)
 3525 10a0 8983      		ldi r30,lo8(34)
  99:sensors.c     **** 	return (50.01*value-51.02);
 3526               	(34)
 3527               		ld r24,Z
 3528 10a2 8981      		andi r24,lo8(-9)
 3529 10a4 9A81      		st X,r24
 3531 10a8 97FD      	.LM296:
 3532 10aa A095      		ldi r24,lo8(2)
 3533 10ac BA2F      		ldi r25,hi8(2)
 3534 10ae BC01      		call delay_us
 3536 10b2 0E94 0000 	.LM297:
 3537 10b6 DC01      		ldi r26,lo8(34)
 3538 10b8 CB01      		ldi r27,hi8(34)
 3539 10ba BC01      		ldi r30,lo8(34)
 3540 10bc CD01      		ldi r31,hi8(34)
 3541 10be 2DE3      		ld r24,Z
 3542 10c0 3AE0      		ori r24,lo8(8)
 3543 10c2 48E4      		st X,r24
 3545 10c6 0E94 0000 	.LM298:
 3546 10ca DC01      		ldi r24,lo8(5)
 3547 10cc CB01      		ldi r25,hi8(5)
 3548 10ce BC01      		call delay_us
 3550 10d2 2BE7      	.LM299:
 3551 10d4 34E1      		ldi r26,lo8(34)
 3552 10d6 4CE4      		ldi r27,hi8(34)
 3553 10d8 52E4      		ldi r30,lo8(34)
 3554 10da 0E94 0000 		ldi r31,hi8(34)
 3555 10de DC01      		ld r24,Z
 3556 10e0 CB01      		andi r24,lo8(-9)
 3557 10e2 BC01      		st X,r24
 3559 10e6 0E94 0000 	.LM300:
 3560 10ea DC01      		ldi r26,lo8(33)
 3561 10ec CB01      		ldi r27,hi8(33)
 3562               		ldi r30,lo8(33)
 100:sensors.c     **** 	}
 3563               	o8(8)
 3564               		eor r24,r25
 3565 10ee 0F90      		st X,r24
 3566 10f0 0F90      	.L148:
 3568 10f4 DF91      	.LM301:
 3569 10f6 0895      		ldi r30,lo8(32)
 3570               		ldi r31,hi8(32)
 3571               		ld r24,Z
 3572               		mov r24,r24
 3573               		ldi r25,lo8(0)
 3574               		andi r24,lo8(8)
 3575               		andi r25,hi8(8)
 101:sensors.c     **** 
 102:sensors.c     **** //PING Sonar
 103:sensors.c     **** //equations were taken from here and not independently verified:
 104:sensors.c     **** //http://www.societyofrobots.com/member_tutorials/node/174
 105:sensors.c     **** //http://www.societyofrobots.com/robotforum/index.php?topic=5123.msg40008
 106:sensors.c     **** //http://www.societyofrobots.com/robotforum/index.php?topic=4656.30
 107:sensors.c     **** //uses timer0
 108:sensors.c     **** int sonar_Ping(void)
 109:sensors.c     **** 	{
 3576               	breq .L148
 3578               	.LM302:
 3579 10f8 DF93      		call reset_timer0
 3580 10fa CF93      	.L149:
 3582 10fe DEB7      	.LM303:
 3583               		ldi r30,lo8(32)
 3584               		ldi r31,hi8(32)
 110:sensors.c     **** 	#define PINGPIN    3          // assign a pin to the Ping Sensor
 111:sensors.c     **** 	#define DDR        DDRA
 112:sensors.c     **** 	#define PORT       PORTA
 113:sensors.c     **** 	#define PIN        PINA
 114:sensors.c     **** 
 115:sensors.c     **** 	PORT_ON(DDR, PINGPIN);   // Switch PingPin to OUPUT
 3585               	
 3586               		mov r24,r24
 3587 1100 A1E2      		ldi r25,lo8(0)
 3588 1102 B0E0      		andi r24,lo8(8)
 3589 1104 E1E2      		andi r25,hi8(8)
 3590 1106 F0E0      		sbiw r24,0
 3591 1108 8081      		brne .L149
 3593 110c 8C93      	.LM304:
 116:sensors.c     **** 	// ------Trigger Pulse--------------
 117:sensors.c     **** 	PORT_OFF(PORT, PINGPIN);   // Bring PingPin low before starting trigger pulse
 3594               	t_timer0_overflow
 3595               		movw r26,r24
 3596 110e A2E2      		movw r24,r22
 3597 1110 B0E0      		ldi r18,lo8(255)
 3598 1112 E2E2      		ldi r19,hi8(255)
 3599 1114 F0E0      		ldi r20,hlo8(255)
 3600 1116 8081      		ldi r21,hhi8(255)
 3601 1118 877F      		movw r22,r24
 3602 111a 8C93      		movw r24,r26
 118:sensors.c     **** 	delay_us(2);        //  Wait for 2 microseconds
 3603               	ulsi3
 3604               		movw r18,r22
 3605 111c 82E0      		movw r20,r24
 3606 111e 90E0      		ldi r30,lo8(70)
 3607 1120 0E94 0000 		ldi r31,hi8(70)
 119:sensors.c     **** 	PORT_ON(PORT, PINGPIN);    // Bring PingPin High for 5us according to spec sheet.
 3608               	24,Z
 3609               		mov r24,r24
 3610 1124 A2E2      		ldi r25,lo8(0)
 3611 1126 B0E0      		ldi r26,lo8(0)
 3612 1128 E2E2      		ldi r27,hi8(0)
 3613 112a F0E0      		add r24,r18
 3614 112c 8081      		adc r25,r19
 3615 112e 8860      		adc r26,r20
 3616 1130 8C93      		adc r27,r21
 120:sensors.c     **** 	delay_us(5);       // Wait for 5 microseconds
 3617               	,r24
 3618               		movw r24,r26
 3619 1132 85E0      		call __floatunsisf
 3620 1134 90E0      		movw r26,r24
 3621 1136 0E94 0000 		movw r24,r22
 121:sensors.c     **** 	PORT_OFF(PORT, PINGPIN);; //  Bring PingPin Low and standby
 3622               	 r22,r24
 3623               		movw r24,r26
 3624 113a A2E2      		ldi r18,lo8(0x400469ee)
 3625 113c B0E0      		ldi r19,hi8(0x400469ee)
 3626 113e E2E2      		ldi r20,hlo8(0x400469ee)
 3627 1140 F0E0      		ldi r21,hhi8(0x400469ee)
 3628 1142 8081      		call __mulsf3
 3629 1144 877F      		movw r26,r24
 3630 1146 8C93      		movw r24,r22
 122:sensors.c     **** 	//--------End Trigger Pulse---------------------
 123:sensors.c     **** 	FLIP_PORT(DDR, PINGPIN);   // Switch PingPin to INPUT
 3631               	,r24
 3632               		movw r24,r26
 3633 1148 A1E2      		call __fixsfsi
 3634 114a B0E0      		movw r26,r24
 3635 114c E1E2      		movw r24,r22
 3636 114e F0E0      	/* epilogue start */
 3638 1152 88E0      	.LM305:
 3639 1154 8927      		pop r28
 3640 1156 8C93      		pop r29
 3641               		ret
 124:sensors.c     **** 	loop_until_bit_is_set(PIN, PINGPIN);     // Loop until the the PingPin goes high  (macro found in 
 3642               	r_Ping, .-sonar_Ping
 3643               	.Lscope57:
 3646 115c 8081      	.global	pressure_phidget
 3648 1160 90E0      	pressure_phidget:
 3650 1164 9070      	.LM306:
 3651 1166 0097      	.LFBB58:
 3652 1168 01F0      		push r29
 125:sensors.c     **** 	//clears timer, reset overflow counter
 126:sensors.c     **** 	reset_timer0();       //reset timer 0
 3653               	rcall .
 3654               		in r28,__SP_L__
 3655 116a 0E94 0000 		in r29,__SP_H__
 3656               	/* prologue: function */
 127:sensors.c     **** 	loop_until_bit_is_clear(PIN, PINGPIN);     // Loop until the the PingPin goes low  (macro found in
 3657               	rame size = 2 */
 3658               		std Y+2,r25
 3659 116e E0E2      		std Y+1,r24
 3661 1172 8081      	.LM307:
 3662 1174 882F      		ldd r24,Y+1
 3663 1176 90E0      		ldd r25,Y+2
 3664 1178 8870      		clr r26
 3665 117a 9070      		sbrc r25,7
 3666 117c 0097      		com r26
 3667 117e 01F4      		mov r27,r26
 128:sensors.c     **** 	//read timer0's overflow counter
 129:sensors.c     **** 	//255 is count before overflow, dependent on clock
 130:sensors.c     **** 	
 131:sensors.c     **** 	return (get_timer0_overflow()*255+TCNT0) * 2.068965517;//elapsed time x conversion
 3668               	24
 3669               		movw r24,r26
 3670 1180 0E94 0000 		call __floatsisf
 3671 1184 DC01      		movw r26,r24
 3672 1186 CB01      		movw r24,r22
 3673 1188 2FEF      		movw r22,r24
 3674 118a 30E0      		movw r24,r26
 3675 118c 40E0      		ldi r18,lo8(0x3e800000)
 3676 118e 50E0      		ldi r19,hi8(0x3e800000)
 3677 1190 BC01      		ldi r20,hlo8(0x3e800000)
 3678 1192 CD01      		ldi r21,hhi8(0x3e800000)
 3679 1194 0E94 0000 		call __mulsf3
 3680 1198 9B01      		movw r26,r24
 3681 119a AC01      		movw r24,r22
 3682 119c E6E4      		movw r22,r24
 3683 119e F0E0      		movw r24,r26
 3684 11a0 8081      		ldi r18,lo8(0x41200000)
 3685 11a2 882F      		ldi r19,hi8(0x41200000)
 3686 11a4 90E0      		ldi r20,hlo8(0x41200000)
 3687 11a6 A0E0      		ldi r21,hhi8(0x41200000)
 3688 11a8 B0E0      		call __addsf3
 3689 11aa 820F      		movw r26,r24
 3690 11ac 931F      		movw r24,r22
 3691 11ae A41F      		movw r22,r24
 3692 11b0 B51F      		movw r24,r26
 3693 11b2 BC01      		call __fixsfsi
 3694 11b4 CD01      		movw r26,r24
 3695 11b6 0E94 0000 		movw r24,r22
 3696 11ba DC01      	/* epilogue start */
 3698 11be BC01      	.LM308:
 3699 11c0 CD01      		pop __tmp_reg__
 3700 11c2 2EEE      		pop __tmp_reg__
 3701 11c4 39E6      		pop r28
 3702 11c6 44E0      		pop r29
 3703 11c8 50E4      		ret
 3705 11ce DC01      	.Lscope58:
 3708 11d4 CD01      	.global	voltage_phidget
 3710 11da DC01      	voltage_phidget:
 3712               	.LM309:
 132:sensors.c     **** 	}
 3713               	,__SP_L__
 3714               		in r29,__SP_H__
 3715 11de CF91      	/* prologue: function */
 3716 11e0 DF91      	/* frame size = 2 */
 3717 11e2 0895      		std Y+2,r25
 3718               		std Y+1,r24
 3720               	.LM310:
 3721               		ldd r24,Y+1
 3722               		ldd r25,Y+2
 3723               		subi r24,lo8(-(-500))
 3724               		sbci r25,hi8(-(-500))
 133:sensors.c     **** 
 134:sensors.c     **** /*****************Phidgets****************/
 135:sensors.c     **** //equations were taken from here and not independently verified:
 136:sensors.c     **** //http://www.robotshop.us/PDF/Phidgets-Sensors.pdf
 137:sensors.c     **** //you can power these sensors directly from the Axon's 5V ADC header row
 138:sensors.c     **** //(unless otherwise specified)
 139:sensors.c     **** //Gas Pressure Sensor
 140:sensors.c     **** int pressure_phidget(int value)
 141:sensors.c     **** 	{
 3725               	rc r25,7
 3726               		com r26
 3727               		mov r27,r26
 3728 11e4 DF93      		movw r22,r24
 3729 11e6 CF93      		movw r24,r26
 3730 11e8 00D0      		call __floatsisf
 3731 11ea CDB7      		movw r26,r24
 3732 11ec DEB7      		movw r24,r22
 3733               		movw r22,r24
 3734               		movw r24,r26
 3735 11ee 9A83      		ldi r18,lo8(0x3d75c28f)
 3736 11f0 8983      		ldi r19,hi8(0x3d75c28f)
 142:sensors.c     **** 	return (value*0.25 + 10);//returns in kilopascals
 3737               	8(0x3d75c28f)
 3738               		ldi r21,hhi8(0x3d75c28f)
 3739 11f2 8981      		call __mulsf3
 3740 11f4 9A81      		movw r26,r24
 3741 11f6 AA27      		movw r24,r22
 3742 11f8 97FD      		movw r22,r24
 3743 11fa A095      		movw r24,r26
 3744 11fc BA2F      		call __fixsfsi
 3745 11fe BC01      		movw r26,r24
 3746 1200 CD01      		movw r24,r22
 3747 1202 0E94 0000 	/* epilogue start */
 3749 1208 CB01      	.LM311:
 3750 120a BC01      		pop __tmp_reg__
 3751 120c CD01      		pop __tmp_reg__
 3752 120e 20E0      		pop r28
 3753 1210 30E0      		pop r29
 3754 1212 40E8      		ret
 3756 1216 0E94 0000 	.Lscope59:
 3759 121e BC01      	.global	magnetic_phidget
 3761 1222 20E0      	magnetic_phidget:
 3763 1226 40E2      	.LM312:
 3764 1228 51E4      	.LFBB60:
 3765 122a 0E94 0000 		push r29
 3766 122e DC01      		push r28
 3767 1230 CB01      		rcall .
 3768 1232 BC01      		in r28,__SP_L__
 3769 1234 CD01      		in r29,__SP_H__
 3770 1236 0E94 0000 	/* prologue: function */
 3771 123a DC01      	/* frame size = 2 */
 3772 123c CB01      		std Y+2,r25
 3773               		std Y+1,r24
 143:sensors.c     **** 	}
 3774               	3:
 3775               		ldi r18,lo8(500)
 3776 123e 0F90      		ldi r19,hi8(500)
 3777 1240 0F90      		ldd r24,Y+1
 3778 1242 CF91      		ldd r25,Y+2
 3779 1244 DF91      		movw r20,r18
 3780 1246 0895      		sub r20,r24
 3781               		sbc r21,r25
 3782               		movw r24,r20
 3783               	/* epilogue start */
 3785               	.LM314:
 3786               		pop __tmp_reg__
 3787               		pop __tmp_reg__
 144:sensors.c     **** //Voltage Sensor
 145:sensors.c     **** int voltage_phidget(int value)
 146:sensors.c     **** 	{
 3788               	r29
 3789               		ret
 3791 1248 DF93      	.Lscope60:
 3794 124e CDB7      	.global	temperature_phidget
 3796               	temperature_phidget:
 3798 1252 9A83      	.LM315:
 3799 1254 8983      	.LFBB61:
 147:sensors.c     **** 	return ((value - 500) * 0.06);//returns in volts
 3800               	ush r28
 3801               		rcall .
 3802 1256 8981      		rcall .
 3803 1258 9A81      		in r28,__SP_L__
 3804 125a 845F      		in r29,__SP_H__
 3805 125c 9140      	/* prologue: function */
 3806 125e AA27      	/* frame size = 4 */
 3807 1260 97FD      		std Y+2,r25
 3808 1262 A095      		std Y+1,r24
 3810 1266 BC01      	.LM316:
 3811 1268 CD01      		ldd r24,Y+1
 3812 126a 0E94 0000 		ldd r25,Y+2
 3813 126e DC01      		subi r24,lo8(-(-200))
 3814 1270 CB01      		sbci r25,hi8(-(-200))
 3815 1272 BC01      		std Y+4,r25
 3816 1274 CD01      		std Y+3,r24
 3817 1276 2FE8      		ldd r24,Y+3
 3818 1278 32EC      		ldd r25,Y+4
 3819 127a 45E7      		tst r25
 3820 127c 5DE3      		brge .L158
 3821 127e 0E94 0000 		ldd r24,Y+3
 3822 1282 DC01      		ldd r25,Y+4
 3823 1284 CB01      		adiw r24,3
 3824 1286 BC01      		std Y+4,r25
 3825 1288 CD01      		std Y+3,r24
 3826 128a 0E94 0000 	.L158:
 3827 128e DC01      		ldd r24,Y+3
 3828 1290 CB01      		ldd r25,Y+4
 3829               		asr r25
 148:sensors.c     **** 	}
 3830               	epilogue start */
 3832 1292 0F90      	.LM317:
 3833 1294 0F90      		pop __tmp_reg__
 3834 1296 CF91      		pop __tmp_reg__
 3835 1298 DF91      		pop __tmp_reg__
 3836 129a 0895      		pop __tmp_reg__
 3837               		pop r28
 3838               		pop r29
 3839               		ret
 3841               	.Lscope61:
 149:sensors.c     **** //Magnetic Sensor
 150:sensors.c     **** int magnetic_phidget(int value)
 151:sensors.c     **** 	{
 3844               	tDC50_phidget
 3846               	currentDC50_phidget:
 3848 129e CF93      	.LM318:
 3849 12a0 00D0      	.LFBB62:
 3850 12a2 CDB7      		push r29
 3851 12a4 DEB7      		push r28
 3852               		rcall .
 3853               		in r28,__SP_L__
 3854 12a6 9A83      		in r29,__SP_H__
 3855 12a8 8983      	/* prologue: function */
 152:sensors.c     **** 	return (500 - value);//returns in gauss
 3856               	e = 2 */
 3857               		std Y+2,r25
 3858 12aa 24EF      		std Y+1,r24
 3860 12ae 8981      	.LM319:
 3861 12b0 9A81      		ldd r24,Y+1
 3862 12b2 A901      		ldd r25,Y+2
 3863 12b4 481B      		subi r24,lo8(-(-500))
 3864 12b6 590B      		sbci r25,hi8(-(-500))
 3865 12b8 CA01      		clr r26
 3866               		sbrc r25,7
 153:sensors.c     **** 	}
 3867               	ov r27,r26
 3868               		movw r22,r24
 3869 12ba 0F90      		movw r24,r26
 3870 12bc 0F90      		call __floatsisf
 3871 12be CF91      		movw r26,r24
 3872 12c0 DF91      		movw r24,r22
 3873 12c2 0895      		movw r22,r24
 3874               		movw r24,r26
 3875               		ldi r18,lo8(0x3e000000)
 3876               		ldi r19,hi8(0x3e000000)
 3877               		ldi r20,hlo8(0x3e000000)
 3878               		ldi r21,hhi8(0x3e000000)
 3879               		call __mulsf3
 3880               		movw r26,r24
 154:sensors.c     **** //Temperature Sensor
 155:sensors.c     **** int temperature_phidget(int value)
 156:sensors.c     **** 	{
 3881               		movw r22,r24
 3882               		movw r24,r26
 3883               		call __fixsfsi
 3884 12c4 DF93      		movw r26,r24
 3885 12c6 CF93      		movw r24,r22
 3886 12c8 00D0      	/* epilogue start */
 3888 12cc CDB7      	.LM320:
 3889 12ce DEB7      		pop __tmp_reg__
 3890               		pop __tmp_reg__
 3891               		pop r28
 3892 12d0 9A83      		pop r29
 3893 12d2 8983      		ret
 157:sensors.c     **** 	return ((value-200)/4);//returns in celsius
 3894               	tDC50_phidget, .-currentDC50_phidget
 3895               	.Lscope62:
 3898 12d8 885C      	.global	currentAC50_phidget
 3900 12dc 9C83      	currentAC50_phidget:
 3902 12e0 8B81      	.LM321:
 3903 12e2 9C81      	.LFBB63:
 3904 12e4 9923      		push r29
 3905 12e6 04F4      		push r28
 3906 12e8 8B81      		rcall .
 3907 12ea 9C81      		in r28,__SP_L__
 3908 12ec 0396      		in r29,__SP_H__
 3909 12ee 9C83      	/* prologue: function */
 3910 12f0 8B83      	/* frame size = 2 */
 3911               		std Y+2,r25
 3912 12f2 8B81      		std Y+1,r24
 3914 12f6 9595      	.LM322:
 3915 12f8 8795      		ldd r24,Y+1
 3916 12fa 9595      		ldd r25,Y+2
 3917 12fc 8795      		clr r26
 3918               		sbrc r25,7
 158:sensors.c     **** 	}
 3919               	vw r22,r24
 3920               		movw r24,r26
 3921 12fe 0F90      		call __floatsisf
 3922 1300 0F90      		movw r26,r24
 3923 1302 0F90      		movw r24,r22
 3924 1304 0F90      		movw r22,r24
 3925 1306 CF91      		movw r24,r26
 3926 1308 DF91      		ldi r18,lo8(0x3d800000)
 3927 130a 0895      		ldi r19,hi8(0x3d800000)
 3928               		ldi r20,hlo8(0x3d800000)
 3929               		ldi r21,hhi8(0x3d800000)
 3930               		call __mulsf3
 3931               		movw r26,r24
 3932               		movw r24,r22
 3933               		movw r22,r24
 3934               		movw r24,r26
 159:sensors.c     **** //50A Current Sensor
 160:sensors.c     **** int currentDC50_phidget(int value)
 161:sensors.c     **** 	{
 3935               		movw r26,r24
 3936               		movw r24,r22
 3937               	/* epilogue start */
 3939 130e CF93      	.LM323:
 3940 1310 00D0      		pop __tmp_reg__
 3941 1312 CDB7      		pop __tmp_reg__
 3942 1314 DEB7      		pop r28
 3943               		pop r29
 3944               		ret
 3946 1318 8983      	.Lscope63:
 162:sensors.c     **** 	return ((value-500)* 0.125);//returns in amps
 3947               	rentDC20_phidget:F(0,1)",36,0,0,currentDC20_phidget
 3949 131a 8981      	.global	currentDC20_phidget
 3951 131e 845F      	currentDC20_phidget:
 3953 1322 AA27      	.LM324:
 3954 1324 97FD      	.LFBB64:
 3955 1326 A095      		push r29
 3956 1328 BA2F      		push r28
 3957 132a BC01      		rcall .
 3958 132c CD01      		in r28,__SP_L__
 3959 132e 0E94 0000 		in r29,__SP_H__
 3960 1332 DC01      	/* prologue: function */
 3961 1334 CB01      	/* frame size = 2 */
 3962 1336 BC01      		std Y+2,r25
 3963 1338 CD01      		std Y+1,r24
 3965 133c 30E0      	.LM325:
 3966 133e 40E0      		ldd r24,Y+1
 3967 1340 5EE3      		ldd r25,Y+2
 3968 1342 0E94 0000 		subi r24,lo8(-(-500))
 3969 1346 DC01      		sbci r25,hi8(-(-500))
 3970 1348 CB01      		clr r26
 3971 134a BC01      		sbrc r25,7
 3972 134c CD01      		com r26
 3973 134e 0E94 0000 		mov r27,r26
 3974 1352 DC01      		movw r22,r24
 3975 1354 CB01      		movw r24,r26
 3976               		call __floatsisf
 163:sensors.c     **** 	}
 3977               	ovw r22,r24
 3978               		movw r24,r26
 3979 1356 0F90      		ldi r18,lo8(0x3d4ccccd)
 3980 1358 0F90      		ldi r19,hi8(0x3d4ccccd)
 3981 135a CF91      		ldi r20,hlo8(0x3d4ccccd)
 3982 135c DF91      		ldi r21,hhi8(0x3d4ccccd)
 3983 135e 0895      		call __mulsf3
 3984               		movw r26,r24
 3985               		movw r24,r22
 3986               		movw r22,r24
 3987               		movw r24,r26
 3988               		call __fixsfsi
 3989               		movw r26,r24
 3990               		movw r24,r22
 164:sensors.c     **** //50A Current Sensor
 165:sensors.c     **** int currentAC50_phidget(int value)
 166:sensors.c     **** 	{
 3991               	art */
 3993               	.LM326:
 3994 1360 DF93      		pop __tmp_reg__
 3995 1362 CF93      		pop __tmp_reg__
 3996 1364 00D0      		pop r28
 3997 1366 CDB7      		pop r29
 3998 1368 DEB7      		ret
 4000               	.Lscope64:
 167:sensors.c     **** 	return (value*0.0625);//returns in amps
 4003               	entAC20_phidget
 4005 136e 8981      	currentAC20_phidget:
 4007 1372 AA27      	.LM327:
 4008 1374 97FD      	.LFBB65:
 4009 1376 A095      		push r29
 4010 1378 BA2F      		push r28
 4011 137a BC01      		rcall .
 4012 137c CD01      		in r28,__SP_L__
 4013 137e 0E94 0000 		in r29,__SP_H__
 4014 1382 DC01      	/* prologue: function */
 4015 1384 CB01      	/* frame size = 2 */
 4016 1386 BC01      		std Y+2,r25
 4017 1388 CD01      		std Y+1,r24
 4019 138c 30E0      	.LM328:
 4020 138e 40E8      		ldd r24,Y+1
 4021 1390 5DE3      		ldd r25,Y+2
 4022 1392 0E94 0000 		clr r26
 4023 1396 DC01      		sbrc r25,7
 4024 1398 CB01      		com r26
 4025 139a BC01      		mov r27,r26
 4026 139c CD01      		movw r22,r24
 4027 139e 0E94 0000 		movw r24,r26
 4028 13a2 DC01      		call __floatsisf
 4029 13a4 CB01      		movw r26,r24
 4030               		movw r24,r22
 168:sensors.c     **** 	}
 4031               		ldi r18,lo8(0x3ccccccd)
 4032               		ldi r19,hi8(0x3ccccccd)
 4033 13a6 0F90      		ldi r20,hlo8(0x3ccccccd)
 4034 13a8 0F90      		ldi r21,hhi8(0x3ccccccd)
 4035 13aa CF91      		call __mulsf3
 4036 13ac DF91      		movw r26,r24
 4037 13ae 0895      		movw r24,r22
 4038               		movw r22,r24
 4039               		movw r24,r26
 4040               		call __fixsfsi
 4041               		movw r26,r24
 4042               		movw r24,r22
 4043               	/* epilogue start */
 169:sensors.c     **** //20A Current Sensor
 170:sensors.c     **** int currentDC20_phidget(int value)
 171:sensors.c     **** 	{
 4045               	_tmp_reg__
 4046               		pop __tmp_reg__
 4047               		pop r28
 4048 13b0 DF93      		pop r29
 4049 13b2 CF93      		ret
 4051 13b6 CDB7      	.Lscope65:
 4054               	.global	humidity_phidget
 4056 13bc 8983      	humidity_phidget:
 172:sensors.c     **** 	return ((value-500)* 0.05);//returns in amps
 4057               	,181,.LM330-.LFBB66
 4058               	.LM330:
 4059 13be 8981      	.LFBB66:
 4060 13c0 9A81      		push r29
 4061 13c2 845F      		push r28
 4062 13c4 9140      		rcall .
 4063 13c6 AA27      		in r28,__SP_L__
 4064 13c8 97FD      		in r29,__SP_H__
 4065 13ca A095      	/* prologue: function */
 4066 13cc BA2F      	/* frame size = 2 */
 4067 13ce BC01      		std Y+2,r25
 4068 13d0 CD01      		std Y+1,r24
 4070 13d6 DC01      	.LM331:
 4071 13d8 CB01      		ldd r24,Y+1
 4072 13da BC01      		ldd r25,Y+2
 4073 13dc CD01      		clr r26
 4074 13de 2DEC      		sbrc r25,7
 4075 13e0 3CEC      		com r26
 4076 13e2 4CE4      		mov r27,r26
 4077 13e4 5DE3      		movw r22,r24
 4078 13e6 0E94 0000 		movw r24,r26
 4079 13ea DC01      		call __floatsisf
 4080 13ec CB01      		movw r26,r24
 4081 13ee BC01      		movw r24,r22
 4082 13f0 CD01      		movw r22,r24
 4083 13f2 0E94 0000 		movw r24,r26
 4084 13f6 DC01      		ldi r18,lo8(0x3e474539)
 4085 13f8 CB01      		ldi r19,hi8(0x3e474539)
 4086               		ldi r20,hlo8(0x3e474539)
 173:sensors.c     **** 	}
 4087               	l __mulsf3
 4088               		movw r26,r24
 4089 13fa 0F90      		movw r24,r22
 4090 13fc 0F90      		movw r22,r24
 4091 13fe CF91      		movw r24,r26
 4092 1400 DF91      		ldi r18,lo8(0x4227eb85)
 4093 1402 0895      		ldi r19,hi8(0x4227eb85)
 4094               		ldi r20,hlo8(0x4227eb85)
 4095               		ldi r21,hhi8(0x4227eb85)
 4096               		call __subsf3
 4097               		movw r26,r24
 4098               		movw r24,r22
 4099               		movw r22,r24
 4100               		movw r24,r26
 174:sensors.c     **** //20A Current Sensor
 175:sensors.c     **** int currentAC20_phidget(int value)
 176:sensors.c     **** 	{
 4101               	i
 4102               		movw r26,r24
 4103               		movw r24,r22
 4104 1404 DF93      	/* epilogue start */
 4106 1408 00D0      	.LM332:
 4107 140a CDB7      		pop __tmp_reg__
 4108 140c DEB7      		pop __tmp_reg__
 4109               		pop r28
 4110               		pop r29
 4111 140e 9A83      		ret
 177:sensors.c     **** 	return (value*0.025);//returns in amps
 4118 1418 97FD      	.global	sabertooth
 4120 141c BA2F      	sabertooth:
 4122 1420 CD01      	.Ltext4:
 4124 1426 DC01      	.LM333:
 4125 1428 CB01      	.LFBB67:
 4126 142a BC01      		push r29
 4127 142c CD01      		push r28
 4128 142e 2DEC      		rcall .
 4129 1430 3CEC      		rcall .
 4130 1432 4CEC      		in r28,__SP_L__
 4131 1434 5CE3      		in r29,__SP_H__
 4132 1436 0E94 0000 	/* prologue: function */
 4133 143a DC01      	/* frame size = 4 */
 4134 143c CB01      		std Y+2,r25
 4135 143e BC01      		std Y+1,r24
 4136 1440 CD01      		std Y+4,r23
 4137 1442 0E94 0000 		std Y+3,r22
 4139 1448 CB01      	.LM334:
 4140               		ldi r24,lo8(2)
 178:sensors.c     **** 	}
 4141               	,hi8(38400)
 4142               		ldi r22,hlo8(38400)
 4143 144a 0F90      		ldi r23,hhi8(38400)
 4144 144c 0F90      		call uartSetBaudRate
 4146 1450 DF91      	.LM335:
 4147 1452 0895      		ldd r24,Y+1
 4148               		call uart2SendByte
 4150               	.LM336:
 4151               		ldd r24,Y+3
 4152               		call uart2SendByte
 4153               	/* epilogue start */
 179:sensors.c     **** //Humidity Sensor
 180:sensors.c     **** int humidity_phidget(int value)
 181:sensors.c     **** 	{
 4155               	_tmp_reg__
 4156               		pop __tmp_reg__
 4157               		pop __tmp_reg__
 4158 1454 DF93      		pop __tmp_reg__
 4159 1456 CF93      		pop r28
 4160 1458 00D0      		pop r29
 4161 145a CDB7      		ret
 4163               	.Lscope67:
 4166 1460 8983      	.global	syren
 182:sensors.c     **** 	return ((value*0.1946) - 41.98);//returns in RH (in %)
 4167               	, @function
 4168               	syren:
 4170 1464 9A81      	.LM338:
 4171 1466 AA27      	.LFBB68:
 4172 1468 97FD      		push r29
 4173 146a A095      		push r28
 4174 146c BA2F      		rcall .
 4175 146e BC01      		in r28,__SP_L__
 4176 1470 CD01      		in r29,__SP_H__
 4177 1472 0E94 0000 	/* prologue: function */
 4178 1476 DC01      	/* frame size = 2 */
 4179 1478 CB01      		std Y+2,r25
 4180 147a BC01      		std Y+1,r24
 4182 147e 29E3      	.LM339:
 4183 1480 35E4      		ldi r24,lo8(2)
 4184 1482 47E4      		ldi r20,lo8(38400)
 4185 1484 5EE3      		ldi r21,hi8(38400)
 4186 1486 0E94 0000 		ldi r22,hlo8(38400)
 4187 148a DC01      		ldi r23,hhi8(38400)
 4188 148c CB01      		call uartSetBaudRate
 4190 1490 CD01      	.LM340:
 4191 1492 25E8      		ldd r24,Y+1
 4192 1494 3BEE      		call uart2SendByte
 4193 1496 47E2      	/* epilogue start */
 4195 149a 0E94 0000 	.LM341:
 4196 149e DC01      		pop __tmp_reg__
 4197 14a0 CB01      		pop __tmp_reg__
 4198 14a2 BC01      		pop r28
 4199 14a4 CD01      		pop r29
 4200 14a6 0E94 0000 		ret
 4202 14ac CB01      	.Lscope68:
 183:sensors.c     **** 	}
 4204               	
 4207 14b0 0F90      	__c.3132:
 4208 14b2 CF91      		.string	"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\r\n"
 4209 14b4 DF91      		.text
 4212               	.global	axon_DAQ
 4214               	axon_DAQ:
 4216               	.Ltext5:
 4218               	.LM342:
 4219               	.LFBB69:
 4220               		push r16
 4221               		push r17
 4222               		push r29
   1:misc.c        **** /****************************************************************************
   2:misc.c        **** *
   3:misc.c        **** *   Copyright (c) 2008 www.societyofrobots.com
   4:misc.c        **** *   (please link back if you use this code!)
   5:misc.c        **** *
   6:misc.c        **** *   This program is free software; you can redistribute it and/or modify
   7:misc.c        **** *   it under the terms of the GNU General Public License version 2 as
   8:misc.c        **** *   published by the Free Software Foundation.
   9:misc.c        **** *
  10:misc.c        **** *   Alternatively, this software may be distributed under the terms of BSD
  11:misc.c        **** *   license.
  12:misc.c        **** *
  13:misc.c        **** ****************************************************************************/
  14:misc.c        **** 
  15:misc.c        **** 
  16:misc.c        **** //this file contains code to use with various robot hardware
  17:misc.c        **** 
  18:misc.c        **** /***************SABERTOOTH****************/
  19:misc.c        **** //This is the motor driver by dimensionengineering. This
  20:misc.c        **** //program lets you send serial data to the driver for motor control.
  21:misc.c        **** //datasheets:
  22:misc.c        **** //http://www.dimensionengineering.com/datasheets/Sabertooth2x5.pdf
  23:misc.c        **** //http://www.dimensionengineering.com/datasheets/Sabertooth2x25.pdf
  24:misc.c        **** //http://www.dimensionengineering.com/datasheets/Sabertooth2x10.pdf
  25:misc.c        **** //note that instead of using serial, you can also use PWM or servo command code
  26:misc.c        **** 
  27:misc.c        **** //see page 13 for serial information
  28:misc.c        **** //Sending a character between 1 and 127 will control motor 1
  29:misc.c        **** //1 is full reverse, 64 is stop and 127 is full forward
  30:misc.c        **** 
  31:misc.c        **** //Sending a character between 128 and 255 will control motor 2
  32:misc.c        **** //128 is full reverse, 192 is stop and 255 is full forward
  33:misc.c        **** 
  34:misc.c        **** //Character 0 will shut down both motors
  35:misc.c        **** 
  36:misc.c        **** //example: sabertooth(38,200);//send command to motors
  37:misc.c        **** 
  38:misc.c        **** void sabertooth(int m1, int m2)
  39:misc.c        **** 	{
 4223               	__SP_L__
 4224               		in r29,__SP_H__
 4225               		sbiw r28,32
 4226 14b8 DF93      		in __tmp_reg__,__SREG__
 4227 14ba CF93      		cli
 4228 14bc 00D0      		out __SP_H__,r29
 4229 14be 00D0      		out __SREG__,__tmp_reg__
 4230 14c0 CDB7      		out __SP_L__,r28
 4231 14c2 DEB7      	/* prologue: function */
 4232               	/* frame size = 32 */
 4234 14c4 9A83      	.LM343:
 4235 14c6 8983      		ldi r24,lo8(5)
 4236 14c8 7C83      		call a2dSetPrescaler
 4237 14ca 6B83      	.L175:
  40:misc.c        **** 	//rprintfInit(uart2SendByte);//select uart2
  41:misc.c        **** 	uartSetBaudRate(2, 38400);//select baud (see page 13/14 of datasheet)
 4238               	,.LM344-.LFBB69
 4239               	.LM344:
 4240 14cc 82E0      		call reset_timer2
 4242 14d0 56E9      	.LM345:
 4243 14d2 60E0      		ldi r24,lo8(0)
 4244 14d4 70E0      		call a2dConvert8bit
 4245 14d6 0E94 0000 		mov r24,r24
  42:misc.c        **** 	uart2SendByte(m1);//send a command for motor 1
 4246               	,lo8(0)
 4247               		std Y+32,r25
 4248 14da 8981      		std Y+31,r24
  43:misc.c        **** 	uart2SendByte(m2);//send a command for motor 2
 4250               	46:
 4251               		ldi r24,lo8(1)
 4252 14e0 8B81      		call a2dConvert8bit
 4253 14e2 0E94 0000 		mov r24,r24
 4254               		ldi r25,lo8(0)
  44:misc.c        **** 	}
 4255               	Y+30,r25
 4256               		std Y+29,r24
 4258 14e8 0F90      	.LM347:
 4259 14ea 0F90      		ldi r24,lo8(2)
 4260 14ec 0F90      		call a2dConvert8bit
 4261 14ee CF91      		mov r24,r24
 4262 14f0 DF91      		ldi r25,lo8(0)
 4263 14f2 0895      		std Y+28,r25
 4264               		std Y+27,r24
 4266               	.LM348:
 4267               		ldi r24,lo8(3)
 4268               		call a2dConvert8bit
 4269               		mov r24,r24
 4270               		ldi r25,lo8(0)
  45:misc.c        **** 
  46:misc.c        **** /*********************SYREN*******************/
  47:misc.c        **** //This is the motor driver by dimensionengineering. This
  48:misc.c        **** //program lets you send serial data to the driver for motor control.
  49:misc.c        **** //note that instead of using serial, you can also use PWM or servo command code
  50:misc.c        **** 
  51:misc.c        **** //http://www.dimensionengineering.com/datasheets/SyRen10-20.pdf
  52:misc.c        **** //http://www.dimensionengineering.com/datasheets/SyRen10-25.pdf
  53:misc.c        **** 
  54:misc.c        **** //0 represents full reverse and 255 represents full forward
  55:misc.c        **** 
  56:misc.c        **** void syren(int m1)
  57:misc.c        **** 	{
 4271               	td Y+25,r24
 4273               	.LM349:
 4274 14f4 DF93      		ldi r24,lo8(4)
 4275 14f6 CF93      		call a2dConvert8bit
 4276 14f8 00D0      		mov r24,r24
 4277 14fa CDB7      		ldi r25,lo8(0)
 4278 14fc DEB7      		std Y+24,r25
 4279               		std Y+23,r24
 4281 14fe 9A83      	.LM350:
 4282 1500 8983      		ldi r24,lo8(5)
  58:misc.c        **** 	//rprintfInit(uart2SendByte);//select uart2
  59:misc.c        **** 	uartSetBaudRate(2, 38400);//select baud (see page 14 of datasheet)
 4283               	vert8bit
 4284               		mov r24,r24
 4285 1502 82E0      		ldi r25,lo8(0)
 4286 1504 40E0      		std Y+22,r25
 4287 1506 56E9      		std Y+21,r24
 4289 150a 70E0      	.LM351:
 4290 150c 0E94 0000 		ldi r24,lo8(6)
  60:misc.c        **** 	uart2SendByte(m1);//send a command for motor 1
 4291               	dConvert8bit
 4292               		mov r24,r24
 4293 1510 8981      		ldi r25,lo8(0)
 4294 1512 0E94 0000 		std Y+20,r25
 4295               		std Y+19,r24
  61:misc.c        **** 	}
 4296               	bn	68,0,56,.LM352-.LFBB69
 4297               	.LM352:
 4298 1516 0F90      		ldi r24,lo8(7)
 4299 1518 0F90      		call a2dConvert8bit
 4300 151a CF91      		mov r24,r24
 4301 151c DF91      		ldi r25,lo8(0)
 4302 151e 0895      		std Y+18,r25
 4303               		std Y+17,r24
 4305               	.LM353:
 4306               		ldi r24,lo8(8)
 4307               		call a2dConvert8bit
 4308               		mov r24,r24
 4309               		ldi r25,lo8(0)
 4310 0000 2564 2025 		std Y+16,r25
 4310      6420 2564 
 4310      2025 6420 
 4310      2564 2025 
 4310      6420 2564 
 4311               		std Y+15,r24
 4313               	.LM354:
 4314               		ldi r24,lo8(9)
 4315               		call a2dConvert8bit
 4316               		mov r24,r24
 4317               		ldi r25,lo8(0)
 4318               		std Y+14,r25
   1:axon_DAQ.c    **** /****************************************************************************
   2:axon_DAQ.c    **** *
   3:axon_DAQ.c    **** *   Copyright (c) 2008 www.societyofrobots.com
   4:axon_DAQ.c    **** *   (please link back if you use this code!)
   5:axon_DAQ.c    **** *
   6:axon_DAQ.c    **** *   This program is free software; you can redistribute it and/or modify
   7:axon_DAQ.c    **** *   it under the terms of the GNU General Public License version 2 as
   8:axon_DAQ.c    **** *   published by the Free Software Foundation.
   9:axon_DAQ.c    **** *
  10:axon_DAQ.c    **** *   Alternatively, this software may be distributed under the terms of BSD
  11:axon_DAQ.c    **** *   license.
  12:axon_DAQ.c    **** *
  13:axon_DAQ.c    **** ****************************************************************************/
  14:axon_DAQ.c    **** 
  15:axon_DAQ.c    **** //this file contains code to convert the Axon into a DAQ (data acquisition device)
  16:axon_DAQ.c    **** 
  17:axon_DAQ.c    **** 
  18:axon_DAQ.c    **** void axon_DAQ(void)
  19:axon_DAQ.c    **** 	{
 4319               	8,0,59,.LM355-.LFBB69
 4320               	.LM355:
 4321               		ldi r24,lo8(10)
 4322 1520 0F93      		call a2dConvert8bit
 4323 1522 1F93      		mov r24,r24
 4324 1524 DF93      		ldi r25,lo8(0)
 4325 1526 CF93      		std Y+12,r25
 4326 1528 CDB7      		std Y+11,r24
 4328 152c A097      	.LM356:
 4329 152e 0FB6      		ldi r24,lo8(11)
 4330 1530 F894      		call a2dConvert8bit
 4331 1532 DEBF      		mov r24,r24
 4332 1534 0FBE      		ldi r25,lo8(0)
 4333 1536 CDBF      		std Y+10,r25
 4334               		std Y+9,r24
  20:axon_DAQ.c    **** 	int a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;
  21:axon_DAQ.c    **** 
  22:axon_DAQ.c    **** 	//select speed/accuracy of data conversion
  23:axon_DAQ.c    **** 	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling, 32 default
 4336               	lo8(12)
 4337               		call a2dConvert8bit
 4338 1538 85E0      		mov r24,r24
 4339 153a 0E94 0000 		ldi r25,lo8(0)
 4340               		std Y+8,r25
  24:axon_DAQ.c    **** 
  25:axon_DAQ.c    **** 	// A2D clock prescaler select
  26:axon_DAQ.c    **** 	//		*selects how much the CPU clock frequency is divided
  27:axon_DAQ.c    **** 	//		to create the A2D clock frequency
  28:axon_DAQ.c    **** 	//		*lower division ratios make conversion go faster
  29:axon_DAQ.c    **** 	//		*higher division ratios make conversions more accurate
  30:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV2 		-> CPU clk/2
  31:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV4	  	-> CPU clk/4
  32:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV8	  	-> CPU clk/8
  33:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV16		-> CPU clk/16
  34:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV32		-> CPU clk/32
  35:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV64		-> CPU clk/64
  36:axon_DAQ.c    **** 	// ADC_PRESCALE_DIV128		-> CPU clk/128
  37:axon_DAQ.c    **** 
  38:axon_DAQ.c    **** 	while(1)
  39:axon_DAQ.c    **** 		{
  40:axon_DAQ.c    **** 		//clear timer
  41:axon_DAQ.c    **** 		reset_timer2();
 4341               	Y+7,r24
 4343 153e 0E94 0000 	.LM358:
  42:axon_DAQ.c    **** 
  43:axon_DAQ.c    **** 		//if you don't require high speed data collection,
  44:axon_DAQ.c    **** 		//add a delay here to slow it down
  45:axon_DAQ.c    **** 		//be careful that clock doesn't overflow!
  46:axon_DAQ.c    **** 		//delay_ms(1);
  47:axon_DAQ.c    **** 
  48:axon_DAQ.c    **** 		//gather data
  49:axon_DAQ.c    **** 		a0=a2dConvert8bit(0);
 4344               	i r24,lo8(13)
 4345               		call a2dConvert8bit
 4346 1542 80E0      		mov r24,r24
 4347 1544 0E94 0000 		ldi r25,lo8(0)
 4348 1548 882F      		std Y+6,r25
 4349 154a 90E0      		std Y+5,r24
 4351 154e 8F8F      	.LM359:
  50:axon_DAQ.c    **** 		a1=a2dConvert8bit(1);
 4352               	,lo8(14)
 4353               		call a2dConvert8bit
 4354 1550 81E0      		mov r24,r24
 4355 1552 0E94 0000 		ldi r25,lo8(0)
 4356 1556 882F      		std Y+4,r25
 4357 1558 90E0      		std Y+3,r24
 4359 155c 8D8F      	.LM360:
  51:axon_DAQ.c    **** 		a2=a2dConvert8bit(2);
 4360               	,lo8(15)
 4361               		call a2dConvert8bit
 4362 155e 82E0      		mov r24,r24
 4363 1560 0E94 0000 		ldi r25,lo8(0)
 4364 1564 882F      		std Y+2,r25
 4365 1566 90E0      		std Y+1,r24
 4366 1568 9C8F      	.LBB2:
  52:axon_DAQ.c    **** 		a3=a2dConvert8bit(3);
 4368               		ldi r16,lo8(__c.3132)
 4369               		ldi r17,hi8(__c.3132)
 4370 156c 83E0      	.LBE2:
 4371 156e 0E94 0000 		call get_timer2_counter
 4372 1572 882F      		mov r18,r24
 4373 1574 90E0      		ldi r19,lo8(0)
 4374 1576 9A8F      		in r24,__SP_L__
 4375 1578 898F      		in r25,__SP_H__
  53:axon_DAQ.c    **** 		a4=a2dConvert8bit(4);
 4376               	4,37
 4377               		in __tmp_reg__,__SREG__
 4378 157a 84E0      		cli
 4379 157c 0E94 0000 		out __SP_H__,r25
 4380 1580 882F      		out __SREG__,__tmp_reg__
 4381 1582 90E0      		out __SP_L__,r24
 4382 1584 988F      		in r30,__SP_L__
 4383 1586 8F8B      		in r31,__SP_H__
  54:axon_DAQ.c    **** 		a5=a2dConvert8bit(5);
 4384               	0,1
 4385               		ldi r24,lo8(1)
 4386 1588 85E0      		st Z,r24
 4387 158a 0E94 0000 		std Z+2,r17
 4388 158e 882F      		std Z+1,r16
 4389 1590 90E0      		ldd r24,Y+31
 4390 1592 9E8B      		ldd r25,Y+32
 4391 1594 8D8B      		std Z+4,r25
  55:axon_DAQ.c    **** 		a6=a2dConvert8bit(6);
 4392               	,r24
 4393               		ldd r24,Y+29
 4394 1596 86E0      		ldd r25,Y+30
 4395 1598 0E94 0000 		std Z+6,r25
 4396 159c 882F      		std Z+5,r24
 4397 159e 90E0      		ldd r24,Y+27
 4398 15a0 9C8B      		ldd r25,Y+28
 4399 15a2 8B8B      		std Z+8,r25
  56:axon_DAQ.c    **** 		a7=a2dConvert8bit(7);
 4400               	,r24
 4401               		ldd r24,Y+25
 4402 15a4 87E0      		ldd r25,Y+26
 4403 15a6 0E94 0000 		std Z+10,r25
 4404 15aa 882F      		std Z+9,r24
 4405 15ac 90E0      		ldd r24,Y+23
 4406 15ae 9A8B      		ldd r25,Y+24
 4407 15b0 898B      		std Z+12,r25
  57:axon_DAQ.c    **** 		a8=a2dConvert8bit(8);
 4408               	1,r24
 4409               		ldd r24,Y+21
 4410 15b2 88E0      		ldd r25,Y+22
 4411 15b4 0E94 0000 		std Z+14,r25
 4412 15b8 882F      		std Z+13,r24
 4413 15ba 90E0      		ldd r24,Y+19
 4414 15bc 988B      		ldd r25,Y+20
 4415 15be 8F87      		std Z+16,r25
  58:axon_DAQ.c    **** 		a9=a2dConvert8bit(9);
 4416               	5,r24
 4417               		ldd r24,Y+17
 4418 15c0 89E0      		ldd r25,Y+18
 4419 15c2 0E94 0000 		std Z+18,r25
 4420 15c6 882F      		std Z+17,r24
 4421 15c8 90E0      		ldd r24,Y+15
 4422 15ca 9E87      		ldd r25,Y+16
 4423 15cc 8D87      		std Z+20,r25
  59:axon_DAQ.c    **** 		a10=a2dConvert8bit(10);
 4424               	9,r24
 4425               		ldd r24,Y+13
 4426 15ce 8AE0      		ldd r25,Y+14
 4427 15d0 0E94 0000 		std Z+22,r25
 4428 15d4 882F      		std Z+21,r24
 4429 15d6 90E0      		ldd r24,Y+11
 4430 15d8 9C87      		ldd r25,Y+12
 4431 15da 8B87      		std Z+24,r25
  60:axon_DAQ.c    **** 		a11=a2dConvert8bit(11);
 4432               	3,r24
 4433               		ldd r24,Y+9
 4434 15dc 8BE0      		ldd r25,Y+10
 4435 15de 0E94 0000 		std Z+26,r25
 4436 15e2 882F      		std Z+25,r24
 4437 15e4 90E0      		ldd r24,Y+7
 4438 15e6 9A87      		ldd r25,Y+8
 4439 15e8 8987      		std Z+28,r25
  61:axon_DAQ.c    **** 		a12=a2dConvert8bit(12);
 4440               	7,r24
 4441               		ldd r24,Y+5
 4442 15ea 8CE0      		ldd r25,Y+6
 4443 15ec 0E94 0000 		std Z+30,r25
 4444 15f0 882F      		std Z+29,r24
 4445 15f2 90E0      		ldd r24,Y+3
 4446 15f4 9887      		ldd r25,Y+4
 4447 15f6 8F83      		std Z+32,r25
  62:axon_DAQ.c    **** 		a13=a2dConvert8bit(13);
 4448               	1,r24
 4449               		ldd r24,Y+1
 4450 15f8 8DE0      		ldd r25,Y+2
 4451 15fa 0E94 0000 		std Z+34,r25
 4452 15fe 882F      		std Z+33,r24
 4453 1600 90E0      		std Z+36,r19
 4454 1602 9E83      		std Z+35,r18
 4455 1604 8D83      		call rprintf1RamRom
  63:axon_DAQ.c    **** 		a14=a2dConvert8bit(14);
 4456               	__SP_L__
 4457               		in r25,__SP_H__
 4458 1606 8EE0      		adiw r24,37
 4459 1608 0E94 0000 		in __tmp_reg__,__SREG__
 4460 160c 882F      		cli
 4461 160e 90E0      		out __SP_H__,r25
 4462 1610 9C83      		out __SREG__,__tmp_reg__
 4463 1612 8B83      		out __SP_L__,r24
  64:axon_DAQ.c    **** 		a15=a2dConvert8bit(15);
 4464               	175
  65:axon_DAQ.c    **** 
  66:axon_DAQ.c    **** 		//report data, add time stamp and overflow count at end of data
  67:axon_DAQ.c    **** 		rprintf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\r\n",a0,a1,a2,a3,a4,a5,a6,a7,a8,a9
 4473               	a7:(0,1)",128,0,0,17
 4487 163a 0FBE      	.Lscope69:
 4488 163c 8DBF      		.section	.progmem.data
 4491 1642 3196      	__c.3157:
 4492 1644 81E0      		.string	"%d\r\n"
 4493 1646 8083      		.text
 4495 164a 0183      	.global	axon_DAQ_fast
 4497 164e 98A1      	axon_DAQ_fast:
 4499 1652 8383      	.LM362:
 4500 1654 8D8D      	.LFBB70:
 4501 1656 9E8D      		push r29
 4502 1658 9683      		push r28
 4503 165a 8583      		rcall .
 4504 165c 8B8D      		in r28,__SP_L__
 4505 165e 9C8D      		in r29,__SP_H__
 4506 1660 9087      	/* prologue: function */
 4507 1662 8783      	/* frame size = 2 */
 4509 1666 9A8D      	.LM363:
 4510 1668 9287      		ldi r24,lo8(2)
 4511 166a 8187      		call a2dSetPrescaler
 4512 166c 8F89      	.L178:
 4514 1670 9487      	.LM364:
 4515 1672 8387      		ldi r24,lo8(9)
 4516 1674 8D89      		call a2dConvert8bit
 4517 1676 9E89      		mov r24,r24
 4518 1678 9687      		ldi r25,lo8(0)
 4519 167a 8587      		std Y+2,r25
 4520 167c 8B89      		std Y+1,r24
 4521 167e 9C89      	.LBB3:
 4523 1682 8787      	.LM365:
 4524 1684 8989      		ldi r18,lo8(__c.3157)
 4525 1686 9A89      		ldi r19,hi8(__c.3157)
 4526 1688 928B      	.LBE3:
 4527 168a 818B      		rcall .
 4528 168c 8F85      		rcall .
 4529 168e 9889      		push __tmp_reg__
 4530 1690 948B      		in r30,__SP_L__
 4531 1692 838B      		in r31,__SP_H__
 4532 1694 8D85      		adiw r30,1
 4533 1696 9E85      		ldi r24,lo8(1)
 4534 1698 968B      		st Z,r24
 4535 169a 858B      		std Z+2,r19
 4536 169c 8B85      		std Z+1,r18
 4537 169e 9C85      		ldd r24,Y+1
 4538 16a0 908F      		ldd r25,Y+2
 4539 16a2 878B      		std Z+4,r25
 4540 16a4 8985      		std Z+3,r24
 4541 16a6 9A85      		call rprintf1RamRom
 4542 16a8 928F      		pop __tmp_reg__
 4543 16aa 818F      		pop __tmp_reg__
 4544 16ac 8F81      		pop __tmp_reg__
 4545 16ae 9885      		pop __tmp_reg__
 4546 16b0 948F      		pop __tmp_reg__
 4547 16b2 838F      		rjmp .L178
 4555 16c2 878F      	.Lscope70:
 4557 16c6 9A81      		.section	.progmem.data
 4560 16cc 34A3      	__c.3175:
 4561 16ce 23A3      		.string	"LEFT DIR:%d, LEFT DST:%d, RIGHT DIR:%d, RIGHT DST:%d\n,"
 4564 16d6 9EB7      	__c.3173:
 4565 16d8 8596      		.string	" %d, %d, %d, %d \n %d %d %d %d \n"
 4566 16da 0FB6      		.text
 4569 16e0 0FBE      	.global	control
 4571 16e4 00C0      	control:
 4573               	.Ltext6:
 4575               	.LM366:
 4576               	.LFBB71:
 4577               		push r29
 4578               		push r28
 4579               		in r28,__SP_L__
 4580               		in r29,__SP_H__
 4581               		sbiw r28,20
 4582               		in __tmp_reg__,__SREG__
 4583               		cli
 4584               		out __SP_H__,r29
 4585               		out __SREG__,__tmp_reg__
 4586               		out __SP_L__,r28
 4587               	/* prologue: function */
 4588               	/* frame size = 20 */
 4590               	.LM367:
 4591               		std Y+20,__zero_reg__
 4592               		std Y+19,__zero_reg__
 4594               	.LM368:
 4595               		std Y+18,__zero_reg__
 4596               		std Y+17,__zero_reg__
 4598               	.LM369:
 4599 0038 2564 0D0A 		std Y+16,__zero_reg__
 4599      00
 4600               		std Y+15,__zero_reg__
 4602               	.LM370:
 4603               		std Y+14,__zero_reg__
 4604               		std Y+13,__zero_reg__
  68:axon_DAQ.c    **** 		}
  69:axon_DAQ.c    **** 	}
  70:axon_DAQ.c    **** 
  71:axon_DAQ.c    **** void axon_DAQ_fast(void)
  72:axon_DAQ.c    **** 	{
 4605               	0,__zero_reg__
 4606               		std Y+9,__zero_reg__
 4608 16e6 DF93      	.LM373:
 4609 16e8 CF93      		ldi r24,lo8(0)
 4610 16ea 00D0      		call a2dConvert8bit
 4611 16ec CDB7      		mov r24,r24
 4612 16ee DEB7      		ldi r25,lo8(0)
 4613               		std Y+8,r25
 4614               		std Y+7,r24
  73:axon_DAQ.c    **** 	int a9;
  74:axon_DAQ.c    **** 
  75:axon_DAQ.c    **** 	//select speed/accuracy of data conversion
  76:axon_DAQ.c    **** 	a2dSetPrescaler(ADC_PRESCALE_DIV4); // configure ADC scaling
 4615               	,0,19,.LM374-.LFBB71
 4616               	.LM374:
 4617 16f0 82E0      		ldi r24,lo8(3)
 4618 16f2 0E94 0000 		call a2dConvert8bit
 4619               		mov r24,r24
  77:axon_DAQ.c    **** 
  78:axon_DAQ.c    **** 	while(1)
  79:axon_DAQ.c    **** 		{
  80:axon_DAQ.c    **** 		//gather data
  81:axon_DAQ.c    **** 		a9=a2dConvert8bit(9);
 4620               	r25,lo8(0)
 4621               		std Y+6,r25
 4622 16f6 89E0      		std Y+5,r24
 4624 16fc 882F      	.LM375:
 4625 16fe 90E0      		ldi r24,lo8(7)
 4626 1700 9A83      		call a2dConvert8bit
 4627 1702 8983      		mov r24,r24
 4628               		ldi r25,lo8(0)
  82:axon_DAQ.c    **** 
  83:axon_DAQ.c    **** 		//report data, add time stamp and overflow count at end of data
  84:axon_DAQ.c    **** 		rprintf("%d\r\n",a9);
 4629               	r25
 4630               		std Y+3,r24
 4632 1706 30E0      	.LM376:
 4633               		ldi r24,lo8(8)
 4634 1708 00D0      		call a2dConvert8bit
 4635 170a 00D0      		mov r24,r24
 4636 170c 0F92      		ldi r25,lo8(0)
 4637 170e EDB7      		std Y+2,r25
 4638 1710 FEB7      		std Y+1,r24
 4639 1712 3196      		rjmp .L181
 4640 1714 81E0      	.L192:
 4642 1718 3283      	.LM377:
 4643 171a 2183      		ldd r24,Y+7
 4644 171c 8981      		ldd r25,Y+8
 4645 171e 9A81      		tst r25
 4646 1720 9483      		brlt .L182
 4647 1722 8383      		ldd r24,Y+7
 4648 1724 0E94 0000 		ldd r25,Y+8
 4649 1728 0F90      		cpi r24,10
 4650 172a 0F90      		cpc r25,__zero_reg__
 4651 172c 0F90      		brge .L182
 4653 1730 0F90      	.LM378:
 4654 1732 00C0      		ldd r24,Y+17
 4655               		ldd r25,Y+18
 4656               		adiw r24,1
 4657               		std Y+18,r25
 4658               		std Y+17,r24
 4659               	.L182:
 4661               	.LM379:
 4662               		ldd r24,Y+7
 4663               		ldd r25,Y+8
 4664               		cpi r24,251
 4665               		cpc r25,__zero_reg__
 4666               		brlt .L183
 4667               		ldd r24,Y+7
 4668 003d 4C45 4654 		ldd r25,Y+8
 4668      2044 4952 
 4668      3A25 642C 
 4668      204C 4546 
 4668      5420 4453 
 4669               		cpi r24,255
 4670               		cpc r25,__zero_reg__
 4671               		breq .+2
 4672 0074 2025 642C 		brge .L183
 4672      2025 642C 
 4672      2025 642C 
 4672      2025 6420 
 4672      0A20 2564 
 4674               	.LM380:
 4675               		ldd r24,Y+19
 4676               		ldd r25,Y+20
 4677               		adiw r24,1
 4678               		std Y+20,r25
 4679               		std Y+19,r24
 4680               	.L183:
   1:control.c     **** void control()
   2:control.c     **** {
 4681               		ldd r25,Y+2
 4682               		tst r25
 4683               		brlt .L184
 4684 1734 DF93      		ldd r24,Y+1
 4685 1736 CF93      		ldd r25,Y+2
 4686 1738 CDB7      		cpi r24,10
 4687 173a DEB7      		cpc r25,__zero_reg__
 4688 173c 6497      		brge .L184
 4690 1740 F894      	.LM382:
 4691 1742 DEBF      		ldd r24,Y+11
 4692 1744 0FBE      		ldd r25,Y+12
 4693 1746 CDBF      		adiw r24,1
 4694               		std Y+12,r25
 4695               		std Y+11,r24
   3:control.c     **** unsigned right_rotHi = 0;
 4696               	68,0,54,.LM383-.LFBB71
 4697               	.LM383:
 4698 1748 1C8A      		ldd r24,Y+1
 4699 174a 1B8A      		ldd r25,Y+2
   4:control.c     **** 
   5:control.c     **** unsigned right_rotLo = 0;
 4700               	 r24,251
 4701               		cpc r25,__zero_reg__
 4702 174c 1A8A      		brlt .L185
 4703 174e 198A      		ldd r24,Y+1
   6:control.c     **** 
   7:control.c     **** int rightCount = 0;
 4704               	 r25,Y+2
 4705               		cpi r24,255
 4706 1750 188A      		cpc r25,__zero_reg__
 4707 1752 1F86      		breq .+2
   8:control.c     **** 
   9:control.c     **** unsigned left_rotHi = 0;
 4708               	e .L185
 4710 1754 1E86      	.LM384:
 4711 1756 1D86      		ldd r24,Y+13
  10:control.c     **** 
  11:control.c     **** unsigned left_rotLo = 0;
 4712               	 r25,Y+14
 4713               		adiw r24,1
 4714 1758 1C86      		std Y+14,r25
 4715 175a 1B86      		std Y+13,r24
  12:control.c     **** 
  13:control.c     **** int leftCount = 0;
 4716               	5:
 4718 175c 1A86      	.LM385:
 4719 175e 1986      		ldd r24,Y+17
  14:control.c     **** 
  15:control.c     **** int right_rotState =a2dConvert8bit(0);//right rotations
 4720               	 r25,Y+18
 4721               		sbiw r24,0
 4722 1760 80E0      		breq .L186
 4723 1762 0E94 0000 		ldd r24,Y+19
 4724 1766 882F      		ldd r25,Y+20
 4725 1768 90E0      		sbiw r24,0
 4726 176a 9887      		breq .L186
  16:control.c     **** 
  17:control.c     **** //int  se1 =a2dConvert8bit(1);
  18:control.c     **** 
  19:control.c     **** int  right_direction =a2dConvert8bit(3);//right direction, forward = low, reverse = hi
 4728               		ldd r24,Y+5
 4729               		ldd r25,Y+6
 4730 176e 83E0      		tst r25
 4731 1770 0E94 0000 		brlt .L187
 4732 1774 882F      		ldd r24,Y+5
 4733 1776 90E0      		ldd r25,Y+6
 4734 1778 9E83      		cpi r24,10
 4735 177a 8D83      		cpc r25,__zero_reg__
  20:control.c     **** 
  21:control.c     **** int  left_direction =a2dConvert8bit(7);//left direction, forward = hi, reverse = low
 4736               	187
 4738 177c 87E0      	.LM387:
 4739 177e 0E94 0000 		ldd r24,Y+15
 4740 1782 882F      		ldd r25,Y+16
 4741 1784 90E0      		adiw r24,1
 4742 1786 9C83      		std Y+16,r25
 4743 1788 8B83      		std Y+15,r24
  22:control.c     **** 
  23:control.c     **** int  left_rotState =a2dConvert8bit(8);//left rotations
 4745               	.LM388:
 4746 178a 88E0      		ldd r24,Y+5
 4747 178c 0E94 0000 		ldd r25,Y+6
 4748 1790 882F      		cpi r24,251
 4749 1792 90E0      		cpc r25,__zero_reg__
 4750 1794 9A83      		brlt .L188
 4751 1796 8983      		ldd r24,Y+5
 4752 1798 00C0      		ldd r25,Y+6
 4753               		cpi r24,255
  24:control.c     **** 
  25:control.c     **** //int  se5 =a2dConvert8bit(9);
  26:control.c     **** 
  27:control.c     **** while( uart1GetByte() != 'x')
  28:control.c     **** {
  29:control.c     **** 
  30:control.c     ****     if( 0 <= right_rotState && 10 > right_rotState ) //if rotState is low
 4754               	_zero_reg__
 4755               		breq .+2
 4756 179a 8F81      		brge .L188
 4758 179e 9923      	.LM389:
 4759 17a0 04F0      		ldd r24,Y+15
 4760 17a2 8F81      		ldd r25,Y+16
 4761 17a4 9885      		sbiw r24,1
 4762 17a6 8A30      		std Y+16,r25
 4763 17a8 9105      		std Y+15,r24
 4764 17aa 04F4      	.L188:
  31:control.c     **** 
  32:control.c     ****     {
  33:control.c     **** 
  34:control.c     ****         right_rotLo++;
 4765               	0,84,.LM390-.LFBB71
 4766               	.LM390:
 4767 17ac 8989      		std Y+18,__zero_reg__
 4768 17ae 9A89      		std Y+17,__zero_reg__
 4770 17b2 9A8B      	.LM391:
 4771 17b4 898B      		std Y+20,__zero_reg__
 4772               		std Y+19,__zero_reg__
  35:control.c     **** 
  36:control.c     ****     } 
  37:control.c     **** 
  38:control.c     ****     if( 250 < right_rotState && 255 >= right_rotState ) //if rotState is high
 4774               	.LM392:
 4775 17b6 8F81      		ldd r24,Y+11
 4776 17b8 9885      		ldd r25,Y+12
 4777 17ba 8B3F      		sbiw r24,0
 4778 17bc 9105      		breq .L189
 4779 17be 04F0      		ldd r24,Y+13
 4780 17c0 8F81      		ldd r25,Y+14
 4781 17c2 9885      		sbiw r24,0
 4782 17c4 8F3F      		breq .L189
 4784 17c8 01F0      	.LM393:
 4785 17ca 04F4      		ldd r24,Y+3
  39:control.c     **** 
  40:control.c     ****     {
  41:control.c     **** 
  42:control.c     ****         right_rotHi++;
 4786               		tst r25
 4787               		brlt .L190
 4788 17cc 8B89      		ldd r24,Y+3
 4789 17ce 9C89      		ldd r25,Y+4
 4790 17d0 0196      		cpi r24,10
 4791 17d2 9C8B      		cpc r25,__zero_reg__
 4792 17d4 8B8B      		brge .L190
  43:control.c     **** 
  44:control.c     ****     }
  45:control.c     **** 
  46:control.c     ****     if( 0 <= left_rotState &&  10 > left_rotState) //if rotState is low
 4794               		ldd r24,Y+9
 4795               		ldd r25,Y+10
 4796 17d6 8981      		sbiw r24,1
 4797 17d8 9A81      		std Y+10,r25
 4798 17da 9923      		std Y+9,r24
 4799 17dc 04F0      	.L190:
 4801 17e0 9A81      	.LM395:
 4802 17e2 8A30      		ldd r24,Y+3
 4803 17e4 9105      		ldd r25,Y+4
 4804 17e6 04F4      		cpi r24,251
  47:control.c     **** 
  48:control.c     ****     {
  49:control.c     **** 
  50:control.c     ****         left_rotLo++;
 4805               	zero_reg__
 4806               		brlt .L191
 4807 17e8 8B85      		ldd r24,Y+3
 4808 17ea 9C85      		ldd r25,Y+4
 4809 17ec 0196      		cpi r24,255
 4810 17ee 9C87      		cpc r25,__zero_reg__
 4811 17f0 8B87      		breq .+2
 4812               		brge .L191
  51:control.c     **** 
  52:control.c     ****     } 
  53:control.c     **** 
  54:control.c     ****     if( 250 < left_rotState &&  255 >=left_rotState) //if rotState is high
 4813               	68,0,106,.LM396-.LFBB71
 4814               	.LM396:
 4815 17f2 8981      		ldd r24,Y+9
 4816 17f4 9A81      		ldd r25,Y+10
 4817 17f6 8B3F      		adiw r24,1
 4818 17f8 9105      		std Y+10,r25
 4819 17fa 04F0      		std Y+9,r24
 4820 17fc 8981      	.L191:
 4822 1800 8F3F      	.LM397:
 4823 1802 9105      		std Y+12,__zero_reg__
 4824 1804 01F0      		std Y+11,__zero_reg__
  55:control.c     **** 
  56:control.c     ****     {
  57:control.c     **** 
  58:control.c     ****         left_rotHi++;
 4826               	Y+14,__zero_reg__
 4827               		std Y+13,__zero_reg__
 4828 1808 8D85      	.L189:
 4829 180a 9E85      	.LBB4:
 4831 180e 9E87      	.LM399:
 4832 1810 8D87      		ldi r18,lo8(__c.3173)
 4833               		ldi r19,hi8(__c.3173)
  59:control.c     **** 
  60:control.c     ****     }
  61:control.c     **** 
  62:control.c     **** //---------------------------
  63:control.c     **** 
  64:control.c     ****     if( right_rotLo > 0 && right_rotHi > 0)//if the encoder has seen both white and black
 4834               	in r24,__SP_L__
 4835               		in r25,__SP_H__
 4836 1812 8989      		sbiw r24,19
 4837 1814 9A89      		in __tmp_reg__,__SREG__
 4838 1816 0097      		cli
 4839 1818 01F0      		out __SP_H__,r25
 4840 181a 8B89      		out __SREG__,__tmp_reg__
 4841 181c 9C89      		out __SP_L__,r24
 4842 181e 0097      		in r30,__SP_L__
 4843 1820 01F0      		in r31,__SP_H__
  65:control.c     **** 
  66:control.c     ****     {
  67:control.c     **** 
  68:control.c     ****         if( 0 <= right_direction && right_direction < 10)
 4844               	1
 4845               		ldi r24,lo8(1)
 4846 1822 8D81      		st Z,r24
 4847 1824 9E81      		std Z+2,r19
 4848 1826 9923      		std Z+1,r18
 4849 1828 04F0      		ldd r24,Y+11
 4850 182a 8D81      		ldd r25,Y+12
 4851 182c 9E81      		std Z+4,r25
 4852 182e 8A30      		std Z+3,r24
 4853 1830 9105      		ldd r24,Y+13
 4854 1832 04F4      		ldd r25,Y+14
  69:control.c     **** 
  70:control.c     ****         {
  71:control.c     **** 
  72:control.c     ****             rightCount++;
 4855               	5
 4856               		std Z+5,r24
 4857 1834 8F85      		ldd r24,Y+3
 4858 1836 9889      		ldd r25,Y+4
 4859 1838 0196      		std Z+8,r25
 4860 183a 988B      		std Z+7,r24
 4861 183c 8F87      		ldd r24,Y+9
 4862               		ldd r25,Y+10
  73:control.c     **** 
  74:control.c     ****         }
  75:control.c     **** 
  76:control.c     ****         if( 250 < right_direction && right_direction <= 255)
 4863               	0,r25
 4864               		std Z+9,r24
 4865 183e 8D81      		ldd r24,Y+17
 4866 1840 9E81      		ldd r25,Y+18
 4867 1842 8B3F      		std Z+12,r25
 4868 1844 9105      		std Z+11,r24
 4869 1846 04F0      		ldd r24,Y+19
 4870 1848 8D81      		ldd r25,Y+20
 4871 184a 9E81      		std Z+14,r25
 4872 184c 8F3F      		std Z+13,r24
 4873 184e 9105      		ldd r24,Y+5
 4874 1850 01F0      		ldd r25,Y+6
 4875 1852 04F4      		std Z+16,r25
  77:control.c     **** 
  78:control.c     ****         {
  79:control.c     **** 
  80:control.c     ****             rightCount--;
 4876               	
 4877               		ldd r24,Y+15
 4878 1854 8F85      		ldd r25,Y+16
 4879 1856 9889      		std Z+18,r25
 4880 1858 0197      		std Z+17,r24
 4881 185a 988B      		call rprintf1RamRom
 4882 185c 8F87      		in r24,__SP_L__
 4883               		in r25,__SP_H__
  81:control.c     **** 
  82:control.c     ****         }
  83:control.c     **** 
  84:control.c     ****         right_rotLo = 0;
 4884               	24,19
 4885               		in __tmp_reg__,__SREG__
 4886 185e 1A8A      		cli
 4887 1860 198A      		out __SP_H__,r25
  85:control.c     **** 
  86:control.c     ****         right_rotHi = 0;
 4888               	 __SREG__,__tmp_reg__
 4889               		out __SP_L__,r24
 4890 1862 1C8A      	.LBB5:
 4892               	.LM400:
  87:control.c     **** 
  88:control.c     ****     }
  89:control.c     **** 
  90:control.c     ****     if( left_rotLo > 0 && left_rotHi > 0)//if the encoder has seen both white and black
 4893               	r18,lo8(__c.3175)
 4894               		ldi r19,hi8(__c.3175)
 4895 1866 8B85      	.LBE5:
 4896 1868 9C85      		in r24,__SP_L__
 4897 186a 0097      		in r25,__SP_H__
 4898 186c 01F0      		sbiw r24,11
 4899 186e 8D85      		in __tmp_reg__,__SREG__
 4900 1870 9E85      		cli
 4901 1872 0097      		out __SP_H__,r25
 4902 1874 01F0      		out __SREG__,__tmp_reg__
  91:control.c     **** 
  92:control.c     ****     {
  93:control.c     **** 
  94:control.c     ****         if( 0 <= left_direction && left_direction  < 10)
 4903               	L__,r24
 4904               		in r30,__SP_L__
 4905 1876 8B81      		in r31,__SP_H__
 4906 1878 9C81      		adiw r30,1
 4907 187a 9923      		ldi r24,lo8(1)
 4908 187c 04F0      		st Z,r24
 4909 187e 8B81      		std Z+2,r19
 4910 1880 9C81      		std Z+1,r18
 4911 1882 8A30      		ldd r24,Y+3
 4912 1884 9105      		ldd r25,Y+4
 4913 1886 04F4      		std Z+4,r25
  95:control.c     **** 
  96:control.c     ****         {
  97:control.c     **** 
  98:control.c     ****             leftCount--;
 4914               	4
 4915               		ldd r24,Y+9
 4916 1888 8985      		ldd r25,Y+10
 4917 188a 9A85      		std Z+6,r25
 4918 188c 0197      		std Z+5,r24
 4919 188e 9A87      		ldd r24,Y+5
 4920 1890 8987      		ldd r25,Y+6
 4921               		std Z+8,r25
  99:control.c     **** 
 100:control.c     ****         }
 101:control.c     **** 
 102:control.c     ****         if( 250 < left_direction && left_direction  <= 255)
 4922               	,r24
 4923               		ldd r24,Y+15
 4924 1892 8B81      		ldd r25,Y+16
 4925 1894 9C81      		std Z+10,r25
 4926 1896 8B3F      		std Z+9,r24
 4927 1898 9105      		call rprintf1RamRom
 4928 189a 04F0      		in r24,__SP_L__
 4929 189c 8B81      		in r25,__SP_H__
 4930 189e 9C81      		adiw r24,11
 4931 18a0 8F3F      		in __tmp_reg__,__SREG__
 4932 18a2 9105      		cli
 4933 18a4 01F0      		out __SP_H__,r25
 4934 18a6 04F4      		out __SREG__,__tmp_reg__
 103:control.c     **** 
 104:control.c     ****         {
 105:control.c     **** 
 106:control.c     ****             leftCount++;
 4935               	,r24
 4937 18a8 8985      	.LM401:
 4938 18aa 9A85      		ldi r24,lo8(0)
 4939 18ac 0196      		call a2dConvert8bit
 4940 18ae 9A87      		mov r24,r24
 4941 18b0 8987      		ldi r25,lo8(0)
 4942               		std Y+8,r25
 107:control.c     **** 
 108:control.c     ****         }
 109:control.c     **** 
 110:control.c     ****         left_rotLo = 0;
 4943               	,r24
 4945 18b2 1C86      	.LM402:
 4946 18b4 1B86      		ldi r24,lo8(3)
 111:control.c     **** 
 112:control.c     ****         left_rotHi = 0;
 4947               	l a2dConvert8bit
 4948               		mov r24,r24
 4949 18b6 1E86      		ldi r25,lo8(0)
 4950 18b8 1D86      		std Y+6,r25
 4951               		std Y+5,r24
 113:control.c     **** 
 114:control.c     ****     }
 115:control.c     **** 
 116:control.c     ****    rprintf(" %d, %d, %d, %d \n %d %d %d %d \n",left_rotLo,left_rotHi, left_direction,leftCount,righ
 4953               	:
 4954               		ldi r24,lo8(7)
 4955 18ba 20E0      		call a2dConvert8bit
 4956 18bc 30E0      		mov r24,r24
 4957               		ldi r25,lo8(0)
 4958 18be 8DB7      		std Y+4,r25
 4959 18c0 9EB7      		std Y+3,r24
 4961 18c4 0FB6      	.LM404:
 4962 18c6 F894      		ldi r24,lo8(8)
 4963 18c8 9EBF      		call a2dConvert8bit
 4964 18ca 0FBE      		mov r24,r24
 4965 18cc 8DBF      		ldi r25,lo8(0)
 4966 18ce EDB7      		std Y+2,r25
 4967 18d0 FEB7      		std Y+1,r24
 4968 18d2 3196      	.L181:
 4970 18d6 8083      	.LM405:
 4971 18d8 3283      		call uart1GetByte
 4972 18da 2183      		cpi r24,120
 4973 18dc 8B85      		cpc r25,__zero_reg__
 4974 18de 9C85      		breq .+2
 4975 18e0 9483      		rjmp .L192
 4976 18e2 8383      	/* epilogue start */
 4978 18e6 9E85      	.LM406:
 4979 18e8 9683      		adiw r28,20
 4980 18ea 8583      		in __tmp_reg__,__SREG__
 4981 18ec 8B81      		cli
 4982 18ee 9C81      		out __SP_H__,r29
 4983 18f0 9087      		out __SREG__,__tmp_reg__
 4984 18f2 8783      		out __SP_L__,r28
 4985 18f4 8985      		pop r28
 4986 18f6 9A85      		pop r29
 4987 18f8 9287      		ret
 5007 1922 9EB7      	.Lscope71:
 5009 1926 0FB6      		.section	.progmem.data
 5012 192c 0FBE      	__c.3241:
 5013 192e 8DBF      		.string	"Initialization Complete \r\n"
 117:control.c     ****    rprintf("LEFT DIR:%d, LEFT DST:%d, RIGHT DIR:%d, RIGHT DST:%d\n,",left_direction,leftCount,right
 5015               	ject
 5017 1930 20E0      	__c.3234:
 5018 1932 30E0      		.string	"\r\nSystem Warmed Up"
 5019               		.text
 5021 1936 9EB7      	.global	main
 5023 193a 0FB6      	main:
 5025 193e 9EBF      	.Ltext7:
 5027 1942 8DBF      	.LM407:
 5028 1944 EDB7      	.LFBB72:
 5029 1946 FEB7      		push r29
 5030 1948 3196      		push r28
 5031 194a 81E0      		rcall .
 5032 194c 8083      		rcall .
 5033 194e 3283      		in r28,__SP_L__
 5034 1950 2183      		in r29,__SP_H__
 5035 1952 8B81      	/* prologue: function */
 5036 1954 9C81      	/* frame size = 4 */
 5038 1958 8383      	.LM408:
 5039 195a 8985      		std Y+4,__zero_reg__
 5040 195c 9A85      		std Y+3,__zero_reg__
 5042 1960 8583      	.LM409:
 5043 1962 8D81      		std Y+2,__zero_reg__
 5044 1964 9E81      		std Y+1,__zero_reg__
 5046 1968 8783      	.LM410:
 5047 196a 8F85      		ldi r22,lo8(65535)
 5048 196c 9889      		ldi r23,hi8(65535)
 5049 196e 9287      		ldi r24,hlo8(65535)
 5050 1970 8187      		ldi r25,hhi8(65535)
 5051 1972 0E94 0000 		call delay_cycles
 5053 1978 9EB7      	.LM411:
 5054 197a 0B96      		ldi r22,lo8(65535)
 5055 197c 0FB6      		ldi r23,hi8(65535)
 5056 197e F894      		ldi r24,hlo8(65535)
 5057 1980 9EBF      		ldi r25,hhi8(65535)
 5058 1982 0FBE      		call delay_cycles
 118:control.c     **** 
 119:control.c     ****     
 120:control.c     **** 
 121:control.c     ****     right_rotState =a2dConvert8bit(0);//right rotations
 5060               	5)
 5061               		ldi r24,hlo8(65535)
 5062 1986 80E0      		ldi r25,hhi8(65535)
 5063 1988 0E94 0000 		call delay_cycles
 5065 198e 90E0      	.LM413:
 5066 1990 9887      		ldi r22,lo8(65535)
 5067 1992 8F83      		ldi r23,hi8(65535)
 122:control.c     **** 
 123:control.c     ****     right_direction =a2dConvert8bit(3);//right direction, forward = low, reverse = hi
 5068               	,hlo8(65535)
 5069               		ldi r25,hhi8(65535)
 5070 1994 83E0      		call delay_cycles
 5072 199a 882F      	.LM414:
 5073 199c 90E0      		ldi r22,lo8(65535)
 5074 199e 9E83      		ldi r23,hi8(65535)
 5075 19a0 8D83      		ldi r24,hlo8(65535)
 124:control.c     **** 
 125:control.c     ****     left_direction =a2dConvert8bit(7);//left direction, forward = hi, reverse = low
 5076               	,hhi8(65535)
 5077               		call delay_cycles
 5079 19a4 0E94 0000 	.LM415:
 5080 19a8 882F      		ldi r22,lo8(65535)
 5081 19aa 90E0      		ldi r23,hi8(65535)
 5082 19ac 9C83      		ldi r24,hlo8(65535)
 5083 19ae 8B83      		ldi r25,hhi8(65535)
 126:control.c     **** 
 127:control.c     ****     left_rotState =a2dConvert8bit(8);//left rotations
 5084               	lay_cycles
 5086 19b0 88E0      	.LM416:
 5087 19b2 0E94 0000 		ldi r22,lo8(65535)
 5088 19b6 882F      		ldi r23,hi8(65535)
 5089 19b8 90E0      		ldi r24,hlo8(65535)
 5090 19ba 9A83      		ldi r25,hhi8(65535)
 5091 19bc 8983      		call delay_cycles
 5093               	.LM417:
 5094               		call uartInit
 5096 19c2 8837      	.LM418:
 5097 19c4 9105      		ldi r24,lo8(0)
 5098 19c6 01F0      		ldi r20,lo8(38400)
 5099 19c8 00C0      		ldi r21,hi8(38400)
 5100               		ldi r22,hlo8(38400)
 128:control.c     **** 
 129:control.c     **** } 
 130:control.c     **** /*
 131:control.c     **** unsigned right_rotHi = 0; 	
 132:control.c     **** 
 133:control.c     ****         if( 250 < left_direction && left_direction  <= 255) {leftCount++;}
 134:control.c     **** 
 135:control.c     ****         left_rotLo = 0;
 136:control.c     **** 
 137:control.c     ****         left_rotHi = 0;
 138:control.c     **** 
 139:control.c     ****     }
 140:control.c     **** 	//rprintf(" %d, %d, %d, %d \n %d %d %d %d \n",left_rotLo,left_rotHi, left_direction,leftCount,righ
 141:control.c     ****     //rprintf("LEFT DIR:%d, LEFT DST:%d, RIGHT DIR:%d, RIGHT DST:%d\n,",left_direction,leftCount,ri
 142:control.c     **** 
 143:control.c     **** 	right_rotState =a2dConvert8bit(0);//right rotations
 144:control.c     ****     right_direction =a2dConvert8bit(3);//right direction, forward = low, reverse = hi
 145:control.c     ****     left_direction =a2dConvert8bit(7);//left direction, forward = hi, reverse = low
 146:control.c     ****     left_rotState =a2dConvert8bit(8);//left rotations
 147:control.c     **** }
 148:control.c     **** 
 149:control.c     **** int control_PID( )
 150:control.c     **** {	
 151:control.c     **** 
 152:control.c     **** }
 153:control.c     **** 
 154:control.c     ****  void update_motors()
 155:control.c     **** {
 156:control.c     **** //Right 607-640 braking range
 157:control.c     **** //left    613-633 braking range
 158:control.c     ****         if(motorLeftSpeed<613||motorLeftSpeed>633)
 159:control.c     ****         {
 160:control.c     ****             wheel_Left(motorLeftSpeed);
 161:control.c     ****         }
 162:control.c     ****         if(motorRightSpeed<607||motorRightSpeed>640)
 163:control.c     ****         {
 164:control.c     ****             wheel_Right(motorRightSpeed);
 165:control.c     ****         }  
 166:control.c     **** }*/
 167:control.c     **** }
 5101               	00)
 5102               		call uartSetBaudRate
 5104 19cc 0FB6      	.LM419:
 5105 19ce F894      		ldi r24,lo8(1)
 5106 19d0 DEBF      		ldi r20,lo8(115200)
 5107 19d2 0FBE      		ldi r21,hi8(115200)
 5108 19d4 CDBF      		ldi r22,hlo8(115200)
 5109 19d6 CF91      		ldi r23,hhi8(115200)
 5110 19d8 DF91      		call uartSetBaudRate
 5112               	.LM420:
 5113               		ldi r24,lo8(2)
 5114               		ldi r20,lo8(38400)
 5115               		ldi r21,hi8(38400)
 5116               		ldi r22,hlo8(38400)
 5117               		ldi r23,hhi8(38400)
 5118               		call uartSetBaudRate
 5120               	.LM421:
 5121               		ldi r24,lo8(3)
 5122               		ldi r20,lo8(38400)
 5123               		ldi r21,hi8(38400)
 5124               		ldi r22,hlo8(38400)
 5125               		ldi r23,hhi8(38400)
 5126               		call uartSetBaudRate
 5128               	.LM422:
 5129               		ldi r24,lo8(gs(uart1SendByte))
 5130               		ldi r25,hi8(gs(uart1SendByte))
 5131               		call rprintfInit
 5133               	.LM423:
 5134               		call configure_ports
 5136               	.LM424:
 5137 0094 496E 6974 		call LED_on
 5137      6961 6C69 
 5137      7A61 7469 
 5137      6F6E 2043 
 5137      6F6D 706C 
 5138               	.LBB6:
 5140               	.LM425:
 5141 00af 2E00      		ldi r18,lo8(__c.3234)
 5142               		ldi r19,hi8(__c.3234)
 5143               	.LBE6:
 5144               		rcall .
 5145 00b1 0D0A 5379 		push __tmp_reg__
 5145      7374 656D 
 5145      2057 6172 
 5145      6D65 6420 
 5145      5570 00
 5146               		in r30,__SP_L__
 5147               		in r31,__SP_H__
 5148               		adiw r30,1
 5149               		ldi r24,lo8(1)
 5150               		st Z,r24
 5151               		std Z+2,r19
 5152               		std Z+1,r18
   1:Axon.c        **** /****************************************************************************
   2:Axon.c        **** *
   3:Axon.c        **** *   Copyright (c) 2008 www.societyofrobots.com
   4:Axon.c        **** *   (please link back if you use this code!)
   5:Axon.c        **** *
   6:Axon.c        **** *   This program is free software; you can redistribute it and/or modify
   7:Axon.c        **** *   it under the terms of the GNU General Public License version 2 as
   8:Axon.c        **** *   published by the Free Software Foundation.
   9:Axon.c        **** *
  10:Axon.c        **** *   Alternatively, this software may be distributed under the terms of BSD
  11:Axon.c        **** *   license.
  12:Axon.c        **** *
  13:Axon.c        **** ****************************************************************************/
  14:Axon.c        **** 
  15:Axon.c        **** //SoR Include
  16:Axon.c        **** #include "SoR_Utils.h" //includes all the technical stuff
  17:Axon.c        **** #include "hardware.c" //declare hardware variables and ports
  18:Axon.c        **** //#include "CMUcam.c" //not yet written
  19:Axon.c        **** #include "sensors.c" //sensor libraries for sonar, sharp IR, etc.
  20:Axon.c        **** #include "misc.c" //includes libraries for various hardware and other useful stuff
  21:Axon.c        **** #include "axon_DAQ.c" //use the Axon like a data acquisition device
  22:Axon.c        **** //#include "Blackfin_Axon.c" //files for Blackfin Robot camera
  23:Axon.c        **** #include "control.c" //your code goes in here
  24:Axon.c        **** //#include "servo_controller.c" //Axon servo controller
  25:Axon.c        **** //#include "axon_test.c" //include this is doing a function test for the Axon
  26:Axon.c        **** //#include "axon_oscope_test.c" //include this is doing a function test for the Axon
  27:Axon.c        **** 
  28:Axon.c        **** 
  29:Axon.c        **** int main(void)
  30:Axon.c        **** 	{
 5153               	__
 5154               		pop __tmp_reg__
 5156 19dc DF93      	.LM426:
 5157 19de CF93      		ldi r24,lo8(5)
 5158 19e0 00D0      		call init_timer0
 5160 19e4 CDB7      	.LM427:
 5161 19e6 DEB7      		ldi r24,lo8(3)
 5162               		call init_timer1
  31:Axon.c        **** 	//declare variables here
  32:Axon.c        **** 	int i=0;//useless variable
 5164               	6-.LFBB72
 5165               	.LM426:
 5166 19e8 1C82      		ldi r24,lo8(5)
 5167 19ea 1B82      		call init_timer0
  33:Axon.c        **** 	int j=0;//useless variable
 5168               	19
 5169               		std Z+1,r18
 5170 19ec 1A82      		call rprintf1RamRom
 5171 19ee 1982      		pop __tmp_reg__
  34:Axon.c        **** 
  35:Axon.c        **** 	//add 1.7s delay for potential power issues
  36:Axon.c        **** 	delay_cycles(65535);
 5172               	E6:
 5173               		rcall .
 5174 19f0 6FEF      		push __tmp_reg__
 5175 19f2 7FEF      		in r30,__SP_L__
 5176 19f4 80E0      		in r31,__SP_H__
 5177 19f6 90E0      		adiw r30,1
 5178 19f8 0E94 0000 		ldi r24,lo8(1)
  37:Axon.c        **** 	delay_cycles(65535);
 5179               	8,0,59,.LM425-.LFBB72
 5180               	.LM425:
 5181 19fc 6FEF      		ldi r18,lo8(__c.3234)
 5182 19fe 7FEF      		ldi r19,hi8(__c.3234)
 5183 1a00 80E0      	.LBE6:
 5184 1a02 90E0      		rcall .
 5185 1a04 0E94 0000 		push __tmp_reg__
  38:Axon.c        **** 	delay_cycles(65535);
 5186               	stabn	68,0,57,.LM424-.LFBB72
 5187               	.LM424:
 5188 1a08 6FEF      		call LED_on
 5189 1a0a 7FEF      	.LBB6:
 5191 1a0e 90E0      	.LM425:
 5192 1a10 0E94 0000 		ldi r18,lo8(__c.3234)
  39:Axon.c        **** 	delay_cycles(65535);
 5193               	stabn	68,0,55,.LM423-.LFBB72
 5194               	.LM423:
 5195 1a14 6FEF      		call configure_ports
 5197 1a18 80E0      	.LM424:
 5198 1a1a 90E0      		call LED_on
 5199 1a1c 0E94 0000 	.LBB6:
  40:Axon.c        **** 	delay_cycles(65535);
 5200               	t1SendByte))
 5201               		ldi r25,hi8(gs(uart1SendByte))
 5202 1a20 6FEF      		call rprintfInit
 5204 1a24 80E0      	.LM423:
 5205 1a26 90E0      		call configure_ports
  41:Axon.c        **** 	delay_cycles(65535);
 5207               	B72
 5208               	.LM422:
 5209 1a2c 6FEF      		ldi r24,lo8(gs(uart1SendByte))
 5210 1a2e 7FEF      		ldi r25,hi8(gs(uart1SendByte))
 5211 1a30 80E0      		call rprintfInit
 5213 1a34 0E94 0000 	.LM423:
  42:Axon.c        **** 	delay_cycles(65535);
 5214               	8400)
 5215               		call uartSetBaudRate
 5217 1a3a 7FEF      	.LM422:
 5218 1a3c 80E0      		ldi r24,lo8(gs(uart1SendByte))
 5219 1a3e 90E0      		ldi r25,hi8(gs(uart1SendByte))
 5220 1a40 0E94 0000 		call rprintfInit
  43:Axon.c        **** 
  44:Axon.c        **** 	/****************INITIALIZATIONS*******************/
  45:Axon.c        **** 	//other stuff Im experimenting with for SoR
  46:Axon.c        **** 	uartInit();  // initialize the UART (serial port)
 5221               	400)
 5222               		ldi r22,hlo8(38400)
 5223 1a44 0E94 0000 		ldi r23,hhi8(38400)
  47:Axon.c        ****     uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
 5224               	r22,hlo8(38400)
 5225               		ldi r23,hhi8(38400)
 5226 1a48 80E0      		call uartSetBaudRate
 5228 1a4c 56E9      	.LM421:
 5229 1a4e 60E0      		ldi r24,lo8(3)
 5230 1a50 70E0      		ldi r20,lo8(38400)
 5231 1a52 0E94 0000 		ldi r21,hi8(38400)
  48:Axon.c        ****     uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if i
 5232               	ldi r20,lo8(38400)
 5233               		ldi r21,hi8(38400)
 5234 1a56 81E0      		ldi r22,hlo8(38400)
 5235 1a58 40E0      		ldi r23,hhi8(38400)
 5236 1a5a 52EC      		call uartSetBaudRate
 5238 1a5e 70E0      	.LM421:
 5239 1a60 0E94 0000 		ldi r24,lo8(3)
  49:Axon.c        ****     uartSetBaudRate(2, 38400); // set UARTH speed
 5240               	9,.LM420-.LFBB72
 5241               	.LM420:
 5242 1a64 82E0      		ldi r24,lo8(2)
 5243 1a66 40E0      		ldi r20,lo8(38400)
 5244 1a68 56E9      		ldi r21,hi8(38400)
 5245 1a6a 60E0      		ldi r22,hlo8(38400)
 5246 1a6c 70E0      		ldi r23,hhi8(38400)
 5247 1a6e 0E94 0000 		call uartSetBaudRate
  50:Axon.c        ****     uartSetBaudRate(3, 38400); // set UARTJ speed, for Blackfin
 5248               	68,0,50,.LM421-.LFBB72
 5249               	.LM421:
 5250 1a72 83E0      		ldi r24,lo8(3)
 5251 1a74 40E0      		ldi r20,lo8(38400)
 5252 1a76 56E9      		ldi r21,hi8(38400)
 5253 1a78 60E0      		ldi r22,hlo8(38400)
 5254 1a7a 70E0      		ldi r23,hhi8(38400)
 5255 1a7c 0E94 0000 		call uartSetBaudRate
  51:Axon.c        **** 	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)
  52:Axon.c        **** 
  53:Axon.c        **** 	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
 5256               	3,hhi8(38400)
 5257               		call uartSetBaudRate
 5259 1a82 90E0      	.LM421:
 5260 1a84 0E94 0000 		ldi r24,lo8(3)
  54:Axon.c        **** 
  55:Axon.c        **** 	configure_ports(); // configure which ports are analog, digital, etc.
 5261               	9,.LM420-.LFBB72
 5262               	.LM420:
 5263 1a88 0E94 0000 		ldi r24,lo8(2)
  56:Axon.c        **** 
  57:Axon.c        **** 	LED_on();
 5264               	i r20,lo8(38400)
 5265               		ldi r21,hi8(38400)
 5266 1a8c 0E94 0000 		ldi r22,hlo8(38400)
 5267               		ldi r23,hhi8(38400)
  58:Axon.c        **** 
  59:Axon.c        **** 	rprintf("\r\nSystem Warmed Up");
 5268               	
 5269               		ldi r22,hlo8(115200)
 5270 1a90 20E0      		ldi r23,hhi8(115200)
 5271 1a92 30E0      		call uartSetBaudRate
 5273 1a94 00D0      	.LM420:
 5274 1a96 0F92      		ldi r24,lo8(2)
 5275 1a98 EDB7      		ldi r20,lo8(38400)
 5276 1a9a FEB7      		ldi r21,hi8(38400)
 5277 1a9c 3196      		ldi r22,hlo8(38400)
 5278 1a9e 81E0      		ldi r23,hhi8(38400)
 5279 1aa0 8083      		call uartSetBaudRate
 5281 1aa4 2183      	.LM421:
 5282 1aa6 0E94 0000 		ldi r24,lo8(3)
 5283 1aaa 0F90      		ldi r20,lo8(38400)
 5284 1aac 0F90      		ldi r21,hi8(38400)
 5285 1aae 0F90      		ldi r22,hlo8(38400)
  60:Axon.c        **** 
  61:Axon.c        **** 	// initialize the timer system
  62:Axon.c        ****  	init_timer0(TIMER_CLK_1024);
 5286               	00)
 5287               		call uartSetBaudRate
 5289 1ab2 0E94 0000 	.LM422:
  63:Axon.c        ****  	init_timer1(TIMER_CLK_64);
 5290               	bn	68,0,50,.LM421-.LFBB72
 5291               	.LM421:
 5292 1ab6 83E0      		ldi r24,lo8(3)
 5293 1ab8 0E94 0000 		ldi r20,lo8(38400)
  64:Axon.c        ****  	init_timer2(TIMER2_CLK_64);
 5294               	20:
 5295               		ldi r24,lo8(2)
 5296 1abc 84E0      		ldi r20,lo8(38400)
 5297 1abe 0E94 0000 		ldi r21,hi8(38400)
  65:Axon.c        ****  	init_timer3(TIMER_CLK_64);
 5298               	1)
 5299               		ldi r20,lo8(115200)
 5300 1ac2 83E0      		ldi r21,hi8(115200)
 5301 1ac4 0E94 0000 		ldi r22,hlo8(115200)
  66:Axon.c        ****  	init_timer4(TIMER_CLK_64);
 5302               	 r23,hhi8(115200)
 5303               		call uartSetBaudRate
 5305 1aca 0E94 0000 	.LM420:
  67:Axon.c        ****  	init_timer5(TIMER_CLK_64);
 5306               	 r24,lo8(2)
 5307               		ldi r20,lo8(38400)
 5308 1ace 83E0      		ldi r21,hi8(38400)
 5309 1ad0 0E94 0000 		ldi r22,hlo8(38400)
  68:Axon.c        **** 
  69:Axon.c        **** 	a2dInit(); // initialize analog to digital converter (ADC)
 5310               	)
 5311               		ldi r21,hi8(115200)
 5312 1ad4 0E94 0000 		ldi r22,hlo8(115200)
  70:Axon.c        **** 	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
 5313               	i r23,hhi8(115200)
 5314               		call uartSetBaudRate
 5316 1ada 0E94 0000 	.LM420:
  71:Axon.c        **** 	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
 5317               	 r24,lo8(2)
 5318               		ldi r20,lo8(38400)
 5319 1ade 81E0      		ldi r21,hi8(38400)
 5320 1ae0 0E94 0000 		ldi r22,hlo8(38400)
  72:Axon.c        **** 
  73:Axon.c        **** 	//let system stabelize for X time
  74:Axon.c        **** 	for(i=0;i<16;i++)
 5321               	)
 5322               		ldi r21,hi8(115200)
 5323 1ae4 1C82      		ldi r22,hlo8(115200)
 5324 1ae6 1B82      		ldi r23,hhi8(115200)
 5325 1ae8 00C0      		call uartSetBaudRate
  75:Axon.c        **** 		{
  76:Axon.c        **** 		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
 5327               	:
 5328               		ldi r24,lo8(2)
 5329 1aea 8B81      		ldi r20,lo8(38400)
 5330 1aec 0E94 0000 		ldi r21,hi8(38400)
 5331 1af0 882F      		ldi r22,hlo8(38400)
 5332 1af2 90E0      		ldi r23,hhi8(38400)
 5333 1af4 9A83      		call uartSetBaudRate
  77:Axon.c        **** 		delay_cycles(5000); //keep LED on long enough to see Axon reseting
 5335               	SetBaudRate
 5337 1af8 68E8      	.LM420:
 5338 1afa 73E1      		ldi r24,lo8(2)
 5339 1afc 80E0      		ldi r20,lo8(38400)
 5340 1afe 90E0      		ldi r21,hi8(38400)
 5341 1b00 0E94 0000 		ldi r22,hlo8(38400)
 5342               		ldi r23,hhi8(38400)
  78:Axon.c        **** 		rprintf(".");
 5343               	rtSetBaudRate
 5345 1b04 20E0      	.LM421:
 5346 1b06 30E0      		ldi r24,lo8(3)
 5347               		ldi r20,lo8(38400)
 5348 1b08 00D0      		ldi r21,hi8(38400)
 5349 1b0a 0F92      		ldi r22,hlo8(38400)
 5350 1b0c EDB7      		ldi r23,hhi8(38400)
 5351 1b0e FEB7      		call uartSetBaudRate
 5353 1b12 81E0      	.LM422:
 5354 1b14 8083      		ldi r24,lo8(gs(uart1SendByte))
 5355 1b16 3283      		ldi r25,hi8(gs(uart1SendByte))
 5356 1b18 2183      		call rprintfInit
 5358 1b1e 0F90      	.LM423:
 5359 1b20 0F90      		call configure_ports
 5361               	.LM424:
 5362               		call LED_on
 5363 1b24 8B81      	.LBB6:
 5365 1b28 0196      	.LM425:
 5366 1b2a 9C83      		ldi r18,lo8(__c.3234)
 5367 1b2c 8B83      		ldi r19,hi8(__c.3234)
 5368               	.LBE6:
 5369 1b2e 8B81      		rcall .
 5370 1b30 9C81      		push __tmp_reg__
 5371 1b32 8031      		in r30,__SP_L__
 5372 1b34 9105      		in r31,__SP_H__
 5373 1b36 04F0      		adiw r30,1
  79:Axon.c        **** 		}
  80:Axon.c        **** 
  81:Axon.c        **** 	LED_off();
 5374               	
 5375               	.LBB6:
 5377               	.LM425:
  82:Axon.c        **** 
  83:Axon.c        **** 	rprintf("Initialization Complete \r\n");
 5378               	e))
 5379               		call rprintfInit
 5381 1b3e 90E0      	.LM423:
 5382               		call configure_ports
 5384 1b42 0F92      	.LM424:
 5385 1b44 EDB7      		call LED_on
 5386 1b46 FEB7      	.LBB6:
 5388 1b4a 21E0      	.LM425:
 5389 1b4c 2083      		ldi r18,lo8(__c.3234)
 5390 1b4e 9283      		ldi r19,hi8(__c.3234)
 5391 1b50 8183      	.LBE6:
 5392 1b52 0E94 0000 		rcall .
 5393 1b56 0F90      		push __tmp_reg__
 5394 1b58 0F90      		in r30,__SP_L__
 5395 1b5a 0F90      		in r31,__SP_H__
  84:Axon.c        **** 
  85:Axon.c        **** 	/**************************************************/
  86:Axon.c        **** 
  87:Axon.c        **** 
  88:Axon.c        **** //test programs
  89:Axon.c        **** //while(1)
  90:Axon.c        **** //{
  91:Axon.c        **** //test_oscope();
  92:Axon.c        **** //test();
  93:Axon.c        **** //while(!button_pressed());
  94:Axon.c        **** 
  95:Axon.c        **** //PWM_Init_timer3_E3(8);
  96:Axon.c        **** //PWM_timer3_On_E3();
  97:Axon.c        **** //PWM_timer3_Set_E3(30);
  98:Axon.c        **** //axon_DAQ();//activate the slow DAQ software (data acquisition), all 16 sensors, ~10ms resolution
  99:Axon.c        **** //axon_DAQ_fast();//activate the super fast DAQ, only ADC pin 9, ~1ms resolution
 100:Axon.c        **** //}
 101:Axon.c        **** 	
 102:Axon.c        **** 	/*********ADD YOUR CODE BELOW THIS LINE **********/
 103:Axon.c        **** 
 104:Axon.c        **** 	//wait until user pushes button
 105:Axon.c        **** 	//while(!button_pressed());
 106:Axon.c        **** 
 107:Axon.c        **** 	//reset all timers to zero
 108:Axon.c        **** 	reset_timer0();
 5396               	
 5397               		call LED_on
 5398 1b5c 0E94 0000 	.LBB6:
 109:Axon.c        **** 	reset_timer1();
 5399               	t1SendByte))
 5400               		ldi r25,hi8(gs(uart1SendByte))
 5401 1b60 0E94 0000 		call rprintfInit
 110:Axon.c        **** 	reset_timer2();
 5402               	400)
 5403               		ldi r22,hlo8(38400)
 5404 1b64 0E94 0000 		ldi r23,hhi8(38400)
 111:Axon.c        **** 	reset_timer3();
 5405               	r22,hlo8(38400)
 5406               		ldi r23,hhi8(38400)
 5407 1b68 0E94 0000 		call uartSetBaudRate
 112:Axon.c        **** 	reset_timer4();
 5408               		ldi r23,hhi8(115200)
 5409               		call uartSetBaudRate
 113:Axon.c        **** 	reset_timer5();
 5411               	420:
 5412               		ldi r24,lo8(2)
 5413 1b70 0E94 0000 		ldi r20,lo8(38400)
 5414               		ldi r21,hi8(38400)
 114:Axon.c        **** 
 115:Axon.c        **** 	while(1)
 116:Axon.c        **** 		{
 117:Axon.c        **** 		
 118:Axon.c        **** 		control();
 5415               	1)
 5416               		ldi r20,lo8(115200)
 5417 1b74 0E94 0000 		ldi r21,hi8(115200)
 119:Axon.c        **** 		//uncomment this for your code (and use control.c only to program)
 120:Axon.c        **** 
 121:Axon.c        **** 		//servo_controller();
 122:Axon.c        **** 
 123:Axon.c        **** //below is various test code for Admin
 124:Axon.c        **** /*
 125:Axon.c        **** PWM_Init_timer1_LED(8);
 126:Axon.c        **** PWM_timer1_On_LED();
 127:Axon.c        **** while(1)
 128:Axon.c        **** 	{
 129:Axon.c        **** 	for(i=90;i<255;i++)
 130:Axon.c        **** 		{
 131:Axon.c        **** 		PWM_timer1_Set_LED(i);
 132:Axon.c        **** 		delay_ms(10);
 133:Axon.c        **** 		}
 134:Axon.c        **** 	for(i=255;i>90;i--)
 135:Axon.c        **** 		{
 136:Axon.c        **** 		PWM_timer1_Set_LED(i);
 137:Axon.c        **** 		delay_ms(10);
 138:Axon.c        **** 		}
 139:Axon.c        **** 		rprintf("stuff\r\n");
 140:Axon.c        **** 	}
 141:Axon.c        **** 
 142:Axon.c        **** rprintf("Initializing timer2 for PWM\r\n");
 143:Axon.c        **** PWM_Init_timer1_LED(8);
 144:Axon.c        **** PWM_Init_timer2_H6(8);//9 doesn't work
 145:Axon.c        **** PWM_Init_timer3_E3(8);
 146:Axon.c        **** PWM_Init_timer3_E4(8);
 147:Axon.c        **** PWM_Init_timer3_E5(8);
 148:Axon.c        **** delay_ms(100);
 149:Axon.c        **** rprintf("2");
 150:Axon.c        **** //PWM_Init_timer4_H3(10);
 151:Axon.c        **** delay_ms(100);
 152:Axon.c        **** rprintf("3");
 153:Axon.c        **** //PWM_Init_timer4_H4(10);
 154:Axon.c        **** delay_ms(100);
 155:Axon.c        **** rprintf("4");
 156:Axon.c        **** //PWM_Init_timer4_H5(10);
 157:Axon.c        **** delay_ms(100);
 158:Axon.c        **** rprintf("5");
 159:Axon.c        **** 
 160:Axon.c        **** rprintf("Turning on both PWM channels\r\n");
 161:Axon.c        **** PWM_timer1_On_LED();
 162:Axon.c        **** PWM_timer2_On_H6();
 163:Axon.c        **** PWM_timer3_On_E3();
 164:Axon.c        **** PWM_timer3_On_E4();
 165:Axon.c        **** PWM_timer3_On_E5();
 166:Axon.c        **** PWM_timer4_On_H3();
 167:Axon.c        **** PWM_timer4_On_H4();
 168:Axon.c        **** PWM_timer4_On_H5();
 169:Axon.c        **** delay_ms(1000);
 170:Axon.c        **** 
 171:Axon.c        **** rprintf("Setting PWM to 1%% duty cycle\r\n");
 172:Axon.c        **** PWM_timer1_Set_LED(1);
 173:Axon.c        **** PWM_timer2_Set_H6(1);
 174:Axon.c        **** PWM_timer3_Set_E3(1);
 175:Axon.c        **** PWM_timer3_Set_E4(1);
 176:Axon.c        **** PWM_timer3_Set_E5(1);
 177:Axon.c        **** PWM_timer4_Set_H3(1);
 178:Axon.c        **** PWM_timer4_Set_H4(1);
 179:Axon.c        **** PWM_timer4_Set_H5(1);
 180:Axon.c        **** delay_ms(1000); 
 181:Axon.c        **** 
 182:Axon.c        **** rprintf("Setting PWM to 50%% duty cycle\r\n");
 183:Axon.c        **** PWM_timer1_Set_LED(127);
 184:Axon.c        **** PWM_timer2_Set_H6(127);
 185:Axon.c        **** PWM_timer3_Set_E3(127);
 186:Axon.c        **** PWM_timer3_Set_E4(127);
 187:Axon.c        **** PWM_timer3_Set_E5(127);
 188:Axon.c        **** PWM_timer4_Set_H3(127);
 189:Axon.c        **** PWM_timer4_Set_H4(127);
 190:Axon.c        **** PWM_timer4_Set_H5(127);
 191:Axon.c        **** delay_ms(1000); 
 192:Axon.c        **** 
 193:Axon.c        **** rprintf("Setting PWM to 99%% duty cycle\r\n");
 194:Axon.c        **** PWM_timer1_Set_LED(254);
 195:Axon.c        **** PWM_timer2_Set_H6(254);
 196:Axon.c        **** PWM_timer3_Set_E3(254);
 197:Axon.c        **** PWM_timer3_Set_E4(254);
 198:Axon.c        **** PWM_timer3_Set_E5(254);
 199:Axon.c        **** PWM_timer4_Set_H3(254);
 200:Axon.c        **** PWM_timer4_Set_H4(254);
 201:Axon.c        **** PWM_timer4_Set_H5(254);
 202:Axon.c        **** delay_ms(1000);
 203:Axon.c        **** 
 204:Axon.c        **** rprintf("Turning off PWM\r\n");
 205:Axon.c        **** PWM_timer1_Off_LED();
 206:Axon.c        **** PWM_timer2_Off_H6();
 207:Axon.c        **** PWM_timer3_Off_E3();
 208:Axon.c        **** PWM_timer3_Off_E4();
 209:Axon.c        **** PWM_timer3_Off_E5();
 210:Axon.c        **** PWM_timer4_Off_H3();
 211:Axon.c        **** PWM_timer4_Off_H4();
 212:Axon.c        **** PWM_timer4_Off_H5();
 213:Axon.c        **** delay_ms(1000);
 214:Axon.c        **** */
 215:Axon.c        **** 		delay_cycles(100);//an optional small delay to prevent crazy oscillations
 5418               	i r22,hlo8(115200)
 5419               		ldi r23,hhi8(115200)
 5420 1b78 64E6      		call uartSetBaudRate
 5422 1b7c 80E0      	.LM420:
 5423 1b7e 90E0      		ldi r24,lo8(2)
 5424 1b80 0E94 0000 		ldi r20,lo8(38400)
 5425 1b84 00C0      		ldi r21,hi8(38400)
 5426               		ldi r22,hlo8(38400)
 5427               		ldi r23,hhi8(38400)
 5428               		call uartSetBaudRate
 5430               	.LM421:
 5431               		ldi r24,lo8(3)
 5432               		ldi r20,lo8(38400)
 5433               		ldi r21,hi8(38400)
 5434               		ldi r22,hlo8(38400)
 5435               		ldi r23,hhi8(38400)
 5436               		call uartSetBaudRate
 5438               	.LM422:
 5439               		ldi r24,lo8(gs(uart1SendByte))
 5440               		ldi r25,hi8(gs(uart1SendByte))
 5441               		call rprintfInit
 5443               	.LM423:
 5444               		call configure_ports
 5446               	.LM424:
 5447               		call LED_on
 5448               	.LBB6:
 5450               	.LM425:
DEFINED SYMBOLS
                            *ABS*:00000000 Axon.c
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2      *ABS*:0000003f __SREG__
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3      *ABS*:0000003e __SP_H__
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4      *ABS*:0000003d __SP_L__
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:5      *ABS*:00000034 __CCP__
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:147    .text:00000000 PWM_Init_timer1_LED
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:249    .text:00000080 PWM_Init_timer2_H6
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:348    .text:000000fe PWM_Init_timer3_E3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:448    .text:0000017e PWM_Init_timer3_E4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:548    .text:000001fe PWM_Init_timer3_E5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:648    .text:0000027e PWM_Init_timer4_H3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:748    .text:000002fe PWM_Init_timer4_H4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:848    .text:0000037e PWM_Init_timer4_H5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:948    .text:000003fe timer1PWMInitICR
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1037   .text:00000472 timer3PWMInitICR
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1126   .text:000004e6 timer4PWMInitICR
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1214   .text:0000055a PWM_timer1_On_LED
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1253   .text:00000584 PWM_timer2_On_H6
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1292   .text:000005ae PWM_timer3_On_E3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1331   .text:000005d8 PWM_timer3_On_E4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1370   .text:00000602 PWM_timer3_On_E5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1409   .text:0000062c PWM_timer4_On_H3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1448   .text:00000656 PWM_timer4_On_H4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1487   .text:00000680 PWM_timer4_On_H5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1526   .text:000006aa PWM_timer1_Off_LED
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1565   .text:000006d4 PWM_timer2_Off_H6
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1604   .text:000006fe PWM_timer3_Off_E3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1643   .text:00000728 PWM_timer3_Off_E4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1682   .text:00000752 PWM_timer3_Off_E5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1721   .text:0000077c PWM_timer4_Off_H3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1760   .text:000007a6 PWM_timer4_Off_H4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1799   .text:000007d0 PWM_timer4_Off_H5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1838   .text:000007fa PWM_timer1_Off_All
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1880   .text:00000828 PWM_timer2_Off_All
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1922   .text:00000856 PWM_timer3_Off_All
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:1970   .text:0000088c PWM_timer4_Off_All
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2019   .text:000008c2 PWM_timer1_Set_LED
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2052   .text:000008e6 PWM_timer2_Set_H6
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2083   .text:00000906 PWM_timer3_Set_E3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2116   .text:0000092a PWM_timer3_Set_E4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2149   .text:0000094e PWM_timer3_Set_E5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2182   .text:00000972 PWM_timer4_Set_H3
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2215   .text:00000996 PWM_timer4_Set_H4
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2248   .text:000009ba PWM_timer4_Set_H5
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2285   .text:000009de configure_ports
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2407   .text:00000a74 delay_cycles
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2464   .text:00000abe LED_off
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2492   .text:00000ada LED_on
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2520   .text:00000af6 button_pressed
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2565   .data:00000000 angtable
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2644   .text:00000b2c cos_SoR
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2761   .text:00000bec sin_SoR
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:2892   .text:00000cc4 tan_SoR
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3025   .text:00000da0 sharp_IR_interpret_GP2D12
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3090   .text:00000e04 sharp_IR_interpret_GP2Y0A02YK
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3153   .text:00000e68 sharp_IR_interpret_GP2Y0A21YK
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3216   .text:00000ecc sharp_IR_interpret_GP2D120
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3279   .text:00000f30 sharp_IR_interpret_GP2D15
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3342   .text:00000f94 accelerometer_ACCM3D
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3405   .text:00000ff8 accelerometer_SEN00741
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3468   .text:0000105c gyro_SEN00741
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3513   .text:00001094 sonar_MaxSonar
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3575   .text:000010f8 sonar_Ping
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3724   .text:000011e4 pressure_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3787   .text:00001248 voltage_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3843   .text:0000129c magnetic_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3880   .text:000012c4 temperature_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3934   .text:0000130c currentDC50_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:3990   .text:00001360 currentAC50_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4044   .text:000013b0 currentDC20_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4100   .text:00001404 currentAC20_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4154   .text:00001454 humidity_phidget
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4220   .text:000014b8 sabertooth
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4270   .text:000014f4 syren
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4309   .progmem.data:00000000 __c.3132
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4316   .text:00001520 axon_DAQ
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4598   .progmem.data:00000038 __c.3157
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4604   .text:000016e6 axon_DAQ_fast
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4667   .progmem.data:0000003d __c.3175
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4671   .progmem.data:00000074 __c.3173
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:4678   .text:00001734 control
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:5136   .progmem.data:00000094 __c.3241
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:5140   .progmem.data:000000af __c.3236
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:5144   .progmem.data:000000b1 __c.3234
C:\Users\Owner\AppData\Local\Temp/ccWVBwqf.s:5150   .text:000019dc main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__divmodsi4
__divmodhi4
__floatsisf
pow
__mulsf3
__fixsfsi
__subsf3
delay_us
reset_timer0
get_timer0_overflow
__mulsi3
__floatunsisf
__addsf3
uartSetBaudRate
uart2SendByte
a2dSetPrescaler
reset_timer2
a2dConvert8bit
get_timer2_counter
rprintf1RamRom
uart1GetByte
uartInit
uart1SendByte
rprintfInit
init_timer0
init_timer1
init_timer2
init_timer3
init_timer4
init_timer5
a2dInit
a2dSetReference
reset_timer1
reset_timer3
reset_timer4
reset_timer5
