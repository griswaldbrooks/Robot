
rtos323.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000019b2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  000019b2  00001a46  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000676  0080006a  0080006a  00001a50  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  00001a50  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000055c  00000000  00000000  00001b30  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001ff7  00000000  00000000  0000208c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000097f  00000000  00000000  00004083  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000190f  00000000  00000000  00004a02  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000400  00000000  00000000  00006314  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000e04  00000000  00000000  00006714  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001146  00000000  00000000  00007518  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  0000865e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 28 00 	jmp	0x50	; 0x50 <__ctors_end>
       4:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       8:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      10:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      14:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      18:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      1c:	0c 94 e0 0b 	jmp	0x17c0	; 0x17c0 <__vector_7>
      20:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      24:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      28:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      2c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      30:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      34:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      38:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      3c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      40:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      44:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      48:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      4c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>

00000050 <__ctors_end>:
      50:	11 24       	eor	r1, r1
      52:	1f be       	out	0x3f, r1	; 63
      54:	cf e5       	ldi	r28, 0x5F	; 95
      56:	d8 e0       	ldi	r29, 0x08	; 8
      58:	de bf       	out	0x3e, r29	; 62
      5a:	cd bf       	out	0x3d, r28	; 61

0000005c <__do_copy_data>:
      5c:	10 e0       	ldi	r17, 0x00	; 0
      5e:	a0 e6       	ldi	r26, 0x60	; 96
      60:	b0 e0       	ldi	r27, 0x00	; 0
      62:	e2 eb       	ldi	r30, 0xB2	; 178
      64:	f9 e1       	ldi	r31, 0x19	; 25
      66:	02 c0       	rjmp	.+4      	; 0x6c <.do_copy_data_start>

00000068 <.do_copy_data_loop>:
      68:	05 90       	lpm	r0, Z+
      6a:	0d 92       	st	X+, r0

0000006c <.do_copy_data_start>:
      6c:	aa 36       	cpi	r26, 0x6A	; 106
      6e:	b1 07       	cpc	r27, r17
      70:	d9 f7       	brne	.-10     	; 0x68 <.do_copy_data_loop>

00000072 <__do_clear_bss>:
      72:	16 e0       	ldi	r17, 0x06	; 6
      74:	aa e6       	ldi	r26, 0x6A	; 106
      76:	b0 e0       	ldi	r27, 0x00	; 0
      78:	01 c0       	rjmp	.+2      	; 0x7c <.do_clear_bss_start>

0000007a <.do_clear_bss_loop>:
      7a:	1d 92       	st	X+, r1

0000007c <.do_clear_bss_start>:
      7c:	a0 3e       	cpi	r26, 0xE0	; 224
      7e:	b1 07       	cpc	r27, r17
      80:	e1 f7       	brne	.-8      	; 0x7a <.do_clear_bss_loop>
      82:	0e 94 47 00 	call	0x8e	; 0x8e <main>
      86:	0c 94 d7 0c 	jmp	0x19ae	; 0x19ae <_exit>

0000008a <__bad_interrupt>:
      8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000008e <main>:
}



int main(void)
{
      8e:	af 92       	push	r10
      90:	bf 92       	push	r11
      92:	cf 92       	push	r12
      94:	df 92       	push	r13
      96:	ef 92       	push	r14
      98:	ff 92       	push	r15
      9a:	0f 93       	push	r16
	

	xTaskCreate(vTaskB, "B", 10, NULL, 1, NULL);
      9c:	8c e6       	ldi	r24, 0x6C	; 108
      9e:	90 e0       	ldi	r25, 0x00	; 0
      a0:	60 e6       	ldi	r22, 0x60	; 96
      a2:	70 e0       	ldi	r23, 0x00	; 0
      a4:	4a e0       	ldi	r20, 0x0A	; 10
      a6:	50 e0       	ldi	r21, 0x00	; 0
      a8:	20 e0       	ldi	r18, 0x00	; 0
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	01 e0       	ldi	r16, 0x01	; 1
      ae:	ee 24       	eor	r14, r14
      b0:	ff 24       	eor	r15, r15
      b2:	cc 24       	eor	r12, r12
      b4:	dd 24       	eor	r13, r13
      b6:	aa 24       	eor	r10, r10
      b8:	bb 24       	eor	r11, r11
      ba:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <xTaskGenericCreate>
	xTaskCreate(vTaskA, "A", 10, NULL, 1, NULL);
      be:	88 e7       	ldi	r24, 0x78	; 120
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	62 e6       	ldi	r22, 0x62	; 98
      c4:	70 e0       	ldi	r23, 0x00	; 0
      c6:	4a e0       	ldi	r20, 0x0A	; 10
      c8:	50 e0       	ldi	r21, 0x00	; 0
      ca:	20 e0       	ldi	r18, 0x00	; 0
      cc:	30 e0       	ldi	r19, 0x00	; 0
      ce:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <xTaskGenericCreate>
	vTaskStartScheduler();
      d2:	0e 94 00 0b 	call	0x1600	; 0x1600 <vTaskStartScheduler>
      d6:	ff cf       	rjmp	.-2      	; 0xd6 <main+0x48>

000000d8 <vTaskB>:
			
	}
}
void vTaskB(void *pvParameters){
	for(;;){
		j++;
      d8:	80 91 dc 06 	lds	r24, 0x06DC
      dc:	90 91 dd 06 	lds	r25, 0x06DD
      e0:	01 96       	adiw	r24, 0x01	; 1
      e2:	90 93 dd 06 	sts	0x06DD, r25
      e6:	80 93 dc 06 	sts	0x06DC, r24
		taskYIELD();
      ea:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
      ee:	f4 cf       	rjmp	.-24     	; 0xd8 <vTaskB>

000000f0 <vTaskA>:

int i, j;

void vTaskA(void *pvParameters){
	for(;;){
		i++;
      f0:	80 91 de 06 	lds	r24, 0x06DE
      f4:	90 91 df 06 	lds	r25, 0x06DF
      f8:	01 96       	adiw	r24, 0x01	; 1
      fa:	90 93 df 06 	sts	0x06DF, r25
      fe:	80 93 de 06 	sts	0x06DE, r24
		taskYIELD();
     102:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
     106:	f4 cf       	rjmp	.-24     	; 0xf0 <vTaskA>

00000108 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     108:	0f 93       	push	r16
     10a:	1f 93       	push	r17
     10c:	cf 93       	push	r28
     10e:	df 93       	push	r29
     110:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     112:	80 81       	ld	r24, Z
     114:	88 23       	and	r24, r24
     116:	19 f4       	brne	.+6      	; 0x11e <xCoRoutineRemoveFromEventList+0x16>
     118:	c0 e0       	ldi	r28, 0x00	; 0
     11a:	d0 e0       	ldi	r29, 0x00	; 0
     11c:	05 c0       	rjmp	.+10     	; 0x128 <xCoRoutineRemoveFromEventList+0x20>
     11e:	05 80       	ldd	r0, Z+5	; 0x05
     120:	f6 81       	ldd	r31, Z+6	; 0x06
     122:	e0 2d       	mov	r30, r0
     124:	c6 81       	ldd	r28, Z+6	; 0x06
     126:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     128:	8e 01       	movw	r16, r28
     12a:	04 5f       	subi	r16, 0xF4	; 244
     12c:	1f 4f       	sbci	r17, 0xFF	; 255
     12e:	c8 01       	movw	r24, r16
     130:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     134:	8b e9       	ldi	r24, 0x9B	; 155
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	b8 01       	movw	r22, r16
     13a:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	e0 91 6a 00 	lds	r30, 0x006A
     144:	f0 91 6b 00 	lds	r31, 0x006B
     148:	9e 89       	ldd	r25, Y+22	; 0x16
     14a:	86 89       	ldd	r24, Z+22	; 0x16
     14c:	98 17       	cp	r25, r24
     14e:	08 f0       	brcs	.+2      	; 0x152 <xCoRoutineRemoveFromEventList+0x4a>
     150:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     152:	82 2f       	mov	r24, r18
     154:	df 91       	pop	r29
     156:	cf 91       	pop	r28
     158:	1f 91       	pop	r17
     15a:	0f 91       	pop	r16
     15c:	08 95       	ret

0000015e <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     15e:	ff 92       	push	r15
     160:	0f 93       	push	r16
     162:	1f 93       	push	r17
     164:	cf 93       	push	r28
     166:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     168:	99 e0       	ldi	r25, 0x09	; 9
     16a:	f9 2e       	mov	r15, r25
     16c:	28 c0       	rjmp	.+80     	; 0x1be <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     16e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     170:	80 91 9b 00 	lds	r24, 0x009B
     174:	88 23       	and	r24, r24
     176:	19 f4       	brne	.+6      	; 0x17e <vCoRoutineSchedule+0x20>
     178:	c0 e0       	ldi	r28, 0x00	; 0
     17a:	d0 e0       	ldi	r29, 0x00	; 0
     17c:	06 c0       	rjmp	.+12     	; 0x18a <vCoRoutineSchedule+0x2c>
     17e:	e0 91 a0 00 	lds	r30, 0x00A0
     182:	f0 91 a1 00 	lds	r31, 0x00A1
     186:	c6 81       	ldd	r28, Z+6	; 0x06
     188:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     18a:	ce 01       	movw	r24, r28
     18c:	0c 96       	adiw	r24, 0x0c	; 12
     18e:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     192:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     194:	8e 01       	movw	r16, r28
     196:	0e 5f       	subi	r16, 0xFE	; 254
     198:	1f 4f       	sbci	r17, 0xFF	; 255
     19a:	c8 01       	movw	r24, r16
     19c:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     1a0:	9e 89       	ldd	r25, Y+22	; 0x16
     1a2:	80 91 6c 00 	lds	r24, 0x006C
     1a6:	89 17       	cp	r24, r25
     1a8:	10 f4       	brcc	.+4      	; 0x1ae <vCoRoutineSchedule+0x50>
     1aa:	90 93 6c 00 	sts	0x006C, r25
     1ae:	9f 9d       	mul	r25, r15
     1b0:	c0 01       	movw	r24, r0
     1b2:	11 24       	eor	r1, r1
     1b4:	8d 58       	subi	r24, 0x8D	; 141
     1b6:	9f 4f       	sbci	r25, 0xFF	; 255
     1b8:	b8 01       	movw	r22, r16
     1ba:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
     1be:	80 91 9b 00 	lds	r24, 0x009B
     1c2:	88 23       	and	r24, r24
     1c4:	a1 f6       	brne	.-88     	; 0x16e <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     1c6:	0e 94 aa 06 	call	0xd54	; 0xd54 <xTaskGetTickCount>
     1ca:	20 91 6d 00 	lds	r18, 0x006D
     1ce:	30 91 6e 00 	lds	r19, 0x006E
     1d2:	82 1b       	sub	r24, r18
     1d4:	93 0b       	sbc	r25, r19
     1d6:	90 93 70 00 	sts	0x0070, r25
     1da:	80 93 6f 00 	sts	0x006F, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     1de:	89 e0       	ldi	r24, 0x09	; 9
     1e0:	f8 2e       	mov	r15, r24
     1e2:	54 c0       	rjmp	.+168    	; 0x28c <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 72 00 	sts	0x0072, r25
     1ea:	80 93 71 00 	sts	0x0071, r24
		xPassedTicks--;
     1ee:	21 50       	subi	r18, 0x01	; 1
     1f0:	30 40       	sbci	r19, 0x00	; 0
     1f2:	30 93 70 00 	sts	0x0070, r19
     1f6:	20 93 6f 00 	sts	0x006F, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     1fa:	89 2b       	or	r24, r25
     1fc:	c9 f5       	brne	.+114    	; 0x270 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     1fe:	20 91 97 00 	lds	r18, 0x0097
     202:	30 91 98 00 	lds	r19, 0x0098
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     206:	80 91 99 00 	lds	r24, 0x0099
     20a:	90 91 9a 00 	lds	r25, 0x009A
     20e:	90 93 98 00 	sts	0x0098, r25
     212:	80 93 97 00 	sts	0x0097, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     216:	30 93 9a 00 	sts	0x009A, r19
     21a:	20 93 99 00 	sts	0x0099, r18
     21e:	28 c0       	rjmp	.+80     	; 0x270 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     220:	20 91 71 00 	lds	r18, 0x0071
     224:	30 91 72 00 	lds	r19, 0x0072
     228:	8a 81       	ldd	r24, Y+2	; 0x02
     22a:	9b 81       	ldd	r25, Y+3	; 0x03
     22c:	28 17       	cp	r18, r24
     22e:	39 07       	cpc	r19, r25
     230:	68 f1       	brcs	.+90     	; 0x28c <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     232:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     234:	8e 01       	movw	r16, r28
     236:	0e 5f       	subi	r16, 0xFE	; 254
     238:	1f 4f       	sbci	r17, 0xFF	; 255
     23a:	c8 01       	movw	r24, r16
     23c:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     240:	8c 89       	ldd	r24, Y+20	; 0x14
     242:	9d 89       	ldd	r25, Y+21	; 0x15
     244:	89 2b       	or	r24, r25
     246:	21 f0       	breq	.+8      	; 0x250 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     248:	ce 01       	movw	r24, r28
     24a:	0c 96       	adiw	r24, 0x0c	; 12
     24c:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     250:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     252:	9e 89       	ldd	r25, Y+22	; 0x16
     254:	80 91 6c 00 	lds	r24, 0x006C
     258:	89 17       	cp	r24, r25
     25a:	10 f4       	brcc	.+4      	; 0x260 <vCoRoutineSchedule+0x102>
     25c:	90 93 6c 00 	sts	0x006C, r25
     260:	9f 9d       	mul	r25, r15
     262:	c0 01       	movw	r24, r0
     264:	11 24       	eor	r1, r1
     266:	8d 58       	subi	r24, 0x8D	; 141
     268:	9f 4f       	sbci	r25, 0xFF	; 255
     26a:	b8 01       	movw	r22, r16
     26c:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
     270:	e0 91 97 00 	lds	r30, 0x0097
     274:	f0 91 98 00 	lds	r31, 0x0098
     278:	80 81       	ld	r24, Z
     27a:	88 23       	and	r24, r24
     27c:	39 f0       	breq	.+14     	; 0x28c <vCoRoutineSchedule+0x12e>
     27e:	05 80       	ldd	r0, Z+5	; 0x05
     280:	f6 81       	ldd	r31, Z+6	; 0x06
     282:	e0 2d       	mov	r30, r0
     284:	c6 81       	ldd	r28, Z+6	; 0x06
     286:	d7 81       	ldd	r29, Z+7	; 0x07
     288:	20 97       	sbiw	r28, 0x00	; 0
     28a:	51 f6       	brne	.-108    	; 0x220 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     28c:	20 91 6f 00 	lds	r18, 0x006F
     290:	30 91 70 00 	lds	r19, 0x0070
     294:	80 91 71 00 	lds	r24, 0x0071
     298:	90 91 72 00 	lds	r25, 0x0072
     29c:	21 15       	cp	r18, r1
     29e:	31 05       	cpc	r19, r1
     2a0:	09 f0       	breq	.+2      	; 0x2a4 <vCoRoutineSchedule+0x146>
     2a2:	a0 cf       	rjmp	.-192    	; 0x1e4 <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     2a4:	90 93 6e 00 	sts	0x006E, r25
     2a8:	80 93 6d 00 	sts	0x006D, r24
     2ac:	90 91 6c 00 	lds	r25, 0x006C

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     2b0:	29 e0       	ldi	r18, 0x09	; 9
     2b2:	06 c0       	rjmp	.+12     	; 0x2c0 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     2b4:	99 23       	and	r25, r25
     2b6:	19 f4       	brne	.+6      	; 0x2be <vCoRoutineSchedule+0x160>
     2b8:	10 92 6c 00 	sts	0x006C, r1
     2bc:	32 c0       	rjmp	.+100    	; 0x322 <vCoRoutineSchedule+0x1c4>
     2be:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     2c0:	92 9f       	mul	r25, r18
     2c2:	d0 01       	movw	r26, r0
     2c4:	11 24       	eor	r1, r1
     2c6:	ad 58       	subi	r26, 0x8D	; 141
     2c8:	bf 4f       	sbci	r27, 0xFF	; 255
     2ca:	8c 91       	ld	r24, X
     2cc:	88 23       	and	r24, r24
     2ce:	91 f3       	breq	.-28     	; 0x2b4 <vCoRoutineSchedule+0x156>
     2d0:	90 93 6c 00 	sts	0x006C, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     2d4:	11 96       	adiw	r26, 0x01	; 1
     2d6:	ed 91       	ld	r30, X+
     2d8:	fc 91       	ld	r31, X
     2da:	12 97       	sbiw	r26, 0x02	; 2
     2dc:	02 80       	ldd	r0, Z+2	; 0x02
     2de:	f3 81       	ldd	r31, Z+3	; 0x03
     2e0:	e0 2d       	mov	r30, r0
     2e2:	12 96       	adiw	r26, 0x02	; 2
     2e4:	fc 93       	st	X, r31
     2e6:	ee 93       	st	-X, r30
     2e8:	11 97       	sbiw	r26, 0x01	; 1
     2ea:	cd 01       	movw	r24, r26
     2ec:	03 96       	adiw	r24, 0x03	; 3
     2ee:	e8 17       	cp	r30, r24
     2f0:	f9 07       	cpc	r31, r25
     2f2:	31 f4       	brne	.+12     	; 0x300 <vCoRoutineSchedule+0x1a2>
     2f4:	82 81       	ldd	r24, Z+2	; 0x02
     2f6:	93 81       	ldd	r25, Z+3	; 0x03
     2f8:	12 96       	adiw	r26, 0x02	; 2
     2fa:	9c 93       	st	X, r25
     2fc:	8e 93       	st	-X, r24
     2fe:	11 97       	sbiw	r26, 0x01	; 1
     300:	11 96       	adiw	r26, 0x01	; 1
     302:	ed 91       	ld	r30, X+
     304:	fc 91       	ld	r31, X
     306:	12 97       	sbiw	r26, 0x02	; 2
     308:	06 80       	ldd	r0, Z+6	; 0x06
     30a:	f7 81       	ldd	r31, Z+7	; 0x07
     30c:	e0 2d       	mov	r30, r0
     30e:	f0 93 6b 00 	sts	0x006B, r31
     312:	e0 93 6a 00 	sts	0x006A, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     316:	20 81       	ld	r18, Z
     318:	31 81       	ldd	r19, Z+1	; 0x01
     31a:	cf 01       	movw	r24, r30
     31c:	67 89       	ldd	r22, Z+23	; 0x17
     31e:	f9 01       	movw	r30, r18
     320:	09 95       	icall

	return;
}
     322:	df 91       	pop	r29
     324:	cf 91       	pop	r28
     326:	1f 91       	pop	r17
     328:	0f 91       	pop	r16
     32a:	ff 90       	pop	r15
     32c:	08 95       	ret

0000032e <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     32e:	0f 93       	push	r16
     330:	1f 93       	push	r17
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     338:	00 91 71 00 	lds	r16, 0x0071
     33c:	10 91 72 00 	lds	r17, 0x0072
     340:	08 0f       	add	r16, r24
     342:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     344:	80 91 6a 00 	lds	r24, 0x006A
     348:	90 91 6b 00 	lds	r25, 0x006B
     34c:	02 96       	adiw	r24, 0x02	; 2
     34e:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     352:	e0 91 6a 00 	lds	r30, 0x006A
     356:	f0 91 6b 00 	lds	r31, 0x006B
     35a:	13 83       	std	Z+3, r17	; 0x03
     35c:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     35e:	80 91 71 00 	lds	r24, 0x0071
     362:	90 91 72 00 	lds	r25, 0x0072
     366:	bf 01       	movw	r22, r30
     368:	6e 5f       	subi	r22, 0xFE	; 254
     36a:	7f 4f       	sbci	r23, 0xFF	; 255
     36c:	08 17       	cp	r16, r24
     36e:	19 07       	cpc	r17, r25
     370:	28 f4       	brcc	.+10     	; 0x37c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     372:	80 91 99 00 	lds	r24, 0x0099
     376:	90 91 9a 00 	lds	r25, 0x009A
     37a:	04 c0       	rjmp	.+8      	; 0x384 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     37c:	80 91 97 00 	lds	r24, 0x0097
     380:	90 91 98 00 	lds	r25, 0x0098
     384:	0e 94 8b 02 	call	0x516	; 0x516 <vListInsert>
	}

	if( pxEventList )
     388:	20 97       	sbiw	r28, 0x00	; 0
     38a:	49 f0       	breq	.+18     	; 0x39e <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     38c:	60 91 6a 00 	lds	r22, 0x006A
     390:	70 91 6b 00 	lds	r23, 0x006B
     394:	64 5f       	subi	r22, 0xF4	; 244
     396:	7f 4f       	sbci	r23, 0xFF	; 255
     398:	ce 01       	movw	r24, r28
     39a:	0e 94 8b 02 	call	0x516	; 0x516 <vListInsert>
	}
}
     39e:	df 91       	pop	r29
     3a0:	cf 91       	pop	r28
     3a2:	1f 91       	pop	r17
     3a4:	0f 91       	pop	r16
     3a6:	08 95       	ret

000003a8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     3a8:	af 92       	push	r10
     3aa:	bf 92       	push	r11
     3ac:	cf 92       	push	r12
     3ae:	df 92       	push	r13
     3b0:	ef 92       	push	r14
     3b2:	ff 92       	push	r15
     3b4:	0f 93       	push	r16
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	6c 01       	movw	r12, r24
     3be:	b6 2e       	mov	r11, r22
     3c0:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     3c2:	8a e1       	ldi	r24, 0x1A	; 26
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pvPortMalloc>
     3ca:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     3cc:	00 97       	sbiw	r24, 0x00	; 0
     3ce:	11 f4       	brne	.+4      	; 0x3d4 <xCoRoutineCreate+0x2c>
     3d0:	8f ef       	ldi	r24, 0xFF	; 255
     3d2:	59 c0       	rjmp	.+178    	; 0x486 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     3d4:	80 91 6a 00 	lds	r24, 0x006A
     3d8:	90 91 6b 00 	lds	r25, 0x006B
     3dc:	89 2b       	or	r24, r25
     3de:	21 f5       	brne	.+72     	; 0x428 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     3e0:	d0 93 6b 00 	sts	0x006B, r29
     3e4:	c0 93 6a 00 	sts	0x006A, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     3e8:	83 e7       	ldi	r24, 0x73	; 115
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
     3f0:	8c e7       	ldi	r24, 0x7C	; 124
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     3f8:	25 e8       	ldi	r18, 0x85	; 133
     3fa:	e2 2e       	mov	r14, r18
     3fc:	20 e0       	ldi	r18, 0x00	; 0
     3fe:	f2 2e       	mov	r15, r18
     400:	c7 01       	movw	r24, r14
     402:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     406:	0e e8       	ldi	r16, 0x8E	; 142
     408:	10 e0       	ldi	r17, 0x00	; 0
     40a:	c8 01       	movw	r24, r16
     40c:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     410:	8b e9       	ldi	r24, 0x9B	; 155
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     418:	f0 92 98 00 	sts	0x0098, r15
     41c:	e0 92 97 00 	sts	0x0097, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     420:	10 93 9a 00 	sts	0x009A, r17
     424:	00 93 99 00 	sts	0x0099, r16
     428:	eb 2c       	mov	r14, r11
     42a:	bb 20       	and	r11, r11
     42c:	11 f0       	breq	.+4      	; 0x432 <xCoRoutineCreate+0x8a>
     42e:	ee 24       	eor	r14, r14
     430:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     432:	19 8e       	std	Y+25, r1	; 0x19
     434:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     436:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     438:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     43a:	fe 01       	movw	r30, r28
     43c:	c1 92       	st	Z+, r12
     43e:	d1 92       	st	Z+, r13
     440:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     442:	cf 01       	movw	r24, r30
     444:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     448:	ce 01       	movw	r24, r28
     44a:	0c 96       	adiw	r24, 0x0c	; 12
     44c:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     450:	d9 87       	std	Y+9, r29	; 0x09
     452:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     454:	db 8b       	std	Y+19, r29	; 0x13
     456:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     458:	84 e0       	ldi	r24, 0x04	; 4
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	8e 19       	sub	r24, r14
     45e:	91 09       	sbc	r25, r1
     460:	9d 87       	std	Y+13, r25	; 0x0d
     462:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     464:	9e 89       	ldd	r25, Y+22	; 0x16
     466:	80 91 6c 00 	lds	r24, 0x006C
     46a:	89 17       	cp	r24, r25
     46c:	10 f4       	brcc	.+4      	; 0x472 <xCoRoutineCreate+0xca>
     46e:	90 93 6c 00 	sts	0x006C, r25
     472:	89 e0       	ldi	r24, 0x09	; 9
     474:	98 9f       	mul	r25, r24
     476:	c0 01       	movw	r24, r0
     478:	11 24       	eor	r1, r1
     47a:	8d 58       	subi	r24, 0x8D	; 141
     47c:	9f 4f       	sbci	r25, 0xFF	; 255
     47e:	b8 01       	movw	r22, r16
     480:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>
     484:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
     486:	df 91       	pop	r29
     488:	cf 91       	pop	r28
     48a:	1f 91       	pop	r17
     48c:	0f 91       	pop	r16
     48e:	ff 90       	pop	r15
     490:	ef 90       	pop	r14
     492:	df 90       	pop	r13
     494:	cf 90       	pop	r12
     496:	bf 90       	pop	r11
     498:	af 90       	pop	r10
     49a:	08 95       	ret

0000049c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     49c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     49e:	9c 01       	movw	r18, r24
     4a0:	2d 5f       	subi	r18, 0xFD	; 253
     4a2:	3f 4f       	sbci	r19, 0xFF	; 255
     4a4:	32 83       	std	Z+2, r19	; 0x02
     4a6:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     4a8:	8f ef       	ldi	r24, 0xFF	; 255
     4aa:	9f ef       	ldi	r25, 0xFF	; 255
     4ac:	94 83       	std	Z+4, r25	; 0x04
     4ae:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     4b0:	36 83       	std	Z+6, r19	; 0x06
     4b2:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     4b4:	30 87       	std	Z+8, r19	; 0x08
     4b6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
     4b8:	10 82       	st	Z, r1
}
     4ba:	08 95       	ret

000004bc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     4bc:	fc 01       	movw	r30, r24
     4be:	11 86       	std	Z+9, r1	; 0x09
     4c0:	10 86       	std	Z+8, r1	; 0x08
}
     4c2:	08 95       	ret

000004c4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	ac 01       	movw	r20, r24
     4ca:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     4cc:	ec 01       	movw	r28, r24
     4ce:	29 81       	ldd	r18, Y+1	; 0x01
     4d0:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     4d2:	f9 01       	movw	r30, r18
     4d4:	82 81       	ldd	r24, Z+2	; 0x02
     4d6:	93 81       	ldd	r25, Z+3	; 0x03
     4d8:	13 96       	adiw	r26, 0x03	; 3
     4da:	9c 93       	st	X, r25
     4dc:	8e 93       	st	-X, r24
     4de:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     4e0:	89 81       	ldd	r24, Y+1	; 0x01
     4e2:	9a 81       	ldd	r25, Y+2	; 0x02
     4e4:	15 96       	adiw	r26, 0x05	; 5
     4e6:	9c 93       	st	X, r25
     4e8:	8e 93       	st	-X, r24
     4ea:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     4ec:	02 80       	ldd	r0, Z+2	; 0x02
     4ee:	f3 81       	ldd	r31, Z+3	; 0x03
     4f0:	e0 2d       	mov	r30, r0
     4f2:	75 83       	std	Z+5, r23	; 0x05
     4f4:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     4f6:	e9 01       	movw	r28, r18
     4f8:	7b 83       	std	Y+3, r23	; 0x03
     4fa:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     4fc:	fa 01       	movw	r30, r20
     4fe:	72 83       	std	Z+2, r23	; 0x02
     500:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     502:	19 96       	adiw	r26, 0x09	; 9
     504:	5c 93       	st	X, r21
     506:	4e 93       	st	-X, r20
     508:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     50a:	80 81       	ld	r24, Z
     50c:	8f 5f       	subi	r24, 0xFF	; 255
     50e:	80 83       	st	Z, r24
}
     510:	df 91       	pop	r29
     512:	cf 91       	pop	r28
     514:	08 95       	ret

00000516 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	9c 01       	movw	r18, r24
     51c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     51e:	48 81       	ld	r20, Y
     520:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     522:	8f ef       	ldi	r24, 0xFF	; 255
     524:	4f 3f       	cpi	r20, 0xFF	; 255
     526:	58 07       	cpc	r21, r24
     528:	21 f4       	brne	.+8      	; 0x532 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     52a:	f9 01       	movw	r30, r18
     52c:	a7 81       	ldd	r26, Z+7	; 0x07
     52e:	b0 85       	ldd	r27, Z+8	; 0x08
     530:	10 c0       	rjmp	.+32     	; 0x552 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     532:	d9 01       	movw	r26, r18
     534:	13 96       	adiw	r26, 0x03	; 3
     536:	04 c0       	rjmp	.+8      	; 0x540 <vListInsert+0x2a>
     538:	12 96       	adiw	r26, 0x02	; 2
     53a:	0d 90       	ld	r0, X+
     53c:	bc 91       	ld	r27, X
     53e:	a0 2d       	mov	r26, r0
     540:	12 96       	adiw	r26, 0x02	; 2
     542:	ed 91       	ld	r30, X+
     544:	fc 91       	ld	r31, X
     546:	13 97       	sbiw	r26, 0x03	; 3
     548:	80 81       	ld	r24, Z
     54a:	91 81       	ldd	r25, Z+1	; 0x01
     54c:	48 17       	cp	r20, r24
     54e:	59 07       	cpc	r21, r25
     550:	98 f7       	brcc	.-26     	; 0x538 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     552:	12 96       	adiw	r26, 0x02	; 2
     554:	ed 91       	ld	r30, X+
     556:	fc 91       	ld	r31, X
     558:	13 97       	sbiw	r26, 0x03	; 3
     55a:	fb 83       	std	Y+3, r31	; 0x03
     55c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     55e:	d5 83       	std	Z+5, r29	; 0x05
     560:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     562:	bd 83       	std	Y+5, r27	; 0x05
     564:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     566:	13 96       	adiw	r26, 0x03	; 3
     568:	dc 93       	st	X, r29
     56a:	ce 93       	st	-X, r28
     56c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     56e:	39 87       	std	Y+9, r19	; 0x09
     570:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     572:	f9 01       	movw	r30, r18
     574:	80 81       	ld	r24, Z
     576:	8f 5f       	subi	r24, 0xFF	; 255
     578:	80 83       	st	Z, r24
}
     57a:	df 91       	pop	r29
     57c:	cf 91       	pop	r28
     57e:	08 95       	ret

00000580 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     580:	cf 93       	push	r28
     582:	df 93       	push	r29
     584:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     586:	12 96       	adiw	r26, 0x02	; 2
     588:	ed 91       	ld	r30, X+
     58a:	fc 91       	ld	r31, X
     58c:	13 97       	sbiw	r26, 0x03	; 3
     58e:	14 96       	adiw	r26, 0x04	; 4
     590:	8d 91       	ld	r24, X+
     592:	9c 91       	ld	r25, X
     594:	15 97       	sbiw	r26, 0x05	; 5
     596:	95 83       	std	Z+5, r25	; 0x05
     598:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     59a:	14 96       	adiw	r26, 0x04	; 4
     59c:	cd 91       	ld	r28, X+
     59e:	dc 91       	ld	r29, X
     5a0:	15 97       	sbiw	r26, 0x05	; 5
     5a2:	fb 83       	std	Y+3, r31	; 0x03
     5a4:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     5a6:	18 96       	adiw	r26, 0x08	; 8
     5a8:	ed 91       	ld	r30, X+
     5aa:	fc 91       	ld	r31, X
     5ac:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     5ae:	81 81       	ldd	r24, Z+1	; 0x01
     5b0:	92 81       	ldd	r25, Z+2	; 0x02
     5b2:	8a 17       	cp	r24, r26
     5b4:	9b 07       	cpc	r25, r27
     5b6:	11 f4       	brne	.+4      	; 0x5bc <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     5b8:	d2 83       	std	Z+2, r29	; 0x02
     5ba:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     5bc:	19 96       	adiw	r26, 0x09	; 9
     5be:	1c 92       	st	X, r1
     5c0:	1e 92       	st	-X, r1
     5c2:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     5c4:	80 81       	ld	r24, Z
     5c6:	81 50       	subi	r24, 0x01	; 1
     5c8:	80 83       	st	Z, r24
}
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	08 95       	ret

000005d0 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     5d0:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     5d8:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     5da:	0f 90       	pop	r0
     5dc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     5de:	08 95       	ret

000005e0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     5e0:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
     5e2:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     5e4:	08 95       	ret

000005e6 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     5e6:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     5e8:	82 8d       	ldd	r24, Z+26	; 0x1a
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	88 23       	and	r24, r24
     5ee:	09 f4       	brne	.+2      	; 0x5f2 <xQueueIsQueueEmptyFromISR+0xc>
     5f0:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     5f2:	89 2f       	mov	r24, r25
     5f4:	08 95       	ret

000005f6 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     5f6:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     5f8:	92 8d       	ldd	r25, Z+26	; 0x1a
     5fa:	20 e0       	ldi	r18, 0x00	; 0
     5fc:	83 8d       	ldd	r24, Z+27	; 0x1b
     5fe:	98 17       	cp	r25, r24
     600:	09 f4       	brne	.+2      	; 0x604 <xQueueIsQueueFullFromISR+0xe>
     602:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     604:	82 2f       	mov	r24, r18
     606:	08 95       	ret

00000608 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	ec 01       	movw	r28, r24
     60e:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     610:	4c 8d       	ldd	r20, Y+28	; 0x1c
     612:	44 23       	and	r20, r20
     614:	a1 f1       	breq	.+104    	; 0x67e <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     616:	88 23       	and	r24, r24
     618:	b1 f4       	brne	.+44     	; 0x646 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     61a:	8c 81       	ldd	r24, Y+4	; 0x04
     61c:	9d 81       	ldd	r25, Y+5	; 0x05
     61e:	50 e0       	ldi	r21, 0x00	; 0
     620:	0e 94 b8 0c 	call	0x1970	; 0x1970 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     624:	8c 8d       	ldd	r24, Y+28	; 0x1c
     626:	2c 81       	ldd	r18, Y+4	; 0x04
     628:	3d 81       	ldd	r19, Y+5	; 0x05
     62a:	28 0f       	add	r18, r24
     62c:	31 1d       	adc	r19, r1
     62e:	3d 83       	std	Y+5, r19	; 0x05
     630:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	28 17       	cp	r18, r24
     638:	39 07       	cpc	r19, r25
     63a:	08 f1       	brcs	.+66     	; 0x67e <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     63c:	88 81       	ld	r24, Y
     63e:	99 81       	ldd	r25, Y+1	; 0x01
     640:	9d 83       	std	Y+5, r25	; 0x05
     642:	8c 83       	std	Y+4, r24	; 0x04
     644:	1c c0       	rjmp	.+56     	; 0x67e <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     646:	8e 81       	ldd	r24, Y+6	; 0x06
     648:	9f 81       	ldd	r25, Y+7	; 0x07
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	0e 94 b8 0c 	call	0x1970	; 0x1970 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     650:	8c 8d       	ldd	r24, Y+28	; 0x1c
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	44 27       	eor	r20, r20
     656:	55 27       	eor	r21, r21
     658:	48 1b       	sub	r20, r24
     65a:	59 0b       	sbc	r21, r25
     65c:	8e 81       	ldd	r24, Y+6	; 0x06
     65e:	9f 81       	ldd	r25, Y+7	; 0x07
     660:	84 0f       	add	r24, r20
     662:	95 1f       	adc	r25, r21
     664:	9f 83       	std	Y+7, r25	; 0x07
     666:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     668:	28 81       	ld	r18, Y
     66a:	39 81       	ldd	r19, Y+1	; 0x01
     66c:	82 17       	cp	r24, r18
     66e:	93 07       	cpc	r25, r19
     670:	30 f4       	brcc	.+12     	; 0x67e <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     672:	8a 81       	ldd	r24, Y+2	; 0x02
     674:	9b 81       	ldd	r25, Y+3	; 0x03
     676:	84 0f       	add	r24, r20
     678:	95 1f       	adc	r25, r21
     67a:	9f 83       	std	Y+7, r25	; 0x07
     67c:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     67e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     680:	8f 5f       	subi	r24, 0xFF	; 255
     682:	8a 8f       	std	Y+26, r24	; 0x1a
}
     684:	df 91       	pop	r29
     686:	cf 91       	pop	r28
     688:	08 95       	ret

0000068a <xQueueCRReceiveFromISR>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
{
     68a:	0f 93       	push	r16
     68c:	1f 93       	push	r17
     68e:	cf 93       	push	r28
     690:	df 93       	push	r29
     692:	ec 01       	movw	r28, r24
     694:	fb 01       	movw	r30, r22
     696:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. If
	not then just leave without doing anything. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     698:	8a 8d       	ldd	r24, Y+26	; 0x1a
     69a:	88 23       	and	r24, r24
     69c:	61 f1       	breq	.+88     	; 0x6f6 <xQueueCRReceiveFromISR+0x6c>
	{
		/* Copy the data from the queue. */
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     69e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     6a0:	2e 81       	ldd	r18, Y+6	; 0x06
     6a2:	3f 81       	ldd	r19, Y+7	; 0x07
     6a4:	28 0f       	add	r18, r24
     6a6:	31 1d       	adc	r19, r1
     6a8:	3f 83       	std	Y+7, r19	; 0x07
     6aa:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     6ac:	8a 81       	ldd	r24, Y+2	; 0x02
     6ae:	9b 81       	ldd	r25, Y+3	; 0x03
     6b0:	28 17       	cp	r18, r24
     6b2:	39 07       	cpc	r19, r25
     6b4:	20 f0       	brcs	.+8      	; 0x6be <xQueueCRReceiveFromISR+0x34>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     6b6:	88 81       	ld	r24, Y
     6b8:	99 81       	ldd	r25, Y+1	; 0x01
     6ba:	9f 83       	std	Y+7, r25	; 0x07
     6bc:	8e 83       	std	Y+6, r24	; 0x06
		}
		--( pxQueue->uxMessagesWaiting );
     6be:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6c0:	81 50       	subi	r24, 0x01	; 1
     6c2:	8a 8f       	std	Y+26, r24	; 0x1a
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     6c4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     6c6:	6e 81       	ldd	r22, Y+6	; 0x06
     6c8:	7f 81       	ldd	r23, Y+7	; 0x07
     6ca:	cf 01       	movw	r24, r30
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	0e 94 b8 0c 	call	0x1970	; 0x1970 <memcpy>

		if( !( *pxCoRoutineWoken ) )
     6d2:	f8 01       	movw	r30, r16
     6d4:	80 81       	ld	r24, Z
     6d6:	88 23       	and	r24, r24
     6d8:	69 f4       	brne	.+26     	; 0x6f4 <xQueueCRReceiveFromISR+0x6a>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     6da:	88 85       	ldd	r24, Y+8	; 0x08
     6dc:	88 23       	and	r24, r24
     6de:	51 f0       	breq	.+20     	; 0x6f4 <xQueueCRReceiveFromISR+0x6a>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     6e0:	ce 01       	movw	r24, r28
     6e2:	08 96       	adiw	r24, 0x08	; 8
     6e4:	0e 94 84 00 	call	0x108	; 0x108 <xCoRoutineRemoveFromEventList>
     6e8:	88 23       	and	r24, r24
     6ea:	21 f0       	breq	.+8      	; 0x6f4 <xQueueCRReceiveFromISR+0x6a>
				{
					*pxCoRoutineWoken = pdTRUE;
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	f8 01       	movw	r30, r16
     6f0:	80 83       	st	Z, r24
     6f2:	01 c0       	rjmp	.+2      	; 0x6f6 <xQueueCRReceiveFromISR+0x6c>
     6f4:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
     6f6:	df 91       	pop	r29
     6f8:	cf 91       	pop	r28
     6fa:	1f 91       	pop	r17
     6fc:	0f 91       	pop	r16
     6fe:	08 95       	ret

00000700 <xQueueCRSendFromISR>:



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
{
     700:	1f 93       	push	r17
     702:	cf 93       	push	r28
     704:	df 93       	push	r29
     706:	ec 01       	movw	r28, r24
     708:	14 2f       	mov	r17, r20
	/* Cannot block within an ISR so if there is no space on the queue then
	exit without doing anything. */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     70a:	9a 8d       	ldd	r25, Y+26	; 0x1a
     70c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     70e:	98 17       	cp	r25, r24
     710:	88 f4       	brcc	.+34     	; 0x734 <xQueueCRSendFromISR+0x34>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
     712:	ce 01       	movw	r24, r28
     714:	40 e0       	ldi	r20, 0x00	; 0
     716:	0e 94 04 03 	call	0x608	; 0x608 <prvCopyDataToQueue>

		/* We only want to wake one co-routine per ISR, so check that a
		co-routine has not already been woken. */
		if( !xCoRoutinePreviouslyWoken )
     71a:	11 23       	and	r17, r17
     71c:	59 f4       	brne	.+22     	; 0x734 <xQueueCRSendFromISR+0x34>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     71e:	89 89       	ldd	r24, Y+17	; 0x11
     720:	88 23       	and	r24, r24
     722:	41 f0       	breq	.+16     	; 0x734 <xQueueCRSendFromISR+0x34>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     724:	ce 01       	movw	r24, r28
     726:	41 96       	adiw	r24, 0x11	; 17
     728:	0e 94 84 00 	call	0x108	; 0x108 <xCoRoutineRemoveFromEventList>
     72c:	48 2f       	mov	r20, r24
     72e:	81 11       	cpse	r24, r1
     730:	41 e0       	ldi	r20, 0x01	; 1
     732:	14 2f       	mov	r17, r20
			}
		}
	}

	return xCoRoutinePreviouslyWoken;
}
     734:	81 2f       	mov	r24, r17
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	1f 91       	pop	r17
     73c:	08 95       	ret

0000073e <xQueueCRReceive>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
{
     73e:	cf 93       	push	r28
     740:	df 93       	push	r29
     742:	ec 01       	movw	r28, r24
     744:	fb 01       	movw	r30, r22
signed portBASE_TYPE xReturn;

	/* If the queue is already empty we may have to block.  A critical section
	is required to prevent an interrupt adding something to the queue
	between the check to see if the queue is empty and blocking on the queue. */
	portDISABLE_INTERRUPTS();
     746:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
     748:	8a 8d       	ldd	r24, Y+26	; 0x1a
     74a:	88 23       	and	r24, r24
     74c:	71 f4       	brne	.+28     	; 0x76a <xQueueCRReceive+0x2c>
		{
			/* There are no messages in the queue, do we want to block or just
			leave with nothing? */
			if( xTicksToWait > ( portTickType ) 0 )
     74e:	41 15       	cp	r20, r1
     750:	51 05       	cpc	r21, r1
     752:	41 f0       	breq	.+16     	; 0x764 <xQueueCRReceive+0x26>
			{
				/* As this is a co-routine we cannot block directly, but return
				indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
     754:	61 96       	adiw	r28, 0x11	; 17
     756:	ca 01       	movw	r24, r20
     758:	be 01       	movw	r22, r28
     75a:	0e 94 97 01 	call	0x32e	; 0x32e <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
     75e:	78 94       	sei
     760:	8c ef       	ldi	r24, 0xFC	; 252
     762:	30 c0       	rjmp	.+96     	; 0x7c4 <xQueueCRReceive+0x86>
				return errQUEUE_BLOCKED;
			}
			else
			{
				portENABLE_INTERRUPTS();
     764:	78 94       	sei
     766:	80 e0       	ldi	r24, 0x00	; 0
     768:	2d c0       	rjmp	.+90     	; 0x7c4 <xQueueCRReceive+0x86>
				return errQUEUE_FULL;
			}
		}
	}
	portENABLE_INTERRUPTS();
     76a:	78 94       	sei

	portNOP();
     76c:	00 00       	nop

	portDISABLE_INTERRUPTS();
     76e:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     770:	8a 8d       	ldd	r24, Y+26	; 0x1a
     772:	88 23       	and	r24, r24
     774:	31 f1       	breq	.+76     	; 0x7c2 <xQueueCRReceive+0x84>
		{
			/* Data is available from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
     776:	8c 8d       	ldd	r24, Y+28	; 0x1c
     778:	2e 81       	ldd	r18, Y+6	; 0x06
     77a:	3f 81       	ldd	r19, Y+7	; 0x07
     77c:	28 0f       	add	r18, r24
     77e:	31 1d       	adc	r19, r1
     780:	3f 83       	std	Y+7, r19	; 0x07
     782:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     784:	8a 81       	ldd	r24, Y+2	; 0x02
     786:	9b 81       	ldd	r25, Y+3	; 0x03
     788:	28 17       	cp	r18, r24
     78a:	39 07       	cpc	r19, r25
     78c:	20 f0       	brcs	.+8      	; 0x796 <xQueueCRReceive+0x58>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
     78e:	88 81       	ld	r24, Y
     790:	99 81       	ldd	r25, Y+1	; 0x01
     792:	9f 83       	std	Y+7, r25	; 0x07
     794:	8e 83       	std	Y+6, r24	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
     796:	8a 8d       	ldd	r24, Y+26	; 0x1a
     798:	81 50       	subi	r24, 0x01	; 1
     79a:	8a 8f       	std	Y+26, r24	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     79c:	4c 8d       	ldd	r20, Y+28	; 0x1c
     79e:	6e 81       	ldd	r22, Y+6	; 0x06
     7a0:	7f 81       	ldd	r23, Y+7	; 0x07
     7a2:	cf 01       	movw	r24, r30
     7a4:	50 e0       	ldi	r21, 0x00	; 0
     7a6:	0e 94 b8 0c 	call	0x1970	; 0x1970 <memcpy>

			xReturn = pdPASS;

			/* Were any co-routines waiting for space to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     7aa:	88 85       	ldd	r24, Y+8	; 0x08
     7ac:	88 23       	and	r24, r24
     7ae:	41 f0       	breq	.+16     	; 0x7c0 <xQueueCRReceive+0x82>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     7b0:	ce 01       	movw	r24, r28
     7b2:	08 96       	adiw	r24, 0x08	; 8
     7b4:	0e 94 84 00 	call	0x108	; 0x108 <xCoRoutineRemoveFromEventList>
     7b8:	88 23       	and	r24, r24
     7ba:	11 f0       	breq	.+4      	; 0x7c0 <xQueueCRReceive+0x82>
     7bc:	8b ef       	ldi	r24, 0xFB	; 251
     7be:	01 c0       	rjmp	.+2      	; 0x7c2 <xQueueCRReceive+0x84>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdFAIL;
		}
	}
	portENABLE_INTERRUPTS();
     7c2:	78 94       	sei

	return xReturn;
}
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	08 95       	ret

000007ca <xQueueCRSend>:
}
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
{
     7ca:	cf 93       	push	r28
     7cc:	df 93       	push	r29
     7ce:	ec 01       	movw	r28, r24
signed portBASE_TYPE xReturn;

	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
     7d0:	f8 94       	cli

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     7d2:	0f b6       	in	r0, 0x3f	; 63
     7d4:	f8 94       	cli
     7d6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     7d8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7da:	9b 8d       	ldd	r25, Y+27	; 0x1b
	taskEXIT_CRITICAL();
     7dc:	0f 90       	pop	r0
     7de:	0f be       	out	0x3f, r0	; 63
	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
	{
		if( prvIsQueueFull( pxQueue ) )
     7e0:	89 17       	cp	r24, r25
     7e2:	71 f4       	brne	.+28     	; 0x800 <xQueueCRSend+0x36>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
     7e4:	41 15       	cp	r20, r1
     7e6:	51 05       	cpc	r21, r1
     7e8:	41 f0       	breq	.+16     	; 0x7fa <xQueueCRSend+0x30>
			{
				/* As this is called from a coroutine we cannot block directly, but
				return indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
     7ea:	28 96       	adiw	r28, 0x08	; 8
     7ec:	ca 01       	movw	r24, r20
     7ee:	be 01       	movw	r22, r28
     7f0:	0e 94 97 01 	call	0x32e	; 0x32e <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
     7f4:	78 94       	sei
     7f6:	8c ef       	ldi	r24, 0xFC	; 252
     7f8:	1c c0       	rjmp	.+56     	; 0x832 <xQueueCRSend+0x68>
				return errQUEUE_BLOCKED;
			}
			else
			{
				portENABLE_INTERRUPTS();
     7fa:	78 94       	sei
     7fc:	80 e0       	ldi	r24, 0x00	; 0
     7fe:	19 c0       	rjmp	.+50     	; 0x832 <xQueueCRSend+0x68>
				return errQUEUE_FULL;
			}
		}
	}
	portENABLE_INTERRUPTS();
     800:	78 94       	sei

	portNOP();
     802:	00 00       	nop

	portDISABLE_INTERRUPTS();
     804:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     806:	8a 8d       	ldd	r24, Y+26	; 0x1a
     808:	89 17       	cp	r24, r25
     80a:	10 f0       	brcs	.+4      	; 0x810 <xQueueCRSend+0x46>
     80c:	80 e0       	ldi	r24, 0x00	; 0
     80e:	10 c0       	rjmp	.+32     	; 0x830 <xQueueCRSend+0x66>
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
     810:	ce 01       	movw	r24, r28
     812:	40 e0       	ldi	r20, 0x00	; 0
     814:	0e 94 04 03 	call	0x608	; 0x608 <prvCopyDataToQueue>
			xReturn = pdPASS;

			/* Were any co-routines waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     818:	89 89       	ldd	r24, Y+17	; 0x11
     81a:	88 23       	and	r24, r24
     81c:	41 f0       	breq	.+16     	; 0x82e <xQueueCRSend+0x64>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     81e:	ce 01       	movw	r24, r28
     820:	41 96       	adiw	r24, 0x11	; 17
     822:	0e 94 84 00 	call	0x108	; 0x108 <xCoRoutineRemoveFromEventList>
     826:	88 23       	and	r24, r24
     828:	11 f0       	breq	.+4      	; 0x82e <xQueueCRSend+0x64>
     82a:	8b ef       	ldi	r24, 0xFB	; 251
     82c:	01 c0       	rjmp	.+2      	; 0x830 <xQueueCRSend+0x66>
     82e:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = errQUEUE_FULL;
		}
	}
	portENABLE_INTERRUPTS();
     830:	78 94       	sei

	return xReturn;
}
     832:	df 91       	pop	r29
     834:	cf 91       	pop	r28
     836:	08 95       	ret

00000838 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     838:	0f 93       	push	r16
     83a:	1f 93       	push	r17
     83c:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     83e:	fc 01       	movw	r30, r24
     840:	80 81       	ld	r24, Z
     842:	91 81       	ldd	r25, Z+1	; 0x01
     844:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortFree>
	vPortFree( pxQueue );
     848:	c8 01       	movw	r24, r16
     84a:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortFree>
}
     84e:	1f 91       	pop	r17
     850:	0f 91       	pop	r16
     852:	08 95       	ret

00000854 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     854:	0f 93       	push	r16
     856:	1f 93       	push	r17
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	ec 01       	movw	r28, r24
     85e:	fb 01       	movw	r30, r22
     860:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     862:	8a 8d       	ldd	r24, Y+26	; 0x1a
     864:	88 23       	and	r24, r24
     866:	81 f1       	breq	.+96     	; 0x8c8 <__stack+0x69>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     868:	48 81       	ld	r20, Y
     86a:	59 81       	ldd	r21, Y+1	; 0x01
     86c:	41 15       	cp	r20, r1
     86e:	51 05       	cpc	r21, r1
     870:	a9 f0       	breq	.+42     	; 0x89c <__stack+0x3d>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     872:	8c 8d       	ldd	r24, Y+28	; 0x1c
     874:	2e 81       	ldd	r18, Y+6	; 0x06
     876:	3f 81       	ldd	r19, Y+7	; 0x07
     878:	28 0f       	add	r18, r24
     87a:	31 1d       	adc	r19, r1
     87c:	3f 83       	std	Y+7, r19	; 0x07
     87e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     880:	8a 81       	ldd	r24, Y+2	; 0x02
     882:	9b 81       	ldd	r25, Y+3	; 0x03
     884:	28 17       	cp	r18, r24
     886:	39 07       	cpc	r19, r25
     888:	10 f0       	brcs	.+4      	; 0x88e <__stack+0x2f>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     88a:	5f 83       	std	Y+7, r21	; 0x07
     88c:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     88e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     890:	6e 81       	ldd	r22, Y+6	; 0x06
     892:	7f 81       	ldd	r23, Y+7	; 0x07
     894:	cf 01       	movw	r24, r30
     896:	50 e0       	ldi	r21, 0x00	; 0
     898:	0e 94 b8 0c 	call	0x1970	; 0x1970 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     89c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     89e:	81 50       	subi	r24, 0x01	; 1
     8a0:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     8a2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8a4:	8f 3f       	cpi	r24, 0xFF	; 255
     8a6:	69 f4       	brne	.+26     	; 0x8c2 <__stack+0x63>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     8a8:	88 85       	ldd	r24, Y+8	; 0x08
     8aa:	88 23       	and	r24, r24
     8ac:	61 f0       	breq	.+24     	; 0x8c6 <__stack+0x67>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     8ae:	ce 01       	movw	r24, r28
     8b0:	08 96       	adiw	r24, 0x08	; 8
     8b2:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     8b6:	88 23       	and	r24, r24
     8b8:	31 f0       	breq	.+12     	; 0x8c6 <__stack+0x67>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	f8 01       	movw	r30, r16
     8be:	80 83       	st	Z, r24
     8c0:	03 c0       	rjmp	.+6      	; 0x8c8 <__stack+0x69>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     8c2:	8f 5f       	subi	r24, 0xFF	; 255
     8c4:	8d 8f       	std	Y+29, r24	; 0x1d
     8c6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     8c8:	df 91       	pop	r29
     8ca:	cf 91       	pop	r28
     8cc:	1f 91       	pop	r17
     8ce:	0f 91       	pop	r16
     8d0:	08 95       	ret

000008d2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     8d2:	0f 93       	push	r16
     8d4:	1f 93       	push	r17
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	ec 01       	movw	r28, r24
     8dc:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     8de:	9a 8d       	ldd	r25, Y+26	; 0x1a
     8e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8e2:	98 17       	cp	r25, r24
     8e4:	10 f0       	brcs	.+4      	; 0x8ea <xQueueGenericSendFromISR+0x18>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	17 c0       	rjmp	.+46     	; 0x918 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     8ea:	ce 01       	movw	r24, r28
     8ec:	42 2f       	mov	r20, r18
     8ee:	0e 94 04 03 	call	0x608	; 0x608 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     8f2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8f4:	8f 3f       	cpi	r24, 0xFF	; 255
     8f6:	69 f4       	brne	.+26     	; 0x912 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     8f8:	89 89       	ldd	r24, Y+17	; 0x11
     8fa:	88 23       	and	r24, r24
     8fc:	61 f0       	breq	.+24     	; 0x916 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     8fe:	ce 01       	movw	r24, r28
     900:	41 96       	adiw	r24, 0x11	; 17
     902:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     906:	88 23       	and	r24, r24
     908:	31 f0       	breq	.+12     	; 0x916 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     90a:	81 e0       	ldi	r24, 0x01	; 1
     90c:	f8 01       	movw	r30, r16
     90e:	80 83       	st	Z, r24
     910:	03 c0       	rjmp	.+6      	; 0x918 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     912:	8f 5f       	subi	r24, 0xFF	; 255
     914:	8e 8f       	std	Y+30, r24	; 0x1e
     916:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     918:	df 91       	pop	r29
     91a:	cf 91       	pop	r28
     91c:	1f 91       	pop	r17
     91e:	0f 91       	pop	r16
     920:	08 95       	ret

00000922 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     922:	0f 93       	push	r16
     924:	1f 93       	push	r17
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     932:	8c 01       	movw	r16, r24
     934:	0f 5e       	subi	r16, 0xEF	; 239
     936:	1f 4f       	sbci	r17, 0xFF	; 255
     938:	0d c0       	rjmp	.+26     	; 0x954 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     93a:	89 89       	ldd	r24, Y+17	; 0x11
     93c:	88 23       	and	r24, r24
     93e:	69 f0       	breq	.+26     	; 0x95a <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     940:	c8 01       	movw	r24, r16
     942:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     946:	88 23       	and	r24, r24
     948:	11 f0       	breq	.+4      	; 0x94e <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     94a:	0e 94 45 07 	call	0xe8a	; 0xe8a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     94e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     950:	81 50       	subi	r24, 0x01	; 1
     952:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     954:	8e 8d       	ldd	r24, Y+30	; 0x1e
     956:	18 16       	cp	r1, r24
     958:	84 f3       	brlt	.-32     	; 0x93a <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     95a:	8f ef       	ldi	r24, 0xFF	; 255
     95c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     95e:	0f 90       	pop	r0
     960:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	f8 94       	cli
     966:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     968:	8e 01       	movw	r16, r28
     96a:	08 5f       	subi	r16, 0xF8	; 248
     96c:	1f 4f       	sbci	r17, 0xFF	; 255
     96e:	0d c0       	rjmp	.+26     	; 0x98a <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     970:	88 85       	ldd	r24, Y+8	; 0x08
     972:	88 23       	and	r24, r24
     974:	69 f0       	breq	.+26     	; 0x990 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     976:	c8 01       	movw	r24, r16
     978:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     97c:	88 23       	and	r24, r24
     97e:	11 f0       	breq	.+4      	; 0x984 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     980:	0e 94 45 07 	call	0xe8a	; 0xe8a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     984:	8d 8d       	ldd	r24, Y+29	; 0x1d
     986:	81 50       	subi	r24, 0x01	; 1
     988:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     98a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     98c:	18 16       	cp	r1, r24
     98e:	84 f3       	brlt	.-32     	; 0x970 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     990:	8f ef       	ldi	r24, 0xFF	; 255
     992:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     994:	0f 90       	pop	r0
     996:	0f be       	out	0x3f, r0	; 63
}
     998:	df 91       	pop	r29
     99a:	cf 91       	pop	r28
     99c:	1f 91       	pop	r17
     99e:	0f 91       	pop	r16
     9a0:	08 95       	ret

000009a2 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     9a2:	7f 92       	push	r7
     9a4:	8f 92       	push	r8
     9a6:	9f 92       	push	r9
     9a8:	af 92       	push	r10
     9aa:	bf 92       	push	r11
     9ac:	cf 92       	push	r12
     9ae:	df 92       	push	r13
     9b0:	ef 92       	push	r14
     9b2:	ff 92       	push	r15
     9b4:	0f 93       	push	r16
     9b6:	1f 93       	push	r17
     9b8:	df 93       	push	r29
     9ba:	cf 93       	push	r28
     9bc:	00 d0       	rcall	.+0      	; 0x9be <xQueueGenericReceive+0x1c>
     9be:	00 d0       	rcall	.+0      	; 0x9c0 <xQueueGenericReceive+0x1e>
     9c0:	0f 92       	push	r0
     9c2:	cd b7       	in	r28, 0x3d	; 61
     9c4:	de b7       	in	r29, 0x3e	; 62
     9c6:	8c 01       	movw	r16, r24
     9c8:	96 2e       	mov	r9, r22
     9ca:	87 2e       	mov	r8, r23
     9cc:	5d 83       	std	Y+5, r21	; 0x05
     9ce:	4c 83       	std	Y+4, r20	; 0x04
     9d0:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     9d2:	91 e1       	ldi	r25, 0x11	; 17
     9d4:	c9 2e       	mov	r12, r25
     9d6:	d1 2c       	mov	r13, r1
     9d8:	c0 0e       	add	r12, r16
     9da:	d1 1e       	adc	r13, r17
     9dc:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     9de:	7e 01       	movw	r14, r28
     9e0:	08 94       	sec
     9e2:	e1 1c       	adc	r14, r1
     9e4:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     9e6:	84 e0       	ldi	r24, 0x04	; 4
     9e8:	a8 2e       	mov	r10, r24
     9ea:	b1 2c       	mov	r11, r1
     9ec:	ac 0e       	add	r10, r28
     9ee:	bd 1e       	adc	r11, r29
     9f0:	01 c0       	rjmp	.+2      	; 0x9f4 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     9f2:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     9f4:	0f b6       	in	r0, 0x3f	; 63
     9f6:	f8 94       	cli
     9f8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     9fa:	f8 01       	movw	r30, r16
     9fc:	82 8d       	ldd	r24, Z+26	; 0x1a
     9fe:	88 23       	and	r24, r24
     a00:	09 f4       	brne	.+2      	; 0xa04 <xQueueGenericReceive+0x62>
     a02:	3e c0       	rjmp	.+124    	; 0xa80 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     a04:	e6 80       	ldd	r14, Z+6	; 0x06
     a06:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     a08:	40 81       	ld	r20, Z
     a0a:	51 81       	ldd	r21, Z+1	; 0x01
     a0c:	41 15       	cp	r20, r1
     a0e:	51 05       	cpc	r21, r1
     a10:	b1 f0       	breq	.+44     	; 0xa3e <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     a12:	84 8d       	ldd	r24, Z+28	; 0x1c
     a14:	97 01       	movw	r18, r14
     a16:	28 0f       	add	r18, r24
     a18:	31 1d       	adc	r19, r1
     a1a:	37 83       	std	Z+7, r19	; 0x07
     a1c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     a1e:	82 81       	ldd	r24, Z+2	; 0x02
     a20:	93 81       	ldd	r25, Z+3	; 0x03
     a22:	28 17       	cp	r18, r24
     a24:	39 07       	cpc	r19, r25
     a26:	10 f0       	brcs	.+4      	; 0xa2c <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     a28:	57 83       	std	Z+7, r21	; 0x07
     a2a:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     a2c:	f8 01       	movw	r30, r16
     a2e:	44 8d       	ldd	r20, Z+28	; 0x1c
     a30:	66 81       	ldd	r22, Z+6	; 0x06
     a32:	77 81       	ldd	r23, Z+7	; 0x07
     a34:	89 2d       	mov	r24, r9
     a36:	98 2d       	mov	r25, r8
     a38:	50 e0       	ldi	r21, 0x00	; 0
     a3a:	0e 94 b8 0c 	call	0x1970	; 0x1970 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     a3e:	77 20       	and	r7, r7
     a40:	71 f4       	brne	.+28     	; 0xa5e <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     a42:	f8 01       	movw	r30, r16
     a44:	82 8d       	ldd	r24, Z+26	; 0x1a
     a46:	81 50       	subi	r24, 0x01	; 1
     a48:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a4a:	80 85       	ldd	r24, Z+8	; 0x08
     a4c:	88 23       	and	r24, r24
     a4e:	a1 f0       	breq	.+40     	; 0xa78 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     a50:	c8 01       	movw	r24, r16
     a52:	08 96       	adiw	r24, 0x08	; 8
     a54:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     a58:	81 30       	cpi	r24, 0x01	; 1
     a5a:	71 f4       	brne	.+28     	; 0xa78 <xQueueGenericReceive+0xd6>
     a5c:	0b c0       	rjmp	.+22     	; 0xa74 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     a5e:	f8 01       	movw	r30, r16
     a60:	f7 82       	std	Z+7, r15	; 0x07
     a62:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     a64:	81 89       	ldd	r24, Z+17	; 0x11
     a66:	88 23       	and	r24, r24
     a68:	39 f0       	breq	.+14     	; 0xa78 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a6a:	c6 01       	movw	r24, r12
     a6c:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     a70:	88 23       	and	r24, r24
     a72:	11 f0       	breq	.+4      	; 0xa78 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     a74:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     a78:	0f 90       	pop	r0
     a7a:	0f be       	out	0x3f, r0	; 63
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	4a c0       	rjmp	.+148    	; 0xb14 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     a80:	8c 81       	ldd	r24, Y+4	; 0x04
     a82:	9d 81       	ldd	r25, Y+5	; 0x05
     a84:	89 2b       	or	r24, r25
     a86:	19 f4       	brne	.+6      	; 0xa8e <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a88:	0f 90       	pop	r0
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	42 c0       	rjmp	.+132    	; 0xb12 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     a8e:	22 23       	and	r18, r18
     a90:	19 f4       	brne	.+6      	; 0xa98 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     a92:	c7 01       	movw	r24, r14
     a94:	0e 94 00 07 	call	0xe00	; 0xe00 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     a98:	0f 90       	pop	r0
     a9a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     a9c:	0e 94 a4 06 	call	0xd48	; 0xd48 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	0f 92       	push	r0
     aa6:	f8 01       	movw	r30, r16
     aa8:	85 8d       	ldd	r24, Z+29	; 0x1d
     aaa:	8f 3f       	cpi	r24, 0xFF	; 255
     aac:	09 f4       	brne	.+2      	; 0xab0 <xQueueGenericReceive+0x10e>
     aae:	15 8e       	std	Z+29, r1	; 0x1d
     ab0:	f8 01       	movw	r30, r16
     ab2:	86 8d       	ldd	r24, Z+30	; 0x1e
     ab4:	8f 3f       	cpi	r24, 0xFF	; 255
     ab6:	09 f4       	brne	.+2      	; 0xaba <xQueueGenericReceive+0x118>
     ab8:	16 8e       	std	Z+30, r1	; 0x1e
     aba:	0f 90       	pop	r0
     abc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     abe:	c7 01       	movw	r24, r14
     ac0:	b5 01       	movw	r22, r10
     ac2:	0e 94 0b 07 	call	0xe16	; 0xe16 <xTaskCheckForTimeOut>
     ac6:	88 23       	and	r24, r24
     ac8:	f9 f4       	brne	.+62     	; 0xb08 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	f8 94       	cli
     ace:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     ad0:	f8 01       	movw	r30, r16
     ad2:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     ad4:	0f 90       	pop	r0
     ad6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
     ad8:	88 23       	and	r24, r24
     ada:	81 f4       	brne	.+32     	; 0xafc <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     adc:	6c 81       	ldd	r22, Y+4	; 0x04
     ade:	7d 81       	ldd	r23, Y+5	; 0x05
     ae0:	c6 01       	movw	r24, r12
     ae2:	0e 94 02 08 	call	0x1004	; 0x1004 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     ae6:	c8 01       	movw	r24, r16
     ae8:	0e 94 91 04 	call	0x922	; 0x922 <prvUnlockQueue>
				if( !xTaskResumeAll() )
     aec:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
     af0:	88 23       	and	r24, r24
     af2:	09 f0       	breq	.+2      	; 0xaf6 <xQueueGenericReceive+0x154>
     af4:	7e cf       	rjmp	.-260    	; 0x9f2 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
     af6:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
     afa:	7b cf       	rjmp	.-266    	; 0x9f2 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     afc:	c8 01       	movw	r24, r16
     afe:	0e 94 91 04 	call	0x922	; 0x922 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b02:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
     b06:	75 cf       	rjmp	.-278    	; 0x9f2 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b08:	c8 01       	movw	r24, r16
     b0a:	0e 94 91 04 	call	0x922	; 0x922 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b0e:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
     b12:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
     b14:	0f 90       	pop	r0
     b16:	0f 90       	pop	r0
     b18:	0f 90       	pop	r0
     b1a:	0f 90       	pop	r0
     b1c:	0f 90       	pop	r0
     b1e:	cf 91       	pop	r28
     b20:	df 91       	pop	r29
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	ff 90       	pop	r15
     b28:	ef 90       	pop	r14
     b2a:	df 90       	pop	r13
     b2c:	cf 90       	pop	r12
     b2e:	bf 90       	pop	r11
     b30:	af 90       	pop	r10
     b32:	9f 90       	pop	r9
     b34:	8f 90       	pop	r8
     b36:	7f 90       	pop	r7
     b38:	08 95       	ret

00000b3a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     b3a:	7f 92       	push	r7
     b3c:	8f 92       	push	r8
     b3e:	9f 92       	push	r9
     b40:	af 92       	push	r10
     b42:	bf 92       	push	r11
     b44:	cf 92       	push	r12
     b46:	df 92       	push	r13
     b48:	ef 92       	push	r14
     b4a:	ff 92       	push	r15
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	df 93       	push	r29
     b52:	cf 93       	push	r28
     b54:	00 d0       	rcall	.+0      	; 0xb56 <xQueueGenericSend+0x1c>
     b56:	00 d0       	rcall	.+0      	; 0xb58 <xQueueGenericSend+0x1e>
     b58:	0f 92       	push	r0
     b5a:	cd b7       	in	r28, 0x3d	; 61
     b5c:	de b7       	in	r29, 0x3e	; 62
     b5e:	8c 01       	movw	r16, r24
     b60:	6b 01       	movw	r12, r22
     b62:	5d 83       	std	Y+5, r21	; 0x05
     b64:	4c 83       	std	Y+4, r20	; 0x04
     b66:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     b68:	48 e0       	ldi	r20, 0x08	; 8
     b6a:	e4 2e       	mov	r14, r20
     b6c:	f1 2c       	mov	r15, r1
     b6e:	e8 0e       	add	r14, r24
     b70:	f9 1e       	adc	r15, r25
     b72:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b74:	5e 01       	movw	r10, r28
     b76:	08 94       	sec
     b78:	a1 1c       	adc	r10, r1
     b7a:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b7c:	34 e0       	ldi	r19, 0x04	; 4
     b7e:	83 2e       	mov	r8, r19
     b80:	91 2c       	mov	r9, r1
     b82:	8c 0e       	add	r8, r28
     b84:	9d 1e       	adc	r9, r29
     b86:	01 c0       	rjmp	.+2      	; 0xb8a <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     b88:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     b90:	f8 01       	movw	r30, r16
     b92:	92 8d       	ldd	r25, Z+26	; 0x1a
     b94:	83 8d       	ldd	r24, Z+27	; 0x1b
     b96:	98 17       	cp	r25, r24
     b98:	a8 f4       	brcc	.+42     	; 0xbc4 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     b9a:	c8 01       	movw	r24, r16
     b9c:	b6 01       	movw	r22, r12
     b9e:	47 2d       	mov	r20, r7
     ba0:	0e 94 04 03 	call	0x608	; 0x608 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ba4:	f8 01       	movw	r30, r16
     ba6:	81 89       	ldd	r24, Z+17	; 0x11
     ba8:	88 23       	and	r24, r24
     baa:	41 f0       	breq	.+16     	; 0xbbc <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     bac:	c8 01       	movw	r24, r16
     bae:	41 96       	adiw	r24, 0x11	; 17
     bb0:	0e 94 49 07 	call	0xe92	; 0xe92 <xTaskRemoveFromEventList>
     bb4:	81 30       	cpi	r24, 0x01	; 1
     bb6:	11 f4       	brne	.+4      	; 0xbbc <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     bb8:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     bbc:	0f 90       	pop	r0
     bbe:	0f be       	out	0x3f, r0	; 63
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	4c c0       	rjmp	.+152    	; 0xc5c <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     bc4:	8c 81       	ldd	r24, Y+4	; 0x04
     bc6:	9d 81       	ldd	r25, Y+5	; 0x05
     bc8:	89 2b       	or	r24, r25
     bca:	19 f4       	brne	.+6      	; 0xbd2 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     bcc:	0f 90       	pop	r0
     bce:	0f be       	out	0x3f, r0	; 63
     bd0:	44 c0       	rjmp	.+136    	; 0xc5a <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     bd2:	22 23       	and	r18, r18
     bd4:	19 f4       	brne	.+6      	; 0xbdc <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     bd6:	c5 01       	movw	r24, r10
     bd8:	0e 94 00 07 	call	0xe00	; 0xe00 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     bdc:	0f 90       	pop	r0
     bde:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     be0:	0e 94 a4 06 	call	0xd48	; 0xd48 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     be4:	0f b6       	in	r0, 0x3f	; 63
     be6:	f8 94       	cli
     be8:	0f 92       	push	r0
     bea:	f8 01       	movw	r30, r16
     bec:	85 8d       	ldd	r24, Z+29	; 0x1d
     bee:	8f 3f       	cpi	r24, 0xFF	; 255
     bf0:	09 f4       	brne	.+2      	; 0xbf4 <xQueueGenericSend+0xba>
     bf2:	15 8e       	std	Z+29, r1	; 0x1d
     bf4:	f8 01       	movw	r30, r16
     bf6:	86 8d       	ldd	r24, Z+30	; 0x1e
     bf8:	8f 3f       	cpi	r24, 0xFF	; 255
     bfa:	09 f4       	brne	.+2      	; 0xbfe <xQueueGenericSend+0xc4>
     bfc:	16 8e       	std	Z+30, r1	; 0x1e
     bfe:	0f 90       	pop	r0
     c00:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c02:	c5 01       	movw	r24, r10
     c04:	b4 01       	movw	r22, r8
     c06:	0e 94 0b 07 	call	0xe16	; 0xe16 <xTaskCheckForTimeOut>
     c0a:	88 23       	and	r24, r24
     c0c:	09 f5       	brne	.+66     	; 0xc50 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     c14:	f8 01       	movw	r30, r16
     c16:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     c18:	0f 90       	pop	r0
     c1a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
     c1c:	f8 01       	movw	r30, r16
     c1e:	83 8d       	ldd	r24, Z+27	; 0x1b
     c20:	98 17       	cp	r25, r24
     c22:	81 f4       	brne	.+32     	; 0xc44 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     c24:	6c 81       	ldd	r22, Y+4	; 0x04
     c26:	7d 81       	ldd	r23, Y+5	; 0x05
     c28:	c7 01       	movw	r24, r14
     c2a:	0e 94 02 08 	call	0x1004	; 0x1004 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     c2e:	c8 01       	movw	r24, r16
     c30:	0e 94 91 04 	call	0x922	; 0x922 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
     c34:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
     c38:	88 23       	and	r24, r24
     c3a:	09 f0       	breq	.+2      	; 0xc3e <xQueueGenericSend+0x104>
     c3c:	a5 cf       	rjmp	.-182    	; 0xb88 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
     c3e:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
     c42:	a2 cf       	rjmp	.-188    	; 0xb88 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c44:	c8 01       	movw	r24, r16
     c46:	0e 94 91 04 	call	0x922	; 0x922 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c4a:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
     c4e:	9c cf       	rjmp	.-200    	; 0xb88 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     c50:	c8 01       	movw	r24, r16
     c52:	0e 94 91 04 	call	0x922	; 0x922 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c56:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
     c5a:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
     c5c:	0f 90       	pop	r0
     c5e:	0f 90       	pop	r0
     c60:	0f 90       	pop	r0
     c62:	0f 90       	pop	r0
     c64:	0f 90       	pop	r0
     c66:	cf 91       	pop	r28
     c68:	df 91       	pop	r29
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	ff 90       	pop	r15
     c70:	ef 90       	pop	r14
     c72:	df 90       	pop	r13
     c74:	cf 90       	pop	r12
     c76:	bf 90       	pop	r11
     c78:	af 90       	pop	r10
     c7a:	9f 90       	pop	r9
     c7c:	8f 90       	pop	r8
     c7e:	7f 90       	pop	r7
     c80:	08 95       	ret

00000c82 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     c82:	8f 92       	push	r8
     c84:	9f 92       	push	r9
     c86:	af 92       	push	r10
     c88:	bf 92       	push	r11
     c8a:	cf 92       	push	r12
     c8c:	df 92       	push	r13
     c8e:	ef 92       	push	r14
     c90:	ff 92       	push	r15
     c92:	0f 93       	push	r16
     c94:	1f 93       	push	r17
     c96:	cf 93       	push	r28
     c98:	df 93       	push	r29
     c9a:	98 2e       	mov	r9, r24
     c9c:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     c9e:	88 23       	and	r24, r24
     ca0:	09 f4       	brne	.+2      	; 0xca4 <xQueueCreate+0x22>
     ca2:	42 c0       	rjmp	.+132    	; 0xd28 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     ca4:	8f e1       	ldi	r24, 0x1F	; 31
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pvPortMalloc>
     cac:	8c 01       	movw	r16, r24
     cae:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     cb0:	00 97       	sbiw	r24, 0x00	; 0
     cb2:	e1 f1       	breq	.+120    	; 0xd2c <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     cb4:	c9 2c       	mov	r12, r9
     cb6:	dd 24       	eor	r13, r13
     cb8:	a8 2c       	mov	r10, r8
     cba:	bb 24       	eor	r11, r11
     cbc:	ac 9c       	mul	r10, r12
     cbe:	70 01       	movw	r14, r0
     cc0:	ad 9c       	mul	r10, r13
     cc2:	f0 0c       	add	r15, r0
     cc4:	bc 9c       	mul	r11, r12
     cc6:	f0 0c       	add	r15, r0
     cc8:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     cca:	c7 01       	movw	r24, r14
     ccc:	01 96       	adiw	r24, 0x01	; 1
     cce:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pvPortMalloc>
     cd2:	9c 01       	movw	r18, r24
     cd4:	99 83       	std	Y+1, r25	; 0x01
     cd6:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     cd8:	00 97       	sbiw	r24, 0x00	; 0
     cda:	19 f1       	breq	.+70     	; 0xd22 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     cdc:	e8 0e       	add	r14, r24
     cde:	f9 1e       	adc	r15, r25
     ce0:	fb 82       	std	Y+3, r15	; 0x03
     ce2:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
     ce4:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     ce6:	9d 83       	std	Y+5, r25	; 0x05
     ce8:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
     cea:	08 94       	sec
     cec:	c1 08       	sbc	r12, r1
     cee:	d1 08       	sbc	r13, r1
     cf0:	ca 9c       	mul	r12, r10
     cf2:	c0 01       	movw	r24, r0
     cf4:	cb 9c       	mul	r12, r11
     cf6:	90 0d       	add	r25, r0
     cf8:	da 9c       	mul	r13, r10
     cfa:	90 0d       	add	r25, r0
     cfc:	11 24       	eor	r1, r1
     cfe:	28 0f       	add	r18, r24
     d00:	39 1f       	adc	r19, r25
     d02:	3f 83       	std	Y+7, r19	; 0x07
     d04:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     d06:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     d08:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     d0a:	8f ef       	ldi	r24, 0xFF	; 255
     d0c:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     d0e:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     d10:	c8 01       	movw	r24, r16
     d12:	08 96       	adiw	r24, 0x08	; 8
     d14:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     d18:	c8 01       	movw	r24, r16
     d1a:	41 96       	adiw	r24, 0x11	; 17
     d1c:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
     d20:	05 c0       	rjmp	.+10     	; 0xd2c <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
     d22:	c8 01       	movw	r24, r16
     d24:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortFree>
     d28:	c0 e0       	ldi	r28, 0x00	; 0
     d2a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
     d2c:	ce 01       	movw	r24, r28
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	df 90       	pop	r13
     d3c:	cf 90       	pop	r12
     d3e:	bf 90       	pop	r11
     d40:	af 90       	pop	r10
     d42:	9f 90       	pop	r9
     d44:	8f 90       	pop	r8
     d46:	08 95       	ret

00000d48 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     d48:	80 91 aa 00 	lds	r24, 0x00AA
     d4c:	8f 5f       	subi	r24, 0xFF	; 255
     d4e:	80 93 aa 00 	sts	0x00AA, r24
}
     d52:	08 95       	ret

00000d54 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
     d54:	0f b6       	in	r0, 0x3f	; 63
     d56:	f8 94       	cli
     d58:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     d5a:	20 91 a8 00 	lds	r18, 0x00A8
     d5e:	30 91 a9 00 	lds	r19, 0x00A9
	}
	portEXIT_CRITICAL();
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     d66:	c9 01       	movw	r24, r18
     d68:	08 95       	ret

00000d6a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
     d6a:	20 91 a8 00 	lds	r18, 0x00A8
     d6e:	30 91 a9 00 	lds	r19, 0x00A9
}
     d72:	c9 01       	movw	r24, r18
     d74:	08 95       	ret

00000d76 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     d76:	80 91 ad 00 	lds	r24, 0x00AD
}
     d7a:	08 95       	ret

00000d7c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     d7c:	80 91 aa 00 	lds	r24, 0x00AA
     d80:	88 23       	and	r24, r24
     d82:	51 f0       	breq	.+20     	; 0xd98 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     d84:	81 e0       	ldi	r24, 0x01	; 1
     d86:	80 93 a6 00 	sts	0x00A6, r24
     d8a:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
     d8c:	80 91 ab 00 	lds	r24, 0x00AB
     d90:	81 50       	subi	r24, 0x01	; 1
     d92:	80 93 ab 00 	sts	0x00AB, r24
     d96:	01 c0       	rjmp	.+2      	; 0xd9a <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     d98:	99 e0       	ldi	r25, 0x09	; 9
     d9a:	e0 91 ab 00 	lds	r30, 0x00AB
     d9e:	e9 9f       	mul	r30, r25
     da0:	f0 01       	movw	r30, r0
     da2:	11 24       	eor	r1, r1
     da4:	ee 54       	subi	r30, 0x4E	; 78
     da6:	ff 4f       	sbci	r31, 0xFF	; 255
     da8:	80 81       	ld	r24, Z
     daa:	88 23       	and	r24, r24
     dac:	79 f3       	breq	.-34     	; 0xd8c <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
     dae:	90 91 ab 00 	lds	r25, 0x00AB
     db2:	89 e0       	ldi	r24, 0x09	; 9
     db4:	98 9f       	mul	r25, r24
     db6:	d0 01       	movw	r26, r0
     db8:	11 24       	eor	r1, r1
     dba:	ae 54       	subi	r26, 0x4E	; 78
     dbc:	bf 4f       	sbci	r27, 0xFF	; 255
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	ed 91       	ld	r30, X+
     dc2:	fc 91       	ld	r31, X
     dc4:	12 97       	sbiw	r26, 0x02	; 2
     dc6:	02 80       	ldd	r0, Z+2	; 0x02
     dc8:	f3 81       	ldd	r31, Z+3	; 0x03
     dca:	e0 2d       	mov	r30, r0
     dcc:	12 96       	adiw	r26, 0x02	; 2
     dce:	fc 93       	st	X, r31
     dd0:	ee 93       	st	-X, r30
     dd2:	11 97       	sbiw	r26, 0x01	; 1
     dd4:	cd 01       	movw	r24, r26
     dd6:	03 96       	adiw	r24, 0x03	; 3
     dd8:	e8 17       	cp	r30, r24
     dda:	f9 07       	cpc	r31, r25
     ddc:	31 f4       	brne	.+12     	; 0xdea <vTaskSwitchContext+0x6e>
     dde:	82 81       	ldd	r24, Z+2	; 0x02
     de0:	93 81       	ldd	r25, Z+3	; 0x03
     de2:	12 96       	adiw	r26, 0x02	; 2
     de4:	9c 93       	st	X, r25
     de6:	8e 93       	st	-X, r24
     de8:	11 97       	sbiw	r26, 0x01	; 1
     dea:	11 96       	adiw	r26, 0x01	; 1
     dec:	ed 91       	ld	r30, X+
     dee:	fc 91       	ld	r31, X
     df0:	12 97       	sbiw	r26, 0x02	; 2
     df2:	86 81       	ldd	r24, Z+6	; 0x06
     df4:	97 81       	ldd	r25, Z+7	; 0x07
     df6:	90 93 a5 00 	sts	0x00A5, r25
     dfa:	80 93 a4 00 	sts	0x00A4, r24
     dfe:	08 95       	ret

00000e00 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
     e00:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     e02:	80 91 a7 00 	lds	r24, 0x00A7
     e06:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     e08:	80 91 a8 00 	lds	r24, 0x00A8
     e0c:	90 91 a9 00 	lds	r25, 0x00A9
     e10:	92 83       	std	Z+2, r25	; 0x02
     e12:	81 83       	std	Z+1, r24	; 0x01
}
     e14:	08 95       	ret

00000e16 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
     e16:	fc 01       	movw	r30, r24
     e18:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
     e1a:	0f b6       	in	r0, 0x3f	; 63
     e1c:	f8 94       	cli
     e1e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
     e20:	90 91 a7 00 	lds	r25, 0x00A7
     e24:	80 81       	ld	r24, Z
     e26:	98 17       	cp	r25, r24
     e28:	49 f0       	breq	.+18     	; 0xe3c <xTaskCheckForTimeOut+0x26>
     e2a:	20 91 a8 00 	lds	r18, 0x00A8
     e2e:	30 91 a9 00 	lds	r19, 0x00A9
     e32:	81 81       	ldd	r24, Z+1	; 0x01
     e34:	92 81       	ldd	r25, Z+2	; 0x02
     e36:	28 17       	cp	r18, r24
     e38:	39 07       	cpc	r19, r25
     e3a:	18 f5       	brcc	.+70     	; 0xe82 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
     e3c:	80 91 a8 00 	lds	r24, 0x00A8
     e40:	90 91 a9 00 	lds	r25, 0x00A9
     e44:	21 81       	ldd	r18, Z+1	; 0x01
     e46:	32 81       	ldd	r19, Z+2	; 0x02
     e48:	4d 91       	ld	r20, X+
     e4a:	5c 91       	ld	r21, X
     e4c:	11 97       	sbiw	r26, 0x01	; 1
     e4e:	82 1b       	sub	r24, r18
     e50:	93 0b       	sbc	r25, r19
     e52:	84 17       	cp	r24, r20
     e54:	95 07       	cpc	r25, r21
     e56:	a8 f4       	brcc	.+42     	; 0xe82 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
     e58:	80 91 a8 00 	lds	r24, 0x00A8
     e5c:	90 91 a9 00 	lds	r25, 0x00A9
     e60:	28 1b       	sub	r18, r24
     e62:	39 0b       	sbc	r19, r25
     e64:	24 0f       	add	r18, r20
     e66:	35 1f       	adc	r19, r21
     e68:	2d 93       	st	X+, r18
     e6a:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     e6c:	80 91 a7 00 	lds	r24, 0x00A7
     e70:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     e72:	80 91 a8 00 	lds	r24, 0x00A8
     e76:	90 91 a9 00 	lds	r25, 0x00A9
     e7a:	92 83       	std	Z+2, r25	; 0x02
     e7c:	81 83       	std	Z+1, r24	; 0x01
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	01 c0       	rjmp	.+2      	; 0xe84 <xTaskCheckForTimeOut+0x6e>
     e82:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
     e84:	0f 90       	pop	r0
     e86:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     e88:	08 95       	ret

00000e8a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
     e8a:	81 e0       	ldi	r24, 0x01	; 1
     e8c:	80 93 a6 00 	sts	0x00A6, r24
}
     e90:	08 95       	ret

00000e92 <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     e92:	0f 93       	push	r16
     e94:	1f 93       	push	r17
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
     e9a:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     e9c:	80 81       	ld	r24, Z
     e9e:	88 23       	and	r24, r24
     ea0:	19 f4       	brne	.+6      	; 0xea8 <xTaskRemoveFromEventList+0x16>
     ea2:	c0 e0       	ldi	r28, 0x00	; 0
     ea4:	d0 e0       	ldi	r29, 0x00	; 0
     ea6:	05 c0       	rjmp	.+10     	; 0xeb2 <xTaskRemoveFromEventList+0x20>
     ea8:	05 80       	ldd	r0, Z+5	; 0x05
     eaa:	f6 81       	ldd	r31, Z+6	; 0x06
     eac:	e0 2d       	mov	r30, r0
     eae:	c6 81       	ldd	r28, Z+6	; 0x06
     eb0:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
     eb2:	8e 01       	movw	r16, r28
     eb4:	04 5f       	subi	r16, 0xF4	; 244
     eb6:	1f 4f       	sbci	r17, 0xFF	; 255
     eb8:	c8 01       	movw	r24, r16
     eba:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     ebe:	80 91 aa 00 	lds	r24, 0x00AA
     ec2:	88 23       	and	r24, r24
     ec4:	a1 f4       	brne	.+40     	; 0xeee <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     ec6:	8e 01       	movw	r16, r28
     ec8:	0e 5f       	subi	r16, 0xFE	; 254
     eca:	1f 4f       	sbci	r17, 0xFF	; 255
     ecc:	c8 01       	movw	r24, r16
     ece:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
     ed2:	9e 89       	ldd	r25, Y+22	; 0x16
     ed4:	80 91 ab 00 	lds	r24, 0x00AB
     ed8:	89 17       	cp	r24, r25
     eda:	10 f4       	brcc	.+4      	; 0xee0 <xTaskRemoveFromEventList+0x4e>
     edc:	90 93 ab 00 	sts	0x00AB, r25
     ee0:	89 e0       	ldi	r24, 0x09	; 9
     ee2:	98 9f       	mul	r25, r24
     ee4:	c0 01       	movw	r24, r0
     ee6:	11 24       	eor	r1, r1
     ee8:	8e 54       	subi	r24, 0x4E	; 78
     eea:	9f 4f       	sbci	r25, 0xFF	; 255
     eec:	02 c0       	rjmp	.+4      	; 0xef2 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     eee:	8c ee       	ldi	r24, 0xEC	; 236
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	b8 01       	movw	r22, r16
     ef4:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ef8:	e0 91 a4 00 	lds	r30, 0x00A4
     efc:	f0 91 a5 00 	lds	r31, 0x00A5
     f00:	20 e0       	ldi	r18, 0x00	; 0
     f02:	9e 89       	ldd	r25, Y+22	; 0x16
     f04:	86 89       	ldd	r24, Z+22	; 0x16
     f06:	98 17       	cp	r25, r24
     f08:	08 f0       	brcs	.+2      	; 0xf0c <xTaskRemoveFromEventList+0x7a>
     f0a:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     f0c:	82 2f       	mov	r24, r18
     f0e:	df 91       	pop	r29
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	08 95       	ret

00000f18 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
     f18:	ff 92       	push	r15
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     f22:	80 91 aa 00 	lds	r24, 0x00AA
     f26:	88 23       	and	r24, r24
     f28:	09 f0       	breq	.+2      	; 0xf2c <vTaskIncrementTick+0x14>
     f2a:	61 c0       	rjmp	.+194    	; 0xfee <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
     f2c:	80 91 a8 00 	lds	r24, 0x00A8
     f30:	90 91 a9 00 	lds	r25, 0x00A9
     f34:	01 96       	adiw	r24, 0x01	; 1
     f36:	90 93 a9 00 	sts	0x00A9, r25
     f3a:	80 93 a8 00 	sts	0x00A8, r24
		if( xTickCount == ( portTickType ) 0 )
     f3e:	80 91 a8 00 	lds	r24, 0x00A8
     f42:	90 91 a9 00 	lds	r25, 0x00A9
     f46:	89 2b       	or	r24, r25
     f48:	e9 f5       	brne	.+122    	; 0xfc4 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
     f4a:	80 91 e8 00 	lds	r24, 0x00E8
     f4e:	90 91 e9 00 	lds	r25, 0x00E9
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     f52:	20 91 ea 00 	lds	r18, 0x00EA
     f56:	30 91 eb 00 	lds	r19, 0x00EB
     f5a:	30 93 e9 00 	sts	0x00E9, r19
     f5e:	20 93 e8 00 	sts	0x00E8, r18
			pxOverflowDelayedTaskList = pxTemp;
     f62:	90 93 eb 00 	sts	0x00EB, r25
     f66:	80 93 ea 00 	sts	0x00EA, r24
			xNumOfOverflows++;
     f6a:	80 91 a7 00 	lds	r24, 0x00A7
     f6e:	8f 5f       	subi	r24, 0xFF	; 255
     f70:	80 93 a7 00 	sts	0x00A7, r24
     f74:	27 c0       	rjmp	.+78     	; 0xfc4 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     f76:	20 91 a8 00 	lds	r18, 0x00A8
     f7a:	30 91 a9 00 	lds	r19, 0x00A9
     f7e:	8a 81       	ldd	r24, Y+2	; 0x02
     f80:	9b 81       	ldd	r25, Y+3	; 0x03
     f82:	28 17       	cp	r18, r24
     f84:	39 07       	cpc	r19, r25
     f86:	c0 f1       	brcs	.+112    	; 0xff8 <vTaskIncrementTick+0xe0>
     f88:	8e 01       	movw	r16, r28
     f8a:	0e 5f       	subi	r16, 0xFE	; 254
     f8c:	1f 4f       	sbci	r17, 0xFF	; 255
     f8e:	c8 01       	movw	r24, r16
     f90:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
     f94:	8c 89       	ldd	r24, Y+20	; 0x14
     f96:	9d 89       	ldd	r25, Y+21	; 0x15
     f98:	89 2b       	or	r24, r25
     f9a:	21 f0       	breq	.+8      	; 0xfa4 <vTaskIncrementTick+0x8c>
     f9c:	ce 01       	movw	r24, r28
     f9e:	0c 96       	adiw	r24, 0x0c	; 12
     fa0:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
     fa4:	9e 89       	ldd	r25, Y+22	; 0x16
     fa6:	80 91 ab 00 	lds	r24, 0x00AB
     faa:	89 17       	cp	r24, r25
     fac:	10 f4       	brcc	.+4      	; 0xfb2 <vTaskIncrementTick+0x9a>
     fae:	90 93 ab 00 	sts	0x00AB, r25
     fb2:	9f 9d       	mul	r25, r15
     fb4:	c0 01       	movw	r24, r0
     fb6:	11 24       	eor	r1, r1
     fb8:	8e 54       	subi	r24, 0x4E	; 78
     fba:	9f 4f       	sbci	r25, 0xFF	; 255
     fbc:	b8 01       	movw	r22, r16
     fbe:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>
     fc2:	02 c0       	rjmp	.+4      	; 0xfc8 <vTaskIncrementTick+0xb0>
     fc4:	89 e0       	ldi	r24, 0x09	; 9
     fc6:	f8 2e       	mov	r15, r24
     fc8:	e0 91 e8 00 	lds	r30, 0x00E8
     fcc:	f0 91 e9 00 	lds	r31, 0x00E9
     fd0:	80 81       	ld	r24, Z
     fd2:	88 23       	and	r24, r24
     fd4:	89 f0       	breq	.+34     	; 0xff8 <vTaskIncrementTick+0xe0>
     fd6:	e0 91 e8 00 	lds	r30, 0x00E8
     fda:	f0 91 e9 00 	lds	r31, 0x00E9
     fde:	05 80       	ldd	r0, Z+5	; 0x05
     fe0:	f6 81       	ldd	r31, Z+6	; 0x06
     fe2:	e0 2d       	mov	r30, r0
     fe4:	c6 81       	ldd	r28, Z+6	; 0x06
     fe6:	d7 81       	ldd	r29, Z+7	; 0x07
     fe8:	20 97       	sbiw	r28, 0x00	; 0
     fea:	29 f6       	brne	.-118    	; 0xf76 <vTaskIncrementTick+0x5e>
     fec:	05 c0       	rjmp	.+10     	; 0xff8 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
     fee:	80 91 ac 00 	lds	r24, 0x00AC
     ff2:	8f 5f       	subi	r24, 0xFF	; 255
     ff4:	80 93 ac 00 	sts	0x00AC, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	ff 90       	pop	r15
    1002:	08 95       	ret

00001004 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1004:	0f 93       	push	r16
    1006:	1f 93       	push	r17
    1008:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    100a:	60 91 a4 00 	lds	r22, 0x00A4
    100e:	70 91 a5 00 	lds	r23, 0x00A5
    1012:	64 5f       	subi	r22, 0xF4	; 244
    1014:	7f 4f       	sbci	r23, 0xFF	; 255
    1016:	0e 94 8b 02 	call	0x516	; 0x516 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    101a:	80 91 a4 00 	lds	r24, 0x00A4
    101e:	90 91 a5 00 	lds	r25, 0x00A5
    1022:	02 96       	adiw	r24, 0x02	; 2
    1024:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1028:	80 91 a8 00 	lds	r24, 0x00A8
    102c:	90 91 a9 00 	lds	r25, 0x00A9
    1030:	80 0f       	add	r24, r16
    1032:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1034:	e0 91 a4 00 	lds	r30, 0x00A4
    1038:	f0 91 a5 00 	lds	r31, 0x00A5
    103c:	93 83       	std	Z+3, r25	; 0x03
    103e:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    1040:	20 91 a8 00 	lds	r18, 0x00A8
    1044:	30 91 a9 00 	lds	r19, 0x00A9
    1048:	82 17       	cp	r24, r18
    104a:	93 07       	cpc	r25, r19
    104c:	28 f4       	brcc	.+10     	; 0x1058 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    104e:	80 91 ea 00 	lds	r24, 0x00EA
    1052:	90 91 eb 00 	lds	r25, 0x00EB
    1056:	04 c0       	rjmp	.+8      	; 0x1060 <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1058:	80 91 e8 00 	lds	r24, 0x00E8
    105c:	90 91 e9 00 	lds	r25, 0x00E9
    1060:	60 91 a4 00 	lds	r22, 0x00A4
    1064:	70 91 a5 00 	lds	r23, 0x00A5
    1068:	6e 5f       	subi	r22, 0xFE	; 254
    106a:	7f 4f       	sbci	r23, 0xFF	; 255
    106c:	0e 94 8b 02 	call	0x516	; 0x516 <vListInsert>
			}
	}
	#endif
}
    1070:	1f 91       	pop	r17
    1072:	0f 91       	pop	r16
    1074:	08 95       	ret

00001076 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1076:	cf 92       	push	r12
    1078:	df 92       	push	r13
    107a:	ff 92       	push	r15
    107c:	0f 93       	push	r16
    107e:	1f 93       	push	r17
    1080:	df 93       	push	r29
    1082:	cf 93       	push	r28
    1084:	0f 92       	push	r0
    1086:	cd b7       	in	r28, 0x3d	; 61
    1088:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    108a:	0f b6       	in	r0, 0x3f	; 63
    108c:	f8 94       	cli
    108e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1090:	80 91 aa 00 	lds	r24, 0x00AA
    1094:	81 50       	subi	r24, 0x01	; 1
    1096:	80 93 aa 00 	sts	0x00AA, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    109a:	80 91 aa 00 	lds	r24, 0x00AA
    109e:	88 23       	and	r24, r24
    10a0:	09 f0       	breq	.+2      	; 0x10a4 <xTaskResumeAll+0x2e>
    10a2:	5a c0       	rjmp	.+180    	; 0x1158 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    10a4:	80 91 ad 00 	lds	r24, 0x00AD
    10a8:	88 23       	and	r24, r24
    10aa:	09 f4       	brne	.+2      	; 0x10ae <xTaskResumeAll+0x38>
    10ac:	55 c0       	rjmp	.+170    	; 0x1158 <xTaskResumeAll+0xe2>
    10ae:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    10b0:	99 e0       	ldi	r25, 0x09	; 9
    10b2:	f9 2e       	mov	r15, r25
    10b4:	27 c0       	rjmp	.+78     	; 0x1104 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    10b6:	c6 01       	movw	r24, r12
    10b8:	0c 96       	adiw	r24, 0x0c	; 12
    10ba:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    10be:	86 01       	movw	r16, r12
    10c0:	0e 5f       	subi	r16, 0xFE	; 254
    10c2:	1f 4f       	sbci	r17, 0xFF	; 255
    10c4:	c8 01       	movw	r24, r16
    10c6:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    10ca:	d6 01       	movw	r26, r12
    10cc:	56 96       	adiw	r26, 0x16	; 22
    10ce:	9c 91       	ld	r25, X
    10d0:	80 91 ab 00 	lds	r24, 0x00AB
    10d4:	89 17       	cp	r24, r25
    10d6:	10 f4       	brcc	.+4      	; 0x10dc <xTaskResumeAll+0x66>
    10d8:	90 93 ab 00 	sts	0x00AB, r25
    10dc:	9f 9d       	mul	r25, r15
    10de:	c0 01       	movw	r24, r0
    10e0:	11 24       	eor	r1, r1
    10e2:	8e 54       	subi	r24, 0x4E	; 78
    10e4:	9f 4f       	sbci	r25, 0xFF	; 255
    10e6:	b8 01       	movw	r22, r16
    10e8:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    10ec:	e0 91 a4 00 	lds	r30, 0x00A4
    10f0:	f0 91 a5 00 	lds	r31, 0x00A5
    10f4:	d6 01       	movw	r26, r12
    10f6:	56 96       	adiw	r26, 0x16	; 22
    10f8:	9c 91       	ld	r25, X
    10fa:	86 89       	ldd	r24, Z+22	; 0x16
    10fc:	98 17       	cp	r25, r24
    10fe:	10 f0       	brcs	.+4      	; 0x1104 <xTaskResumeAll+0x8e>
    1100:	b1 e0       	ldi	r27, 0x01	; 1
    1102:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    1104:	80 91 ec 00 	lds	r24, 0x00EC
    1108:	88 23       	and	r24, r24
    110a:	49 f0       	breq	.+18     	; 0x111e <xTaskResumeAll+0xa8>
    110c:	e0 91 f1 00 	lds	r30, 0x00F1
    1110:	f0 91 f2 00 	lds	r31, 0x00F2
    1114:	c6 80       	ldd	r12, Z+6	; 0x06
    1116:	d7 80       	ldd	r13, Z+7	; 0x07
    1118:	c1 14       	cp	r12, r1
    111a:	d1 04       	cpc	r13, r1
    111c:	61 f6       	brne	.-104    	; 0x10b6 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    111e:	80 91 ac 00 	lds	r24, 0x00AC
    1122:	88 23       	and	r24, r24
    1124:	41 f4       	brne	.+16     	; 0x1136 <xTaskResumeAll+0xc0>
    1126:	0b c0       	rjmp	.+22     	; 0x113e <xTaskResumeAll+0xc8>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1128:	0e 94 8c 07 	call	0xf18	; 0xf18 <vTaskIncrementTick>
						--uxMissedTicks;
    112c:	80 91 ac 00 	lds	r24, 0x00AC
    1130:	81 50       	subi	r24, 0x01	; 1
    1132:	80 93 ac 00 	sts	0x00AC, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1136:	80 91 ac 00 	lds	r24, 0x00AC
    113a:	88 23       	and	r24, r24
    113c:	a9 f7       	brne	.-22     	; 0x1128 <xTaskResumeAll+0xb2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    113e:	e9 81       	ldd	r30, Y+1	; 0x01
    1140:	e1 30       	cpi	r30, 0x01	; 1
    1142:	21 f0       	breq	.+8      	; 0x114c <xTaskResumeAll+0xd6>
    1144:	80 91 a6 00 	lds	r24, 0x00A6
    1148:	81 30       	cpi	r24, 0x01	; 1
    114a:	31 f4       	brne	.+12     	; 0x1158 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    114c:	10 92 a6 00 	sts	0x00A6, r1
					portYIELD_WITHIN_API();
    1150:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
    1154:	81 e0       	ldi	r24, 0x01	; 1
    1156:	01 c0       	rjmp	.+2      	; 0x115a <xTaskResumeAll+0xe4>
    1158:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    115a:	0f 90       	pop	r0
    115c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    115e:	0f 90       	pop	r0
    1160:	cf 91       	pop	r28
    1162:	df 91       	pop	r29
    1164:	1f 91       	pop	r17
    1166:	0f 91       	pop	r16
    1168:	ff 90       	pop	r15
    116a:	df 90       	pop	r13
    116c:	cf 90       	pop	r12
    116e:	08 95       	ret

00001170 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1170:	0f 93       	push	r16
    1172:	1f 93       	push	r17
    1174:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    1176:	00 97       	sbiw	r24, 0x00	; 0
    1178:	a1 f1       	breq	.+104    	; 0x11e2 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    117a:	80 91 aa 00 	lds	r24, 0x00AA
    117e:	8f 5f       	subi	r24, 0xFF	; 255
    1180:	80 93 aa 00 	sts	0x00AA, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1184:	00 91 a8 00 	lds	r16, 0x00A8
    1188:	10 91 a9 00 	lds	r17, 0x00A9
    118c:	02 0f       	add	r16, r18
    118e:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1190:	80 91 a4 00 	lds	r24, 0x00A4
    1194:	90 91 a5 00 	lds	r25, 0x00A5
    1198:	02 96       	adiw	r24, 0x02	; 2
    119a:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    119e:	e0 91 a4 00 	lds	r30, 0x00A4
    11a2:	f0 91 a5 00 	lds	r31, 0x00A5
    11a6:	13 83       	std	Z+3, r17	; 0x03
    11a8:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    11aa:	80 91 a8 00 	lds	r24, 0x00A8
    11ae:	90 91 a9 00 	lds	r25, 0x00A9
    11b2:	08 17       	cp	r16, r24
    11b4:	19 07       	cpc	r17, r25
    11b6:	28 f4       	brcc	.+10     	; 0x11c2 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11b8:	80 91 ea 00 	lds	r24, 0x00EA
    11bc:	90 91 eb 00 	lds	r25, 0x00EB
    11c0:	04 c0       	rjmp	.+8      	; 0x11ca <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    11c2:	80 91 e8 00 	lds	r24, 0x00E8
    11c6:	90 91 e9 00 	lds	r25, 0x00E9
    11ca:	60 91 a4 00 	lds	r22, 0x00A4
    11ce:	70 91 a5 00 	lds	r23, 0x00A5
    11d2:	6e 5f       	subi	r22, 0xFE	; 254
    11d4:	7f 4f       	sbci	r23, 0xFF	; 255
    11d6:	0e 94 8b 02 	call	0x516	; 0x516 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    11da:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    11de:	88 23       	and	r24, r24
    11e0:	11 f4       	brne	.+4      	; 0x11e6 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    11e2:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
		}
	}
    11e6:	1f 91       	pop	r17
    11e8:	0f 91       	pop	r16
    11ea:	08 95       	ret

000011ec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    11ec:	cf 93       	push	r28
    11ee:	df 93       	push	r29
    11f0:	fc 01       	movw	r30, r24
    11f2:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    11f4:	80 91 aa 00 	lds	r24, 0x00AA
    11f8:	8f 5f       	subi	r24, 0xFF	; 255
    11fa:	80 93 aa 00 	sts	0x00AA, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    11fe:	20 81       	ld	r18, Z
    1200:	31 81       	ldd	r19, Z+1	; 0x01
    1202:	c2 0f       	add	r28, r18
    1204:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    1206:	80 91 a8 00 	lds	r24, 0x00A8
    120a:	90 91 a9 00 	lds	r25, 0x00A9
    120e:	82 17       	cp	r24, r18
    1210:	93 07       	cpc	r25, r19
    1212:	28 f4       	brcc	.+10     	; 0x121e <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1214:	c2 17       	cp	r28, r18
    1216:	d3 07       	cpc	r29, r19
    1218:	28 f0       	brcs	.+10     	; 0x1224 <vTaskDelayUntil+0x38>
    121a:	20 e0       	ldi	r18, 0x00	; 0
    121c:	0c c0       	rjmp	.+24     	; 0x1236 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    121e:	c2 17       	cp	r28, r18
    1220:	d3 07       	cpc	r29, r19
    1222:	40 f0       	brcs	.+16     	; 0x1234 <vTaskDelayUntil+0x48>
    1224:	80 91 a8 00 	lds	r24, 0x00A8
    1228:	90 91 a9 00 	lds	r25, 0x00A9
    122c:	20 e0       	ldi	r18, 0x00	; 0
    122e:	8c 17       	cp	r24, r28
    1230:	9d 07       	cpc	r25, r29
    1232:	08 f4       	brcc	.+2      	; 0x1236 <vTaskDelayUntil+0x4a>
    1234:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1236:	d1 83       	std	Z+1, r29	; 0x01
    1238:	c0 83       	st	Z, r28

			if( xShouldDelay )
    123a:	22 23       	and	r18, r18
    123c:	29 f1       	breq	.+74     	; 0x1288 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    123e:	80 91 a4 00 	lds	r24, 0x00A4
    1242:	90 91 a5 00 	lds	r25, 0x00A5
    1246:	02 96       	adiw	r24, 0x02	; 2
    1248:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    124c:	e0 91 a4 00 	lds	r30, 0x00A4
    1250:	f0 91 a5 00 	lds	r31, 0x00A5
    1254:	d3 83       	std	Z+3, r29	; 0x03
    1256:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    1258:	80 91 a8 00 	lds	r24, 0x00A8
    125c:	90 91 a9 00 	lds	r25, 0x00A9
    1260:	c8 17       	cp	r28, r24
    1262:	d9 07       	cpc	r29, r25
    1264:	28 f4       	brcc	.+10     	; 0x1270 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1266:	80 91 ea 00 	lds	r24, 0x00EA
    126a:	90 91 eb 00 	lds	r25, 0x00EB
    126e:	04 c0       	rjmp	.+8      	; 0x1278 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1270:	80 91 e8 00 	lds	r24, 0x00E8
    1274:	90 91 e9 00 	lds	r25, 0x00E9
    1278:	60 91 a4 00 	lds	r22, 0x00A4
    127c:	70 91 a5 00 	lds	r23, 0x00A5
    1280:	6e 5f       	subi	r22, 0xFE	; 254
    1282:	7f 4f       	sbci	r23, 0xFF	; 255
    1284:	0e 94 8b 02 	call	0x516	; 0x516 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1288:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    128c:	88 23       	and	r24, r24
    128e:	11 f4       	brne	.+4      	; 0x1294 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    1290:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
		}
	}
    1294:	df 91       	pop	r29
    1296:	cf 91       	pop	r28
    1298:	08 95       	ret

0000129a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    129a:	ef 92       	push	r14
    129c:	ff 92       	push	r15
    129e:	0f 93       	push	r16
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    12a8:	0f b6       	in	r0, 0x3f	; 63
    12aa:	f8 94       	cli
    12ac:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    12ae:	80 91 a4 00 	lds	r24, 0x00A4
    12b2:	90 91 a5 00 	lds	r25, 0x00A5
    12b6:	08 17       	cp	r16, r24
    12b8:	19 07       	cpc	r17, r25
    12ba:	19 f4       	brne	.+6      	; 0x12c2 <vTaskDelete+0x28>
    12bc:	00 e0       	ldi	r16, 0x00	; 0
    12be:	10 e0       	ldi	r17, 0x00	; 0
    12c0:	03 c0       	rjmp	.+6      	; 0x12c8 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    12c2:	01 15       	cp	r16, r1
    12c4:	11 05       	cpc	r17, r1
    12c6:	29 f4       	brne	.+10     	; 0x12d2 <vTaskDelete+0x38>
    12c8:	c0 91 a4 00 	lds	r28, 0x00A4
    12cc:	d0 91 a5 00 	lds	r29, 0x00A5
    12d0:	01 c0       	rjmp	.+2      	; 0x12d4 <vTaskDelete+0x3a>
    12d2:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    12d4:	22 e0       	ldi	r18, 0x02	; 2
    12d6:	e2 2e       	mov	r14, r18
    12d8:	f1 2c       	mov	r15, r1
    12da:	ec 0e       	add	r14, r28
    12dc:	fd 1e       	adc	r15, r29
    12de:	c7 01       	movw	r24, r14
    12e0:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    12e4:	8c 89       	ldd	r24, Y+20	; 0x14
    12e6:	9d 89       	ldd	r25, Y+21	; 0x15
    12e8:	89 2b       	or	r24, r25
    12ea:	21 f0       	breq	.+8      	; 0x12f4 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    12ec:	ce 01       	movw	r24, r28
    12ee:	0c 96       	adiw	r24, 0x0c	; 12
    12f0:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    12f4:	85 ef       	ldi	r24, 0xF5	; 245
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	b7 01       	movw	r22, r14
    12fa:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    12fe:	80 91 af 00 	lds	r24, 0x00AF
    1302:	8f 5f       	subi	r24, 0xFF	; 255
    1304:	80 93 af 00 	sts	0x00AF, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1308:	80 91 b0 00 	lds	r24, 0x00B0
    130c:	8f 5f       	subi	r24, 0xFF	; 255
    130e:	80 93 b0 00 	sts	0x00B0, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    1312:	0f 90       	pop	r0
    1314:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1316:	80 91 ae 00 	lds	r24, 0x00AE
    131a:	88 23       	and	r24, r24
    131c:	21 f0       	breq	.+8      	; 0x1326 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    131e:	01 2b       	or	r16, r17
    1320:	11 f4       	brne	.+4      	; 0x1326 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    1322:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
			}
		}
	}
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	1f 91       	pop	r17
    132c:	0f 91       	pop	r16
    132e:	ff 90       	pop	r15
    1330:	ef 90       	pop	r14
    1332:	08 95       	ret

00001334 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1334:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1336:	10 92 ae 00 	sts	0x00AE, r1
	vPortEndScheduler();
    133a:	0e 94 df 0b 	call	0x17be	; 0x17be <vPortEndScheduler>
}
    133e:	08 95       	ret

00001340 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1340:	1f 93       	push	r17
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    1346:	80 91 af 00 	lds	r24, 0x00AF
    134a:	88 23       	and	r24, r24
    134c:	91 f1       	breq	.+100    	; 0x13b2 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    134e:	80 91 aa 00 	lds	r24, 0x00AA
    1352:	8f 5f       	subi	r24, 0xFF	; 255
    1354:	80 93 aa 00 	sts	0x00AA, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1358:	10 91 f5 00 	lds	r17, 0x00F5
			xTaskResumeAll();
    135c:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>

			if( !xListIsEmpty )
    1360:	11 23       	and	r17, r17
    1362:	39 f1       	breq	.+78     	; 0x13b2 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    1364:	0f b6       	in	r0, 0x3f	; 63
    1366:	f8 94       	cli
    1368:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    136a:	80 91 f5 00 	lds	r24, 0x00F5
    136e:	88 23       	and	r24, r24
    1370:	19 f4       	brne	.+6      	; 0x1378 <prvIdleTask+0x38>
    1372:	c0 e0       	ldi	r28, 0x00	; 0
    1374:	d0 e0       	ldi	r29, 0x00	; 0
    1376:	06 c0       	rjmp	.+12     	; 0x1384 <prvIdleTask+0x44>
    1378:	e0 91 fa 00 	lds	r30, 0x00FA
    137c:	f0 91 fb 00 	lds	r31, 0x00FB
    1380:	c6 81       	ldd	r28, Z+6	; 0x06
    1382:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1384:	ce 01       	movw	r24, r28
    1386:	02 96       	adiw	r24, 0x02	; 2
    1388:	0e 94 c0 02 	call	0x580	; 0x580 <vListRemove>
					--uxCurrentNumberOfTasks;
    138c:	80 91 ad 00 	lds	r24, 0x00AD
    1390:	81 50       	subi	r24, 0x01	; 1
    1392:	80 93 ad 00 	sts	0x00AD, r24
					--uxTasksDeleted;
    1396:	80 91 af 00 	lds	r24, 0x00AF
    139a:	81 50       	subi	r24, 0x01	; 1
    139c:	80 93 af 00 	sts	0x00AF, r24
				}
				portEXIT_CRITICAL();
    13a0:	0f 90       	pop	r0
    13a2:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    13a4:	8f 89       	ldd	r24, Y+23	; 0x17
    13a6:	98 8d       	ldd	r25, Y+24	; 0x18
    13a8:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortFree>
		vPortFree( pxTCB );
    13ac:	ce 01       	movw	r24, r28
    13ae:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortFree>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    13b2:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
    13b6:	c7 cf       	rjmp	.-114    	; 0x1346 <prvIdleTask+0x6>

000013b8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    13b8:	2f 92       	push	r2
    13ba:	3f 92       	push	r3
    13bc:	5f 92       	push	r5
    13be:	6f 92       	push	r6
    13c0:	7f 92       	push	r7
    13c2:	8f 92       	push	r8
    13c4:	9f 92       	push	r9
    13c6:	af 92       	push	r10
    13c8:	bf 92       	push	r11
    13ca:	cf 92       	push	r12
    13cc:	df 92       	push	r13
    13ce:	ef 92       	push	r14
    13d0:	ff 92       	push	r15
    13d2:	0f 93       	push	r16
    13d4:	1f 93       	push	r17
    13d6:	df 93       	push	r29
    13d8:	cf 93       	push	r28
    13da:	00 d0       	rcall	.+0      	; 0x13dc <xTaskGenericCreate+0x24>
    13dc:	00 d0       	rcall	.+0      	; 0x13de <xTaskGenericCreate+0x26>
    13de:	cd b7       	in	r28, 0x3d	; 61
    13e0:	de b7       	in	r29, 0x3e	; 62
    13e2:	9a 83       	std	Y+2, r25	; 0x02
    13e4:	89 83       	std	Y+1, r24	; 0x01
    13e6:	4b 01       	movw	r8, r22
    13e8:	5a 01       	movw	r10, r20
    13ea:	19 01       	movw	r2, r18
    13ec:	50 2e       	mov	r5, r16
    13ee:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    13f0:	81 e2       	ldi	r24, 0x21	; 33
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pvPortMalloc>
    13f8:	8b 83       	std	Y+3, r24	; 0x03
    13fa:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    13fc:	8b 81       	ldd	r24, Y+3	; 0x03
    13fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1400:	89 2b       	or	r24, r25
    1402:	89 f0       	breq	.+34     	; 0x1426 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1404:	c1 14       	cp	r12, r1
    1406:	d1 04       	cpc	r13, r1
    1408:	21 f4       	brne	.+8      	; 0x1412 <xTaskGenericCreate+0x5a>
    140a:	c5 01       	movw	r24, r10
    140c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pvPortMalloc>
    1410:	6c 01       	movw	r12, r24
    1412:	eb 81       	ldd	r30, Y+3	; 0x03
    1414:	fc 81       	ldd	r31, Y+4	; 0x04
    1416:	d0 8e       	std	Z+24, r13	; 0x18
    1418:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    141a:	c1 14       	cp	r12, r1
    141c:	d1 04       	cpc	r13, r1
    141e:	29 f4       	brne	.+10     	; 0x142a <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1420:	cf 01       	movw	r24, r30
    1422:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortFree>
    1426:	8f ef       	ldi	r24, 0xFF	; 255
    1428:	d5 c0       	rjmp	.+426    	; 0x15d4 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    142a:	c6 01       	movw	r24, r12
    142c:	65 ea       	ldi	r22, 0xA5	; 165
    142e:	70 e0       	ldi	r23, 0x00	; 0
    1430:	a5 01       	movw	r20, r10
    1432:	0e 94 c1 0c 	call	0x1982	; 0x1982 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    1436:	08 94       	sec
    1438:	a1 08       	sbc	r10, r1
    143a:	b1 08       	sbc	r11, r1
    143c:	eb 81       	ldd	r30, Y+3	; 0x03
    143e:	fc 81       	ldd	r31, Y+4	; 0x04
    1440:	e7 88       	ldd	r14, Z+23	; 0x17
    1442:	f0 8c       	ldd	r15, Z+24	; 0x18
    1444:	ea 0c       	add	r14, r10
    1446:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1448:	cf 01       	movw	r24, r30
    144a:	49 96       	adiw	r24, 0x19	; 25
    144c:	b4 01       	movw	r22, r8
    144e:	48 e0       	ldi	r20, 0x08	; 8
    1450:	50 e0       	ldi	r21, 0x00	; 0
    1452:	0e 94 c8 0c 	call	0x1990	; 0x1990 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    1456:	eb 81       	ldd	r30, Y+3	; 0x03
    1458:	fc 81       	ldd	r31, Y+4	; 0x04
    145a:	10 a2       	std	Z+32, r1	; 0x20
    145c:	05 2d       	mov	r16, r5
    145e:	f3 e0       	ldi	r31, 0x03	; 3
    1460:	f5 15       	cp	r31, r5
    1462:	08 f4       	brcc	.+2      	; 0x1466 <xTaskGenericCreate+0xae>
    1464:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    1466:	eb 81       	ldd	r30, Y+3	; 0x03
    1468:	fc 81       	ldd	r31, Y+4	; 0x04
    146a:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    146c:	42 e0       	ldi	r20, 0x02	; 2
    146e:	c4 2e       	mov	r12, r20
    1470:	d1 2c       	mov	r13, r1
    1472:	ce 0e       	add	r12, r30
    1474:	df 1e       	adc	r13, r31
    1476:	c6 01       	movw	r24, r12
    1478:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    147c:	8b 81       	ldd	r24, Y+3	; 0x03
    147e:	9c 81       	ldd	r25, Y+4	; 0x04
    1480:	0c 96       	adiw	r24, 0x0c	; 12
    1482:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	fc 01       	movw	r30, r24
    148c:	91 87       	std	Z+9, r25	; 0x09
    148e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1490:	84 e0       	ldi	r24, 0x04	; 4
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	80 1b       	sub	r24, r16
    1496:	91 09       	sbc	r25, r1
    1498:	95 87       	std	Z+13, r25	; 0x0d
    149a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    149c:	f3 8b       	std	Z+19, r31	; 0x13
    149e:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    14a0:	c7 01       	movw	r24, r14
    14a2:	69 81       	ldd	r22, Y+1	; 0x01
    14a4:	7a 81       	ldd	r23, Y+2	; 0x02
    14a6:	a1 01       	movw	r20, r2
    14a8:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <pxPortInitialiseStack>
    14ac:	eb 81       	ldd	r30, Y+3	; 0x03
    14ae:	fc 81       	ldd	r31, Y+4	; 0x04
    14b0:	91 83       	std	Z+1, r25	; 0x01
    14b2:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    14b4:	61 14       	cp	r6, r1
    14b6:	71 04       	cpc	r7, r1
    14b8:	21 f0       	breq	.+8      	; 0x14c2 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    14ba:	cf 01       	movw	r24, r30
    14bc:	f3 01       	movw	r30, r6
    14be:	91 83       	std	Z+1, r25	; 0x01
    14c0:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    14c2:	0f b6       	in	r0, 0x3f	; 63
    14c4:	f8 94       	cli
    14c6:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    14c8:	80 91 ad 00 	lds	r24, 0x00AD
    14cc:	8f 5f       	subi	r24, 0xFF	; 255
    14ce:	80 93 ad 00 	sts	0x00AD, r24
			if( pxCurrentTCB == NULL )
    14d2:	80 91 a4 00 	lds	r24, 0x00A4
    14d6:	90 91 a5 00 	lds	r25, 0x00A5
    14da:	89 2b       	or	r24, r25
    14dc:	b9 f5       	brne	.+110    	; 0x154c <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    14de:	eb 81       	ldd	r30, Y+3	; 0x03
    14e0:	fc 81       	ldd	r31, Y+4	; 0x04
    14e2:	f0 93 a5 00 	sts	0x00A5, r31
    14e6:	e0 93 a4 00 	sts	0x00A4, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    14ea:	80 91 ad 00 	lds	r24, 0x00AD
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	f1 f5       	brne	.+124    	; 0x156e <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    14f2:	82 eb       	ldi	r24, 0xB2	; 178
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
    14fa:	8b eb       	ldi	r24, 0xBB	; 187
    14fc:	90 e0       	ldi	r25, 0x00	; 0
    14fe:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
    1502:	84 ec       	ldi	r24, 0xC4	; 196
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
    150a:	8d ec       	ldi	r24, 0xCD	; 205
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1512:	36 ed       	ldi	r19, 0xD6	; 214
    1514:	e3 2e       	mov	r14, r19
    1516:	30 e0       	ldi	r19, 0x00	; 0
    1518:	f3 2e       	mov	r15, r19
    151a:	c7 01       	movw	r24, r14
    151c:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1520:	0f ed       	ldi	r16, 0xDF	; 223
    1522:	10 e0       	ldi	r17, 0x00	; 0
    1524:	c8 01       	movw	r24, r16
    1526:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    152a:	8c ee       	ldi	r24, 0xEC	; 236
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1532:	85 ef       	ldi	r24, 0xF5	; 245
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	0e 94 4e 02 	call	0x49c	; 0x49c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    153a:	f0 92 e9 00 	sts	0x00E9, r15
    153e:	e0 92 e8 00 	sts	0x00E8, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1542:	10 93 eb 00 	sts	0x00EB, r17
    1546:	00 93 ea 00 	sts	0x00EA, r16
    154a:	11 c0       	rjmp	.+34     	; 0x156e <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    154c:	80 91 ae 00 	lds	r24, 0x00AE
    1550:	88 23       	and	r24, r24
    1552:	69 f4       	brne	.+26     	; 0x156e <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1554:	e0 91 a4 00 	lds	r30, 0x00A4
    1558:	f0 91 a5 00 	lds	r31, 0x00A5
    155c:	86 89       	ldd	r24, Z+22	; 0x16
    155e:	58 16       	cp	r5, r24
    1560:	30 f0       	brcs	.+12     	; 0x156e <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    1562:	8b 81       	ldd	r24, Y+3	; 0x03
    1564:	9c 81       	ldd	r25, Y+4	; 0x04
    1566:	90 93 a5 00 	sts	0x00A5, r25
    156a:	80 93 a4 00 	sts	0x00A4, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	96 89       	ldd	r25, Z+22	; 0x16
    1574:	80 91 b1 00 	lds	r24, 0x00B1
    1578:	89 17       	cp	r24, r25
    157a:	10 f4       	brcc	.+4      	; 0x1580 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    157c:	90 93 b1 00 	sts	0x00B1, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1580:	80 91 b0 00 	lds	r24, 0x00B0
    1584:	8f 5f       	subi	r24, 0xFF	; 255
    1586:	80 93 b0 00 	sts	0x00B0, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	96 89       	ldd	r25, Z+22	; 0x16
    1590:	80 91 ab 00 	lds	r24, 0x00AB
    1594:	89 17       	cp	r24, r25
    1596:	10 f4       	brcc	.+4      	; 0x159c <xTaskGenericCreate+0x1e4>
    1598:	90 93 ab 00 	sts	0x00AB, r25
    159c:	eb 81       	ldd	r30, Y+3	; 0x03
    159e:	fc 81       	ldd	r31, Y+4	; 0x04
    15a0:	86 89       	ldd	r24, Z+22	; 0x16
    15a2:	29 e0       	ldi	r18, 0x09	; 9
    15a4:	82 9f       	mul	r24, r18
    15a6:	c0 01       	movw	r24, r0
    15a8:	11 24       	eor	r1, r1
    15aa:	8e 54       	subi	r24, 0x4E	; 78
    15ac:	9f 4f       	sbci	r25, 0xFF	; 255
    15ae:	b6 01       	movw	r22, r12
    15b0:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    15b4:	0f 90       	pop	r0
    15b6:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    15b8:	80 91 ae 00 	lds	r24, 0x00AE
    15bc:	88 23       	and	r24, r24
    15be:	49 f0       	breq	.+18     	; 0x15d2 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    15c0:	e0 91 a4 00 	lds	r30, 0x00A4
    15c4:	f0 91 a5 00 	lds	r31, 0x00A5
    15c8:	86 89       	ldd	r24, Z+22	; 0x16
    15ca:	85 15       	cp	r24, r5
    15cc:	10 f4       	brcc	.+4      	; 0x15d2 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    15ce:	0e 94 5f 0c 	call	0x18be	; 0x18be <vPortYield>
    15d2:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    15d4:	0f 90       	pop	r0
    15d6:	0f 90       	pop	r0
    15d8:	0f 90       	pop	r0
    15da:	0f 90       	pop	r0
    15dc:	cf 91       	pop	r28
    15de:	df 91       	pop	r29
    15e0:	1f 91       	pop	r17
    15e2:	0f 91       	pop	r16
    15e4:	ff 90       	pop	r15
    15e6:	ef 90       	pop	r14
    15e8:	df 90       	pop	r13
    15ea:	cf 90       	pop	r12
    15ec:	bf 90       	pop	r11
    15ee:	af 90       	pop	r10
    15f0:	9f 90       	pop	r9
    15f2:	8f 90       	pop	r8
    15f4:	7f 90       	pop	r7
    15f6:	6f 90       	pop	r6
    15f8:	5f 90       	pop	r5
    15fa:	3f 90       	pop	r3
    15fc:	2f 90       	pop	r2
    15fe:	08 95       	ret

00001600 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1600:	af 92       	push	r10
    1602:	bf 92       	push	r11
    1604:	cf 92       	push	r12
    1606:	df 92       	push	r13
    1608:	ef 92       	push	r14
    160a:	ff 92       	push	r15
    160c:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    160e:	80 ea       	ldi	r24, 0xA0	; 160
    1610:	99 e0       	ldi	r25, 0x09	; 9
    1612:	64 e6       	ldi	r22, 0x64	; 100
    1614:	70 e0       	ldi	r23, 0x00	; 0
    1616:	45 e5       	ldi	r20, 0x55	; 85
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	20 e0       	ldi	r18, 0x00	; 0
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	00 e0       	ldi	r16, 0x00	; 0
    1620:	ee 24       	eor	r14, r14
    1622:	ff 24       	eor	r15, r15
    1624:	cc 24       	eor	r12, r12
    1626:	dd 24       	eor	r13, r13
    1628:	aa 24       	eor	r10, r10
    162a:	bb 24       	eor	r11, r11
    162c:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    1630:	81 30       	cpi	r24, 0x01	; 1
    1632:	49 f4       	brne	.+18     	; 0x1646 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1634:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1636:	80 93 ae 00 	sts	0x00AE, r24
		xTickCount = ( portTickType ) 0;
    163a:	10 92 a9 00 	sts	0x00A9, r1
    163e:	10 92 a8 00 	sts	0x00A8, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    1642:	0e 94 aa 0b 	call	0x1754	; 0x1754 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    1646:	0f 91       	pop	r16
    1648:	ff 90       	pop	r15
    164a:	ef 90       	pop	r14
    164c:	df 90       	pop	r13
    164e:	cf 90       	pop	r12
    1650:	bf 90       	pop	r11
    1652:	af 90       	pop	r10
    1654:	08 95       	ret

00001656 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1656:	08 95       	ret

00001658 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1658:	10 92 ff 00 	sts	0x00FF, r1
    165c:	10 92 fe 00 	sts	0x00FE, r1
}
    1660:	08 95       	ret

00001662 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1662:	2c ed       	ldi	r18, 0xDC	; 220
    1664:	35 e0       	ldi	r19, 0x05	; 5
    1666:	80 91 fe 00 	lds	r24, 0x00FE
    166a:	90 91 ff 00 	lds	r25, 0x00FF
    166e:	28 1b       	sub	r18, r24
    1670:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    1672:	c9 01       	movw	r24, r18
    1674:	08 95       	ret

00001676 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1676:	0f 93       	push	r16
    1678:	1f 93       	push	r17
    167a:	cf 93       	push	r28
    167c:	df 93       	push	r29
    167e:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1680:	0e 94 a4 06 	call	0xd48	; 0xd48 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1684:	80 91 fe 00 	lds	r24, 0x00FE
    1688:	90 91 ff 00 	lds	r25, 0x00FF
    168c:	98 01       	movw	r18, r16
    168e:	28 0f       	add	r18, r24
    1690:	39 1f       	adc	r19, r25
    1692:	45 e0       	ldi	r20, 0x05	; 5
    1694:	2c 3d       	cpi	r18, 0xDC	; 220
    1696:	34 07       	cpc	r19, r20
    1698:	58 f4       	brcc	.+22     	; 0x16b0 <pvPortMalloc+0x3a>
    169a:	82 17       	cp	r24, r18
    169c:	93 07       	cpc	r25, r19
    169e:	40 f4       	brcc	.+16     	; 0x16b0 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    16a0:	ec 01       	movw	r28, r24
    16a2:	c0 50       	subi	r28, 0x00	; 0
    16a4:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
    16a6:	30 93 ff 00 	sts	0x00FF, r19
    16aa:	20 93 fe 00 	sts	0x00FE, r18
    16ae:	02 c0       	rjmp	.+4      	; 0x16b4 <pvPortMalloc+0x3e>
    16b0:	c0 e0       	ldi	r28, 0x00	; 0
    16b2:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    16b4:	0e 94 3b 08 	call	0x1076	; 0x1076 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    16b8:	ce 01       	movw	r24, r28
    16ba:	df 91       	pop	r29
    16bc:	cf 91       	pop	r28
    16be:	1f 91       	pop	r17
    16c0:	0f 91       	pop	r16
    16c2:	08 95       	ret

000016c4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    16c4:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    16c6:	91 e1       	ldi	r25, 0x11	; 17
    16c8:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    16ca:	22 e2       	ldi	r18, 0x22	; 34
    16cc:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    16ce:	83 e3       	ldi	r24, 0x33	; 51
    16d0:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    16d2:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    16d4:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    16d6:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    16d8:	80 e8       	ldi	r24, 0x80	; 128
    16da:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    16dc:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    16de:	82 e0       	ldi	r24, 0x02	; 2
    16e0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    16e2:	83 e0       	ldi	r24, 0x03	; 3
    16e4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    16e6:	84 e0       	ldi	r24, 0x04	; 4
    16e8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    16ea:	85 e0       	ldi	r24, 0x05	; 5
    16ec:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    16ee:	86 e0       	ldi	r24, 0x06	; 6
    16f0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    16f2:	87 e0       	ldi	r24, 0x07	; 7
    16f4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    16f6:	88 e0       	ldi	r24, 0x08	; 8
    16f8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    16fa:	89 e0       	ldi	r24, 0x09	; 9
    16fc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    16fe:	80 e1       	ldi	r24, 0x10	; 16
    1700:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1702:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1704:	82 e1       	ldi	r24, 0x12	; 18
    1706:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1708:	83 e1       	ldi	r24, 0x13	; 19
    170a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    170c:	84 e1       	ldi	r24, 0x14	; 20
    170e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1710:	85 e1       	ldi	r24, 0x15	; 21
    1712:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1714:	86 e1       	ldi	r24, 0x16	; 22
    1716:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1718:	87 e1       	ldi	r24, 0x17	; 23
    171a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    171c:	88 e1       	ldi	r24, 0x18	; 24
    171e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1720:	89 e1       	ldi	r24, 0x19	; 25
    1722:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1724:	80 e2       	ldi	r24, 0x20	; 32
    1726:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1728:	81 e2       	ldi	r24, 0x21	; 33
    172a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    172c:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    172e:	83 e2       	ldi	r24, 0x23	; 35
    1730:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1732:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1734:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1736:	86 e2       	ldi	r24, 0x26	; 38
    1738:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    173a:	87 e2       	ldi	r24, 0x27	; 39
    173c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    173e:	88 e2       	ldi	r24, 0x28	; 40
    1740:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1742:	89 e2       	ldi	r24, 0x29	; 41
    1744:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1746:	80 e3       	ldi	r24, 0x30	; 48
    1748:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    174a:	81 e3       	ldi	r24, 0x31	; 49
    174c:	82 93       	st	-Z, r24
    174e:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1750:	cf 01       	movw	r24, r30
    1752:	08 95       	ret

00001754 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    1754:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    1756:	8c e7       	ldi	r24, 0x7C	; 124
    1758:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    175a:	8b e0       	ldi	r24, 0x0B	; 11
    175c:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    175e:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1760:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    1762:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1764:	a0 91 a4 00 	lds	r26, 0x00A4
    1768:	b0 91 a5 00 	lds	r27, 0x00A5
    176c:	cd 91       	ld	r28, X+
    176e:	cd bf       	out	0x3d, r28	; 61
    1770:	dd 91       	ld	r29, X+
    1772:	de bf       	out	0x3e, r29	; 62
    1774:	ff 91       	pop	r31
    1776:	ef 91       	pop	r30
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	bf 91       	pop	r27
    177e:	af 91       	pop	r26
    1780:	9f 91       	pop	r25
    1782:	8f 91       	pop	r24
    1784:	7f 91       	pop	r23
    1786:	6f 91       	pop	r22
    1788:	5f 91       	pop	r21
    178a:	4f 91       	pop	r20
    178c:	3f 91       	pop	r19
    178e:	2f 91       	pop	r18
    1790:	1f 91       	pop	r17
    1792:	0f 91       	pop	r16
    1794:	ff 90       	pop	r15
    1796:	ef 90       	pop	r14
    1798:	df 90       	pop	r13
    179a:	cf 90       	pop	r12
    179c:	bf 90       	pop	r11
    179e:	af 90       	pop	r10
    17a0:	9f 90       	pop	r9
    17a2:	8f 90       	pop	r8
    17a4:	7f 90       	pop	r7
    17a6:	6f 90       	pop	r6
    17a8:	5f 90       	pop	r5
    17aa:	4f 90       	pop	r4
    17ac:	3f 90       	pop	r3
    17ae:	2f 90       	pop	r2
    17b0:	1f 90       	pop	r1
    17b2:	0f 90       	pop	r0
    17b4:	0f be       	out	0x3f, r0	; 63
    17b6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    17b8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    17ba:	81 e0       	ldi	r24, 0x01	; 1
    17bc:	08 95       	ret

000017be <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    17be:	08 95       	ret

000017c0 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    17c0:	1f 92       	push	r1
    17c2:	0f 92       	push	r0
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	0f 92       	push	r0
    17c8:	11 24       	eor	r1, r1
    17ca:	2f 93       	push	r18
    17cc:	3f 93       	push	r19
    17ce:	4f 93       	push	r20
    17d0:	5f 93       	push	r21
    17d2:	6f 93       	push	r22
    17d4:	7f 93       	push	r23
    17d6:	8f 93       	push	r24
    17d8:	9f 93       	push	r25
    17da:	af 93       	push	r26
    17dc:	bf 93       	push	r27
    17de:	ef 93       	push	r30
    17e0:	ff 93       	push	r31
		vTaskIncrementTick();
    17e2:	0e 94 8c 07 	call	0xf18	; 0xf18 <vTaskIncrementTick>
	}
    17e6:	ff 91       	pop	r31
    17e8:	ef 91       	pop	r30
    17ea:	bf 91       	pop	r27
    17ec:	af 91       	pop	r26
    17ee:	9f 91       	pop	r25
    17f0:	8f 91       	pop	r24
    17f2:	7f 91       	pop	r23
    17f4:	6f 91       	pop	r22
    17f6:	5f 91       	pop	r21
    17f8:	4f 91       	pop	r20
    17fa:	3f 91       	pop	r19
    17fc:	2f 91       	pop	r18
    17fe:	0f 90       	pop	r0
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	0f 90       	pop	r0
    1804:	1f 90       	pop	r1
    1806:	18 95       	reti

00001808 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1808:	0f 92       	push	r0
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	f8 94       	cli
    180e:	0f 92       	push	r0
    1810:	1f 92       	push	r1
    1812:	11 24       	eor	r1, r1
    1814:	2f 92       	push	r2
    1816:	3f 92       	push	r3
    1818:	4f 92       	push	r4
    181a:	5f 92       	push	r5
    181c:	6f 92       	push	r6
    181e:	7f 92       	push	r7
    1820:	8f 92       	push	r8
    1822:	9f 92       	push	r9
    1824:	af 92       	push	r10
    1826:	bf 92       	push	r11
    1828:	cf 92       	push	r12
    182a:	df 92       	push	r13
    182c:	ef 92       	push	r14
    182e:	ff 92       	push	r15
    1830:	0f 93       	push	r16
    1832:	1f 93       	push	r17
    1834:	2f 93       	push	r18
    1836:	3f 93       	push	r19
    1838:	4f 93       	push	r20
    183a:	5f 93       	push	r21
    183c:	6f 93       	push	r22
    183e:	7f 93       	push	r23
    1840:	8f 93       	push	r24
    1842:	9f 93       	push	r25
    1844:	af 93       	push	r26
    1846:	bf 93       	push	r27
    1848:	cf 93       	push	r28
    184a:	df 93       	push	r29
    184c:	ef 93       	push	r30
    184e:	ff 93       	push	r31
    1850:	a0 91 a4 00 	lds	r26, 0x00A4
    1854:	b0 91 a5 00 	lds	r27, 0x00A5
    1858:	0d b6       	in	r0, 0x3d	; 61
    185a:	0d 92       	st	X+, r0
    185c:	0e b6       	in	r0, 0x3e	; 62
    185e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1860:	0e 94 8c 07 	call	0xf18	; 0xf18 <vTaskIncrementTick>
	vTaskSwitchContext();
    1864:	0e 94 be 06 	call	0xd7c	; 0xd7c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1868:	a0 91 a4 00 	lds	r26, 0x00A4
    186c:	b0 91 a5 00 	lds	r27, 0x00A5
    1870:	cd 91       	ld	r28, X+
    1872:	cd bf       	out	0x3d, r28	; 61
    1874:	dd 91       	ld	r29, X+
    1876:	de bf       	out	0x3e, r29	; 62
    1878:	ff 91       	pop	r31
    187a:	ef 91       	pop	r30
    187c:	df 91       	pop	r29
    187e:	cf 91       	pop	r28
    1880:	bf 91       	pop	r27
    1882:	af 91       	pop	r26
    1884:	9f 91       	pop	r25
    1886:	8f 91       	pop	r24
    1888:	7f 91       	pop	r23
    188a:	6f 91       	pop	r22
    188c:	5f 91       	pop	r21
    188e:	4f 91       	pop	r20
    1890:	3f 91       	pop	r19
    1892:	2f 91       	pop	r18
    1894:	1f 91       	pop	r17
    1896:	0f 91       	pop	r16
    1898:	ff 90       	pop	r15
    189a:	ef 90       	pop	r14
    189c:	df 90       	pop	r13
    189e:	cf 90       	pop	r12
    18a0:	bf 90       	pop	r11
    18a2:	af 90       	pop	r10
    18a4:	9f 90       	pop	r9
    18a6:	8f 90       	pop	r8
    18a8:	7f 90       	pop	r7
    18aa:	6f 90       	pop	r6
    18ac:	5f 90       	pop	r5
    18ae:	4f 90       	pop	r4
    18b0:	3f 90       	pop	r3
    18b2:	2f 90       	pop	r2
    18b4:	1f 90       	pop	r1
    18b6:	0f 90       	pop	r0
    18b8:	0f be       	out	0x3f, r0	; 63
    18ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18bc:	08 95       	ret

000018be <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    18be:	0f 92       	push	r0
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	0f 92       	push	r0
    18c6:	1f 92       	push	r1
    18c8:	11 24       	eor	r1, r1
    18ca:	2f 92       	push	r2
    18cc:	3f 92       	push	r3
    18ce:	4f 92       	push	r4
    18d0:	5f 92       	push	r5
    18d2:	6f 92       	push	r6
    18d4:	7f 92       	push	r7
    18d6:	8f 92       	push	r8
    18d8:	9f 92       	push	r9
    18da:	af 92       	push	r10
    18dc:	bf 92       	push	r11
    18de:	cf 92       	push	r12
    18e0:	df 92       	push	r13
    18e2:	ef 92       	push	r14
    18e4:	ff 92       	push	r15
    18e6:	0f 93       	push	r16
    18e8:	1f 93       	push	r17
    18ea:	2f 93       	push	r18
    18ec:	3f 93       	push	r19
    18ee:	4f 93       	push	r20
    18f0:	5f 93       	push	r21
    18f2:	6f 93       	push	r22
    18f4:	7f 93       	push	r23
    18f6:	8f 93       	push	r24
    18f8:	9f 93       	push	r25
    18fa:	af 93       	push	r26
    18fc:	bf 93       	push	r27
    18fe:	cf 93       	push	r28
    1900:	df 93       	push	r29
    1902:	ef 93       	push	r30
    1904:	ff 93       	push	r31
    1906:	a0 91 a4 00 	lds	r26, 0x00A4
    190a:	b0 91 a5 00 	lds	r27, 0x00A5
    190e:	0d b6       	in	r0, 0x3d	; 61
    1910:	0d 92       	st	X+, r0
    1912:	0e b6       	in	r0, 0x3e	; 62
    1914:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1916:	0e 94 be 06 	call	0xd7c	; 0xd7c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    191a:	a0 91 a4 00 	lds	r26, 0x00A4
    191e:	b0 91 a5 00 	lds	r27, 0x00A5
    1922:	cd 91       	ld	r28, X+
    1924:	cd bf       	out	0x3d, r28	; 61
    1926:	dd 91       	ld	r29, X+
    1928:	de bf       	out	0x3e, r29	; 62
    192a:	ff 91       	pop	r31
    192c:	ef 91       	pop	r30
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	bf 91       	pop	r27
    1934:	af 91       	pop	r26
    1936:	9f 91       	pop	r25
    1938:	8f 91       	pop	r24
    193a:	7f 91       	pop	r23
    193c:	6f 91       	pop	r22
    193e:	5f 91       	pop	r21
    1940:	4f 91       	pop	r20
    1942:	3f 91       	pop	r19
    1944:	2f 91       	pop	r18
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	df 90       	pop	r13
    1950:	cf 90       	pop	r12
    1952:	bf 90       	pop	r11
    1954:	af 90       	pop	r10
    1956:	9f 90       	pop	r9
    1958:	8f 90       	pop	r8
    195a:	7f 90       	pop	r7
    195c:	6f 90       	pop	r6
    195e:	5f 90       	pop	r5
    1960:	4f 90       	pop	r4
    1962:	3f 90       	pop	r3
    1964:	2f 90       	pop	r2
    1966:	1f 90       	pop	r1
    1968:	0f 90       	pop	r0
    196a:	0f be       	out	0x3f, r0	; 63
    196c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    196e:	08 95       	ret

00001970 <memcpy>:
    1970:	fb 01       	movw	r30, r22
    1972:	dc 01       	movw	r26, r24
    1974:	02 c0       	rjmp	.+4      	; 0x197a <memcpy+0xa>
    1976:	01 90       	ld	r0, Z+
    1978:	0d 92       	st	X+, r0
    197a:	41 50       	subi	r20, 0x01	; 1
    197c:	50 40       	sbci	r21, 0x00	; 0
    197e:	d8 f7       	brcc	.-10     	; 0x1976 <memcpy+0x6>
    1980:	08 95       	ret

00001982 <memset>:
    1982:	dc 01       	movw	r26, r24
    1984:	01 c0       	rjmp	.+2      	; 0x1988 <memset+0x6>
    1986:	6d 93       	st	X+, r22
    1988:	41 50       	subi	r20, 0x01	; 1
    198a:	50 40       	sbci	r21, 0x00	; 0
    198c:	e0 f7       	brcc	.-8      	; 0x1986 <memset+0x4>
    198e:	08 95       	ret

00001990 <strncpy>:
    1990:	fb 01       	movw	r30, r22
    1992:	dc 01       	movw	r26, r24
    1994:	41 50       	subi	r20, 0x01	; 1
    1996:	50 40       	sbci	r21, 0x00	; 0
    1998:	48 f0       	brcs	.+18     	; 0x19ac <strncpy+0x1c>
    199a:	01 90       	ld	r0, Z+
    199c:	0d 92       	st	X+, r0
    199e:	00 20       	and	r0, r0
    19a0:	c9 f7       	brne	.-14     	; 0x1994 <strncpy+0x4>
    19a2:	01 c0       	rjmp	.+2      	; 0x19a6 <strncpy+0x16>
    19a4:	1d 92       	st	X+, r1
    19a6:	41 50       	subi	r20, 0x01	; 1
    19a8:	50 40       	sbci	r21, 0x00	; 0
    19aa:	e0 f7       	brcc	.-8      	; 0x19a4 <strncpy+0x14>
    19ac:	08 95       	ret

000019ae <_exit>:
    19ae:	f8 94       	cli

000019b0 <__stop_program>:
    19b0:	ff cf       	rjmp	.-2      	; 0x19b0 <__stop_program>
