
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b4  00800200  000048c6  0000495a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000048c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001d33  008002b4  008002b4  00004a0e  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00004a0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000015ff  00000000  00000000  00004bae  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004cb6  00000000  00000000  000061ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001563  00000000  00000000  0000ae63  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003df9  00000000  00000000  0000c3c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000010b0  00000000  00000000  000101c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000021ad  00000000  00000000  00011270  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002390  00000000  00000000  0001341d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  000157ad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 00 	jmp	0x152	; 0x152 <__ctors_end>
       4:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
       8:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
       c:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      10:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      14:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      18:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      1c:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      20:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      24:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      28:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      2c:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      30:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      34:	0c 94 6e 14 	jmp	0x28dc	; 0x28dc <__vector_13>
      38:	0c 94 9b 14 	jmp	0x2936	; 0x2936 <__vector_14>
      3c:	0c 94 8d 12 	jmp	0x251a	; 0x251a <__vector_15>
      40:	0c 94 e7 13 	jmp	0x27ce	; 0x27ce <__vector_16>
      44:	0c 94 bb 0d 	jmp	0x1b76	; 0x1b76 <__vector_17>
      48:	0c 94 14 14 	jmp	0x2828	; 0x2828 <__vector_18>
      4c:	0c 94 41 14 	jmp	0x2882	; 0x2882 <__vector_19>
      50:	0c 94 4d 12 	jmp	0x249a	; 0x249a <__vector_20>
      54:	0c 94 8d 13 	jmp	0x271a	; 0x271a <__vector_21>
      58:	0c 94 ba 13 	jmp	0x2774	; 0x2774 <__vector_22>
      5c:	0c 94 fa 11 	jmp	0x23f4	; 0x23f4 <__vector_23>
      60:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      64:	0c 94 64 18 	jmp	0x30c8	; 0x30c8 <__vector_25>
      68:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      6c:	0c 94 c1 19 	jmp	0x3382	; 0x3382 <__vector_27>
      70:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      74:	0c 94 7b 1c 	jmp	0x38f6	; 0x38f6 <__vector_29>
      78:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      7c:	0c 94 c8 14 	jmp	0x2990	; 0x2990 <__vector_31>
      80:	0c 94 f5 14 	jmp	0x29ea	; 0x29ea <__vector_32>
      84:	0c 94 22 15 	jmp	0x2a44	; 0x2a44 <__vector_33>
      88:	0c 94 4f 15 	jmp	0x2a9e	; 0x2a9e <__vector_34>
      8c:	0c 94 cd 12 	jmp	0x259a	; 0x259a <__vector_35>
      90:	0c 94 3f 18 	jmp	0x307e	; 0x307e <__vector_36>
      94:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      98:	0c 94 9c 19 	jmp	0x3338	; 0x3338 <__vector_38>
      9c:	0c 94 99 20 	jmp	0x4132	; 0x4132 <__vector_39>
      a0:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      a4:	0c 94 7c 15 	jmp	0x2af8	; 0x2af8 <__vector_41>
      a8:	0c 94 a9 15 	jmp	0x2b52	; 0x2b52 <__vector_42>
      ac:	0c 94 d6 15 	jmp	0x2bac	; 0x2bac <__vector_43>
      b0:	0c 94 03 16 	jmp	0x2c06	; 0x2c06 <__vector_44>
      b4:	0c 94 0d 13 	jmp	0x261a	; 0x261a <__vector_45>
      b8:	0c 94 30 16 	jmp	0x2c60	; 0x2c60 <__vector_46>
      bc:	0c 94 5d 16 	jmp	0x2cba	; 0x2cba <__vector_47>
      c0:	0c 94 8a 16 	jmp	0x2d14	; 0x2d14 <__vector_48>
      c4:	0c 94 b7 16 	jmp	0x2d6e	; 0x2d6e <__vector_49>
      c8:	0c 94 4d 13 	jmp	0x269a	; 0x269a <__vector_50>
      cc:	0c 94 1a 18 	jmp	0x3034	; 0x3034 <__vector_51>
      d0:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      d4:	0c 94 77 19 	jmp	0x32ee	; 0x32ee <__vector_53>
      d8:	0c 94 f5 17 	jmp	0x2fea	; 0x2fea <__vector_54>
      dc:	0c 94 c6 00 	jmp	0x18c	; 0x18c <__bad_interrupt>
      e0:	0c 94 52 19 	jmp	0x32a4	; 0x32a4 <__vector_56>

000000e4 <__c.2853>:
      e4:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
      f4:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

000000ff <__c.2848>:
      ff:	2e 00                                               ..

00000101 <__c.2846>:
     101:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     111:	55 70 00                                            Up.

00000114 <TimerPrescaleFactor>:
     114:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

00000120 <Timer2PrescaleFactor>:
     120:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

00000130 <__c.1991>:
     130:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

00000141 <HexChars>:
     141:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

00000152 <__ctors_end>:
     152:	11 24       	eor	r1, r1
     154:	1f be       	out	0x3f, r1	; 63
     156:	cf ef       	ldi	r28, 0xFF	; 255
     158:	d1 e2       	ldi	r29, 0x21	; 33
     15a:	de bf       	out	0x3e, r29	; 62
     15c:	cd bf       	out	0x3d, r28	; 61

0000015e <__do_copy_data>:
     15e:	12 e0       	ldi	r17, 0x02	; 2
     160:	a0 e0       	ldi	r26, 0x00	; 0
     162:	b2 e0       	ldi	r27, 0x02	; 2
     164:	e6 ec       	ldi	r30, 0xC6	; 198
     166:	f8 e4       	ldi	r31, 0x48	; 72
     168:	02 c0       	rjmp	.+4      	; 0x16e <.do_copy_data_start>

0000016a <.do_copy_data_loop>:
     16a:	05 90       	lpm	r0, Z+
     16c:	0d 92       	st	X+, r0

0000016e <.do_copy_data_start>:
     16e:	a4 3b       	cpi	r26, 0xB4	; 180
     170:	b1 07       	cpc	r27, r17
     172:	d9 f7       	brne	.-10     	; 0x16a <.do_copy_data_loop>

00000174 <__do_clear_bss>:
     174:	1f e1       	ldi	r17, 0x1F	; 31
     176:	a4 eb       	ldi	r26, 0xB4	; 180
     178:	b2 e0       	ldi	r27, 0x02	; 2
     17a:	01 c0       	rjmp	.+2      	; 0x17e <.do_clear_bss_start>

0000017c <.do_clear_bss_loop>:
     17c:	1d 92       	st	X+, r1

0000017e <.do_clear_bss_start>:
     17e:	a7 3e       	cpi	r26, 0xE7	; 231
     180:	b1 07       	cpc	r27, r17
     182:	e1 f7       	brne	.-8      	; 0x17c <.do_clear_bss_loop>
     184:	0e 94 c6 04 	call	0x98c	; 0x98c <main>
     188:	0c 94 c5 21 	jmp	0x438a	; 0x438a <exit>

0000018c <__bad_interrupt>:
     18c:	0c 94 e4 16 	jmp	0x2dc8	; 0x2dc8 <__vector_default>

00000190 <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     190:	89 30       	cpi	r24, 0x09	; 9
     192:	49 f4       	brne	.+18     	; 0x1a6 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     194:	80 91 80 00 	lds	r24, 0x0080
     198:	82 60       	ori	r24, 0x02	; 2
     19a:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     19e:	80 91 80 00 	lds	r24, 0x0080
     1a2:	8e 7f       	andi	r24, 0xFE	; 254
     1a4:	0e c0       	rjmp	.+28     	; 0x1c2 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     1a6:	8a 30       	cpi	r24, 0x0A	; 10
     1a8:	21 f4       	brne	.+8      	; 0x1b2 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     1aa:	80 91 80 00 	lds	r24, 0x0080
     1ae:	82 60       	ori	r24, 0x02	; 2
     1b0:	03 c0       	rjmp	.+6      	; 0x1b8 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     1b2:	80 91 80 00 	lds	r24, 0x0080
     1b6:	8d 7f       	andi	r24, 0xFD	; 253
     1b8:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     1bc:	80 91 80 00 	lds	r24, 0x0080
     1c0:	81 60       	ori	r24, 0x01	; 1
     1c2:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     1c6:	10 92 8b 00 	sts	0x008B, r1
     1ca:	10 92 8a 00 	sts	0x008A, r1
}
     1ce:	08 95       	ret

000001d0 <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     1d0:	89 30       	cpi	r24, 0x09	; 9
     1d2:	49 f4       	brne	.+18     	; 0x1e6 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     1d4:	80 91 b0 00 	lds	r24, 0x00B0
     1d8:	82 60       	ori	r24, 0x02	; 2
     1da:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     1de:	80 91 b0 00 	lds	r24, 0x00B0
     1e2:	8e 7f       	andi	r24, 0xFE	; 254
     1e4:	0e c0       	rjmp	.+28     	; 0x202 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     1e6:	8a 30       	cpi	r24, 0x0A	; 10
     1e8:	21 f4       	brne	.+8      	; 0x1f2 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     1ea:	80 91 b0 00 	lds	r24, 0x00B0
     1ee:	82 60       	ori	r24, 0x02	; 2
     1f0:	03 c0       	rjmp	.+6      	; 0x1f8 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     1f2:	80 91 b0 00 	lds	r24, 0x00B0
     1f6:	8d 7f       	andi	r24, 0xFD	; 253
     1f8:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     1fc:	80 91 b0 00 	lds	r24, 0x00B0
     200:	81 60       	ori	r24, 0x01	; 1
     202:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     206:	10 92 b4 00 	sts	0x00B4, r1
}
     20a:	08 95       	ret

0000020c <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     20c:	89 30       	cpi	r24, 0x09	; 9
     20e:	49 f4       	brne	.+18     	; 0x222 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     210:	80 91 90 00 	lds	r24, 0x0090
     214:	82 60       	ori	r24, 0x02	; 2
     216:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     21a:	80 91 90 00 	lds	r24, 0x0090
     21e:	8e 7f       	andi	r24, 0xFE	; 254
     220:	0e c0       	rjmp	.+28     	; 0x23e <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     222:	8a 30       	cpi	r24, 0x0A	; 10
     224:	21 f4       	brne	.+8      	; 0x22e <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     226:	80 91 90 00 	lds	r24, 0x0090
     22a:	82 60       	ori	r24, 0x02	; 2
     22c:	03 c0       	rjmp	.+6      	; 0x234 <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     22e:	80 91 90 00 	lds	r24, 0x0090
     232:	8d 7f       	andi	r24, 0xFD	; 253
     234:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     238:	80 91 90 00 	lds	r24, 0x0090
     23c:	81 60       	ori	r24, 0x01	; 1
     23e:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     242:	10 92 99 00 	sts	0x0099, r1
     246:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     24a:	08 95       	ret

0000024c <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     24c:	89 30       	cpi	r24, 0x09	; 9
     24e:	49 f4       	brne	.+18     	; 0x262 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     250:	80 91 91 00 	lds	r24, 0x0091
     254:	82 60       	ori	r24, 0x02	; 2
     256:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     25a:	80 91 91 00 	lds	r24, 0x0091
     25e:	8e 7f       	andi	r24, 0xFE	; 254
     260:	0e c0       	rjmp	.+28     	; 0x27e <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     262:	8a 30       	cpi	r24, 0x0A	; 10
     264:	21 f4       	brne	.+8      	; 0x26e <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     266:	80 91 91 00 	lds	r24, 0x0091
     26a:	82 60       	ori	r24, 0x02	; 2
     26c:	03 c0       	rjmp	.+6      	; 0x274 <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     26e:	80 91 91 00 	lds	r24, 0x0091
     272:	8d 7f       	andi	r24, 0xFD	; 253
     274:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     278:	80 91 91 00 	lds	r24, 0x0091
     27c:	81 60       	ori	r24, 0x01	; 1
     27e:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     282:	10 92 9b 00 	sts	0x009B, r1
     286:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     28a:	08 95       	ret

0000028c <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     28c:	89 30       	cpi	r24, 0x09	; 9
     28e:	49 f4       	brne	.+18     	; 0x2a2 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     290:	80 91 92 00 	lds	r24, 0x0092
     294:	82 60       	ori	r24, 0x02	; 2
     296:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     29a:	80 91 92 00 	lds	r24, 0x0092
     29e:	8e 7f       	andi	r24, 0xFE	; 254
     2a0:	0e c0       	rjmp	.+28     	; 0x2be <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     2a2:	8a 30       	cpi	r24, 0x0A	; 10
     2a4:	21 f4       	brne	.+8      	; 0x2ae <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     2a6:	80 91 92 00 	lds	r24, 0x0092
     2aa:	82 60       	ori	r24, 0x02	; 2
     2ac:	03 c0       	rjmp	.+6      	; 0x2b4 <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     2ae:	80 91 92 00 	lds	r24, 0x0092
     2b2:	8d 7f       	andi	r24, 0xFD	; 253
     2b4:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     2b8:	80 91 92 00 	lds	r24, 0x0092
     2bc:	81 60       	ori	r24, 0x01	; 1
     2be:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     2c2:	10 92 9d 00 	sts	0x009D, r1
     2c6:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2ca:	08 95       	ret

000002cc <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     2cc:	89 30       	cpi	r24, 0x09	; 9
     2ce:	49 f4       	brne	.+18     	; 0x2e2 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     2d0:	80 91 a0 00 	lds	r24, 0x00A0
     2d4:	82 60       	ori	r24, 0x02	; 2
     2d6:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     2da:	80 91 a0 00 	lds	r24, 0x00A0
     2de:	8e 7f       	andi	r24, 0xFE	; 254
     2e0:	0e c0       	rjmp	.+28     	; 0x2fe <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     2e2:	8a 30       	cpi	r24, 0x0A	; 10
     2e4:	21 f4       	brne	.+8      	; 0x2ee <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     2e6:	80 91 a0 00 	lds	r24, 0x00A0
     2ea:	82 60       	ori	r24, 0x02	; 2
     2ec:	03 c0       	rjmp	.+6      	; 0x2f4 <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     2ee:	80 91 a0 00 	lds	r24, 0x00A0
     2f2:	8d 7f       	andi	r24, 0xFD	; 253
     2f4:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     2f8:	80 91 a0 00 	lds	r24, 0x00A0
     2fc:	81 60       	ori	r24, 0x01	; 1
     2fe:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     302:	10 92 a9 00 	sts	0x00A9, r1
     306:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     30a:	08 95       	ret

0000030c <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     30c:	89 30       	cpi	r24, 0x09	; 9
     30e:	49 f4       	brne	.+18     	; 0x322 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     310:	80 91 a1 00 	lds	r24, 0x00A1
     314:	82 60       	ori	r24, 0x02	; 2
     316:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     31a:	80 91 a1 00 	lds	r24, 0x00A1
     31e:	8e 7f       	andi	r24, 0xFE	; 254
     320:	0e c0       	rjmp	.+28     	; 0x33e <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     322:	8a 30       	cpi	r24, 0x0A	; 10
     324:	21 f4       	brne	.+8      	; 0x32e <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     326:	80 91 a1 00 	lds	r24, 0x00A1
     32a:	82 60       	ori	r24, 0x02	; 2
     32c:	03 c0       	rjmp	.+6      	; 0x334 <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     32e:	80 91 a1 00 	lds	r24, 0x00A1
     332:	8d 7f       	andi	r24, 0xFD	; 253
     334:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     338:	80 91 a1 00 	lds	r24, 0x00A1
     33c:	81 60       	ori	r24, 0x01	; 1
     33e:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     342:	10 92 ab 00 	sts	0x00AB, r1
     346:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     34a:	08 95       	ret

0000034c <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     34c:	89 30       	cpi	r24, 0x09	; 9
     34e:	49 f4       	brne	.+18     	; 0x362 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     350:	80 91 a0 00 	lds	r24, 0x00A0
     354:	82 60       	ori	r24, 0x02	; 2
     356:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     35a:	80 91 a0 00 	lds	r24, 0x00A0
     35e:	8e 7f       	andi	r24, 0xFE	; 254
     360:	0e c0       	rjmp	.+28     	; 0x37e <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     362:	8a 30       	cpi	r24, 0x0A	; 10
     364:	21 f4       	brne	.+8      	; 0x36e <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     366:	80 91 a0 00 	lds	r24, 0x00A0
     36a:	82 60       	ori	r24, 0x02	; 2
     36c:	03 c0       	rjmp	.+6      	; 0x374 <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     36e:	80 91 a0 00 	lds	r24, 0x00A0
     372:	8d 7f       	andi	r24, 0xFD	; 253
     374:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     378:	80 91 a0 00 	lds	r24, 0x00A0
     37c:	81 60       	ori	r24, 0x01	; 1
     37e:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     382:	10 92 ad 00 	sts	0x00AD, r1
     386:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     38a:	08 95       	ret

0000038c <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     38c:	e0 e8       	ldi	r30, 0x80	; 128
     38e:	f0 e0       	ldi	r31, 0x00	; 0
     390:	20 81       	ld	r18, Z
     392:	2e 7f       	andi	r18, 0xFE	; 254
     394:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     396:	20 81       	ld	r18, Z
     398:	22 60       	ori	r18, 0x02	; 2
     39a:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     39c:	e1 e8       	ldi	r30, 0x81	; 129
     39e:	f0 e0       	ldi	r31, 0x00	; 0
     3a0:	20 81       	ld	r18, Z
     3a2:	28 60       	ori	r18, 0x08	; 8
     3a4:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     3a6:	20 81       	ld	r18, Z
     3a8:	20 61       	ori	r18, 0x10	; 16
     3aa:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     3ac:	90 93 87 00 	sts	0x0087, r25
     3b0:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     3b4:	10 92 89 00 	sts	0x0089, r1
     3b8:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     3bc:	10 92 8b 00 	sts	0x008B, r1
     3c0:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     3c4:	10 92 8d 00 	sts	0x008D, r1
     3c8:	10 92 8c 00 	sts	0x008C, r1
}
     3cc:	08 95       	ret

000003ce <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     3ce:	e0 e9       	ldi	r30, 0x90	; 144
     3d0:	f0 e0       	ldi	r31, 0x00	; 0
     3d2:	20 81       	ld	r18, Z
     3d4:	2e 7f       	andi	r18, 0xFE	; 254
     3d6:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     3d8:	20 81       	ld	r18, Z
     3da:	22 60       	ori	r18, 0x02	; 2
     3dc:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     3de:	e1 e9       	ldi	r30, 0x91	; 145
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	20 81       	ld	r18, Z
     3e4:	28 60       	ori	r18, 0x08	; 8
     3e6:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     3e8:	20 81       	ld	r18, Z
     3ea:	20 61       	ori	r18, 0x10	; 16
     3ec:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     3ee:	90 93 97 00 	sts	0x0097, r25
     3f2:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     3f6:	10 92 99 00 	sts	0x0099, r1
     3fa:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     3fe:	10 92 9b 00 	sts	0x009B, r1
     402:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     406:	10 92 9d 00 	sts	0x009D, r1
     40a:	10 92 9c 00 	sts	0x009C, r1
}
     40e:	08 95       	ret

00000410 <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     410:	e0 ea       	ldi	r30, 0xA0	; 160
     412:	f0 e0       	ldi	r31, 0x00	; 0
     414:	20 81       	ld	r18, Z
     416:	2e 7f       	andi	r18, 0xFE	; 254
     418:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     41a:	20 81       	ld	r18, Z
     41c:	22 60       	ori	r18, 0x02	; 2
     41e:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     420:	e1 ea       	ldi	r30, 0xA1	; 161
     422:	f0 e0       	ldi	r31, 0x00	; 0
     424:	20 81       	ld	r18, Z
     426:	28 60       	ori	r18, 0x08	; 8
     428:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     42a:	20 81       	ld	r18, Z
     42c:	20 61       	ori	r18, 0x10	; 16
     42e:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     430:	90 93 a7 00 	sts	0x00A7, r25
     434:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     438:	10 92 a9 00 	sts	0x00A9, r1
     43c:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     440:	10 92 ab 00 	sts	0x00AB, r1
     444:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     448:	10 92 ad 00 	sts	0x00AD, r1
     44c:	10 92 ac 00 	sts	0x00AC, r1
}
     450:	08 95       	ret

00000452 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     452:	e0 e8       	ldi	r30, 0x80	; 128
     454:	f0 e0       	ldi	r31, 0x00	; 0
     456:	80 81       	ld	r24, Z
     458:	80 62       	ori	r24, 0x20	; 32
     45a:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     45c:	80 81       	ld	r24, Z
     45e:	8f 7e       	andi	r24, 0xEF	; 239
     460:	80 83       	st	Z, r24
}
     462:	08 95       	ret

00000464 <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     464:	e0 eb       	ldi	r30, 0xB0	; 176
     466:	f0 e0       	ldi	r31, 0x00	; 0
     468:	80 81       	ld	r24, Z
     46a:	80 62       	ori	r24, 0x20	; 32
     46c:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     46e:	80 81       	ld	r24, Z
     470:	8f 7e       	andi	r24, 0xEF	; 239
     472:	80 83       	st	Z, r24
}
     474:	08 95       	ret

00000476 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     476:	e0 e9       	ldi	r30, 0x90	; 144
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	80 81       	ld	r24, Z
     47c:	80 68       	ori	r24, 0x80	; 128
     47e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     480:	80 81       	ld	r24, Z
     482:	8f 7b       	andi	r24, 0xBF	; 191
     484:	80 83       	st	Z, r24
}
     486:	08 95       	ret

00000488 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     488:	e0 e9       	ldi	r30, 0x90	; 144
     48a:	f0 e0       	ldi	r31, 0x00	; 0
     48c:	80 81       	ld	r24, Z
     48e:	80 62       	ori	r24, 0x20	; 32
     490:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     492:	80 81       	ld	r24, Z
     494:	8f 7e       	andi	r24, 0xEF	; 239
     496:	80 83       	st	Z, r24
}
     498:	08 95       	ret

0000049a <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     49a:	e0 e9       	ldi	r30, 0x90	; 144
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	80 81       	ld	r24, Z
     4a0:	88 60       	ori	r24, 0x08	; 8
     4a2:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     4a4:	80 81       	ld	r24, Z
     4a6:	8b 7f       	andi	r24, 0xFB	; 251
     4a8:	80 83       	st	Z, r24
}
     4aa:	08 95       	ret

000004ac <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     4ac:	e0 ea       	ldi	r30, 0xA0	; 160
     4ae:	f0 e0       	ldi	r31, 0x00	; 0
     4b0:	80 81       	ld	r24, Z
     4b2:	80 68       	ori	r24, 0x80	; 128
     4b4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     4b6:	80 81       	ld	r24, Z
     4b8:	8f 7b       	andi	r24, 0xBF	; 191
     4ba:	80 83       	st	Z, r24
}
     4bc:	08 95       	ret

000004be <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     4be:	e0 ea       	ldi	r30, 0xA0	; 160
     4c0:	f0 e0       	ldi	r31, 0x00	; 0
     4c2:	80 81       	ld	r24, Z
     4c4:	80 62       	ori	r24, 0x20	; 32
     4c6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     4c8:	80 81       	ld	r24, Z
     4ca:	8f 7e       	andi	r24, 0xEF	; 239
     4cc:	80 83       	st	Z, r24
}
     4ce:	08 95       	ret

000004d0 <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     4d0:	e0 ea       	ldi	r30, 0xA0	; 160
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	80 81       	ld	r24, Z
     4d6:	88 60       	ori	r24, 0x08	; 8
     4d8:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     4da:	80 81       	ld	r24, Z
     4dc:	8b 7f       	andi	r24, 0xFB	; 251
     4de:	80 83       	st	Z, r24
}
     4e0:	08 95       	ret

000004e2 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     4e2:	e0 e8       	ldi	r30, 0x80	; 128
     4e4:	f0 e0       	ldi	r31, 0x00	; 0
     4e6:	80 81       	ld	r24, Z
     4e8:	8f 7d       	andi	r24, 0xDF	; 223
     4ea:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4ec:	80 81       	ld	r24, Z
     4ee:	8f 7e       	andi	r24, 0xEF	; 239
     4f0:	80 83       	st	Z, r24
}
     4f2:	08 95       	ret

000004f4 <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     4f4:	e0 eb       	ldi	r30, 0xB0	; 176
     4f6:	f0 e0       	ldi	r31, 0x00	; 0
     4f8:	80 81       	ld	r24, Z
     4fa:	8f 7d       	andi	r24, 0xDF	; 223
     4fc:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4fe:	80 81       	ld	r24, Z
     500:	8f 7e       	andi	r24, 0xEF	; 239
     502:	80 83       	st	Z, r24
}
     504:	08 95       	ret

00000506 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     506:	e0 e9       	ldi	r30, 0x90	; 144
     508:	f0 e0       	ldi	r31, 0x00	; 0
     50a:	80 81       	ld	r24, Z
     50c:	8f 77       	andi	r24, 0x7F	; 127
     50e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     510:	80 81       	ld	r24, Z
     512:	8f 7b       	andi	r24, 0xBF	; 191
     514:	80 83       	st	Z, r24
}
     516:	08 95       	ret

00000518 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     518:	e0 e9       	ldi	r30, 0x90	; 144
     51a:	f0 e0       	ldi	r31, 0x00	; 0
     51c:	80 81       	ld	r24, Z
     51e:	8f 7d       	andi	r24, 0xDF	; 223
     520:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     522:	80 81       	ld	r24, Z
     524:	8f 7e       	andi	r24, 0xEF	; 239
     526:	80 83       	st	Z, r24
}
     528:	08 95       	ret

0000052a <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     52a:	e0 e9       	ldi	r30, 0x90	; 144
     52c:	f0 e0       	ldi	r31, 0x00	; 0
     52e:	80 81       	ld	r24, Z
     530:	87 7f       	andi	r24, 0xF7	; 247
     532:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     534:	80 81       	ld	r24, Z
     536:	8b 7f       	andi	r24, 0xFB	; 251
     538:	80 83       	st	Z, r24
}
     53a:	08 95       	ret

0000053c <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     53c:	e0 ea       	ldi	r30, 0xA0	; 160
     53e:	f0 e0       	ldi	r31, 0x00	; 0
     540:	80 81       	ld	r24, Z
     542:	8f 77       	andi	r24, 0x7F	; 127
     544:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     546:	80 81       	ld	r24, Z
     548:	8f 7b       	andi	r24, 0xBF	; 191
     54a:	80 83       	st	Z, r24
}
     54c:	08 95       	ret

0000054e <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f0 e0       	ldi	r31, 0x00	; 0
     552:	80 81       	ld	r24, Z
     554:	8f 7d       	andi	r24, 0xDF	; 223
     556:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     558:	80 81       	ld	r24, Z
     55a:	8f 7e       	andi	r24, 0xEF	; 239
     55c:	80 83       	st	Z, r24
}
     55e:	08 95       	ret

00000560 <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     560:	e0 ea       	ldi	r30, 0xA0	; 160
     562:	f0 e0       	ldi	r31, 0x00	; 0
     564:	80 81       	ld	r24, Z
     566:	87 7f       	andi	r24, 0xF7	; 247
     568:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     56a:	80 81       	ld	r24, Z
     56c:	8b 7f       	andi	r24, 0xFB	; 251
     56e:	80 83       	st	Z, r24
}
     570:	08 95       	ret

00000572 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     572:	e0 e8       	ldi	r30, 0x80	; 128
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	80 81       	ld	r24, Z
     578:	8d 7f       	andi	r24, 0xFD	; 253
     57a:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     57c:	80 81       	ld	r24, Z
     57e:	8e 7f       	andi	r24, 0xFE	; 254
     580:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     582:	80 81       	ld	r24, Z
     584:	8f 7d       	andi	r24, 0xDF	; 223
     586:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     588:	80 81       	ld	r24, Z
     58a:	8f 7e       	andi	r24, 0xEF	; 239
     58c:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     58e:	08 95       	ret

00000590 <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     590:	e0 eb       	ldi	r30, 0xB0	; 176
     592:	f0 e0       	ldi	r31, 0x00	; 0
     594:	80 81       	ld	r24, Z
     596:	8d 7f       	andi	r24, 0xFD	; 253
     598:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     59a:	80 81       	ld	r24, Z
     59c:	8e 7f       	andi	r24, 0xFE	; 254
     59e:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     5a0:	80 81       	ld	r24, Z
     5a2:	8f 7d       	andi	r24, 0xDF	; 223
     5a4:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     5a6:	80 81       	ld	r24, Z
     5a8:	8f 7e       	andi	r24, 0xEF	; 239
     5aa:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     5ac:	08 95       	ret

000005ae <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     5ae:	e0 e9       	ldi	r30, 0x90	; 144
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	80 81       	ld	r24, Z
     5b4:	8d 7f       	andi	r24, 0xFD	; 253
     5b6:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     5b8:	80 81       	ld	r24, Z
     5ba:	8e 7f       	andi	r24, 0xFE	; 254
     5bc:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     5be:	80 81       	ld	r24, Z
     5c0:	8f 77       	andi	r24, 0x7F	; 127
     5c2:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     5c4:	80 81       	ld	r24, Z
     5c6:	8f 7b       	andi	r24, 0xBF	; 191
     5c8:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     5ca:	80 81       	ld	r24, Z
     5cc:	8f 7d       	andi	r24, 0xDF	; 223
     5ce:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     5d0:	80 81       	ld	r24, Z
     5d2:	8f 7e       	andi	r24, 0xEF	; 239
     5d4:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5d6:	80 81       	ld	r24, Z
     5d8:	87 7f       	andi	r24, 0xF7	; 247
     5da:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5dc:	80 81       	ld	r24, Z
     5de:	8b 7f       	andi	r24, 0xFB	; 251
     5e0:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     5e2:	08 95       	ret

000005e4 <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f0 e0       	ldi	r31, 0x00	; 0
     5e8:	80 81       	ld	r24, Z
     5ea:	8d 7f       	andi	r24, 0xFD	; 253
     5ec:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     5ee:	80 81       	ld	r24, Z
     5f0:	8e 7f       	andi	r24, 0xFE	; 254
     5f2:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5f4:	80 81       	ld	r24, Z
     5f6:	8f 77       	andi	r24, 0x7F	; 127
     5f8:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5fa:	80 81       	ld	r24, Z
     5fc:	8f 7b       	andi	r24, 0xBF	; 191
     5fe:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     600:	80 81       	ld	r24, Z
     602:	8f 7d       	andi	r24, 0xDF	; 223
     604:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     606:	80 81       	ld	r24, Z
     608:	8f 7e       	andi	r24, 0xEF	; 239
     60a:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     60c:	80 81       	ld	r24, Z
     60e:	87 7f       	andi	r24, 0xF7	; 247
     610:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     612:	80 81       	ld	r24, Z
     614:	8b 7f       	andi	r24, 0xFB	; 251
     616:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     618:	08 95       	ret

0000061a <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     61a:	90 93 8b 00 	sts	0x008B, r25
     61e:	80 93 8a 00 	sts	0x008A, r24
     622:	08 95       	ret

00000624 <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     624:	80 93 b4 00 	sts	0x00B4, r24
     628:	08 95       	ret

0000062a <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     62a:	90 93 99 00 	sts	0x0099, r25
     62e:	80 93 98 00 	sts	0x0098, r24
     632:	08 95       	ret

00000634 <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     634:	90 93 9b 00 	sts	0x009B, r25
     638:	80 93 9a 00 	sts	0x009A, r24
     63c:	08 95       	ret

0000063e <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     63e:	90 93 9d 00 	sts	0x009D, r25
     642:	80 93 9c 00 	sts	0x009C, r24
     646:	08 95       	ret

00000648 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     648:	90 93 a9 00 	sts	0x00A9, r25
     64c:	80 93 a8 00 	sts	0x00A8, r24
     650:	08 95       	ret

00000652 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     652:	90 93 ab 00 	sts	0x00AB, r25
     656:	80 93 aa 00 	sts	0x00AA, r24
     65a:	08 95       	ret

0000065c <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     65c:	90 93 ad 00 	sts	0x00AD, r25
     660:	80 93 ac 00 	sts	0x00AC, r24
     664:	08 95       	ret

00000666 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     666:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     668:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     66a:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     66e:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     672:	9f ef       	ldi	r25, 0xFF	; 255
     674:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     676:	80 e4       	ldi	r24, 0x40	; 64
     678:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     67a:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     67c:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     67e:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     680:	83 ef       	ldi	r24, 0xF3	; 243
     682:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     684:	8e ef       	ldi	r24, 0xFE	; 254
     686:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     688:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     68a:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     68c:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     690:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     694:	08 95       	ret

00000696 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     696:	08 95       	ret

00000698 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     698:	2e 9a       	sbi	0x05, 6	; 5
     69a:	08 95       	ret

0000069c <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     69c:	2e 98       	cbi	0x05, 6	; 5
     69e:	08 95       	ret

000006a0 <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     6a0:	22 b3       	in	r18, 0x12	; 18
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	85 e0       	ldi	r24, 0x05	; 5
     6a6:	36 95       	lsr	r19
     6a8:	27 95       	ror	r18
     6aa:	8a 95       	dec	r24
     6ac:	e1 f7       	brne	.-8      	; 0x6a6 <button_pressed+0x6>
     6ae:	20 95       	com	r18
     6b0:	30 95       	com	r19
     6b2:	21 70       	andi	r18, 0x01	; 1
     6b4:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     6b6:	c9 01       	movw	r24, r18
     6b8:	08 95       	ret

000006ba <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     6ba:	97 fd       	sbrc	r25, 7
     6bc:	10 c0       	rjmp	.+32     	; 0x6de <cos_SoR+0x24>
		return angtable[degrees/5];
     6be:	25 e0       	ldi	r18, 0x05	; 5
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	40 e0       	ldi	r20, 0x00	; 0
     6c4:	50 e0       	ldi	r21, 0x00	; 0
     6c6:	0e 94 46 24 	call	0x488c	; 0x488c <__divmodsi4>
     6ca:	da 01       	movw	r26, r20
     6cc:	c9 01       	movw	r24, r18
     6ce:	88 0f       	add	r24, r24
     6d0:	99 1f       	adc	r25, r25
     6d2:	83 5e       	subi	r24, 0xE3	; 227
     6d4:	9d 4f       	sbci	r25, 0xFD	; 253
     6d6:	fc 01       	movw	r30, r24
     6d8:	20 81       	ld	r18, Z
     6da:	31 81       	ldd	r19, Z+1	; 0x01
     6dc:	17 c0       	rjmp	.+46     	; 0x70c <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     6de:	25 e0       	ldi	r18, 0x05	; 5
     6e0:	30 e0       	ldi	r19, 0x00	; 0
     6e2:	40 e0       	ldi	r20, 0x00	; 0
     6e4:	50 e0       	ldi	r21, 0x00	; 0
     6e6:	0e 94 46 24 	call	0x488c	; 0x488c <__divmodsi4>
     6ea:	da 01       	movw	r26, r20
     6ec:	c9 01       	movw	r24, r18
     6ee:	88 5b       	subi	r24, 0xB8	; 184
     6f0:	9f 4f       	sbci	r25, 0xFF	; 255
     6f2:	af 4f       	sbci	r26, 0xFF	; 255
     6f4:	bf 4f       	sbci	r27, 0xFF	; 255
     6f6:	88 0f       	add	r24, r24
     6f8:	99 1f       	adc	r25, r25
     6fa:	83 5e       	subi	r24, 0xE3	; 227
     6fc:	9d 4f       	sbci	r25, 0xFD	; 253
     6fe:	fc 01       	movw	r30, r24
     700:	80 81       	ld	r24, Z
     702:	91 81       	ldd	r25, Z+1	; 0x01
     704:	22 27       	eor	r18, r18
     706:	33 27       	eor	r19, r19
     708:	28 1b       	sub	r18, r24
     70a:	39 0b       	sbc	r19, r25
	}
     70c:	c9 01       	movw	r24, r18
     70e:	08 95       	ret

00000710 <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     710:	6a 55       	subi	r22, 0x5A	; 90
     712:	70 40       	sbci	r23, 0x00	; 0
     714:	80 40       	sbci	r24, 0x00	; 0
     716:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     718:	97 fd       	sbrc	r25, 7
     71a:	10 c0       	rjmp	.+32     	; 0x73c <sin_SoR+0x2c>
		return angtable[degrees/5];
     71c:	25 e0       	ldi	r18, 0x05	; 5
     71e:	30 e0       	ldi	r19, 0x00	; 0
     720:	40 e0       	ldi	r20, 0x00	; 0
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	0e 94 46 24 	call	0x488c	; 0x488c <__divmodsi4>
     728:	da 01       	movw	r26, r20
     72a:	c9 01       	movw	r24, r18
     72c:	88 0f       	add	r24, r24
     72e:	99 1f       	adc	r25, r25
     730:	83 5e       	subi	r24, 0xE3	; 227
     732:	9d 4f       	sbci	r25, 0xFD	; 253
     734:	fc 01       	movw	r30, r24
     736:	20 81       	ld	r18, Z
     738:	31 81       	ldd	r19, Z+1	; 0x01
     73a:	17 c0       	rjmp	.+46     	; 0x76a <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     73c:	25 e0       	ldi	r18, 0x05	; 5
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	0e 94 46 24 	call	0x488c	; 0x488c <__divmodsi4>
     748:	da 01       	movw	r26, r20
     74a:	c9 01       	movw	r24, r18
     74c:	88 5b       	subi	r24, 0xB8	; 184
     74e:	9f 4f       	sbci	r25, 0xFF	; 255
     750:	af 4f       	sbci	r26, 0xFF	; 255
     752:	bf 4f       	sbci	r27, 0xFF	; 255
     754:	88 0f       	add	r24, r24
     756:	99 1f       	adc	r25, r25
     758:	83 5e       	subi	r24, 0xE3	; 227
     75a:	9d 4f       	sbci	r25, 0xFD	; 253
     75c:	fc 01       	movw	r30, r24
     75e:	80 81       	ld	r24, Z
     760:	91 81       	ldd	r25, Z+1	; 0x01
     762:	22 27       	eor	r18, r18
     764:	33 27       	eor	r19, r19
     766:	28 1b       	sub	r18, r24
     768:	39 0b       	sbc	r19, r25
	}
     76a:	c9 01       	movw	r24, r18
     76c:	08 95       	ret

0000076e <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     76e:	cf 92       	push	r12
     770:	df 92       	push	r13
     772:	ef 92       	push	r14
     774:	ff 92       	push	r15
     776:	0f 93       	push	r16
     778:	1f 93       	push	r17
     77a:	6b 01       	movw	r12, r22
     77c:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     77e:	8a e5       	ldi	r24, 0x5A	; 90
     780:	c8 16       	cp	r12, r24
     782:	d1 04       	cpc	r13, r1
     784:	e1 04       	cpc	r14, r1
     786:	f1 04       	cpc	r15, r1
     788:	a1 f1       	breq	.+104    	; 0x7f2 <tan_SoR+0x84>
     78a:	86 ea       	ldi	r24, 0xA6	; 166
     78c:	c8 16       	cp	r12, r24
     78e:	8f ef       	ldi	r24, 0xFF	; 255
     790:	d8 06       	cpc	r13, r24
     792:	8f ef       	ldi	r24, 0xFF	; 255
     794:	e8 06       	cpc	r14, r24
     796:	8f ef       	ldi	r24, 0xFF	; 255
     798:	f8 06       	cpc	r15, r24
     79a:	59 f1       	breq	.+86     	; 0x7f2 <tan_SoR+0x84>
     79c:	8e e0       	ldi	r24, 0x0E	; 14
     79e:	c8 16       	cp	r12, r24
     7a0:	81 e0       	ldi	r24, 0x01	; 1
     7a2:	d8 06       	cpc	r13, r24
     7a4:	80 e0       	ldi	r24, 0x00	; 0
     7a6:	e8 06       	cpc	r14, r24
     7a8:	80 e0       	ldi	r24, 0x00	; 0
     7aa:	f8 06       	cpc	r15, r24
     7ac:	11 f1       	breq	.+68     	; 0x7f2 <tan_SoR+0x84>
     7ae:	82 ef       	ldi	r24, 0xF2	; 242
     7b0:	c8 16       	cp	r12, r24
     7b2:	8e ef       	ldi	r24, 0xFE	; 254
     7b4:	d8 06       	cpc	r13, r24
     7b6:	8f ef       	ldi	r24, 0xFF	; 255
     7b8:	e8 06       	cpc	r14, r24
     7ba:	8f ef       	ldi	r24, 0xFF	; 255
     7bc:	f8 06       	cpc	r15, r24
     7be:	c9 f0       	breq	.+50     	; 0x7f2 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     7c0:	c7 01       	movw	r24, r14
     7c2:	b6 01       	movw	r22, r12
     7c4:	0e 94 88 03 	call	0x710	; 0x710 <sin_SoR>
     7c8:	8c 01       	movw	r16, r24
     7ca:	c7 01       	movw	r24, r14
     7cc:	b6 01       	movw	r22, r12
     7ce:	0e 94 5d 03 	call	0x6ba	; 0x6ba <cos_SoR>
     7d2:	bc 01       	movw	r22, r24
     7d4:	c8 01       	movw	r24, r16
     7d6:	0e 94 11 24 	call	0x4822	; 0x4822 <__divmodhi4>
     7da:	cb 01       	movw	r24, r22
     7dc:	9b 01       	movw	r18, r22
     7de:	73 e0       	ldi	r23, 0x03	; 3
     7e0:	22 0f       	add	r18, r18
     7e2:	33 1f       	adc	r19, r19
     7e4:	7a 95       	dec	r23
     7e6:	e1 f7       	brne	.-8      	; 0x7e0 <tan_SoR+0x72>
     7e8:	88 0f       	add	r24, r24
     7ea:	99 1f       	adc	r25, r25
     7ec:	28 0f       	add	r18, r24
     7ee:	39 1f       	adc	r19, r25
     7f0:	02 c0       	rjmp	.+4      	; 0x7f6 <tan_SoR+0x88>
     7f2:	20 e0       	ldi	r18, 0x00	; 0
     7f4:	30 e0       	ldi	r19, 0x00	; 0
	}
     7f6:	c9 01       	movw	r24, r18
     7f8:	1f 91       	pop	r17
     7fa:	0f 91       	pop	r16
     7fc:	ff 90       	pop	r15
     7fe:	ef 90       	pop	r14
     800:	df 90       	pop	r13
     802:	cf 90       	pop	r12
     804:	08 95       	ret

00000806 <vPassChars>:
//	prvPWMSetup();

}


void vPassChars(){
     806:	ef 92       	push	r14
     808:	ff 92       	push	r15
     80a:	1f 93       	push	r17
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
	uint8_t fromUser;
	
	uart3SendByte(0x1B);
     810:	8b e1       	ldi	r24, 0x1B	; 27
     812:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
	uart3SendByte(0x1B);
     816:	8b e1       	ldi	r24, 0x1B	; 27
     818:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
	uart3SendByte(0x1B);
     81c:	8b e1       	ldi	r24, 0x1B	; 27
     81e:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
	
	for(;;){
		fromUser = uart1GetByte();
		uart3SendByte(fromUser);
		if(fromUser=='G'){
		uart3SendByte("SetBaud 500000\n");
     822:	e0 e0       	ldi	r30, 0x00	; 0
     824:	ee 2e       	mov	r14, r30
     826:	e2 e0       	ldi	r30, 0x02	; 2
     828:	fe 2e       	mov	r15, r30
		uart3SendByte(0x1B);
		uart3SendByte(0x1B);
		uart3SendByte(0x1B);
		
		uartSetBaudRate(1, 500000);
		uart1SendByte("Baud Set 5K\n");
     82a:	c0 e1       	ldi	r28, 0x10	; 16
     82c:	d2 e0       	ldi	r29, 0x02	; 2
	//uart3SendByte("SetBaud 256000");
	//uartSetBaudRate(3, 256000);
	//uartSetBaudRate(1, 256000);
	
	for(;;){
		fromUser = uart1GetByte();
     82e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <uart1GetByte>
     832:	18 2f       	mov	r17, r24
		uart3SendByte(fromUser);
     834:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
		if(fromUser=='G'){
     838:	17 34       	cpi	r17, 0x47	; 71
     83a:	c9 f7       	brne	.-14     	; 0x82e <vPassChars+0x28>
		uart3SendByte("SetBaud 500000\n");
     83c:	8e 2d       	mov	r24, r14
     83e:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
		uartSetBaudRate(3, 500000);
     842:	83 e0       	ldi	r24, 0x03	; 3
     844:	40 e2       	ldi	r20, 0x20	; 32
     846:	51 ea       	ldi	r21, 0xA1	; 161
     848:	67 e0       	ldi	r22, 0x07	; 7
     84a:	70 e0       	ldi	r23, 0x00	; 0
     84c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
		uart3SendByte(0x1B);
     850:	8b e1       	ldi	r24, 0x1B	; 27
     852:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
		uart3SendByte(0x1B);
     856:	8b e1       	ldi	r24, 0x1B	; 27
     858:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
		uart3SendByte(0x1B);
     85c:	8b e1       	ldi	r24, 0x1B	; 27
     85e:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <uart3SendByte>
		
		uartSetBaudRate(1, 500000);
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	40 e2       	ldi	r20, 0x20	; 32
     866:	51 ea       	ldi	r21, 0xA1	; 161
     868:	67 e0       	ldi	r22, 0x07	; 7
     86a:	70 e0       	ldi	r23, 0x00	; 0
     86c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
		uart1SendByte("Baud Set 5K\n");
     870:	8c 2f       	mov	r24, r28
     872:	0e 94 99 17 	call	0x2f32	; 0x2f32 <uart1SendByte>
     876:	db cf       	rjmp	.-74     	; 0x82e <vPassChars+0x28>

00000878 <prvSetupHardware>:
		//rprintf("%c",c);
		//rprintfu08(c);
	
}

void prvSetupHardware(){
     878:	0f 93       	push	r16
     87a:	1f 93       	push	r17
     87c:	cf 93       	push	r28
     87e:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
     880:	0e 94 46 1b 	call	0x368c	; 0x368c <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
     884:	80 e0       	ldi	r24, 0x00	; 0
     886:	40 e0       	ldi	r20, 0x00	; 0
     888:	56 e9       	ldi	r21, 0x96	; 150
     88a:	60 e0       	ldi	r22, 0x00	; 0
     88c:	70 e0       	ldi	r23, 0x00	; 0
     88e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
     892:	81 e0       	ldi	r24, 0x01	; 1
     894:	40 e0       	ldi	r20, 0x00	; 0
     896:	52 ec       	ldi	r21, 0xC2	; 194
     898:	61 e0       	ldi	r22, 0x01	; 1
     89a:	70 e0       	ldi	r23, 0x00	; 0
     89c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
    uartSetBaudRate(2, 115200); // set UARTH speed
     8a0:	82 e0       	ldi	r24, 0x02	; 2
     8a2:	40 e0       	ldi	r20, 0x00	; 0
     8a4:	52 ec       	ldi	r21, 0xC2	; 194
     8a6:	61 e0       	ldi	r22, 0x01	; 1
     8a8:	70 e0       	ldi	r23, 0x00	; 0
     8aa:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
     8ae:	83 e0       	ldi	r24, 0x03	; 3
     8b0:	40 e0       	ldi	r20, 0x00	; 0
     8b2:	52 ec       	ldi	r21, 0xC2	; 194
     8b4:	61 e0       	ldi	r22, 0x01	; 1
     8b6:	70 e0       	ldi	r23, 0x00	; 0
     8b8:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
     8bc:	89 e9       	ldi	r24, 0x99	; 153
     8be:	97 e1       	ldi	r25, 0x17	; 23
     8c0:	0e 94 8a 1c 	call	0x3914	; 0x3914 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
     8c4:	0e 94 33 03 	call	0x666	; 0x666 <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(3, &LDSrcv);
     8c8:	83 e0       	ldi	r24, 0x03	; 3
     8ca:	69 ec       	ldi	r22, 0xC9	; 201
     8cc:	74 e0       	ldi	r23, 0x04	; 4
     8ce:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <uartSetRxHandler>
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     8d2:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <prvSetupHardware+0x5e>
     8d6:	0f 92       	push	r0
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	ed b7       	in	r30, 0x3d	; 61
     8dc:	fe b7       	in	r31, 0x3e	; 62
     8de:	81 83       	std	Z+1, r24	; 0x01
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	91 e0       	ldi	r25, 0x01	; 1
     8e4:	93 83       	std	Z+3, r25	; 0x03
     8e6:	82 83       	std	Z+2, r24	; 0x02
     8e8:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
     8ec:	0f 90       	pop	r0
     8ee:	0f 90       	pop	r0
     8f0:	0f 90       	pop	r0
     8f2:	85 e0       	ldi	r24, 0x05	; 5
     8f4:	0e 94 2c 11 	call	0x2258	; 0x2258 <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	init_timer2(TIMER2_CLK_64);
     8f8:	84 e0       	ldi	r24, 0x04	; 4
     8fa:	0e 94 4c 11 	call	0x2298	; 0x2298 <init_timer2>
 	init_timer3(TIMER_CLK_64);
     8fe:	83 e0       	ldi	r24, 0x03	; 3
     900:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <init_timer3>
 	init_timer4(TIMER_CLK_64);
     904:	83 e0       	ldi	r24, 0x03	; 3
     906:	0e 94 6e 11 	call	0x22dc	; 0x22dc <init_timer4>
 	init_timer5(TIMER_CLK_64);
     90a:	83 e0       	ldi	r24, 0x03	; 3
     90c:	0e 94 80 11 	call	0x2300	; 0x2300 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
     910:	0e 94 ff 1b 	call	0x37fe	; 0x37fe <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
     914:	85 e0       	ldi	r24, 0x05	; 5
     916:	0e 94 24 1c 	call	0x3848	; 0x3848 <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
     91a:	81 e0       	ldi	r24, 0x01	; 1
     91c:	0e 94 2b 1c 	call	0x3856	; 0x3856 <a2dSetReference>
     920:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     922:	01 e0       	ldi	r16, 0x01	; 1
     924:	cf ef       	ldi	r28, 0xFF	; 255
     926:	d0 e0       	ldi	r29, 0x00	; 0
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
     928:	81 2f       	mov	r24, r17
     92a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     92e:	00 d0       	rcall	.+0      	; 0x930 <prvSetupHardware+0xb8>
     930:	0f 92       	push	r0
     932:	ed b7       	in	r30, 0x3d	; 61
     934:	fe b7       	in	r31, 0x3e	; 62
     936:	01 83       	std	Z+1, r16	; 0x01
     938:	d3 83       	std	Z+3, r29	; 0x03
     93a:	c2 83       	std	Z+2, r28	; 0x02
     93c:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <rprintf1RamRom>
     940:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
     942:	0f 90       	pop	r0
     944:	0f 90       	pop	r0
     946:	0f 90       	pop	r0
     948:	10 31       	cpi	r17, 0x10	; 16
     94a:	71 f7       	brne	.-36     	; 0x928 <prvSetupHardware+0xb0>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     94c:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
     94e:	00 d0       	rcall	.+0      	; 0x950 <prvSetupHardware+0xd8>
     950:	0f 92       	push	r0
     952:	ed b7       	in	r30, 0x3d	; 61
     954:	fe b7       	in	r31, 0x3e	; 62
     956:	01 83       	std	Z+1, r16	; 0x01
     958:	84 ee       	ldi	r24, 0xE4	; 228
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	93 83       	std	Z+3, r25	; 0x03
     95e:	82 83       	std	Z+2, r24	; 0x02
     960:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
     964:	0f 90       	pop	r0
     966:	0f 90       	pop	r0
     968:	0f 90       	pop	r0
     96a:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <reset_timer0>
	reset_timer1();
     96e:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <reset_timer1>
	reset_timer2();
     972:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <reset_timer2>
	reset_timer3();
     976:	0e 94 04 11 	call	0x2208	; 0x2208 <reset_timer3>
	reset_timer4();
     97a:	0e 94 11 11 	call	0x2222	; 0x2222 <reset_timer4>
	reset_timer5();
     97e:	0e 94 1e 11 	call	0x223c	; 0x223c <reset_timer5>


	/********PWM Setup***********/
//	prvPWMSetup();

}
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	1f 91       	pop	r17
     988:	0f 91       	pop	r16
     98a:	08 95       	ret

0000098c <main>:
	
}

int main(void)
{
	prvSetupHardware();
     98c:	0e 94 3c 04 	call	0x878	; 0x878 <prvSetupHardware>
     990:	ff cf       	rjmp	.-2      	; 0x990 <main+0x4>

00000992 <LDSrcv>:
uint8_t arr[SIZE];
uint8_t full = UNSET;
uint8_t ang_vel_ready = UNSET;
uint8_t ang_vel[2];

void LDSrcv(unsigned char c){	//modified for LDS 06/15/11
     992:	1f 93       	push	r17
     994:	18 2f       	mov	r17, r24
		else{
			full = SET;
		}
		*/
		//c = c & 0b01111111;		//for some reason, every byte has its first bit set to 1
		uart1SendByte(c);
     996:	0e 94 99 17 	call	0x2f32	; 0x2f32 <uart1SendByte>
		uart2SendByte(c);
     99a:	81 2f       	mov	r24, r17
     99c:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <uart2SendByte>
		//rprintf("%c",c);
		//rprintfu08(c);
	
}
     9a0:	1f 91       	pop	r17
     9a2:	08 95       	ret

000009a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     9a4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     9a6:	9c 01       	movw	r18, r24
     9a8:	2d 5f       	subi	r18, 0xFD	; 253
     9aa:	3f 4f       	sbci	r19, 0xFF	; 255
     9ac:	32 83       	std	Z+2, r19	; 0x02
     9ae:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9b0:	8f ef       	ldi	r24, 0xFF	; 255
     9b2:	9f ef       	ldi	r25, 0xFF	; 255
     9b4:	94 83       	std	Z+4, r25	; 0x04
     9b6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     9b8:	36 83       	std	Z+6, r19	; 0x06
     9ba:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     9bc:	30 87       	std	Z+8, r19	; 0x08
     9be:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
     9c0:	10 82       	st	Z, r1
}
     9c2:	08 95       	ret

000009c4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9c4:	fc 01       	movw	r30, r24
     9c6:	11 86       	std	Z+9, r1	; 0x09
     9c8:	10 86       	std	Z+8, r1	; 0x08
}
     9ca:	08 95       	ret

000009cc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	ac 01       	movw	r20, r24
     9d2:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     9d4:	ec 01       	movw	r28, r24
     9d6:	29 81       	ldd	r18, Y+1	; 0x01
     9d8:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     9da:	f9 01       	movw	r30, r18
     9dc:	82 81       	ldd	r24, Z+2	; 0x02
     9de:	93 81       	ldd	r25, Z+3	; 0x03
     9e0:	13 96       	adiw	r26, 0x03	; 3
     9e2:	9c 93       	st	X, r25
     9e4:	8e 93       	st	-X, r24
     9e6:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     9e8:	89 81       	ldd	r24, Y+1	; 0x01
     9ea:	9a 81       	ldd	r25, Y+2	; 0x02
     9ec:	15 96       	adiw	r26, 0x05	; 5
     9ee:	9c 93       	st	X, r25
     9f0:	8e 93       	st	-X, r24
     9f2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     9f4:	02 80       	ldd	r0, Z+2	; 0x02
     9f6:	f3 81       	ldd	r31, Z+3	; 0x03
     9f8:	e0 2d       	mov	r30, r0
     9fa:	75 83       	std	Z+5, r23	; 0x05
     9fc:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     9fe:	e9 01       	movw	r28, r18
     a00:	7b 83       	std	Y+3, r23	; 0x03
     a02:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     a04:	fa 01       	movw	r30, r20
     a06:	72 83       	std	Z+2, r23	; 0x02
     a08:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a0a:	19 96       	adiw	r26, 0x09	; 9
     a0c:	5c 93       	st	X, r21
     a0e:	4e 93       	st	-X, r20
     a10:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     a12:	80 81       	ld	r24, Z
     a14:	8f 5f       	subi	r24, 0xFF	; 255
     a16:	80 83       	st	Z, r24
}
     a18:	df 91       	pop	r29
     a1a:	cf 91       	pop	r28
     a1c:	08 95       	ret

00000a1e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	9c 01       	movw	r18, r24
     a24:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     a26:	48 81       	ld	r20, Y
     a28:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a2a:	8f ef       	ldi	r24, 0xFF	; 255
     a2c:	4f 3f       	cpi	r20, 0xFF	; 255
     a2e:	58 07       	cpc	r21, r24
     a30:	21 f4       	brne	.+8      	; 0xa3a <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a32:	f9 01       	movw	r30, r18
     a34:	a7 81       	ldd	r26, Z+7	; 0x07
     a36:	b0 85       	ldd	r27, Z+8	; 0x08
     a38:	10 c0       	rjmp	.+32     	; 0xa5a <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     a3a:	d9 01       	movw	r26, r18
     a3c:	13 96       	adiw	r26, 0x03	; 3
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <vListInsert+0x2a>
     a40:	12 96       	adiw	r26, 0x02	; 2
     a42:	0d 90       	ld	r0, X+
     a44:	bc 91       	ld	r27, X
     a46:	a0 2d       	mov	r26, r0
     a48:	12 96       	adiw	r26, 0x02	; 2
     a4a:	ed 91       	ld	r30, X+
     a4c:	fc 91       	ld	r31, X
     a4e:	13 97       	sbiw	r26, 0x03	; 3
     a50:	80 81       	ld	r24, Z
     a52:	91 81       	ldd	r25, Z+1	; 0x01
     a54:	48 17       	cp	r20, r24
     a56:	59 07       	cpc	r21, r25
     a58:	98 f7       	brcc	.-26     	; 0xa40 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a5a:	12 96       	adiw	r26, 0x02	; 2
     a5c:	ed 91       	ld	r30, X+
     a5e:	fc 91       	ld	r31, X
     a60:	13 97       	sbiw	r26, 0x03	; 3
     a62:	fb 83       	std	Y+3, r31	; 0x03
     a64:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     a66:	d5 83       	std	Z+5, r29	; 0x05
     a68:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a6a:	bd 83       	std	Y+5, r27	; 0x05
     a6c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     a6e:	13 96       	adiw	r26, 0x03	; 3
     a70:	dc 93       	st	X, r29
     a72:	ce 93       	st	-X, r28
     a74:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a76:	39 87       	std	Y+9, r19	; 0x09
     a78:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a7a:	f9 01       	movw	r30, r18
     a7c:	80 81       	ld	r24, Z
     a7e:	8f 5f       	subi	r24, 0xFF	; 255
     a80:	80 83       	st	Z, r24
}
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a8e:	12 96       	adiw	r26, 0x02	; 2
     a90:	ed 91       	ld	r30, X+
     a92:	fc 91       	ld	r31, X
     a94:	13 97       	sbiw	r26, 0x03	; 3
     a96:	14 96       	adiw	r26, 0x04	; 4
     a98:	8d 91       	ld	r24, X+
     a9a:	9c 91       	ld	r25, X
     a9c:	15 97       	sbiw	r26, 0x05	; 5
     a9e:	95 83       	std	Z+5, r25	; 0x05
     aa0:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     aa2:	14 96       	adiw	r26, 0x04	; 4
     aa4:	cd 91       	ld	r28, X+
     aa6:	dc 91       	ld	r29, X
     aa8:	15 97       	sbiw	r26, 0x05	; 5
     aaa:	fb 83       	std	Y+3, r31	; 0x03
     aac:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     aae:	18 96       	adiw	r26, 0x08	; 8
     ab0:	ed 91       	ld	r30, X+
     ab2:	fc 91       	ld	r31, X
     ab4:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	92 81       	ldd	r25, Z+2	; 0x02
     aba:	8a 17       	cp	r24, r26
     abc:	9b 07       	cpc	r25, r27
     abe:	11 f4       	brne	.+4      	; 0xac4 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ac0:	d2 83       	std	Z+2, r29	; 0x02
     ac2:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     ac4:	19 96       	adiw	r26, 0x09	; 9
     ac6:	1c 92       	st	X, r1
     ac8:	1e 92       	st	-X, r1
     aca:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     acc:	80 81       	ld	r24, Z
     ace:	81 50       	subi	r24, 0x01	; 1
     ad0:	80 83       	st	Z, r24
}
     ad2:	df 91       	pop	r29
     ad4:	cf 91       	pop	r28
     ad6:	08 95       	ret

00000ad8 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     ad8:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
     ada:	0f b6       	in	r0, 0x3f	; 63
     adc:	f8 94       	cli
     ade:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     ae0:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     ae2:	0f 90       	pop	r0
     ae4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     ae6:	08 95       	ret

00000ae8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     ae8:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
     aea:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     aec:	08 95       	ret

00000aee <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     aee:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     af0:	82 8d       	ldd	r24, Z+26	; 0x1a
     af2:	90 e0       	ldi	r25, 0x00	; 0
     af4:	88 23       	and	r24, r24
     af6:	09 f4       	brne	.+2      	; 0xafa <xQueueIsQueueEmptyFromISR+0xc>
     af8:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     afa:	89 2f       	mov	r24, r25
     afc:	08 95       	ret

00000afe <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     afe:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     b00:	92 8d       	ldd	r25, Z+26	; 0x1a
     b02:	20 e0       	ldi	r18, 0x00	; 0
     b04:	83 8d       	ldd	r24, Z+27	; 0x1b
     b06:	98 17       	cp	r25, r24
     b08:	09 f4       	brne	.+2      	; 0xb0c <xQueueIsQueueFullFromISR+0xe>
     b0a:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     b0c:	82 2f       	mov	r24, r18
     b0e:	08 95       	ret

00000b10 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     b10:	0f 93       	push	r16
     b12:	1f 93       	push	r17
     b14:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     b16:	fc 01       	movw	r30, r24
     b18:	80 81       	ld	r24, Z
     b1a:	91 81       	ldd	r25, Z+1	; 0x01
     b1c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vPortFree>
	vPortFree( pxQueue );
     b20:	c8 01       	movw	r24, r16
     b22:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vPortFree>
}
     b26:	1f 91       	pop	r17
     b28:	0f 91       	pop	r16
     b2a:	08 95       	ret

00000b2c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     b2c:	0f 93       	push	r16
     b2e:	1f 93       	push	r17
     b30:	cf 93       	push	r28
     b32:	df 93       	push	r29
     b34:	ec 01       	movw	r28, r24
     b36:	fb 01       	movw	r30, r22
     b38:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     b3a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b3c:	88 23       	and	r24, r24
     b3e:	81 f1       	breq	.+96     	; 0xba0 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     b40:	48 81       	ld	r20, Y
     b42:	59 81       	ldd	r21, Y+1	; 0x01
     b44:	41 15       	cp	r20, r1
     b46:	51 05       	cpc	r21, r1
     b48:	a9 f0       	breq	.+42     	; 0xb74 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     b4a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     b4c:	2e 81       	ldd	r18, Y+6	; 0x06
     b4e:	3f 81       	ldd	r19, Y+7	; 0x07
     b50:	28 0f       	add	r18, r24
     b52:	31 1d       	adc	r19, r1
     b54:	3f 83       	std	Y+7, r19	; 0x07
     b56:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     b58:	8a 81       	ldd	r24, Y+2	; 0x02
     b5a:	9b 81       	ldd	r25, Y+3	; 0x03
     b5c:	28 17       	cp	r18, r24
     b5e:	39 07       	cpc	r19, r25
     b60:	10 f0       	brcs	.+4      	; 0xb66 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     b62:	5f 83       	std	Y+7, r21	; 0x07
     b64:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     b66:	4c 8d       	ldd	r20, Y+28	; 0x1c
     b68:	6e 81       	ldd	r22, Y+6	; 0x06
     b6a:	7f 81       	ldd	r23, Y+7	; 0x07
     b6c:	cf 01       	movw	r24, r30
     b6e:	50 e0       	ldi	r21, 0x00	; 0
     b70:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     b74:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b76:	81 50       	subi	r24, 0x01	; 1
     b78:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     b7a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b7c:	8f 3f       	cpi	r24, 0xFF	; 255
     b7e:	69 f4       	brne	.+26     	; 0xb9a <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     b80:	88 85       	ldd	r24, Y+8	; 0x08
     b82:	88 23       	and	r24, r24
     b84:	61 f0       	breq	.+24     	; 0xb9e <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b86:	ce 01       	movw	r24, r28
     b88:	08 96       	adiw	r24, 0x08	; 8
     b8a:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     b8e:	88 23       	and	r24, r24
     b90:	31 f0       	breq	.+12     	; 0xb9e <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     b92:	81 e0       	ldi	r24, 0x01	; 1
     b94:	f8 01       	movw	r30, r16
     b96:	80 83       	st	Z, r24
     b98:	03 c0       	rjmp	.+6      	; 0xba0 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     b9a:	8f 5f       	subi	r24, 0xFF	; 255
     b9c:	8d 8f       	std	Y+29, r24	; 0x1d
     b9e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     ba0:	df 91       	pop	r29
     ba2:	cf 91       	pop	r28
     ba4:	1f 91       	pop	r17
     ba6:	0f 91       	pop	r16
     ba8:	08 95       	ret

00000baa <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	ec 01       	movw	r28, r24
     bb0:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     bb2:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bb4:	44 23       	and	r20, r20
     bb6:	a1 f1       	breq	.+104    	; 0xc20 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     bb8:	88 23       	and	r24, r24
     bba:	b1 f4       	brne	.+44     	; 0xbe8 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     bbc:	8c 81       	ldd	r24, Y+4	; 0x04
     bbe:	9d 81       	ldd	r25, Y+5	; 0x05
     bc0:	50 e0       	ldi	r21, 0x00	; 0
     bc2:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     bc6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     bc8:	2c 81       	ldd	r18, Y+4	; 0x04
     bca:	3d 81       	ldd	r19, Y+5	; 0x05
     bcc:	28 0f       	add	r18, r24
     bce:	31 1d       	adc	r19, r1
     bd0:	3d 83       	std	Y+5, r19	; 0x05
     bd2:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     bd4:	8a 81       	ldd	r24, Y+2	; 0x02
     bd6:	9b 81       	ldd	r25, Y+3	; 0x03
     bd8:	28 17       	cp	r18, r24
     bda:	39 07       	cpc	r19, r25
     bdc:	08 f1       	brcs	.+66     	; 0xc20 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     bde:	88 81       	ld	r24, Y
     be0:	99 81       	ldd	r25, Y+1	; 0x01
     be2:	9d 83       	std	Y+5, r25	; 0x05
     be4:	8c 83       	std	Y+4, r24	; 0x04
     be6:	1c c0       	rjmp	.+56     	; 0xc20 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     be8:	8e 81       	ldd	r24, Y+6	; 0x06
     bea:	9f 81       	ldd	r25, Y+7	; 0x07
     bec:	50 e0       	ldi	r21, 0x00	; 0
     bee:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     bf2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	44 27       	eor	r20, r20
     bf8:	55 27       	eor	r21, r21
     bfa:	48 1b       	sub	r20, r24
     bfc:	59 0b       	sbc	r21, r25
     bfe:	8e 81       	ldd	r24, Y+6	; 0x06
     c00:	9f 81       	ldd	r25, Y+7	; 0x07
     c02:	84 0f       	add	r24, r20
     c04:	95 1f       	adc	r25, r21
     c06:	9f 83       	std	Y+7, r25	; 0x07
     c08:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     c0a:	28 81       	ld	r18, Y
     c0c:	39 81       	ldd	r19, Y+1	; 0x01
     c0e:	82 17       	cp	r24, r18
     c10:	93 07       	cpc	r25, r19
     c12:	30 f4       	brcc	.+12     	; 0xc20 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     c14:	8a 81       	ldd	r24, Y+2	; 0x02
     c16:	9b 81       	ldd	r25, Y+3	; 0x03
     c18:	84 0f       	add	r24, r20
     c1a:	95 1f       	adc	r25, r21
     c1c:	9f 83       	std	Y+7, r25	; 0x07
     c1e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     c20:	8a 8d       	ldd	r24, Y+26	; 0x1a
     c22:	8f 5f       	subi	r24, 0xFF	; 255
     c24:	8a 8f       	std	Y+26, r24	; 0x1a
}
     c26:	df 91       	pop	r29
     c28:	cf 91       	pop	r28
     c2a:	08 95       	ret

00000c2c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     c2c:	0f 93       	push	r16
     c2e:	1f 93       	push	r17
     c30:	cf 93       	push	r28
     c32:	df 93       	push	r29
     c34:	ec 01       	movw	r28, r24
     c36:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     c38:	9a 8d       	ldd	r25, Y+26	; 0x1a
     c3a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     c3c:	98 17       	cp	r25, r24
     c3e:	10 f0       	brcs	.+4      	; 0xc44 <xQueueGenericSendFromISR+0x18>
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	17 c0       	rjmp	.+46     	; 0xc72 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     c44:	ce 01       	movw	r24, r28
     c46:	42 2f       	mov	r20, r18
     c48:	0e 94 d5 05 	call	0xbaa	; 0xbaa <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     c4c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c4e:	8f 3f       	cpi	r24, 0xFF	; 255
     c50:	69 f4       	brne	.+26     	; 0xc6c <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     c52:	89 89       	ldd	r24, Y+17	; 0x11
     c54:	88 23       	and	r24, r24
     c56:	61 f0       	breq	.+24     	; 0xc70 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c58:	ce 01       	movw	r24, r28
     c5a:	41 96       	adiw	r24, 0x11	; 17
     c5c:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     c60:	88 23       	and	r24, r24
     c62:	31 f0       	breq	.+12     	; 0xc70 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     c64:	81 e0       	ldi	r24, 0x01	; 1
     c66:	f8 01       	movw	r30, r16
     c68:	80 83       	st	Z, r24
     c6a:	03 c0       	rjmp	.+6      	; 0xc72 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     c6c:	8f 5f       	subi	r24, 0xFF	; 255
     c6e:	8e 8f       	std	Y+30, r24	; 0x1e
     c70:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	08 95       	ret

00000c7c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     c7c:	0f 93       	push	r16
     c7e:	1f 93       	push	r17
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
     c84:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c86:	0f b6       	in	r0, 0x3f	; 63
     c88:	f8 94       	cli
     c8a:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c8c:	8c 01       	movw	r16, r24
     c8e:	0f 5e       	subi	r16, 0xEF	; 239
     c90:	1f 4f       	sbci	r17, 0xFF	; 255
     c92:	0d c0       	rjmp	.+26     	; 0xcae <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     c94:	89 89       	ldd	r24, Y+17	; 0x11
     c96:	88 23       	and	r24, r24
     c98:	69 f0       	breq	.+26     	; 0xcb4 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c9a:	c8 01       	movw	r24, r16
     c9c:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     ca0:	88 23       	and	r24, r24
     ca2:	11 f0       	breq	.+4      	; 0xca8 <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     ca4:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     ca8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     caa:	81 50       	subi	r24, 0x01	; 1
     cac:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     cae:	8e 8d       	ldd	r24, Y+30	; 0x1e
     cb0:	18 16       	cp	r1, r24
     cb2:	84 f3       	brlt	.-32     	; 0xc94 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     cb4:	8f ef       	ldi	r24, 0xFF	; 255
     cb6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     cb8:	0f 90       	pop	r0
     cba:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     cbc:	0f b6       	in	r0, 0x3f	; 63
     cbe:	f8 94       	cli
     cc0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     cc2:	8e 01       	movw	r16, r28
     cc4:	08 5f       	subi	r16, 0xF8	; 248
     cc6:	1f 4f       	sbci	r17, 0xFF	; 255
     cc8:	0d c0       	rjmp	.+26     	; 0xce4 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     cca:	88 85       	ldd	r24, Y+8	; 0x08
     ccc:	88 23       	and	r24, r24
     cce:	69 f0       	breq	.+26     	; 0xcea <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     cd0:	c8 01       	movw	r24, r16
     cd2:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     cd6:	88 23       	and	r24, r24
     cd8:	11 f0       	breq	.+4      	; 0xcde <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     cda:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     cde:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ce0:	81 50       	subi	r24, 0x01	; 1
     ce2:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ce4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ce6:	18 16       	cp	r1, r24
     ce8:	84 f3       	brlt	.-32     	; 0xcca <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     cea:	8f ef       	ldi	r24, 0xFF	; 255
     cec:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     cee:	0f 90       	pop	r0
     cf0:	0f be       	out	0x3f, r0	; 63
}
     cf2:	df 91       	pop	r29
     cf4:	cf 91       	pop	r28
     cf6:	1f 91       	pop	r17
     cf8:	0f 91       	pop	r16
     cfa:	08 95       	ret

00000cfc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     cfc:	7f 92       	push	r7
     cfe:	8f 92       	push	r8
     d00:	9f 92       	push	r9
     d02:	af 92       	push	r10
     d04:	bf 92       	push	r11
     d06:	cf 92       	push	r12
     d08:	df 92       	push	r13
     d0a:	ef 92       	push	r14
     d0c:	ff 92       	push	r15
     d0e:	0f 93       	push	r16
     d10:	1f 93       	push	r17
     d12:	df 93       	push	r29
     d14:	cf 93       	push	r28
     d16:	00 d0       	rcall	.+0      	; 0xd18 <xQueueGenericReceive+0x1c>
     d18:	00 d0       	rcall	.+0      	; 0xd1a <xQueueGenericReceive+0x1e>
     d1a:	0f 92       	push	r0
     d1c:	cd b7       	in	r28, 0x3d	; 61
     d1e:	de b7       	in	r29, 0x3e	; 62
     d20:	8c 01       	movw	r16, r24
     d22:	96 2e       	mov	r9, r22
     d24:	87 2e       	mov	r8, r23
     d26:	5d 83       	std	Y+5, r21	; 0x05
     d28:	4c 83       	std	Y+4, r20	; 0x04
     d2a:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d2c:	91 e1       	ldi	r25, 0x11	; 17
     d2e:	c9 2e       	mov	r12, r25
     d30:	d1 2c       	mov	r13, r1
     d32:	c0 0e       	add	r12, r16
     d34:	d1 1e       	adc	r13, r17
     d36:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d38:	7e 01       	movw	r14, r28
     d3a:	08 94       	sec
     d3c:	e1 1c       	adc	r14, r1
     d3e:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d40:	84 e0       	ldi	r24, 0x04	; 4
     d42:	a8 2e       	mov	r10, r24
     d44:	b1 2c       	mov	r11, r1
     d46:	ac 0e       	add	r10, r28
     d48:	bd 1e       	adc	r11, r29
     d4a:	01 c0       	rjmp	.+2      	; 0xd4e <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d4c:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     d54:	f8 01       	movw	r30, r16
     d56:	82 8d       	ldd	r24, Z+26	; 0x1a
     d58:	88 23       	and	r24, r24
     d5a:	09 f4       	brne	.+2      	; 0xd5e <xQueueGenericReceive+0x62>
     d5c:	3e c0       	rjmp	.+124    	; 0xdda <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     d5e:	e6 80       	ldd	r14, Z+6	; 0x06
     d60:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     d62:	40 81       	ld	r20, Z
     d64:	51 81       	ldd	r21, Z+1	; 0x01
     d66:	41 15       	cp	r20, r1
     d68:	51 05       	cpc	r21, r1
     d6a:	b1 f0       	breq	.+44     	; 0xd98 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     d6c:	84 8d       	ldd	r24, Z+28	; 0x1c
     d6e:	97 01       	movw	r18, r14
     d70:	28 0f       	add	r18, r24
     d72:	31 1d       	adc	r19, r1
     d74:	37 83       	std	Z+7, r19	; 0x07
     d76:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     d78:	82 81       	ldd	r24, Z+2	; 0x02
     d7a:	93 81       	ldd	r25, Z+3	; 0x03
     d7c:	28 17       	cp	r18, r24
     d7e:	39 07       	cpc	r19, r25
     d80:	10 f0       	brcs	.+4      	; 0xd86 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     d82:	57 83       	std	Z+7, r21	; 0x07
     d84:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     d86:	f8 01       	movw	r30, r16
     d88:	44 8d       	ldd	r20, Z+28	; 0x1c
     d8a:	66 81       	ldd	r22, Z+6	; 0x06
     d8c:	77 81       	ldd	r23, Z+7	; 0x07
     d8e:	89 2d       	mov	r24, r9
     d90:	98 2d       	mov	r25, r8
     d92:	50 e0       	ldi	r21, 0x00	; 0
     d94:	0e 94 c8 21 	call	0x4390	; 0x4390 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     d98:	77 20       	and	r7, r7
     d9a:	71 f4       	brne	.+28     	; 0xdb8 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     d9c:	f8 01       	movw	r30, r16
     d9e:	82 8d       	ldd	r24, Z+26	; 0x1a
     da0:	81 50       	subi	r24, 0x01	; 1
     da2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     da4:	80 85       	ldd	r24, Z+8	; 0x08
     da6:	88 23       	and	r24, r24
     da8:	a1 f0       	breq	.+40     	; 0xdd2 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     daa:	c8 01       	movw	r24, r16
     dac:	08 96       	adiw	r24, 0x08	; 8
     dae:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     db2:	81 30       	cpi	r24, 0x01	; 1
     db4:	71 f4       	brne	.+28     	; 0xdd2 <xQueueGenericReceive+0xd6>
     db6:	0b c0       	rjmp	.+22     	; 0xdce <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     db8:	f8 01       	movw	r30, r16
     dba:	f7 82       	std	Z+7, r15	; 0x07
     dbc:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     dbe:	81 89       	ldd	r24, Z+17	; 0x11
     dc0:	88 23       	and	r24, r24
     dc2:	39 f0       	breq	.+14     	; 0xdd2 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dc4:	c6 01       	movw	r24, r12
     dc6:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     dca:	88 23       	and	r24, r24
     dcc:	11 f0       	breq	.+4      	; 0xdd2 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     dce:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     dd2:	0f 90       	pop	r0
     dd4:	0f be       	out	0x3f, r0	; 63
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	4a c0       	rjmp	.+148    	; 0xe6e <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     dda:	8c 81       	ldd	r24, Y+4	; 0x04
     ddc:	9d 81       	ldd	r25, Y+5	; 0x05
     dde:	89 2b       	or	r24, r25
     de0:	19 f4       	brne	.+6      	; 0xde8 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     de2:	0f 90       	pop	r0
     de4:	0f be       	out	0x3f, r0	; 63
     de6:	42 c0       	rjmp	.+132    	; 0xe6c <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     de8:	22 23       	and	r18, r18
     dea:	19 f4       	brne	.+6      	; 0xdf2 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     dec:	c7 01       	movw	r24, r14
     dee:	0e 94 ad 08 	call	0x115a	; 0x115a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     df2:	0f 90       	pop	r0
     df4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     df6:	0e 94 51 08 	call	0x10a2	; 0x10a2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     dfa:	0f b6       	in	r0, 0x3f	; 63
     dfc:	f8 94       	cli
     dfe:	0f 92       	push	r0
     e00:	f8 01       	movw	r30, r16
     e02:	85 8d       	ldd	r24, Z+29	; 0x1d
     e04:	8f 3f       	cpi	r24, 0xFF	; 255
     e06:	09 f4       	brne	.+2      	; 0xe0a <xQueueGenericReceive+0x10e>
     e08:	15 8e       	std	Z+29, r1	; 0x1d
     e0a:	f8 01       	movw	r30, r16
     e0c:	86 8d       	ldd	r24, Z+30	; 0x1e
     e0e:	8f 3f       	cpi	r24, 0xFF	; 255
     e10:	09 f4       	brne	.+2      	; 0xe14 <xQueueGenericReceive+0x118>
     e12:	16 8e       	std	Z+30, r1	; 0x1e
     e14:	0f 90       	pop	r0
     e16:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e18:	c7 01       	movw	r24, r14
     e1a:	b5 01       	movw	r22, r10
     e1c:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskCheckForTimeOut>
     e20:	88 23       	and	r24, r24
     e22:	f9 f4       	brne	.+62     	; 0xe62 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e24:	0f b6       	in	r0, 0x3f	; 63
     e26:	f8 94       	cli
     e28:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     e2a:	f8 01       	movw	r30, r16
     e2c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     e2e:	0f 90       	pop	r0
     e30:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
     e32:	88 23       	and	r24, r24
     e34:	81 f4       	brne	.+32     	; 0xe56 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e36:	6c 81       	ldd	r22, Y+4	; 0x04
     e38:	7d 81       	ldd	r23, Y+5	; 0x05
     e3a:	c6 01       	movw	r24, r12
     e3c:	0e 94 af 09 	call	0x135e	; 0x135e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     e40:	c8 01       	movw	r24, r16
     e42:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvUnlockQueue>
				if( !xTaskResumeAll() )
     e46:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
     e4a:	88 23       	and	r24, r24
     e4c:	09 f0       	breq	.+2      	; 0xe50 <xQueueGenericReceive+0x154>
     e4e:	7e cf       	rjmp	.-260    	; 0xd4c <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
     e50:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
     e54:	7b cf       	rjmp	.-266    	; 0xd4c <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e56:	c8 01       	movw	r24, r16
     e58:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e5c:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
     e60:	75 cf       	rjmp	.-278    	; 0xd4c <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     e62:	c8 01       	movw	r24, r16
     e64:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e68:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
     e6c:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
     e6e:	0f 90       	pop	r0
     e70:	0f 90       	pop	r0
     e72:	0f 90       	pop	r0
     e74:	0f 90       	pop	r0
     e76:	0f 90       	pop	r0
     e78:	cf 91       	pop	r28
     e7a:	df 91       	pop	r29
     e7c:	1f 91       	pop	r17
     e7e:	0f 91       	pop	r16
     e80:	ff 90       	pop	r15
     e82:	ef 90       	pop	r14
     e84:	df 90       	pop	r13
     e86:	cf 90       	pop	r12
     e88:	bf 90       	pop	r11
     e8a:	af 90       	pop	r10
     e8c:	9f 90       	pop	r9
     e8e:	8f 90       	pop	r8
     e90:	7f 90       	pop	r7
     e92:	08 95       	ret

00000e94 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     e94:	7f 92       	push	r7
     e96:	8f 92       	push	r8
     e98:	9f 92       	push	r9
     e9a:	af 92       	push	r10
     e9c:	bf 92       	push	r11
     e9e:	cf 92       	push	r12
     ea0:	df 92       	push	r13
     ea2:	ef 92       	push	r14
     ea4:	ff 92       	push	r15
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	00 d0       	rcall	.+0      	; 0xeb0 <xQueueGenericSend+0x1c>
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <xQueueGenericSend+0x1e>
     eb2:	0f 92       	push	r0
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	8c 01       	movw	r16, r24
     eba:	6b 01       	movw	r12, r22
     ebc:	5d 83       	std	Y+5, r21	; 0x05
     ebe:	4c 83       	std	Y+4, r20	; 0x04
     ec0:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ec2:	48 e0       	ldi	r20, 0x08	; 8
     ec4:	e4 2e       	mov	r14, r20
     ec6:	f1 2c       	mov	r15, r1
     ec8:	e8 0e       	add	r14, r24
     eca:	f9 1e       	adc	r15, r25
     ecc:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ece:	5e 01       	movw	r10, r28
     ed0:	08 94       	sec
     ed2:	a1 1c       	adc	r10, r1
     ed4:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ed6:	34 e0       	ldi	r19, 0x04	; 4
     ed8:	83 2e       	mov	r8, r19
     eda:	91 2c       	mov	r9, r1
     edc:	8c 0e       	add	r8, r28
     ede:	9d 1e       	adc	r9, r29
     ee0:	01 c0       	rjmp	.+2      	; 0xee4 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     ee2:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ee4:	0f b6       	in	r0, 0x3f	; 63
     ee6:	f8 94       	cli
     ee8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     eea:	f8 01       	movw	r30, r16
     eec:	92 8d       	ldd	r25, Z+26	; 0x1a
     eee:	83 8d       	ldd	r24, Z+27	; 0x1b
     ef0:	98 17       	cp	r25, r24
     ef2:	a8 f4       	brcc	.+42     	; 0xf1e <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     ef4:	c8 01       	movw	r24, r16
     ef6:	b6 01       	movw	r22, r12
     ef8:	47 2d       	mov	r20, r7
     efa:	0e 94 d5 05 	call	0xbaa	; 0xbaa <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     efe:	f8 01       	movw	r30, r16
     f00:	81 89       	ldd	r24, Z+17	; 0x11
     f02:	88 23       	and	r24, r24
     f04:	41 f0       	breq	.+16     	; 0xf16 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     f06:	c8 01       	movw	r24, r16
     f08:	41 96       	adiw	r24, 0x11	; 17
     f0a:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xTaskRemoveFromEventList>
     f0e:	81 30       	cpi	r24, 0x01	; 1
     f10:	11 f4       	brne	.+4      	; 0xf16 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     f12:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     f16:	0f 90       	pop	r0
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	81 e0       	ldi	r24, 0x01	; 1
     f1c:	4c c0       	rjmp	.+152    	; 0xfb6 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     f1e:	8c 81       	ldd	r24, Y+4	; 0x04
     f20:	9d 81       	ldd	r25, Y+5	; 0x05
     f22:	89 2b       	or	r24, r25
     f24:	19 f4       	brne	.+6      	; 0xf2c <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	44 c0       	rjmp	.+136    	; 0xfb4 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     f2c:	22 23       	and	r18, r18
     f2e:	19 f4       	brne	.+6      	; 0xf36 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f30:	c5 01       	movw	r24, r10
     f32:	0e 94 ad 08 	call	0x115a	; 0x115a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     f36:	0f 90       	pop	r0
     f38:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f3a:	0e 94 51 08 	call	0x10a2	; 0x10a2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	f8 94       	cli
     f42:	0f 92       	push	r0
     f44:	f8 01       	movw	r30, r16
     f46:	85 8d       	ldd	r24, Z+29	; 0x1d
     f48:	8f 3f       	cpi	r24, 0xFF	; 255
     f4a:	09 f4       	brne	.+2      	; 0xf4e <xQueueGenericSend+0xba>
     f4c:	15 8e       	std	Z+29, r1	; 0x1d
     f4e:	f8 01       	movw	r30, r16
     f50:	86 8d       	ldd	r24, Z+30	; 0x1e
     f52:	8f 3f       	cpi	r24, 0xFF	; 255
     f54:	09 f4       	brne	.+2      	; 0xf58 <xQueueGenericSend+0xc4>
     f56:	16 8e       	std	Z+30, r1	; 0x1e
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f5c:	c5 01       	movw	r24, r10
     f5e:	b4 01       	movw	r22, r8
     f60:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskCheckForTimeOut>
     f64:	88 23       	and	r24, r24
     f66:	09 f5       	brne	.+66     	; 0xfaa <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     f6e:	f8 01       	movw	r30, r16
     f70:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     f72:	0f 90       	pop	r0
     f74:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
     f76:	f8 01       	movw	r30, r16
     f78:	83 8d       	ldd	r24, Z+27	; 0x1b
     f7a:	98 17       	cp	r25, r24
     f7c:	81 f4       	brne	.+32     	; 0xf9e <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f7e:	6c 81       	ldd	r22, Y+4	; 0x04
     f80:	7d 81       	ldd	r23, Y+5	; 0x05
     f82:	c7 01       	movw	r24, r14
     f84:	0e 94 af 09 	call	0x135e	; 0x135e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f88:	c8 01       	movw	r24, r16
     f8a:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
     f8e:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
     f92:	88 23       	and	r24, r24
     f94:	09 f0       	breq	.+2      	; 0xf98 <xQueueGenericSend+0x104>
     f96:	a5 cf       	rjmp	.-182    	; 0xee2 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
     f98:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
     f9c:	a2 cf       	rjmp	.-188    	; 0xee2 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f9e:	c8 01       	movw	r24, r16
     fa0:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fa4:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
     fa8:	9c cf       	rjmp	.-200    	; 0xee2 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     faa:	c8 01       	movw	r24, r16
     fac:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fb0:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
     fb4:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
     fb6:	0f 90       	pop	r0
     fb8:	0f 90       	pop	r0
     fba:	0f 90       	pop	r0
     fbc:	0f 90       	pop	r0
     fbe:	0f 90       	pop	r0
     fc0:	cf 91       	pop	r28
     fc2:	df 91       	pop	r29
     fc4:	1f 91       	pop	r17
     fc6:	0f 91       	pop	r16
     fc8:	ff 90       	pop	r15
     fca:	ef 90       	pop	r14
     fcc:	df 90       	pop	r13
     fce:	cf 90       	pop	r12
     fd0:	bf 90       	pop	r11
     fd2:	af 90       	pop	r10
     fd4:	9f 90       	pop	r9
     fd6:	8f 90       	pop	r8
     fd8:	7f 90       	pop	r7
     fda:	08 95       	ret

00000fdc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     fdc:	8f 92       	push	r8
     fde:	9f 92       	push	r9
     fe0:	af 92       	push	r10
     fe2:	bf 92       	push	r11
     fe4:	cf 92       	push	r12
     fe6:	df 92       	push	r13
     fe8:	ef 92       	push	r14
     fea:	ff 92       	push	r15
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	98 2e       	mov	r9, r24
     ff6:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     ff8:	88 23       	and	r24, r24
     ffa:	09 f4       	brne	.+2      	; 0xffe <xQueueCreate+0x22>
     ffc:	42 c0       	rjmp	.+132    	; 0x1082 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     ffe:	8f e1       	ldi	r24, 0x1F	; 31
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <pvPortMalloc>
    1006:	8c 01       	movw	r16, r24
    1008:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    100a:	00 97       	sbiw	r24, 0x00	; 0
    100c:	e1 f1       	breq	.+120    	; 0x1086 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    100e:	c9 2c       	mov	r12, r9
    1010:	dd 24       	eor	r13, r13
    1012:	a8 2c       	mov	r10, r8
    1014:	bb 24       	eor	r11, r11
    1016:	ac 9c       	mul	r10, r12
    1018:	70 01       	movw	r14, r0
    101a:	ad 9c       	mul	r10, r13
    101c:	f0 0c       	add	r15, r0
    101e:	bc 9c       	mul	r11, r12
    1020:	f0 0c       	add	r15, r0
    1022:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1024:	c7 01       	movw	r24, r14
    1026:	01 96       	adiw	r24, 0x01	; 1
    1028:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <pvPortMalloc>
    102c:	9c 01       	movw	r18, r24
    102e:	99 83       	std	Y+1, r25	; 0x01
    1030:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1032:	00 97       	sbiw	r24, 0x00	; 0
    1034:	19 f1       	breq	.+70     	; 0x107c <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1036:	e8 0e       	add	r14, r24
    1038:	f9 1e       	adc	r15, r25
    103a:	fb 82       	std	Y+3, r15	; 0x03
    103c:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    103e:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1040:	9d 83       	std	Y+5, r25	; 0x05
    1042:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    1044:	08 94       	sec
    1046:	c1 08       	sbc	r12, r1
    1048:	d1 08       	sbc	r13, r1
    104a:	ca 9c       	mul	r12, r10
    104c:	c0 01       	movw	r24, r0
    104e:	cb 9c       	mul	r12, r11
    1050:	90 0d       	add	r25, r0
    1052:	da 9c       	mul	r13, r10
    1054:	90 0d       	add	r25, r0
    1056:	11 24       	eor	r1, r1
    1058:	28 0f       	add	r18, r24
    105a:	39 1f       	adc	r19, r25
    105c:	3f 83       	std	Y+7, r19	; 0x07
    105e:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1060:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1062:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1064:	8f ef       	ldi	r24, 0xFF	; 255
    1066:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1068:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    106a:	c8 01       	movw	r24, r16
    106c:	08 96       	adiw	r24, 0x08	; 8
    106e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1072:	c8 01       	movw	r24, r16
    1074:	41 96       	adiw	r24, 0x11	; 17
    1076:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
    107a:	05 c0       	rjmp	.+10     	; 0x1086 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    107c:	c8 01       	movw	r24, r16
    107e:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vPortFree>
    1082:	c0 e0       	ldi	r28, 0x00	; 0
    1084:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    1086:	ce 01       	movw	r24, r28
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	1f 91       	pop	r17
    108e:	0f 91       	pop	r16
    1090:	ff 90       	pop	r15
    1092:	ef 90       	pop	r14
    1094:	df 90       	pop	r13
    1096:	cf 90       	pop	r12
    1098:	bf 90       	pop	r11
    109a:	af 90       	pop	r10
    109c:	9f 90       	pop	r9
    109e:	8f 90       	pop	r8
    10a0:	08 95       	ret

000010a2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    10a2:	80 91 bc 02 	lds	r24, 0x02BC
    10a6:	8f 5f       	subi	r24, 0xFF	; 255
    10a8:	80 93 bc 02 	sts	0x02BC, r24
}
    10ac:	08 95       	ret

000010ae <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    10ae:	0f b6       	in	r0, 0x3f	; 63
    10b0:	f8 94       	cli
    10b2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    10b4:	20 91 ba 02 	lds	r18, 0x02BA
    10b8:	30 91 bb 02 	lds	r19, 0x02BB
	}
	portEXIT_CRITICAL();
    10bc:	0f 90       	pop	r0
    10be:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    10c0:	c9 01       	movw	r24, r18
    10c2:	08 95       	ret

000010c4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    10c4:	20 91 ba 02 	lds	r18, 0x02BA
    10c8:	30 91 bb 02 	lds	r19, 0x02BB
}
    10cc:	c9 01       	movw	r24, r18
    10ce:	08 95       	ret

000010d0 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    10d0:	80 91 bf 02 	lds	r24, 0x02BF
}
    10d4:	08 95       	ret

000010d6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    10d6:	80 91 bc 02 	lds	r24, 0x02BC
    10da:	88 23       	and	r24, r24
    10dc:	51 f0       	breq	.+20     	; 0x10f2 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	80 93 b8 02 	sts	0x02B8, r24
    10e4:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    10e6:	80 91 bd 02 	lds	r24, 0x02BD
    10ea:	81 50       	subi	r24, 0x01	; 1
    10ec:	80 93 bd 02 	sts	0x02BD, r24
    10f0:	01 c0       	rjmp	.+2      	; 0x10f4 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    10f2:	99 e0       	ldi	r25, 0x09	; 9
    10f4:	e0 91 bd 02 	lds	r30, 0x02BD
    10f8:	e9 9f       	mul	r30, r25
    10fa:	f0 01       	movw	r30, r0
    10fc:	11 24       	eor	r1, r1
    10fe:	ec 53       	subi	r30, 0x3C	; 60
    1100:	fd 4f       	sbci	r31, 0xFD	; 253
    1102:	80 81       	ld	r24, Z
    1104:	88 23       	and	r24, r24
    1106:	79 f3       	breq	.-34     	; 0x10e6 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1108:	90 91 bd 02 	lds	r25, 0x02BD
    110c:	89 e0       	ldi	r24, 0x09	; 9
    110e:	98 9f       	mul	r25, r24
    1110:	d0 01       	movw	r26, r0
    1112:	11 24       	eor	r1, r1
    1114:	ac 53       	subi	r26, 0x3C	; 60
    1116:	bd 4f       	sbci	r27, 0xFD	; 253
    1118:	11 96       	adiw	r26, 0x01	; 1
    111a:	ed 91       	ld	r30, X+
    111c:	fc 91       	ld	r31, X
    111e:	12 97       	sbiw	r26, 0x02	; 2
    1120:	02 80       	ldd	r0, Z+2	; 0x02
    1122:	f3 81       	ldd	r31, Z+3	; 0x03
    1124:	e0 2d       	mov	r30, r0
    1126:	12 96       	adiw	r26, 0x02	; 2
    1128:	fc 93       	st	X, r31
    112a:	ee 93       	st	-X, r30
    112c:	11 97       	sbiw	r26, 0x01	; 1
    112e:	cd 01       	movw	r24, r26
    1130:	03 96       	adiw	r24, 0x03	; 3
    1132:	e8 17       	cp	r30, r24
    1134:	f9 07       	cpc	r31, r25
    1136:	31 f4       	brne	.+12     	; 0x1144 <vTaskSwitchContext+0x6e>
    1138:	82 81       	ldd	r24, Z+2	; 0x02
    113a:	93 81       	ldd	r25, Z+3	; 0x03
    113c:	12 96       	adiw	r26, 0x02	; 2
    113e:	9c 93       	st	X, r25
    1140:	8e 93       	st	-X, r24
    1142:	11 97       	sbiw	r26, 0x01	; 1
    1144:	11 96       	adiw	r26, 0x01	; 1
    1146:	ed 91       	ld	r30, X+
    1148:	fc 91       	ld	r31, X
    114a:	12 97       	sbiw	r26, 0x02	; 2
    114c:	86 81       	ldd	r24, Z+6	; 0x06
    114e:	97 81       	ldd	r25, Z+7	; 0x07
    1150:	90 93 b7 02 	sts	0x02B7, r25
    1154:	80 93 b6 02 	sts	0x02B6, r24
    1158:	08 95       	ret

0000115a <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    115a:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    115c:	80 91 b9 02 	lds	r24, 0x02B9
    1160:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1162:	80 91 ba 02 	lds	r24, 0x02BA
    1166:	90 91 bb 02 	lds	r25, 0x02BB
    116a:	92 83       	std	Z+2, r25	; 0x02
    116c:	81 83       	std	Z+1, r24	; 0x01
}
    116e:	08 95       	ret

00001170 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    1170:	fc 01       	movw	r30, r24
    1172:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    1174:	0f b6       	in	r0, 0x3f	; 63
    1176:	f8 94       	cli
    1178:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    117a:	90 91 b9 02 	lds	r25, 0x02B9
    117e:	80 81       	ld	r24, Z
    1180:	98 17       	cp	r25, r24
    1182:	49 f0       	breq	.+18     	; 0x1196 <xTaskCheckForTimeOut+0x26>
    1184:	20 91 ba 02 	lds	r18, 0x02BA
    1188:	30 91 bb 02 	lds	r19, 0x02BB
    118c:	81 81       	ldd	r24, Z+1	; 0x01
    118e:	92 81       	ldd	r25, Z+2	; 0x02
    1190:	28 17       	cp	r18, r24
    1192:	39 07       	cpc	r19, r25
    1194:	18 f5       	brcc	.+70     	; 0x11dc <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1196:	80 91 ba 02 	lds	r24, 0x02BA
    119a:	90 91 bb 02 	lds	r25, 0x02BB
    119e:	21 81       	ldd	r18, Z+1	; 0x01
    11a0:	32 81       	ldd	r19, Z+2	; 0x02
    11a2:	4d 91       	ld	r20, X+
    11a4:	5c 91       	ld	r21, X
    11a6:	11 97       	sbiw	r26, 0x01	; 1
    11a8:	82 1b       	sub	r24, r18
    11aa:	93 0b       	sbc	r25, r19
    11ac:	84 17       	cp	r24, r20
    11ae:	95 07       	cpc	r25, r21
    11b0:	a8 f4       	brcc	.+42     	; 0x11dc <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    11b2:	80 91 ba 02 	lds	r24, 0x02BA
    11b6:	90 91 bb 02 	lds	r25, 0x02BB
    11ba:	28 1b       	sub	r18, r24
    11bc:	39 0b       	sbc	r19, r25
    11be:	24 0f       	add	r18, r20
    11c0:	35 1f       	adc	r19, r21
    11c2:	2d 93       	st	X+, r18
    11c4:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    11c6:	80 91 b9 02 	lds	r24, 0x02B9
    11ca:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    11cc:	80 91 ba 02 	lds	r24, 0x02BA
    11d0:	90 91 bb 02 	lds	r25, 0x02BB
    11d4:	92 83       	std	Z+2, r25	; 0x02
    11d6:	81 83       	std	Z+1, r24	; 0x01
    11d8:	80 e0       	ldi	r24, 0x00	; 0
    11da:	01 c0       	rjmp	.+2      	; 0x11de <xTaskCheckForTimeOut+0x6e>
    11dc:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    11de:	0f 90       	pop	r0
    11e0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    11e2:	08 95       	ret

000011e4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	80 93 b8 02 	sts	0x02B8, r24
}
    11ea:	08 95       	ret

000011ec <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    11ec:	0f 93       	push	r16
    11ee:	1f 93       	push	r17
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    11f6:	80 81       	ld	r24, Z
    11f8:	88 23       	and	r24, r24
    11fa:	19 f4       	brne	.+6      	; 0x1202 <xTaskRemoveFromEventList+0x16>
    11fc:	c0 e0       	ldi	r28, 0x00	; 0
    11fe:	d0 e0       	ldi	r29, 0x00	; 0
    1200:	05 c0       	rjmp	.+10     	; 0x120c <xTaskRemoveFromEventList+0x20>
    1202:	05 80       	ldd	r0, Z+5	; 0x05
    1204:	f6 81       	ldd	r31, Z+6	; 0x06
    1206:	e0 2d       	mov	r30, r0
    1208:	c6 81       	ldd	r28, Z+6	; 0x06
    120a:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    120c:	8e 01       	movw	r16, r28
    120e:	04 5f       	subi	r16, 0xF4	; 244
    1210:	1f 4f       	sbci	r17, 0xFF	; 255
    1212:	c8 01       	movw	r24, r16
    1214:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1218:	80 91 bc 02 	lds	r24, 0x02BC
    121c:	88 23       	and	r24, r24
    121e:	a1 f4       	brne	.+40     	; 0x1248 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1220:	8e 01       	movw	r16, r28
    1222:	0e 5f       	subi	r16, 0xFE	; 254
    1224:	1f 4f       	sbci	r17, 0xFF	; 255
    1226:	c8 01       	movw	r24, r16
    1228:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    122c:	9e 89       	ldd	r25, Y+22	; 0x16
    122e:	80 91 bd 02 	lds	r24, 0x02BD
    1232:	89 17       	cp	r24, r25
    1234:	10 f4       	brcc	.+4      	; 0x123a <xTaskRemoveFromEventList+0x4e>
    1236:	90 93 bd 02 	sts	0x02BD, r25
    123a:	89 e0       	ldi	r24, 0x09	; 9
    123c:	98 9f       	mul	r25, r24
    123e:	c0 01       	movw	r24, r0
    1240:	11 24       	eor	r1, r1
    1242:	8c 53       	subi	r24, 0x3C	; 60
    1244:	9d 4f       	sbci	r25, 0xFD	; 253
    1246:	02 c0       	rjmp	.+4      	; 0x124c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1248:	8e ef       	ldi	r24, 0xFE	; 254
    124a:	92 e0       	ldi	r25, 0x02	; 2
    124c:	b8 01       	movw	r22, r16
    124e:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1252:	e0 91 b6 02 	lds	r30, 0x02B6
    1256:	f0 91 b7 02 	lds	r31, 0x02B7
    125a:	20 e0       	ldi	r18, 0x00	; 0
    125c:	9e 89       	ldd	r25, Y+22	; 0x16
    125e:	86 89       	ldd	r24, Z+22	; 0x16
    1260:	98 17       	cp	r25, r24
    1262:	08 f0       	brcs	.+2      	; 0x1266 <xTaskRemoveFromEventList+0x7a>
    1264:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1266:	82 2f       	mov	r24, r18
    1268:	df 91       	pop	r29
    126a:	cf 91       	pop	r28
    126c:	1f 91       	pop	r17
    126e:	0f 91       	pop	r16
    1270:	08 95       	ret

00001272 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    1272:	ff 92       	push	r15
    1274:	0f 93       	push	r16
    1276:	1f 93       	push	r17
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    127c:	80 91 bc 02 	lds	r24, 0x02BC
    1280:	88 23       	and	r24, r24
    1282:	09 f0       	breq	.+2      	; 0x1286 <vTaskIncrementTick+0x14>
    1284:	61 c0       	rjmp	.+194    	; 0x1348 <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    1286:	80 91 ba 02 	lds	r24, 0x02BA
    128a:	90 91 bb 02 	lds	r25, 0x02BB
    128e:	01 96       	adiw	r24, 0x01	; 1
    1290:	90 93 bb 02 	sts	0x02BB, r25
    1294:	80 93 ba 02 	sts	0x02BA, r24
		if( xTickCount == ( portTickType ) 0 )
    1298:	80 91 ba 02 	lds	r24, 0x02BA
    129c:	90 91 bb 02 	lds	r25, 0x02BB
    12a0:	89 2b       	or	r24, r25
    12a2:	e9 f5       	brne	.+122    	; 0x131e <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    12a4:	80 91 fa 02 	lds	r24, 0x02FA
    12a8:	90 91 fb 02 	lds	r25, 0x02FB
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    12ac:	20 91 fc 02 	lds	r18, 0x02FC
    12b0:	30 91 fd 02 	lds	r19, 0x02FD
    12b4:	30 93 fb 02 	sts	0x02FB, r19
    12b8:	20 93 fa 02 	sts	0x02FA, r18
			pxOverflowDelayedTaskList = pxTemp;
    12bc:	90 93 fd 02 	sts	0x02FD, r25
    12c0:	80 93 fc 02 	sts	0x02FC, r24
			xNumOfOverflows++;
    12c4:	80 91 b9 02 	lds	r24, 0x02B9
    12c8:	8f 5f       	subi	r24, 0xFF	; 255
    12ca:	80 93 b9 02 	sts	0x02B9, r24
    12ce:	27 c0       	rjmp	.+78     	; 0x131e <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    12d0:	20 91 ba 02 	lds	r18, 0x02BA
    12d4:	30 91 bb 02 	lds	r19, 0x02BB
    12d8:	8a 81       	ldd	r24, Y+2	; 0x02
    12da:	9b 81       	ldd	r25, Y+3	; 0x03
    12dc:	28 17       	cp	r18, r24
    12de:	39 07       	cpc	r19, r25
    12e0:	c0 f1       	brcs	.+112    	; 0x1352 <vTaskIncrementTick+0xe0>
    12e2:	8e 01       	movw	r16, r28
    12e4:	0e 5f       	subi	r16, 0xFE	; 254
    12e6:	1f 4f       	sbci	r17, 0xFF	; 255
    12e8:	c8 01       	movw	r24, r16
    12ea:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
    12ee:	8c 89       	ldd	r24, Y+20	; 0x14
    12f0:	9d 89       	ldd	r25, Y+21	; 0x15
    12f2:	89 2b       	or	r24, r25
    12f4:	21 f0       	breq	.+8      	; 0x12fe <vTaskIncrementTick+0x8c>
    12f6:	ce 01       	movw	r24, r28
    12f8:	0c 96       	adiw	r24, 0x0c	; 12
    12fa:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
    12fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1300:	80 91 bd 02 	lds	r24, 0x02BD
    1304:	89 17       	cp	r24, r25
    1306:	10 f4       	brcc	.+4      	; 0x130c <vTaskIncrementTick+0x9a>
    1308:	90 93 bd 02 	sts	0x02BD, r25
    130c:	9f 9d       	mul	r25, r15
    130e:	c0 01       	movw	r24, r0
    1310:	11 24       	eor	r1, r1
    1312:	8c 53       	subi	r24, 0x3C	; 60
    1314:	9d 4f       	sbci	r25, 0xFD	; 253
    1316:	b8 01       	movw	r22, r16
    1318:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    131c:	02 c0       	rjmp	.+4      	; 0x1322 <vTaskIncrementTick+0xb0>
    131e:	89 e0       	ldi	r24, 0x09	; 9
    1320:	f8 2e       	mov	r15, r24
    1322:	e0 91 fa 02 	lds	r30, 0x02FA
    1326:	f0 91 fb 02 	lds	r31, 0x02FB
    132a:	80 81       	ld	r24, Z
    132c:	88 23       	and	r24, r24
    132e:	89 f0       	breq	.+34     	; 0x1352 <vTaskIncrementTick+0xe0>
    1330:	e0 91 fa 02 	lds	r30, 0x02FA
    1334:	f0 91 fb 02 	lds	r31, 0x02FB
    1338:	05 80       	ldd	r0, Z+5	; 0x05
    133a:	f6 81       	ldd	r31, Z+6	; 0x06
    133c:	e0 2d       	mov	r30, r0
    133e:	c6 81       	ldd	r28, Z+6	; 0x06
    1340:	d7 81       	ldd	r29, Z+7	; 0x07
    1342:	20 97       	sbiw	r28, 0x00	; 0
    1344:	29 f6       	brne	.-118    	; 0x12d0 <vTaskIncrementTick+0x5e>
    1346:	05 c0       	rjmp	.+10     	; 0x1352 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    1348:	80 91 be 02 	lds	r24, 0x02BE
    134c:	8f 5f       	subi	r24, 0xFF	; 255
    134e:	80 93 be 02 	sts	0x02BE, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1352:	df 91       	pop	r29
    1354:	cf 91       	pop	r28
    1356:	1f 91       	pop	r17
    1358:	0f 91       	pop	r16
    135a:	ff 90       	pop	r15
    135c:	08 95       	ret

0000135e <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    135e:	0f 93       	push	r16
    1360:	1f 93       	push	r17
    1362:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1364:	60 91 b6 02 	lds	r22, 0x02B6
    1368:	70 91 b7 02 	lds	r23, 0x02B7
    136c:	64 5f       	subi	r22, 0xF4	; 244
    136e:	7f 4f       	sbci	r23, 0xFF	; 255
    1370:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1374:	80 91 b6 02 	lds	r24, 0x02B6
    1378:	90 91 b7 02 	lds	r25, 0x02B7
    137c:	02 96       	adiw	r24, 0x02	; 2
    137e:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1382:	80 91 ba 02 	lds	r24, 0x02BA
    1386:	90 91 bb 02 	lds	r25, 0x02BB
    138a:	80 0f       	add	r24, r16
    138c:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    138e:	e0 91 b6 02 	lds	r30, 0x02B6
    1392:	f0 91 b7 02 	lds	r31, 0x02B7
    1396:	93 83       	std	Z+3, r25	; 0x03
    1398:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    139a:	20 91 ba 02 	lds	r18, 0x02BA
    139e:	30 91 bb 02 	lds	r19, 0x02BB
    13a2:	82 17       	cp	r24, r18
    13a4:	93 07       	cpc	r25, r19
    13a6:	28 f4       	brcc	.+10     	; 0x13b2 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13a8:	80 91 fc 02 	lds	r24, 0x02FC
    13ac:	90 91 fd 02 	lds	r25, 0x02FD
    13b0:	04 c0       	rjmp	.+8      	; 0x13ba <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    13b2:	80 91 fa 02 	lds	r24, 0x02FA
    13b6:	90 91 fb 02 	lds	r25, 0x02FB
    13ba:	60 91 b6 02 	lds	r22, 0x02B6
    13be:	70 91 b7 02 	lds	r23, 0x02B7
    13c2:	6e 5f       	subi	r22, 0xFE	; 254
    13c4:	7f 4f       	sbci	r23, 0xFF	; 255
    13c6:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsert>
			}
	}
	#endif
}
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	08 95       	ret

000013d0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    13d0:	cf 92       	push	r12
    13d2:	df 92       	push	r13
    13d4:	ff 92       	push	r15
    13d6:	0f 93       	push	r16
    13d8:	1f 93       	push	r17
    13da:	df 93       	push	r29
    13dc:	cf 93       	push	r28
    13de:	0f 92       	push	r0
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    13e4:	0f b6       	in	r0, 0x3f	; 63
    13e6:	f8 94       	cli
    13e8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    13ea:	80 91 bc 02 	lds	r24, 0x02BC
    13ee:	81 50       	subi	r24, 0x01	; 1
    13f0:	80 93 bc 02 	sts	0x02BC, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    13f4:	80 91 bc 02 	lds	r24, 0x02BC
    13f8:	88 23       	and	r24, r24
    13fa:	09 f0       	breq	.+2      	; 0x13fe <xTaskResumeAll+0x2e>
    13fc:	5b c0       	rjmp	.+182    	; 0x14b4 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    13fe:	80 91 bf 02 	lds	r24, 0x02BF
    1402:	88 23       	and	r24, r24
    1404:	09 f4       	brne	.+2      	; 0x1408 <xTaskResumeAll+0x38>
    1406:	56 c0       	rjmp	.+172    	; 0x14b4 <xTaskResumeAll+0xe4>
    1408:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    140a:	99 e0       	ldi	r25, 0x09	; 9
    140c:	f9 2e       	mov	r15, r25
    140e:	27 c0       	rjmp	.+78     	; 0x145e <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    1410:	c6 01       	movw	r24, r12
    1412:	0c 96       	adiw	r24, 0x0c	; 12
    1414:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1418:	86 01       	movw	r16, r12
    141a:	0e 5f       	subi	r16, 0xFE	; 254
    141c:	1f 4f       	sbci	r17, 0xFF	; 255
    141e:	c8 01       	movw	r24, r16
    1420:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1424:	d6 01       	movw	r26, r12
    1426:	56 96       	adiw	r26, 0x16	; 22
    1428:	9c 91       	ld	r25, X
    142a:	80 91 bd 02 	lds	r24, 0x02BD
    142e:	89 17       	cp	r24, r25
    1430:	10 f4       	brcc	.+4      	; 0x1436 <xTaskResumeAll+0x66>
    1432:	90 93 bd 02 	sts	0x02BD, r25
    1436:	9f 9d       	mul	r25, r15
    1438:	c0 01       	movw	r24, r0
    143a:	11 24       	eor	r1, r1
    143c:	8c 53       	subi	r24, 0x3C	; 60
    143e:	9d 4f       	sbci	r25, 0xFD	; 253
    1440:	b8 01       	movw	r22, r16
    1442:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1446:	e0 91 b6 02 	lds	r30, 0x02B6
    144a:	f0 91 b7 02 	lds	r31, 0x02B7
    144e:	d6 01       	movw	r26, r12
    1450:	56 96       	adiw	r26, 0x16	; 22
    1452:	9c 91       	ld	r25, X
    1454:	86 89       	ldd	r24, Z+22	; 0x16
    1456:	98 17       	cp	r25, r24
    1458:	10 f0       	brcs	.+4      	; 0x145e <xTaskResumeAll+0x8e>
    145a:	b1 e0       	ldi	r27, 0x01	; 1
    145c:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    145e:	80 91 fe 02 	lds	r24, 0x02FE
    1462:	88 23       	and	r24, r24
    1464:	49 f0       	breq	.+18     	; 0x1478 <xTaskResumeAll+0xa8>
    1466:	e0 91 03 03 	lds	r30, 0x0303
    146a:	f0 91 04 03 	lds	r31, 0x0304
    146e:	c6 80       	ldd	r12, Z+6	; 0x06
    1470:	d7 80       	ldd	r13, Z+7	; 0x07
    1472:	c1 14       	cp	r12, r1
    1474:	d1 04       	cpc	r13, r1
    1476:	61 f6       	brne	.-104    	; 0x1410 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1478:	80 91 be 02 	lds	r24, 0x02BE
    147c:	88 23       	and	r24, r24
    147e:	41 f4       	brne	.+16     	; 0x1490 <xTaskResumeAll+0xc0>
    1480:	0c c0       	rjmp	.+24     	; 0x149a <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1482:	0e 94 39 09 	call	0x1272	; 0x1272 <vTaskIncrementTick>
						--uxMissedTicks;
    1486:	80 91 be 02 	lds	r24, 0x02BE
    148a:	81 50       	subi	r24, 0x01	; 1
    148c:	80 93 be 02 	sts	0x02BE, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1490:	80 91 be 02 	lds	r24, 0x02BE
    1494:	88 23       	and	r24, r24
    1496:	a9 f7       	brne	.-22     	; 0x1482 <xTaskResumeAll+0xb2>
    1498:	07 c0       	rjmp	.+14     	; 0x14a8 <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    149a:	e9 81       	ldd	r30, Y+1	; 0x01
    149c:	e1 30       	cpi	r30, 0x01	; 1
    149e:	21 f0       	breq	.+8      	; 0x14a8 <xTaskResumeAll+0xd8>
    14a0:	80 91 b8 02 	lds	r24, 0x02B8
    14a4:	81 30       	cpi	r24, 0x01	; 1
    14a6:	31 f4       	brne	.+12     	; 0x14b4 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    14a8:	10 92 b8 02 	sts	0x02B8, r1
					portYIELD_WITHIN_API();
    14ac:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	01 c0       	rjmp	.+2      	; 0x14b6 <xTaskResumeAll+0xe6>
    14b4:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    14b6:	0f 90       	pop	r0
    14b8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    14ba:	0f 90       	pop	r0
    14bc:	cf 91       	pop	r28
    14be:	df 91       	pop	r29
    14c0:	1f 91       	pop	r17
    14c2:	0f 91       	pop	r16
    14c4:	ff 90       	pop	r15
    14c6:	df 90       	pop	r13
    14c8:	cf 90       	pop	r12
    14ca:	08 95       	ret

000014cc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    14cc:	0f 93       	push	r16
    14ce:	1f 93       	push	r17
    14d0:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    14d2:	00 97       	sbiw	r24, 0x00	; 0
    14d4:	a1 f1       	breq	.+104    	; 0x153e <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    14d6:	80 91 bc 02 	lds	r24, 0x02BC
    14da:	8f 5f       	subi	r24, 0xFF	; 255
    14dc:	80 93 bc 02 	sts	0x02BC, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    14e0:	00 91 ba 02 	lds	r16, 0x02BA
    14e4:	10 91 bb 02 	lds	r17, 0x02BB
    14e8:	02 0f       	add	r16, r18
    14ea:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    14ec:	80 91 b6 02 	lds	r24, 0x02B6
    14f0:	90 91 b7 02 	lds	r25, 0x02B7
    14f4:	02 96       	adiw	r24, 0x02	; 2
    14f6:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    14fa:	e0 91 b6 02 	lds	r30, 0x02B6
    14fe:	f0 91 b7 02 	lds	r31, 0x02B7
    1502:	13 83       	std	Z+3, r17	; 0x03
    1504:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    1506:	80 91 ba 02 	lds	r24, 0x02BA
    150a:	90 91 bb 02 	lds	r25, 0x02BB
    150e:	08 17       	cp	r16, r24
    1510:	19 07       	cpc	r17, r25
    1512:	28 f4       	brcc	.+10     	; 0x151e <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1514:	80 91 fc 02 	lds	r24, 0x02FC
    1518:	90 91 fd 02 	lds	r25, 0x02FD
    151c:	04 c0       	rjmp	.+8      	; 0x1526 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    151e:	80 91 fa 02 	lds	r24, 0x02FA
    1522:	90 91 fb 02 	lds	r25, 0x02FB
    1526:	60 91 b6 02 	lds	r22, 0x02B6
    152a:	70 91 b7 02 	lds	r23, 0x02B7
    152e:	6e 5f       	subi	r22, 0xFE	; 254
    1530:	7f 4f       	sbci	r23, 0xFF	; 255
    1532:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    1536:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    153a:	88 23       	and	r24, r24
    153c:	11 f4       	brne	.+4      	; 0x1542 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    153e:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
		}
	}
    1542:	1f 91       	pop	r17
    1544:	0f 91       	pop	r16
    1546:	08 95       	ret

00001548 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1548:	cf 93       	push	r28
    154a:	df 93       	push	r29
    154c:	fc 01       	movw	r30, r24
    154e:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1550:	80 91 bc 02 	lds	r24, 0x02BC
    1554:	8f 5f       	subi	r24, 0xFF	; 255
    1556:	80 93 bc 02 	sts	0x02BC, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    155a:	20 81       	ld	r18, Z
    155c:	31 81       	ldd	r19, Z+1	; 0x01
    155e:	c2 0f       	add	r28, r18
    1560:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    1562:	80 91 ba 02 	lds	r24, 0x02BA
    1566:	90 91 bb 02 	lds	r25, 0x02BB
    156a:	82 17       	cp	r24, r18
    156c:	93 07       	cpc	r25, r19
    156e:	28 f4       	brcc	.+10     	; 0x157a <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1570:	c2 17       	cp	r28, r18
    1572:	d3 07       	cpc	r29, r19
    1574:	28 f0       	brcs	.+10     	; 0x1580 <vTaskDelayUntil+0x38>
    1576:	20 e0       	ldi	r18, 0x00	; 0
    1578:	0c c0       	rjmp	.+24     	; 0x1592 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    157a:	c2 17       	cp	r28, r18
    157c:	d3 07       	cpc	r29, r19
    157e:	40 f0       	brcs	.+16     	; 0x1590 <vTaskDelayUntil+0x48>
    1580:	80 91 ba 02 	lds	r24, 0x02BA
    1584:	90 91 bb 02 	lds	r25, 0x02BB
    1588:	20 e0       	ldi	r18, 0x00	; 0
    158a:	8c 17       	cp	r24, r28
    158c:	9d 07       	cpc	r25, r29
    158e:	08 f4       	brcc	.+2      	; 0x1592 <vTaskDelayUntil+0x4a>
    1590:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1592:	d1 83       	std	Z+1, r29	; 0x01
    1594:	c0 83       	st	Z, r28

			if( xShouldDelay )
    1596:	22 23       	and	r18, r18
    1598:	29 f1       	breq	.+74     	; 0x15e4 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    159a:	80 91 b6 02 	lds	r24, 0x02B6
    159e:	90 91 b7 02 	lds	r25, 0x02B7
    15a2:	02 96       	adiw	r24, 0x02	; 2
    15a4:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    15a8:	e0 91 b6 02 	lds	r30, 0x02B6
    15ac:	f0 91 b7 02 	lds	r31, 0x02B7
    15b0:	d3 83       	std	Z+3, r29	; 0x03
    15b2:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    15b4:	80 91 ba 02 	lds	r24, 0x02BA
    15b8:	90 91 bb 02 	lds	r25, 0x02BB
    15bc:	c8 17       	cp	r28, r24
    15be:	d9 07       	cpc	r29, r25
    15c0:	28 f4       	brcc	.+10     	; 0x15cc <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15c2:	80 91 fc 02 	lds	r24, 0x02FC
    15c6:	90 91 fd 02 	lds	r25, 0x02FD
    15ca:	04 c0       	rjmp	.+8      	; 0x15d4 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15cc:	80 91 fa 02 	lds	r24, 0x02FA
    15d0:	90 91 fb 02 	lds	r25, 0x02FB
    15d4:	60 91 b6 02 	lds	r22, 0x02B6
    15d8:	70 91 b7 02 	lds	r23, 0x02B7
    15dc:	6e 5f       	subi	r22, 0xFE	; 254
    15de:	7f 4f       	sbci	r23, 0xFF	; 255
    15e0:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    15e4:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    15e8:	88 23       	and	r24, r24
    15ea:	11 f4       	brne	.+4      	; 0x15f0 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    15ec:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
		}
	}
    15f0:	df 91       	pop	r29
    15f2:	cf 91       	pop	r28
    15f4:	08 95       	ret

000015f6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    15f6:	ef 92       	push	r14
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	f8 94       	cli
    1608:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    160a:	80 91 b6 02 	lds	r24, 0x02B6
    160e:	90 91 b7 02 	lds	r25, 0x02B7
    1612:	08 17       	cp	r16, r24
    1614:	19 07       	cpc	r17, r25
    1616:	19 f4       	brne	.+6      	; 0x161e <vTaskDelete+0x28>
    1618:	00 e0       	ldi	r16, 0x00	; 0
    161a:	10 e0       	ldi	r17, 0x00	; 0
    161c:	03 c0       	rjmp	.+6      	; 0x1624 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    161e:	01 15       	cp	r16, r1
    1620:	11 05       	cpc	r17, r1
    1622:	29 f4       	brne	.+10     	; 0x162e <vTaskDelete+0x38>
    1624:	c0 91 b6 02 	lds	r28, 0x02B6
    1628:	d0 91 b7 02 	lds	r29, 0x02B7
    162c:	01 c0       	rjmp	.+2      	; 0x1630 <vTaskDelete+0x3a>
    162e:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1630:	22 e0       	ldi	r18, 0x02	; 2
    1632:	e2 2e       	mov	r14, r18
    1634:	f1 2c       	mov	r15, r1
    1636:	ec 0e       	add	r14, r28
    1638:	fd 1e       	adc	r15, r29
    163a:	c7 01       	movw	r24, r14
    163c:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    1640:	8c 89       	ldd	r24, Y+20	; 0x14
    1642:	9d 89       	ldd	r25, Y+21	; 0x15
    1644:	89 2b       	or	r24, r25
    1646:	21 f0       	breq	.+8      	; 0x1650 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1648:	ce 01       	movw	r24, r28
    164a:	0c 96       	adiw	r24, 0x0c	; 12
    164c:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1650:	87 e0       	ldi	r24, 0x07	; 7
    1652:	93 e0       	ldi	r25, 0x03	; 3
    1654:	b7 01       	movw	r22, r14
    1656:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    165a:	80 91 c1 02 	lds	r24, 0x02C1
    165e:	8f 5f       	subi	r24, 0xFF	; 255
    1660:	80 93 c1 02 	sts	0x02C1, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1664:	80 91 c2 02 	lds	r24, 0x02C2
    1668:	8f 5f       	subi	r24, 0xFF	; 255
    166a:	80 93 c2 02 	sts	0x02C2, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    166e:	0f 90       	pop	r0
    1670:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1672:	80 91 c0 02 	lds	r24, 0x02C0
    1676:	88 23       	and	r24, r24
    1678:	21 f0       	breq	.+8      	; 0x1682 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    167a:	01 2b       	or	r16, r17
    167c:	11 f4       	brne	.+4      	; 0x1682 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    167e:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
			}
		}
	}
    1682:	df 91       	pop	r29
    1684:	cf 91       	pop	r28
    1686:	1f 91       	pop	r17
    1688:	0f 91       	pop	r16
    168a:	ff 90       	pop	r15
    168c:	ef 90       	pop	r14
    168e:	08 95       	ret

00001690 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1690:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1692:	10 92 c0 02 	sts	0x02C0, r1
	vPortEndScheduler();
    1696:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortEndScheduler>
}
    169a:	08 95       	ret

0000169c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    169c:	1f 93       	push	r17
    169e:	cf 93       	push	r28
    16a0:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    16a2:	80 91 c1 02 	lds	r24, 0x02C1
    16a6:	88 23       	and	r24, r24
    16a8:	91 f1       	breq	.+100    	; 0x170e <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    16aa:	80 91 bc 02 	lds	r24, 0x02BC
    16ae:	8f 5f       	subi	r24, 0xFF	; 255
    16b0:	80 93 bc 02 	sts	0x02BC, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    16b4:	10 91 07 03 	lds	r17, 0x0307
			xTaskResumeAll();
    16b8:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>

			if( !xListIsEmpty )
    16bc:	11 23       	and	r17, r17
    16be:	39 f1       	breq	.+78     	; 0x170e <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    16c0:	0f b6       	in	r0, 0x3f	; 63
    16c2:	f8 94       	cli
    16c4:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    16c6:	80 91 07 03 	lds	r24, 0x0307
    16ca:	88 23       	and	r24, r24
    16cc:	19 f4       	brne	.+6      	; 0x16d4 <prvIdleTask+0x38>
    16ce:	c0 e0       	ldi	r28, 0x00	; 0
    16d0:	d0 e0       	ldi	r29, 0x00	; 0
    16d2:	06 c0       	rjmp	.+12     	; 0x16e0 <prvIdleTask+0x44>
    16d4:	e0 91 0c 03 	lds	r30, 0x030C
    16d8:	f0 91 0d 03 	lds	r31, 0x030D
    16dc:	c6 81       	ldd	r28, Z+6	; 0x06
    16de:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    16e0:	ce 01       	movw	r24, r28
    16e2:	02 96       	adiw	r24, 0x02	; 2
    16e4:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
					--uxCurrentNumberOfTasks;
    16e8:	80 91 bf 02 	lds	r24, 0x02BF
    16ec:	81 50       	subi	r24, 0x01	; 1
    16ee:	80 93 bf 02 	sts	0x02BF, r24
					--uxTasksDeleted;
    16f2:	80 91 c1 02 	lds	r24, 0x02C1
    16f6:	81 50       	subi	r24, 0x01	; 1
    16f8:	80 93 c1 02 	sts	0x02C1, r24
				}
				portEXIT_CRITICAL();
    16fc:	0f 90       	pop	r0
    16fe:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1700:	8f 89       	ldd	r24, Y+23	; 0x17
    1702:	98 8d       	ldd	r25, Y+24	; 0x18
    1704:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vPortFree>
		vPortFree( pxTCB );
    1708:	ce 01       	movw	r24, r28
    170a:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    170e:	80 91 c4 02 	lds	r24, 0x02C4
    1712:	82 30       	cpi	r24, 0x02	; 2
    1714:	30 f2       	brcs	.-116    	; 0x16a2 <prvIdleTask+0x6>
			{
				taskYIELD();
    1716:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
    171a:	c3 cf       	rjmp	.-122    	; 0x16a2 <prvIdleTask+0x6>

0000171c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    171c:	2f 92       	push	r2
    171e:	3f 92       	push	r3
    1720:	5f 92       	push	r5
    1722:	6f 92       	push	r6
    1724:	7f 92       	push	r7
    1726:	8f 92       	push	r8
    1728:	9f 92       	push	r9
    172a:	af 92       	push	r10
    172c:	bf 92       	push	r11
    172e:	cf 92       	push	r12
    1730:	df 92       	push	r13
    1732:	ef 92       	push	r14
    1734:	ff 92       	push	r15
    1736:	0f 93       	push	r16
    1738:	1f 93       	push	r17
    173a:	df 93       	push	r29
    173c:	cf 93       	push	r28
    173e:	00 d0       	rcall	.+0      	; 0x1740 <xTaskGenericCreate+0x24>
    1740:	00 d0       	rcall	.+0      	; 0x1742 <xTaskGenericCreate+0x26>
    1742:	cd b7       	in	r28, 0x3d	; 61
    1744:	de b7       	in	r29, 0x3e	; 62
    1746:	9a 83       	std	Y+2, r25	; 0x02
    1748:	89 83       	std	Y+1, r24	; 0x01
    174a:	4b 01       	movw	r8, r22
    174c:	5a 01       	movw	r10, r20
    174e:	19 01       	movw	r2, r18
    1750:	50 2e       	mov	r5, r16
    1752:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1754:	81 e2       	ldi	r24, 0x21	; 33
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <pvPortMalloc>
    175c:	8b 83       	std	Y+3, r24	; 0x03
    175e:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    1760:	8b 81       	ldd	r24, Y+3	; 0x03
    1762:	9c 81       	ldd	r25, Y+4	; 0x04
    1764:	89 2b       	or	r24, r25
    1766:	89 f0       	breq	.+34     	; 0x178a <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1768:	c1 14       	cp	r12, r1
    176a:	d1 04       	cpc	r13, r1
    176c:	21 f4       	brne	.+8      	; 0x1776 <xTaskGenericCreate+0x5a>
    176e:	c5 01       	movw	r24, r10
    1770:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <pvPortMalloc>
    1774:	6c 01       	movw	r12, r24
    1776:	eb 81       	ldd	r30, Y+3	; 0x03
    1778:	fc 81       	ldd	r31, Y+4	; 0x04
    177a:	d0 8e       	std	Z+24, r13	; 0x18
    177c:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    177e:	c1 14       	cp	r12, r1
    1780:	d1 04       	cpc	r13, r1
    1782:	29 f4       	brne	.+10     	; 0x178e <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1784:	cf 01       	movw	r24, r30
    1786:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vPortFree>
    178a:	8f ef       	ldi	r24, 0xFF	; 255
    178c:	d5 c0       	rjmp	.+426    	; 0x1938 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    178e:	c6 01       	movw	r24, r12
    1790:	65 ea       	ldi	r22, 0xA5	; 165
    1792:	70 e0       	ldi	r23, 0x00	; 0
    1794:	a5 01       	movw	r20, r10
    1796:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    179a:	08 94       	sec
    179c:	a1 08       	sbc	r10, r1
    179e:	b1 08       	sbc	r11, r1
    17a0:	eb 81       	ldd	r30, Y+3	; 0x03
    17a2:	fc 81       	ldd	r31, Y+4	; 0x04
    17a4:	e7 88       	ldd	r14, Z+23	; 0x17
    17a6:	f0 8c       	ldd	r15, Z+24	; 0x18
    17a8:	ea 0c       	add	r14, r10
    17aa:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    17ac:	cf 01       	movw	r24, r30
    17ae:	49 96       	adiw	r24, 0x19	; 25
    17b0:	b4 01       	movw	r22, r8
    17b2:	48 e0       	ldi	r20, 0x08	; 8
    17b4:	50 e0       	ldi	r21, 0x00	; 0
    17b6:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    17ba:	eb 81       	ldd	r30, Y+3	; 0x03
    17bc:	fc 81       	ldd	r31, Y+4	; 0x04
    17be:	10 a2       	std	Z+32, r1	; 0x20
    17c0:	05 2d       	mov	r16, r5
    17c2:	f3 e0       	ldi	r31, 0x03	; 3
    17c4:	f5 15       	cp	r31, r5
    17c6:	08 f4       	brcc	.+2      	; 0x17ca <xTaskGenericCreate+0xae>
    17c8:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    17ca:	eb 81       	ldd	r30, Y+3	; 0x03
    17cc:	fc 81       	ldd	r31, Y+4	; 0x04
    17ce:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    17d0:	42 e0       	ldi	r20, 0x02	; 2
    17d2:	c4 2e       	mov	r12, r20
    17d4:	d1 2c       	mov	r13, r1
    17d6:	ce 0e       	add	r12, r30
    17d8:	df 1e       	adc	r13, r31
    17da:	c6 01       	movw	r24, r12
    17dc:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    17e0:	8b 81       	ldd	r24, Y+3	; 0x03
    17e2:	9c 81       	ldd	r25, Y+4	; 0x04
    17e4:	0c 96       	adiw	r24, 0x0c	; 12
    17e6:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	9c 81       	ldd	r25, Y+4	; 0x04
    17ee:	fc 01       	movw	r30, r24
    17f0:	91 87       	std	Z+9, r25	; 0x09
    17f2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    17f4:	84 e0       	ldi	r24, 0x04	; 4
    17f6:	90 e0       	ldi	r25, 0x00	; 0
    17f8:	80 1b       	sub	r24, r16
    17fa:	91 09       	sbc	r25, r1
    17fc:	95 87       	std	Z+13, r25	; 0x0d
    17fe:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1800:	f3 8b       	std	Z+19, r31	; 0x13
    1802:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1804:	c7 01       	movw	r24, r14
    1806:	69 81       	ldd	r22, Y+1	; 0x01
    1808:	7a 81       	ldd	r23, Y+2	; 0x02
    180a:	a1 01       	movw	r20, r2
    180c:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <pxPortInitialiseStack>
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	91 83       	std	Z+1, r25	; 0x01
    1816:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    1818:	61 14       	cp	r6, r1
    181a:	71 04       	cpc	r7, r1
    181c:	21 f0       	breq	.+8      	; 0x1826 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    181e:	cf 01       	movw	r24, r30
    1820:	f3 01       	movw	r30, r6
    1822:	91 83       	std	Z+1, r25	; 0x01
    1824:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    1826:	0f b6       	in	r0, 0x3f	; 63
    1828:	f8 94       	cli
    182a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    182c:	80 91 bf 02 	lds	r24, 0x02BF
    1830:	8f 5f       	subi	r24, 0xFF	; 255
    1832:	80 93 bf 02 	sts	0x02BF, r24
			if( pxCurrentTCB == NULL )
    1836:	80 91 b6 02 	lds	r24, 0x02B6
    183a:	90 91 b7 02 	lds	r25, 0x02B7
    183e:	89 2b       	or	r24, r25
    1840:	b9 f5       	brne	.+110    	; 0x18b0 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1842:	eb 81       	ldd	r30, Y+3	; 0x03
    1844:	fc 81       	ldd	r31, Y+4	; 0x04
    1846:	f0 93 b7 02 	sts	0x02B7, r31
    184a:	e0 93 b6 02 	sts	0x02B6, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    184e:	80 91 bf 02 	lds	r24, 0x02BF
    1852:	81 30       	cpi	r24, 0x01	; 1
    1854:	f1 f5       	brne	.+124    	; 0x18d2 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1856:	84 ec       	ldi	r24, 0xC4	; 196
    1858:	92 e0       	ldi	r25, 0x02	; 2
    185a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
    185e:	8d ec       	ldi	r24, 0xCD	; 205
    1860:	92 e0       	ldi	r25, 0x02	; 2
    1862:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
    1866:	86 ed       	ldi	r24, 0xD6	; 214
    1868:	92 e0       	ldi	r25, 0x02	; 2
    186a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
    186e:	8f ed       	ldi	r24, 0xDF	; 223
    1870:	92 e0       	ldi	r25, 0x02	; 2
    1872:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1876:	38 ee       	ldi	r19, 0xE8	; 232
    1878:	e3 2e       	mov	r14, r19
    187a:	32 e0       	ldi	r19, 0x02	; 2
    187c:	f3 2e       	mov	r15, r19
    187e:	c7 01       	movw	r24, r14
    1880:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1884:	01 ef       	ldi	r16, 0xF1	; 241
    1886:	12 e0       	ldi	r17, 0x02	; 2
    1888:	c8 01       	movw	r24, r16
    188a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    188e:	8e ef       	ldi	r24, 0xFE	; 254
    1890:	92 e0       	ldi	r25, 0x02	; 2
    1892:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1896:	87 e0       	ldi	r24, 0x07	; 7
    1898:	93 e0       	ldi	r25, 0x03	; 3
    189a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    189e:	f0 92 fb 02 	sts	0x02FB, r15
    18a2:	e0 92 fa 02 	sts	0x02FA, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    18a6:	10 93 fd 02 	sts	0x02FD, r17
    18aa:	00 93 fc 02 	sts	0x02FC, r16
    18ae:	11 c0       	rjmp	.+34     	; 0x18d2 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    18b0:	80 91 c0 02 	lds	r24, 0x02C0
    18b4:	88 23       	and	r24, r24
    18b6:	69 f4       	brne	.+26     	; 0x18d2 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    18b8:	e0 91 b6 02 	lds	r30, 0x02B6
    18bc:	f0 91 b7 02 	lds	r31, 0x02B7
    18c0:	86 89       	ldd	r24, Z+22	; 0x16
    18c2:	58 16       	cp	r5, r24
    18c4:	30 f0       	brcs	.+12     	; 0x18d2 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ca:	90 93 b7 02 	sts	0x02B7, r25
    18ce:	80 93 b6 02 	sts	0x02B6, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    18d2:	eb 81       	ldd	r30, Y+3	; 0x03
    18d4:	fc 81       	ldd	r31, Y+4	; 0x04
    18d6:	96 89       	ldd	r25, Z+22	; 0x16
    18d8:	80 91 c3 02 	lds	r24, 0x02C3
    18dc:	89 17       	cp	r24, r25
    18de:	10 f4       	brcc	.+4      	; 0x18e4 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    18e0:	90 93 c3 02 	sts	0x02C3, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    18e4:	80 91 c2 02 	lds	r24, 0x02C2
    18e8:	8f 5f       	subi	r24, 0xFF	; 255
    18ea:	80 93 c2 02 	sts	0x02C2, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    18ee:	eb 81       	ldd	r30, Y+3	; 0x03
    18f0:	fc 81       	ldd	r31, Y+4	; 0x04
    18f2:	96 89       	ldd	r25, Z+22	; 0x16
    18f4:	80 91 bd 02 	lds	r24, 0x02BD
    18f8:	89 17       	cp	r24, r25
    18fa:	10 f4       	brcc	.+4      	; 0x1900 <xTaskGenericCreate+0x1e4>
    18fc:	90 93 bd 02 	sts	0x02BD, r25
    1900:	eb 81       	ldd	r30, Y+3	; 0x03
    1902:	fc 81       	ldd	r31, Y+4	; 0x04
    1904:	86 89       	ldd	r24, Z+22	; 0x16
    1906:	29 e0       	ldi	r18, 0x09	; 9
    1908:	82 9f       	mul	r24, r18
    190a:	c0 01       	movw	r24, r0
    190c:	11 24       	eor	r1, r1
    190e:	8c 53       	subi	r24, 0x3C	; 60
    1910:	9d 4f       	sbci	r25, 0xFD	; 253
    1912:	b6 01       	movw	r22, r12
    1914:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    1918:	0f 90       	pop	r0
    191a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    191c:	80 91 c0 02 	lds	r24, 0x02C0
    1920:	88 23       	and	r24, r24
    1922:	49 f0       	breq	.+18     	; 0x1936 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1924:	e0 91 b6 02 	lds	r30, 0x02B6
    1928:	f0 91 b7 02 	lds	r31, 0x02B7
    192c:	86 89       	ldd	r24, Z+22	; 0x16
    192e:	85 15       	cp	r24, r5
    1930:	10 f4       	brcc	.+4      	; 0x1936 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    1932:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vPortYield>
    1936:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1938:	0f 90       	pop	r0
    193a:	0f 90       	pop	r0
    193c:	0f 90       	pop	r0
    193e:	0f 90       	pop	r0
    1940:	cf 91       	pop	r28
    1942:	df 91       	pop	r29
    1944:	1f 91       	pop	r17
    1946:	0f 91       	pop	r16
    1948:	ff 90       	pop	r15
    194a:	ef 90       	pop	r14
    194c:	df 90       	pop	r13
    194e:	cf 90       	pop	r12
    1950:	bf 90       	pop	r11
    1952:	af 90       	pop	r10
    1954:	9f 90       	pop	r9
    1956:	8f 90       	pop	r8
    1958:	7f 90       	pop	r7
    195a:	6f 90       	pop	r6
    195c:	5f 90       	pop	r5
    195e:	3f 90       	pop	r3
    1960:	2f 90       	pop	r2
    1962:	08 95       	ret

00001964 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1964:	af 92       	push	r10
    1966:	bf 92       	push	r11
    1968:	cf 92       	push	r12
    196a:	df 92       	push	r13
    196c:	ef 92       	push	r14
    196e:	ff 92       	push	r15
    1970:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    1972:	8e e4       	ldi	r24, 0x4E	; 78
    1974:	9b e0       	ldi	r25, 0x0B	; 11
    1976:	6f ea       	ldi	r22, 0xAF	; 175
    1978:	72 e0       	ldi	r23, 0x02	; 2
    197a:	45 e5       	ldi	r20, 0x55	; 85
    197c:	50 e0       	ldi	r21, 0x00	; 0
    197e:	20 e0       	ldi	r18, 0x00	; 0
    1980:	30 e0       	ldi	r19, 0x00	; 0
    1982:	00 e0       	ldi	r16, 0x00	; 0
    1984:	ee 24       	eor	r14, r14
    1986:	ff 24       	eor	r15, r15
    1988:	cc 24       	eor	r12, r12
    198a:	dd 24       	eor	r13, r13
    198c:	aa 24       	eor	r10, r10
    198e:	bb 24       	eor	r11, r11
    1990:	0e 94 8e 0b 	call	0x171c	; 0x171c <xTaskGenericCreate>

	if( xReturn == pdPASS )
    1994:	81 30       	cpi	r24, 0x01	; 1
    1996:	49 f4       	brne	.+18     	; 0x19aa <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1998:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    199a:	80 93 c0 02 	sts	0x02C0, r24
		xTickCount = ( portTickType ) 0;
    199e:	10 92 bb 02 	sts	0x02BB, r1
    19a2:	10 92 ba 02 	sts	0x02BA, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    19a6:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    19aa:	0f 91       	pop	r16
    19ac:	ff 90       	pop	r15
    19ae:	ef 90       	pop	r14
    19b0:	df 90       	pop	r13
    19b2:	cf 90       	pop	r12
    19b4:	bf 90       	pop	r11
    19b6:	af 90       	pop	r10
    19b8:	08 95       	ret

000019ba <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    19ba:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    19bc:	91 e1       	ldi	r25, 0x11	; 17
    19be:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    19c0:	22 e2       	ldi	r18, 0x22	; 34
    19c2:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    19c4:	83 e3       	ldi	r24, 0x33	; 51
    19c6:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    19c8:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    19ca:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    19cc:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    19ce:	80 e8       	ldi	r24, 0x80	; 128
    19d0:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    19d2:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    19d4:	82 e0       	ldi	r24, 0x02	; 2
    19d6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    19d8:	83 e0       	ldi	r24, 0x03	; 3
    19da:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    19dc:	84 e0       	ldi	r24, 0x04	; 4
    19de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    19e0:	85 e0       	ldi	r24, 0x05	; 5
    19e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    19e4:	86 e0       	ldi	r24, 0x06	; 6
    19e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    19e8:	87 e0       	ldi	r24, 0x07	; 7
    19ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    19ec:	88 e0       	ldi	r24, 0x08	; 8
    19ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    19f0:	89 e0       	ldi	r24, 0x09	; 9
    19f2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    19f4:	80 e1       	ldi	r24, 0x10	; 16
    19f6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    19f8:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    19fa:	82 e1       	ldi	r24, 0x12	; 18
    19fc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    19fe:	83 e1       	ldi	r24, 0x13	; 19
    1a00:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1a02:	84 e1       	ldi	r24, 0x14	; 20
    1a04:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1a06:	85 e1       	ldi	r24, 0x15	; 21
    1a08:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1a0a:	86 e1       	ldi	r24, 0x16	; 22
    1a0c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1a0e:	87 e1       	ldi	r24, 0x17	; 23
    1a10:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1a12:	88 e1       	ldi	r24, 0x18	; 24
    1a14:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1a16:	89 e1       	ldi	r24, 0x19	; 25
    1a18:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1a1a:	80 e2       	ldi	r24, 0x20	; 32
    1a1c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1a1e:	81 e2       	ldi	r24, 0x21	; 33
    1a20:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1a22:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1a24:	83 e2       	ldi	r24, 0x23	; 35
    1a26:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1a28:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1a2a:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1a2c:	86 e2       	ldi	r24, 0x26	; 38
    1a2e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1a30:	87 e2       	ldi	r24, 0x27	; 39
    1a32:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1a34:	88 e2       	ldi	r24, 0x28	; 40
    1a36:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1a38:	89 e2       	ldi	r24, 0x29	; 41
    1a3a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1a3c:	80 e3       	ldi	r24, 0x30	; 48
    1a3e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1a40:	81 e3       	ldi	r24, 0x31	; 49
    1a42:	82 93       	st	-Z, r24
    1a44:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1a46:	cf 01       	movw	r24, r30
    1a48:	08 95       	ret

00001a4a <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    1a4a:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    1a4e:	89 ef       	ldi	r24, 0xF9	; 249
    1a50:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1a54:	8b e0       	ldi	r24, 0x0B	; 11
    1a56:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    1a5a:	ef e6       	ldi	r30, 0x6F	; 111
    1a5c:	f0 e0       	ldi	r31, 0x00	; 0
    1a5e:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1a60:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    1a62:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1a64:	a0 91 b6 02 	lds	r26, 0x02B6
    1a68:	b0 91 b7 02 	lds	r27, 0x02B7
    1a6c:	cd 91       	ld	r28, X+
    1a6e:	cd bf       	out	0x3d, r28	; 61
    1a70:	dd 91       	ld	r29, X+
    1a72:	de bf       	out	0x3e, r29	; 62
    1a74:	ff 91       	pop	r31
    1a76:	ef 91       	pop	r30
    1a78:	df 91       	pop	r29
    1a7a:	cf 91       	pop	r28
    1a7c:	bf 91       	pop	r27
    1a7e:	af 91       	pop	r26
    1a80:	9f 91       	pop	r25
    1a82:	8f 91       	pop	r24
    1a84:	7f 91       	pop	r23
    1a86:	6f 91       	pop	r22
    1a88:	5f 91       	pop	r21
    1a8a:	4f 91       	pop	r20
    1a8c:	3f 91       	pop	r19
    1a8e:	2f 91       	pop	r18
    1a90:	1f 91       	pop	r17
    1a92:	0f 91       	pop	r16
    1a94:	ff 90       	pop	r15
    1a96:	ef 90       	pop	r14
    1a98:	df 90       	pop	r13
    1a9a:	cf 90       	pop	r12
    1a9c:	bf 90       	pop	r11
    1a9e:	af 90       	pop	r10
    1aa0:	9f 90       	pop	r9
    1aa2:	8f 90       	pop	r8
    1aa4:	7f 90       	pop	r7
    1aa6:	6f 90       	pop	r6
    1aa8:	5f 90       	pop	r5
    1aaa:	4f 90       	pop	r4
    1aac:	3f 90       	pop	r3
    1aae:	2f 90       	pop	r2
    1ab0:	1f 90       	pop	r1
    1ab2:	0f 90       	pop	r0
    1ab4:	0f be       	out	0x3f, r0	; 63
    1ab6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1ab8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1aba:	81 e0       	ldi	r24, 0x01	; 1
    1abc:	08 95       	ret

00001abe <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1abe:	08 95       	ret

00001ac0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ac0:	0f 92       	push	r0
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	0f 92       	push	r0
    1ac8:	1f 92       	push	r1
    1aca:	11 24       	eor	r1, r1
    1acc:	2f 92       	push	r2
    1ace:	3f 92       	push	r3
    1ad0:	4f 92       	push	r4
    1ad2:	5f 92       	push	r5
    1ad4:	6f 92       	push	r6
    1ad6:	7f 92       	push	r7
    1ad8:	8f 92       	push	r8
    1ada:	9f 92       	push	r9
    1adc:	af 92       	push	r10
    1ade:	bf 92       	push	r11
    1ae0:	cf 92       	push	r12
    1ae2:	df 92       	push	r13
    1ae4:	ef 92       	push	r14
    1ae6:	ff 92       	push	r15
    1ae8:	0f 93       	push	r16
    1aea:	1f 93       	push	r17
    1aec:	2f 93       	push	r18
    1aee:	3f 93       	push	r19
    1af0:	4f 93       	push	r20
    1af2:	5f 93       	push	r21
    1af4:	6f 93       	push	r22
    1af6:	7f 93       	push	r23
    1af8:	8f 93       	push	r24
    1afa:	9f 93       	push	r25
    1afc:	af 93       	push	r26
    1afe:	bf 93       	push	r27
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
    1b04:	ef 93       	push	r30
    1b06:	ff 93       	push	r31
    1b08:	a0 91 b6 02 	lds	r26, 0x02B6
    1b0c:	b0 91 b7 02 	lds	r27, 0x02B7
    1b10:	0d b6       	in	r0, 0x3d	; 61
    1b12:	0d 92       	st	X+, r0
    1b14:	0e b6       	in	r0, 0x3e	; 62
    1b16:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1b18:	0e 94 39 09 	call	0x1272	; 0x1272 <vTaskIncrementTick>
	vTaskSwitchContext();
    1b1c:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b20:	a0 91 b6 02 	lds	r26, 0x02B6
    1b24:	b0 91 b7 02 	lds	r27, 0x02B7
    1b28:	cd 91       	ld	r28, X+
    1b2a:	cd bf       	out	0x3d, r28	; 61
    1b2c:	dd 91       	ld	r29, X+
    1b2e:	de bf       	out	0x3e, r29	; 62
    1b30:	ff 91       	pop	r31
    1b32:	ef 91       	pop	r30
    1b34:	df 91       	pop	r29
    1b36:	cf 91       	pop	r28
    1b38:	bf 91       	pop	r27
    1b3a:	af 91       	pop	r26
    1b3c:	9f 91       	pop	r25
    1b3e:	8f 91       	pop	r24
    1b40:	7f 91       	pop	r23
    1b42:	6f 91       	pop	r22
    1b44:	5f 91       	pop	r21
    1b46:	4f 91       	pop	r20
    1b48:	3f 91       	pop	r19
    1b4a:	2f 91       	pop	r18
    1b4c:	1f 91       	pop	r17
    1b4e:	0f 91       	pop	r16
    1b50:	ff 90       	pop	r15
    1b52:	ef 90       	pop	r14
    1b54:	df 90       	pop	r13
    1b56:	cf 90       	pop	r12
    1b58:	bf 90       	pop	r11
    1b5a:	af 90       	pop	r10
    1b5c:	9f 90       	pop	r9
    1b5e:	8f 90       	pop	r8
    1b60:	7f 90       	pop	r7
    1b62:	6f 90       	pop	r6
    1b64:	5f 90       	pop	r5
    1b66:	4f 90       	pop	r4
    1b68:	3f 90       	pop	r3
    1b6a:	2f 90       	pop	r2
    1b6c:	1f 90       	pop	r1
    1b6e:	0f 90       	pop	r0
    1b70:	0f be       	out	0x3f, r0	; 63
    1b72:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b74:	08 95       	ret

00001b76 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1b76:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1b7a:	18 95       	reti

00001b7c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1b7c:	0f 92       	push	r0
    1b7e:	0f b6       	in	r0, 0x3f	; 63
    1b80:	f8 94       	cli
    1b82:	0f 92       	push	r0
    1b84:	1f 92       	push	r1
    1b86:	11 24       	eor	r1, r1
    1b88:	2f 92       	push	r2
    1b8a:	3f 92       	push	r3
    1b8c:	4f 92       	push	r4
    1b8e:	5f 92       	push	r5
    1b90:	6f 92       	push	r6
    1b92:	7f 92       	push	r7
    1b94:	8f 92       	push	r8
    1b96:	9f 92       	push	r9
    1b98:	af 92       	push	r10
    1b9a:	bf 92       	push	r11
    1b9c:	cf 92       	push	r12
    1b9e:	df 92       	push	r13
    1ba0:	ef 92       	push	r14
    1ba2:	ff 92       	push	r15
    1ba4:	0f 93       	push	r16
    1ba6:	1f 93       	push	r17
    1ba8:	2f 93       	push	r18
    1baa:	3f 93       	push	r19
    1bac:	4f 93       	push	r20
    1bae:	5f 93       	push	r21
    1bb0:	6f 93       	push	r22
    1bb2:	7f 93       	push	r23
    1bb4:	8f 93       	push	r24
    1bb6:	9f 93       	push	r25
    1bb8:	af 93       	push	r26
    1bba:	bf 93       	push	r27
    1bbc:	cf 93       	push	r28
    1bbe:	df 93       	push	r29
    1bc0:	ef 93       	push	r30
    1bc2:	ff 93       	push	r31
    1bc4:	a0 91 b6 02 	lds	r26, 0x02B6
    1bc8:	b0 91 b7 02 	lds	r27, 0x02B7
    1bcc:	0d b6       	in	r0, 0x3d	; 61
    1bce:	0d 92       	st	X+, r0
    1bd0:	0e b6       	in	r0, 0x3e	; 62
    1bd2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1bd4:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1bd8:	a0 91 b6 02 	lds	r26, 0x02B6
    1bdc:	b0 91 b7 02 	lds	r27, 0x02B7
    1be0:	cd 91       	ld	r28, X+
    1be2:	cd bf       	out	0x3d, r28	; 61
    1be4:	dd 91       	ld	r29, X+
    1be6:	de bf       	out	0x3e, r29	; 62
    1be8:	ff 91       	pop	r31
    1bea:	ef 91       	pop	r30
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	bf 91       	pop	r27
    1bf2:	af 91       	pop	r26
    1bf4:	9f 91       	pop	r25
    1bf6:	8f 91       	pop	r24
    1bf8:	7f 91       	pop	r23
    1bfa:	6f 91       	pop	r22
    1bfc:	5f 91       	pop	r21
    1bfe:	4f 91       	pop	r20
    1c00:	3f 91       	pop	r19
    1c02:	2f 91       	pop	r18
    1c04:	1f 91       	pop	r17
    1c06:	0f 91       	pop	r16
    1c08:	ff 90       	pop	r15
    1c0a:	ef 90       	pop	r14
    1c0c:	df 90       	pop	r13
    1c0e:	cf 90       	pop	r12
    1c10:	bf 90       	pop	r11
    1c12:	af 90       	pop	r10
    1c14:	9f 90       	pop	r9
    1c16:	8f 90       	pop	r8
    1c18:	7f 90       	pop	r7
    1c1a:	6f 90       	pop	r6
    1c1c:	5f 90       	pop	r5
    1c1e:	4f 90       	pop	r4
    1c20:	3f 90       	pop	r3
    1c22:	2f 90       	pop	r2
    1c24:	1f 90       	pop	r1
    1c26:	0f 90       	pop	r0
    1c28:	0f be       	out	0x3f, r0	; 63
    1c2a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c2c:	08 95       	ret

00001c2e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1c2e:	0f 93       	push	r16
    1c30:	1f 93       	push	r17
    1c32:	cf 93       	push	r28
    1c34:	df 93       	push	r29
    1c36:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1c38:	80 81       	ld	r24, Z
    1c3a:	88 23       	and	r24, r24
    1c3c:	19 f4       	brne	.+6      	; 0x1c44 <xCoRoutineRemoveFromEventList+0x16>
    1c3e:	c0 e0       	ldi	r28, 0x00	; 0
    1c40:	d0 e0       	ldi	r29, 0x00	; 0
    1c42:	05 c0       	rjmp	.+10     	; 0x1c4e <xCoRoutineRemoveFromEventList+0x20>
    1c44:	05 80       	ldd	r0, Z+5	; 0x05
    1c46:	f6 81       	ldd	r31, Z+6	; 0x06
    1c48:	e0 2d       	mov	r30, r0
    1c4a:	c6 81       	ldd	r28, Z+6	; 0x06
    1c4c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1c4e:	8e 01       	movw	r16, r28
    1c50:	04 5f       	subi	r16, 0xF4	; 244
    1c52:	1f 4f       	sbci	r17, 0xFF	; 255
    1c54:	c8 01       	movw	r24, r16
    1c56:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1c5a:	81 e4       	ldi	r24, 0x41	; 65
    1c5c:	93 e0       	ldi	r25, 0x03	; 3
    1c5e:	b8 01       	movw	r22, r16
    1c60:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1c64:	20 e0       	ldi	r18, 0x00	; 0
    1c66:	e0 91 10 03 	lds	r30, 0x0310
    1c6a:	f0 91 11 03 	lds	r31, 0x0311
    1c6e:	9e 89       	ldd	r25, Y+22	; 0x16
    1c70:	86 89       	ldd	r24, Z+22	; 0x16
    1c72:	98 17       	cp	r25, r24
    1c74:	08 f0       	brcs	.+2      	; 0x1c78 <xCoRoutineRemoveFromEventList+0x4a>
    1c76:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1c78:	82 2f       	mov	r24, r18
    1c7a:	df 91       	pop	r29
    1c7c:	cf 91       	pop	r28
    1c7e:	1f 91       	pop	r17
    1c80:	0f 91       	pop	r16
    1c82:	08 95       	ret

00001c84 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1c84:	ff 92       	push	r15
    1c86:	0f 93       	push	r16
    1c88:	1f 93       	push	r17
    1c8a:	cf 93       	push	r28
    1c8c:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1c8e:	99 e0       	ldi	r25, 0x09	; 9
    1c90:	f9 2e       	mov	r15, r25
    1c92:	28 c0       	rjmp	.+80     	; 0x1ce4 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1c94:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1c96:	80 91 41 03 	lds	r24, 0x0341
    1c9a:	88 23       	and	r24, r24
    1c9c:	19 f4       	brne	.+6      	; 0x1ca4 <vCoRoutineSchedule+0x20>
    1c9e:	c0 e0       	ldi	r28, 0x00	; 0
    1ca0:	d0 e0       	ldi	r29, 0x00	; 0
    1ca2:	06 c0       	rjmp	.+12     	; 0x1cb0 <vCoRoutineSchedule+0x2c>
    1ca4:	e0 91 46 03 	lds	r30, 0x0346
    1ca8:	f0 91 47 03 	lds	r31, 0x0347
    1cac:	c6 81       	ldd	r28, Z+6	; 0x06
    1cae:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	0c 96       	adiw	r24, 0x0c	; 12
    1cb4:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1cb8:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1cba:	8e 01       	movw	r16, r28
    1cbc:	0e 5f       	subi	r16, 0xFE	; 254
    1cbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1cc0:	c8 01       	movw	r24, r16
    1cc2:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1cc6:	9e 89       	ldd	r25, Y+22	; 0x16
    1cc8:	80 91 12 03 	lds	r24, 0x0312
    1ccc:	89 17       	cp	r24, r25
    1cce:	10 f4       	brcc	.+4      	; 0x1cd4 <vCoRoutineSchedule+0x50>
    1cd0:	90 93 12 03 	sts	0x0312, r25
    1cd4:	9f 9d       	mul	r25, r15
    1cd6:	c0 01       	movw	r24, r0
    1cd8:	11 24       	eor	r1, r1
    1cda:	87 5e       	subi	r24, 0xE7	; 231
    1cdc:	9c 4f       	sbci	r25, 0xFC	; 252
    1cde:	b8 01       	movw	r22, r16
    1ce0:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    1ce4:	80 91 41 03 	lds	r24, 0x0341
    1ce8:	88 23       	and	r24, r24
    1cea:	a1 f6       	brne	.-88     	; 0x1c94 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1cec:	0e 94 57 08 	call	0x10ae	; 0x10ae <xTaskGetTickCount>
    1cf0:	20 91 13 03 	lds	r18, 0x0313
    1cf4:	30 91 14 03 	lds	r19, 0x0314
    1cf8:	82 1b       	sub	r24, r18
    1cfa:	93 0b       	sbc	r25, r19
    1cfc:	90 93 16 03 	sts	0x0316, r25
    1d00:	80 93 15 03 	sts	0x0315, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1d04:	89 e0       	ldi	r24, 0x09	; 9
    1d06:	f8 2e       	mov	r15, r24
    1d08:	54 c0       	rjmp	.+168    	; 0x1db2 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1d0a:	01 96       	adiw	r24, 0x01	; 1
    1d0c:	90 93 18 03 	sts	0x0318, r25
    1d10:	80 93 17 03 	sts	0x0317, r24
		xPassedTicks--;
    1d14:	21 50       	subi	r18, 0x01	; 1
    1d16:	30 40       	sbci	r19, 0x00	; 0
    1d18:	30 93 16 03 	sts	0x0316, r19
    1d1c:	20 93 15 03 	sts	0x0315, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1d20:	89 2b       	or	r24, r25
    1d22:	c9 f5       	brne	.+114    	; 0x1d96 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1d24:	20 91 3d 03 	lds	r18, 0x033D
    1d28:	30 91 3e 03 	lds	r19, 0x033E
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1d2c:	80 91 3f 03 	lds	r24, 0x033F
    1d30:	90 91 40 03 	lds	r25, 0x0340
    1d34:	90 93 3e 03 	sts	0x033E, r25
    1d38:	80 93 3d 03 	sts	0x033D, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1d3c:	30 93 40 03 	sts	0x0340, r19
    1d40:	20 93 3f 03 	sts	0x033F, r18
    1d44:	28 c0       	rjmp	.+80     	; 0x1d96 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1d46:	20 91 17 03 	lds	r18, 0x0317
    1d4a:	30 91 18 03 	lds	r19, 0x0318
    1d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d50:	9b 81       	ldd	r25, Y+3	; 0x03
    1d52:	28 17       	cp	r18, r24
    1d54:	39 07       	cpc	r19, r25
    1d56:	68 f1       	brcs	.+90     	; 0x1db2 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1d58:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1d5a:	8e 01       	movw	r16, r28
    1d5c:	0e 5f       	subi	r16, 0xFE	; 254
    1d5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d60:	c8 01       	movw	r24, r16
    1d62:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1d66:	8c 89       	ldd	r24, Y+20	; 0x14
    1d68:	9d 89       	ldd	r25, Y+21	; 0x15
    1d6a:	89 2b       	or	r24, r25
    1d6c:	21 f0       	breq	.+8      	; 0x1d76 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1d6e:	ce 01       	movw	r24, r28
    1d70:	0c 96       	adiw	r24, 0x0c	; 12
    1d72:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1d76:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1d78:	9e 89       	ldd	r25, Y+22	; 0x16
    1d7a:	80 91 12 03 	lds	r24, 0x0312
    1d7e:	89 17       	cp	r24, r25
    1d80:	10 f4       	brcc	.+4      	; 0x1d86 <vCoRoutineSchedule+0x102>
    1d82:	90 93 12 03 	sts	0x0312, r25
    1d86:	9f 9d       	mul	r25, r15
    1d88:	c0 01       	movw	r24, r0
    1d8a:	11 24       	eor	r1, r1
    1d8c:	87 5e       	subi	r24, 0xE7	; 231
    1d8e:	9c 4f       	sbci	r25, 0xFC	; 252
    1d90:	b8 01       	movw	r22, r16
    1d92:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    1d96:	e0 91 3d 03 	lds	r30, 0x033D
    1d9a:	f0 91 3e 03 	lds	r31, 0x033E
    1d9e:	80 81       	ld	r24, Z
    1da0:	88 23       	and	r24, r24
    1da2:	39 f0       	breq	.+14     	; 0x1db2 <vCoRoutineSchedule+0x12e>
    1da4:	05 80       	ldd	r0, Z+5	; 0x05
    1da6:	f6 81       	ldd	r31, Z+6	; 0x06
    1da8:	e0 2d       	mov	r30, r0
    1daa:	c6 81       	ldd	r28, Z+6	; 0x06
    1dac:	d7 81       	ldd	r29, Z+7	; 0x07
    1dae:	20 97       	sbiw	r28, 0x00	; 0
    1db0:	51 f6       	brne	.-108    	; 0x1d46 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1db2:	20 91 15 03 	lds	r18, 0x0315
    1db6:	30 91 16 03 	lds	r19, 0x0316
    1dba:	80 91 17 03 	lds	r24, 0x0317
    1dbe:	90 91 18 03 	lds	r25, 0x0318
    1dc2:	21 15       	cp	r18, r1
    1dc4:	31 05       	cpc	r19, r1
    1dc6:	09 f0       	breq	.+2      	; 0x1dca <vCoRoutineSchedule+0x146>
    1dc8:	a0 cf       	rjmp	.-192    	; 0x1d0a <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1dca:	90 93 14 03 	sts	0x0314, r25
    1dce:	80 93 13 03 	sts	0x0313, r24
    1dd2:	90 91 12 03 	lds	r25, 0x0312

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1dd6:	29 e0       	ldi	r18, 0x09	; 9
    1dd8:	06 c0       	rjmp	.+12     	; 0x1de6 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1dda:	99 23       	and	r25, r25
    1ddc:	19 f4       	brne	.+6      	; 0x1de4 <vCoRoutineSchedule+0x160>
    1dde:	10 92 12 03 	sts	0x0312, r1
    1de2:	32 c0       	rjmp	.+100    	; 0x1e48 <vCoRoutineSchedule+0x1c4>
    1de4:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1de6:	92 9f       	mul	r25, r18
    1de8:	d0 01       	movw	r26, r0
    1dea:	11 24       	eor	r1, r1
    1dec:	a7 5e       	subi	r26, 0xE7	; 231
    1dee:	bc 4f       	sbci	r27, 0xFC	; 252
    1df0:	8c 91       	ld	r24, X
    1df2:	88 23       	and	r24, r24
    1df4:	91 f3       	breq	.-28     	; 0x1dda <vCoRoutineSchedule+0x156>
    1df6:	90 93 12 03 	sts	0x0312, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1dfa:	11 96       	adiw	r26, 0x01	; 1
    1dfc:	ed 91       	ld	r30, X+
    1dfe:	fc 91       	ld	r31, X
    1e00:	12 97       	sbiw	r26, 0x02	; 2
    1e02:	02 80       	ldd	r0, Z+2	; 0x02
    1e04:	f3 81       	ldd	r31, Z+3	; 0x03
    1e06:	e0 2d       	mov	r30, r0
    1e08:	12 96       	adiw	r26, 0x02	; 2
    1e0a:	fc 93       	st	X, r31
    1e0c:	ee 93       	st	-X, r30
    1e0e:	11 97       	sbiw	r26, 0x01	; 1
    1e10:	cd 01       	movw	r24, r26
    1e12:	03 96       	adiw	r24, 0x03	; 3
    1e14:	e8 17       	cp	r30, r24
    1e16:	f9 07       	cpc	r31, r25
    1e18:	31 f4       	brne	.+12     	; 0x1e26 <vCoRoutineSchedule+0x1a2>
    1e1a:	82 81       	ldd	r24, Z+2	; 0x02
    1e1c:	93 81       	ldd	r25, Z+3	; 0x03
    1e1e:	12 96       	adiw	r26, 0x02	; 2
    1e20:	9c 93       	st	X, r25
    1e22:	8e 93       	st	-X, r24
    1e24:	11 97       	sbiw	r26, 0x01	; 1
    1e26:	11 96       	adiw	r26, 0x01	; 1
    1e28:	ed 91       	ld	r30, X+
    1e2a:	fc 91       	ld	r31, X
    1e2c:	12 97       	sbiw	r26, 0x02	; 2
    1e2e:	06 80       	ldd	r0, Z+6	; 0x06
    1e30:	f7 81       	ldd	r31, Z+7	; 0x07
    1e32:	e0 2d       	mov	r30, r0
    1e34:	f0 93 11 03 	sts	0x0311, r31
    1e38:	e0 93 10 03 	sts	0x0310, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1e3c:	20 81       	ld	r18, Z
    1e3e:	31 81       	ldd	r19, Z+1	; 0x01
    1e40:	cf 01       	movw	r24, r30
    1e42:	67 89       	ldd	r22, Z+23	; 0x17
    1e44:	f9 01       	movw	r30, r18
    1e46:	09 95       	icall

	return;
}
    1e48:	df 91       	pop	r29
    1e4a:	cf 91       	pop	r28
    1e4c:	1f 91       	pop	r17
    1e4e:	0f 91       	pop	r16
    1e50:	ff 90       	pop	r15
    1e52:	08 95       	ret

00001e54 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1e54:	0f 93       	push	r16
    1e56:	1f 93       	push	r17
    1e58:	cf 93       	push	r28
    1e5a:	df 93       	push	r29
    1e5c:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1e5e:	00 91 17 03 	lds	r16, 0x0317
    1e62:	10 91 18 03 	lds	r17, 0x0318
    1e66:	08 0f       	add	r16, r24
    1e68:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e6a:	80 91 10 03 	lds	r24, 0x0310
    1e6e:	90 91 11 03 	lds	r25, 0x0311
    1e72:	02 96       	adiw	r24, 0x02	; 2
    1e74:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1e78:	e0 91 10 03 	lds	r30, 0x0310
    1e7c:	f0 91 11 03 	lds	r31, 0x0311
    1e80:	13 83       	std	Z+3, r17	; 0x03
    1e82:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1e84:	80 91 17 03 	lds	r24, 0x0317
    1e88:	90 91 18 03 	lds	r25, 0x0318
    1e8c:	bf 01       	movw	r22, r30
    1e8e:	6e 5f       	subi	r22, 0xFE	; 254
    1e90:	7f 4f       	sbci	r23, 0xFF	; 255
    1e92:	08 17       	cp	r16, r24
    1e94:	19 07       	cpc	r17, r25
    1e96:	28 f4       	brcc	.+10     	; 0x1ea2 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e98:	80 91 3f 03 	lds	r24, 0x033F
    1e9c:	90 91 40 03 	lds	r25, 0x0340
    1ea0:	04 c0       	rjmp	.+8      	; 0x1eaa <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ea2:	80 91 3d 03 	lds	r24, 0x033D
    1ea6:	90 91 3e 03 	lds	r25, 0x033E
    1eaa:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsert>
	}

	if( pxEventList )
    1eae:	20 97       	sbiw	r28, 0x00	; 0
    1eb0:	49 f0       	breq	.+18     	; 0x1ec4 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1eb2:	60 91 10 03 	lds	r22, 0x0310
    1eb6:	70 91 11 03 	lds	r23, 0x0311
    1eba:	64 5f       	subi	r22, 0xF4	; 244
    1ebc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ebe:	ce 01       	movw	r24, r28
    1ec0:	0e 94 0f 05 	call	0xa1e	; 0xa1e <vListInsert>
	}
}
    1ec4:	df 91       	pop	r29
    1ec6:	cf 91       	pop	r28
    1ec8:	1f 91       	pop	r17
    1eca:	0f 91       	pop	r16
    1ecc:	08 95       	ret

00001ece <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1ece:	af 92       	push	r10
    1ed0:	bf 92       	push	r11
    1ed2:	cf 92       	push	r12
    1ed4:	df 92       	push	r13
    1ed6:	ef 92       	push	r14
    1ed8:	ff 92       	push	r15
    1eda:	0f 93       	push	r16
    1edc:	1f 93       	push	r17
    1ede:	cf 93       	push	r28
    1ee0:	df 93       	push	r29
    1ee2:	6c 01       	movw	r12, r24
    1ee4:	b6 2e       	mov	r11, r22
    1ee6:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1ee8:	8a e1       	ldi	r24, 0x1A	; 26
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <pvPortMalloc>
    1ef0:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1ef2:	00 97       	sbiw	r24, 0x00	; 0
    1ef4:	11 f4       	brne	.+4      	; 0x1efa <xCoRoutineCreate+0x2c>
    1ef6:	8f ef       	ldi	r24, 0xFF	; 255
    1ef8:	59 c0       	rjmp	.+178    	; 0x1fac <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1efa:	80 91 10 03 	lds	r24, 0x0310
    1efe:	90 91 11 03 	lds	r25, 0x0311
    1f02:	89 2b       	or	r24, r25
    1f04:	21 f5       	brne	.+72     	; 0x1f4e <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1f06:	d0 93 11 03 	sts	0x0311, r29
    1f0a:	c0 93 10 03 	sts	0x0310, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1f0e:	89 e1       	ldi	r24, 0x19	; 25
    1f10:	93 e0       	ldi	r25, 0x03	; 3
    1f12:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
    1f16:	82 e2       	ldi	r24, 0x22	; 34
    1f18:	93 e0       	ldi	r25, 0x03	; 3
    1f1a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1f1e:	2b e2       	ldi	r18, 0x2B	; 43
    1f20:	e2 2e       	mov	r14, r18
    1f22:	23 e0       	ldi	r18, 0x03	; 3
    1f24:	f2 2e       	mov	r15, r18
    1f26:	c7 01       	movw	r24, r14
    1f28:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1f2c:	04 e3       	ldi	r16, 0x34	; 52
    1f2e:	13 e0       	ldi	r17, 0x03	; 3
    1f30:	c8 01       	movw	r24, r16
    1f32:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1f36:	81 e4       	ldi	r24, 0x41	; 65
    1f38:	93 e0       	ldi	r25, 0x03	; 3
    1f3a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1f3e:	f0 92 3e 03 	sts	0x033E, r15
    1f42:	e0 92 3d 03 	sts	0x033D, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1f46:	10 93 40 03 	sts	0x0340, r17
    1f4a:	00 93 3f 03 	sts	0x033F, r16
    1f4e:	eb 2c       	mov	r14, r11
    1f50:	bb 20       	and	r11, r11
    1f52:	11 f0       	breq	.+4      	; 0x1f58 <xCoRoutineCreate+0x8a>
    1f54:	ee 24       	eor	r14, r14
    1f56:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1f58:	19 8e       	std	Y+25, r1	; 0x19
    1f5a:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1f5c:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1f5e:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1f60:	fe 01       	movw	r30, r28
    1f62:	c1 92       	st	Z+, r12
    1f64:	d1 92       	st	Z+, r13
    1f66:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1f68:	cf 01       	movw	r24, r30
    1f6a:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1f6e:	ce 01       	movw	r24, r28
    1f70:	0c 96       	adiw	r24, 0x0c	; 12
    1f72:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1f76:	d9 87       	std	Y+9, r29	; 0x09
    1f78:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1f7a:	db 8b       	std	Y+19, r29	; 0x13
    1f7c:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1f7e:	84 e0       	ldi	r24, 0x04	; 4
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	8e 19       	sub	r24, r14
    1f84:	91 09       	sbc	r25, r1
    1f86:	9d 87       	std	Y+13, r25	; 0x0d
    1f88:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1f8a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f8c:	80 91 12 03 	lds	r24, 0x0312
    1f90:	89 17       	cp	r24, r25
    1f92:	10 f4       	brcc	.+4      	; 0x1f98 <xCoRoutineCreate+0xca>
    1f94:	90 93 12 03 	sts	0x0312, r25
    1f98:	89 e0       	ldi	r24, 0x09	; 9
    1f9a:	98 9f       	mul	r25, r24
    1f9c:	c0 01       	movw	r24, r0
    1f9e:	11 24       	eor	r1, r1
    1fa0:	87 5e       	subi	r24, 0xE7	; 231
    1fa2:	9c 4f       	sbci	r25, 0xFC	; 252
    1fa4:	b8 01       	movw	r22, r16
    1fa6:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInsertEnd>
    1faa:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    1fac:	df 91       	pop	r29
    1fae:	cf 91       	pop	r28
    1fb0:	1f 91       	pop	r17
    1fb2:	0f 91       	pop	r16
    1fb4:	ff 90       	pop	r15
    1fb6:	ef 90       	pop	r14
    1fb8:	df 90       	pop	r13
    1fba:	cf 90       	pop	r12
    1fbc:	bf 90       	pop	r11
    1fbe:	af 90       	pop	r10
    1fc0:	08 95       	ret

00001fc2 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1fc2:	08 95       	ret

00001fc4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1fc4:	10 92 4b 03 	sts	0x034B, r1
    1fc8:	10 92 4a 03 	sts	0x034A, r1
}
    1fcc:	08 95       	ret

00001fce <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1fce:	28 eb       	ldi	r18, 0xB8	; 184
    1fd0:	3b e0       	ldi	r19, 0x0B	; 11
    1fd2:	80 91 4a 03 	lds	r24, 0x034A
    1fd6:	90 91 4b 03 	lds	r25, 0x034B
    1fda:	28 1b       	sub	r18, r24
    1fdc:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    1fde:	c9 01       	movw	r24, r18
    1fe0:	08 95       	ret

00001fe2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1fe2:	0f 93       	push	r16
    1fe4:	1f 93       	push	r17
    1fe6:	cf 93       	push	r28
    1fe8:	df 93       	push	r29
    1fea:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1fec:	0e 94 51 08 	call	0x10a2	; 0x10a2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1ff0:	80 91 4a 03 	lds	r24, 0x034A
    1ff4:	90 91 4b 03 	lds	r25, 0x034B
    1ff8:	98 01       	movw	r18, r16
    1ffa:	28 0f       	add	r18, r24
    1ffc:	39 1f       	adc	r19, r25
    1ffe:	4b e0       	ldi	r20, 0x0B	; 11
    2000:	28 3b       	cpi	r18, 0xB8	; 184
    2002:	34 07       	cpc	r19, r20
    2004:	58 f4       	brcc	.+22     	; 0x201c <pvPortMalloc+0x3a>
    2006:	82 17       	cp	r24, r18
    2008:	93 07       	cpc	r25, r19
    200a:	40 f4       	brcc	.+16     	; 0x201c <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    200c:	ec 01       	movw	r28, r24
    200e:	c4 5b       	subi	r28, 0xB4	; 180
    2010:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    2012:	30 93 4b 03 	sts	0x034B, r19
    2016:	20 93 4a 03 	sts	0x034A, r18
    201a:	02 c0       	rjmp	.+4      	; 0x2020 <pvPortMalloc+0x3e>
    201c:	c0 e0       	ldi	r28, 0x00	; 0
    201e:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    2020:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    2024:	ce 01       	movw	r24, r28
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	1f 91       	pop	r17
    202c:	0f 91       	pop	r16
    202e:	08 95       	ret

00002030 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2030:	e8 2f       	mov	r30, r24
    2032:	f0 e0       	ldi	r31, 0x00	; 0
    2034:	e7 70       	andi	r30, 0x07	; 7
    2036:	f0 70       	andi	r31, 0x00	; 0
    2038:	ee 0f       	add	r30, r30
    203a:	ff 1f       	adc	r31, r31
    203c:	ec 5e       	subi	r30, 0xEC	; 236
    203e:	fe 4f       	sbci	r31, 0xFE	; 254
    2040:	25 91       	lpm	r18, Z+
    2042:	34 91       	lpm	r19, Z+
}
    2044:	c9 01       	movw	r24, r18
    2046:	08 95       	ret

00002048 <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2048:	e8 2f       	mov	r30, r24
    204a:	f0 e0       	ldi	r31, 0x00	; 0
    204c:	e7 70       	andi	r30, 0x07	; 7
    204e:	f0 70       	andi	r31, 0x00	; 0
    2050:	ee 0f       	add	r30, r30
    2052:	ff 1f       	adc	r31, r31
    2054:	e0 5e       	subi	r30, 0xE0	; 224
    2056:	fe 4f       	sbci	r31, 0xFE	; 254
    2058:	25 91       	lpm	r18, Z+
    205a:	34 91       	lpm	r19, Z+
}
    205c:	c9 01       	movw	r24, r18
    205e:	08 95       	ret

00002060 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    2060:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2062:	e8 2f       	mov	r30, r24
    2064:	f0 e0       	ldi	r31, 0x00	; 0
    2066:	e7 70       	andi	r30, 0x07	; 7
    2068:	f0 70       	andi	r31, 0x00	; 0
    206a:	ee 0f       	add	r30, r30
    206c:	ff 1f       	adc	r31, r31
    206e:	ec 5e       	subi	r30, 0xEC	; 236
    2070:	fe 4f       	sbci	r31, 0xFE	; 254
    2072:	25 91       	lpm	r18, Z+
    2074:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    2076:	c9 01       	movw	r24, r18
    2078:	08 95       	ret

0000207a <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    207a:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    207e:	e8 2f       	mov	r30, r24
    2080:	f0 e0       	ldi	r31, 0x00	; 0
    2082:	e7 70       	andi	r30, 0x07	; 7
    2084:	f0 70       	andi	r31, 0x00	; 0
    2086:	ee 0f       	add	r30, r30
    2088:	ff 1f       	adc	r31, r31
    208a:	ec 5e       	subi	r30, 0xEC	; 236
    208c:	fe 4f       	sbci	r31, 0xFE	; 254
    208e:	25 91       	lpm	r18, Z+
    2090:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    2092:	c9 01       	movw	r24, r18
    2094:	08 95       	ret

00002096 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    2096:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    209a:	e8 2f       	mov	r30, r24
    209c:	f0 e0       	ldi	r31, 0x00	; 0
    209e:	e7 70       	andi	r30, 0x07	; 7
    20a0:	f0 70       	andi	r31, 0x00	; 0
    20a2:	ee 0f       	add	r30, r30
    20a4:	ff 1f       	adc	r31, r31
    20a6:	e0 5e       	subi	r30, 0xE0	; 224
    20a8:	fe 4f       	sbci	r31, 0xFE	; 254
    20aa:	25 91       	lpm	r18, Z+
    20ac:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    20ae:	c9 01       	movw	r24, r18
    20b0:	08 95       	ret

000020b2 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    20b2:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    20b6:	e8 2f       	mov	r30, r24
    20b8:	f0 e0       	ldi	r31, 0x00	; 0
    20ba:	e7 70       	andi	r30, 0x07	; 7
    20bc:	f0 70       	andi	r31, 0x00	; 0
    20be:	ee 0f       	add	r30, r30
    20c0:	ff 1f       	adc	r31, r31
    20c2:	ec 5e       	subi	r30, 0xEC	; 236
    20c4:	fe 4f       	sbci	r31, 0xFE	; 254
    20c6:	25 91       	lpm	r18, Z+
    20c8:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    20ca:	c9 01       	movw	r24, r18
    20cc:	08 95       	ret

000020ce <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    20ce:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    20d2:	e8 2f       	mov	r30, r24
    20d4:	f0 e0       	ldi	r31, 0x00	; 0
    20d6:	e7 70       	andi	r30, 0x07	; 7
    20d8:	f0 70       	andi	r31, 0x00	; 0
    20da:	ee 0f       	add	r30, r30
    20dc:	ff 1f       	adc	r31, r31
    20de:	ec 5e       	subi	r30, 0xEC	; 236
    20e0:	fe 4f       	sbci	r31, 0xFE	; 254
    20e2:	25 91       	lpm	r18, Z+
    20e4:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    20e6:	c9 01       	movw	r24, r18
    20e8:	08 95       	ret

000020ea <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    20ea:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    20ee:	e8 2f       	mov	r30, r24
    20f0:	f0 e0       	ldi	r31, 0x00	; 0
    20f2:	e7 70       	andi	r30, 0x07	; 7
    20f4:	f0 70       	andi	r31, 0x00	; 0
    20f6:	ee 0f       	add	r30, r30
    20f8:	ff 1f       	adc	r31, r31
    20fa:	ec 5e       	subi	r30, 0xEC	; 236
    20fc:	fe 4f       	sbci	r31, 0xFE	; 254
    20fe:	25 91       	lpm	r18, Z+
    2100:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    2102:	c9 01       	movw	r24, r18
    2104:	08 95       	ret

00002106 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    2106:	20 91 82 1f 	lds	r18, 0x1F82
    210a:	30 91 83 1f 	lds	r19, 0x1F83
    210e:	40 91 84 1f 	lds	r20, 0x1F84
    2112:	50 91 85 1f 	lds	r21, 0x1F85
}
    2116:	b9 01       	movw	r22, r18
    2118:	ca 01       	movw	r24, r20
    211a:	08 95       	ret

0000211c <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    211c:	20 91 7e 1f 	lds	r18, 0x1F7E
    2120:	30 91 7f 1f 	lds	r19, 0x1F7F
    2124:	40 91 80 1f 	lds	r20, 0x1F80
    2128:	50 91 81 1f 	lds	r21, 0x1F81
}
    212c:	b9 01       	movw	r22, r18
    212e:	ca 01       	movw	r24, r20
    2130:	08 95       	ret

00002132 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    2132:	20 91 86 1f 	lds	r18, 0x1F86
    2136:	30 91 87 1f 	lds	r19, 0x1F87
    213a:	40 91 88 1f 	lds	r20, 0x1F88
    213e:	50 91 89 1f 	lds	r21, 0x1F89
}
    2142:	b9 01       	movw	r22, r18
    2144:	ca 01       	movw	r24, r20
    2146:	08 95       	ret

00002148 <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    2148:	20 91 8e 1f 	lds	r18, 0x1F8E
    214c:	30 91 8f 1f 	lds	r19, 0x1F8F
    2150:	40 91 90 1f 	lds	r20, 0x1F90
    2154:	50 91 91 1f 	lds	r21, 0x1F91
}
    2158:	b9 01       	movw	r22, r18
    215a:	ca 01       	movw	r24, r20
    215c:	08 95       	ret

0000215e <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    215e:	20 91 7a 1f 	lds	r18, 0x1F7A
    2162:	30 91 7b 1f 	lds	r19, 0x1F7B
    2166:	40 91 7c 1f 	lds	r20, 0x1F7C
    216a:	50 91 7d 1f 	lds	r21, 0x1F7D
}
    216e:	b9 01       	movw	r22, r18
    2170:	ca 01       	movw	r24, r20
    2172:	08 95       	ret

00002174 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    2174:	20 91 92 1f 	lds	r18, 0x1F92
    2178:	30 91 93 1f 	lds	r19, 0x1F93
    217c:	40 91 94 1f 	lds	r20, 0x1F94
    2180:	50 91 95 1f 	lds	r21, 0x1F95
}
    2184:	b9 01       	movw	r22, r18
    2186:	ca 01       	movw	r24, r20
    2188:	08 95       	ret

0000218a <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    218a:	86 b5       	in	r24, 0x26	; 38
}
    218c:	08 95       	ret

0000218e <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    218e:	20 91 84 00 	lds	r18, 0x0084
    2192:	30 91 85 00 	lds	r19, 0x0085
}
    2196:	c9 01       	movw	r24, r18
    2198:	08 95       	ret

0000219a <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    219a:	80 91 b2 00 	lds	r24, 0x00B2
}
    219e:	08 95       	ret

000021a0 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    21a0:	20 91 94 00 	lds	r18, 0x0094
    21a4:	30 91 95 00 	lds	r19, 0x0095
}
    21a8:	c9 01       	movw	r24, r18
    21aa:	08 95       	ret

000021ac <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    21ac:	20 91 a4 00 	lds	r18, 0x00A4
    21b0:	30 91 a5 00 	lds	r19, 0x00A5
}
    21b4:	c9 01       	movw	r24, r18
    21b6:	08 95       	ret

000021b8 <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    21b8:	20 91 24 01 	lds	r18, 0x0124
    21bc:	30 91 25 01 	lds	r19, 0x0125
}
    21c0:	c9 01       	movw	r24, r18
    21c2:	08 95       	ret

000021c4 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    21c4:	10 92 82 1f 	sts	0x1F82, r1
    21c8:	10 92 83 1f 	sts	0x1F83, r1
    21cc:	10 92 84 1f 	sts	0x1F84, r1
    21d0:	10 92 85 1f 	sts	0x1F85, r1
    21d4:	16 bc       	out	0x26, r1	; 38
}
    21d6:	08 95       	ret

000021d8 <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    21d8:	10 92 7e 1f 	sts	0x1F7E, r1
    21dc:	10 92 7f 1f 	sts	0x1F7F, r1
    21e0:	10 92 80 1f 	sts	0x1F80, r1
    21e4:	10 92 81 1f 	sts	0x1F81, r1
    21e8:	10 92 85 00 	sts	0x0085, r1
    21ec:	10 92 84 00 	sts	0x0084, r1
}
    21f0:	08 95       	ret

000021f2 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    21f2:	10 92 86 1f 	sts	0x1F86, r1
    21f6:	10 92 87 1f 	sts	0x1F87, r1
    21fa:	10 92 88 1f 	sts	0x1F88, r1
    21fe:	10 92 89 1f 	sts	0x1F89, r1
    2202:	10 92 b2 00 	sts	0x00B2, r1
}
    2206:	08 95       	ret

00002208 <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    2208:	10 92 8e 1f 	sts	0x1F8E, r1
    220c:	10 92 8f 1f 	sts	0x1F8F, r1
    2210:	10 92 90 1f 	sts	0x1F90, r1
    2214:	10 92 91 1f 	sts	0x1F91, r1
    2218:	10 92 95 00 	sts	0x0095, r1
    221c:	10 92 94 00 	sts	0x0094, r1
}
    2220:	08 95       	ret

00002222 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    2222:	10 92 7a 1f 	sts	0x1F7A, r1
    2226:	10 92 7b 1f 	sts	0x1F7B, r1
    222a:	10 92 7c 1f 	sts	0x1F7C, r1
    222e:	10 92 7d 1f 	sts	0x1F7D, r1
    2232:	10 92 a5 00 	sts	0x00A5, r1
    2236:	10 92 a4 00 	sts	0x00A4, r1
}
    223a:	08 95       	ret

0000223c <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    223c:	10 92 92 1f 	sts	0x1F92, r1
    2240:	10 92 93 1f 	sts	0x1F93, r1
    2244:	10 92 94 1f 	sts	0x1F94, r1
    2248:	10 92 95 1f 	sts	0x1F95, r1
    224c:	10 92 25 01 	sts	0x0125, r1
    2250:	10 92 24 01 	sts	0x0124, r1
}
    2254:	08 95       	ret

00002256 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    2256:	08 95       	ret

00002258 <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    2258:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    225a:	81 e0       	ldi	r24, 0x01	; 1
    225c:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    2260:	10 92 82 1f 	sts	0x1F82, r1
    2264:	10 92 83 1f 	sts	0x1F83, r1
    2268:	10 92 84 1f 	sts	0x1F84, r1
    226c:	10 92 85 1f 	sts	0x1F85, r1
    2270:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    2272:	08 95       	ret

00002274 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    2274:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    2278:	81 e0       	ldi	r24, 0x01	; 1
    227a:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    227e:	10 92 7e 1f 	sts	0x1F7E, r1
    2282:	10 92 7f 1f 	sts	0x1F7F, r1
    2286:	10 92 80 1f 	sts	0x1F80, r1
    228a:	10 92 81 1f 	sts	0x1F81, r1
    228e:	10 92 85 00 	sts	0x0085, r1
    2292:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    2296:	08 95       	ret

00002298 <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    2298:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    229c:	81 e0       	ldi	r24, 0x01	; 1
    229e:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    22a2:	10 92 86 1f 	sts	0x1F86, r1
    22a6:	10 92 87 1f 	sts	0x1F87, r1
    22aa:	10 92 88 1f 	sts	0x1F88, r1
    22ae:	10 92 89 1f 	sts	0x1F89, r1
    22b2:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    22b6:	08 95       	ret

000022b8 <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    22b8:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    22c2:	10 92 8e 1f 	sts	0x1F8E, r1
    22c6:	10 92 8f 1f 	sts	0x1F8F, r1
    22ca:	10 92 90 1f 	sts	0x1F90, r1
    22ce:	10 92 91 1f 	sts	0x1F91, r1
    22d2:	10 92 95 00 	sts	0x0095, r1
    22d6:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    22da:	08 95       	ret

000022dc <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    22dc:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    22e0:	81 e0       	ldi	r24, 0x01	; 1
    22e2:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    22e6:	10 92 7a 1f 	sts	0x1F7A, r1
    22ea:	10 92 7b 1f 	sts	0x1F7B, r1
    22ee:	10 92 7c 1f 	sts	0x1F7C, r1
    22f2:	10 92 7d 1f 	sts	0x1F7D, r1
    22f6:	10 92 a5 00 	sts	0x00A5, r1
    22fa:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    22fe:	08 95       	ret

00002300 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    2300:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    2304:	81 e0       	ldi	r24, 0x01	; 1
    2306:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    230a:	10 92 92 1f 	sts	0x1F92, r1
    230e:	10 92 93 1f 	sts	0x1F93, r1
    2312:	10 92 94 1f 	sts	0x1F94, r1
    2316:	10 92 95 1f 	sts	0x1F95, r1
    231a:	10 92 25 01 	sts	0x0125, r1
    231e:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    2322:	08 95       	ret

00002324 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    2324:	e8 2f       	mov	r30, r24
    2326:	f0 e0       	ldi	r31, 0x00	; 0
    2328:	ee 0f       	add	r30, r30
    232a:	ff 1f       	adc	r31, r31
    232c:	ec 5f       	subi	r30, 0xFC	; 252
    232e:	f0 4f       	sbci	r31, 0xF0	; 240
    2330:	71 83       	std	Z+1, r23	; 0x01
    2332:	60 83       	st	Z, r22
}
    2334:	08 95       	ret

00002336 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    2336:	e8 2f       	mov	r30, r24
    2338:	f0 e0       	ldi	r31, 0x00	; 0
    233a:	ee 0f       	add	r30, r30
    233c:	ff 1f       	adc	r31, r31
    233e:	ec 5f       	subi	r30, 0xFC	; 252
    2340:	f0 4f       	sbci	r31, 0xF0	; 240
    2342:	11 82       	std	Z+1, r1	; 0x01
    2344:	10 82       	st	Z, r1
}
    2346:	08 95       	ret

00002348 <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2348:	01 97       	sbiw	r24, 0x01	; 1
    234a:	f1 f7       	brne	.-4      	; 0x2348 <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    234c:	08 95       	ret

0000234e <sleep>:

void sleep(uint16_t time_ms)
{
    234e:	af 92       	push	r10
    2350:	bf 92       	push	r11
    2352:	cf 92       	push	r12
    2354:	df 92       	push	r13
    2356:	ef 92       	push	r14
    2358:	ff 92       	push	r15
    235a:	0f 93       	push	r16
    235c:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    235e:	a0 e0       	ldi	r26, 0x00	; 0
    2360:	b0 e0       	ldi	r27, 0x00	; 0
    2362:	bc 01       	movw	r22, r24
    2364:	cd 01       	movw	r24, r26
    2366:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <__floatunsisf>
    236a:	5b 01       	movw	r10, r22
    236c:	6c 01       	movw	r12, r24
    236e:	20 e0       	ldi	r18, 0x00	; 0
    2370:	30 e0       	ldi	r19, 0x00	; 0
    2372:	4a e7       	ldi	r20, 0x7A	; 122
    2374:	55 e4       	ldi	r21, 0x45	; 69
    2376:	0e 94 9a 23 	call	0x4734	; 0x4734 <__mulsf3>
    237a:	7b 01       	movw	r14, r22
    237c:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    237e:	20 e0       	ldi	r18, 0x00	; 0
    2380:	30 e0       	ldi	r19, 0x00	; 0
    2382:	40 e8       	ldi	r20, 0x80	; 128
    2384:	5f e3       	ldi	r21, 0x3F	; 63
    2386:	0e 94 4c 22 	call	0x4498	; 0x4498 <__cmpsf2>
    238a:	88 23       	and	r24, r24
    238c:	1c f4       	brge	.+6      	; 0x2394 <sleep+0x46>
    238e:	61 e0       	ldi	r22, 0x01	; 1
    2390:	70 e0       	ldi	r23, 0x00	; 0
    2392:	24 c0       	rjmp	.+72     	; 0x23dc <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    2394:	c8 01       	movw	r24, r16
    2396:	b7 01       	movw	r22, r14
    2398:	20 e0       	ldi	r18, 0x00	; 0
    239a:	3f ef       	ldi	r19, 0xFF	; 255
    239c:	4f e7       	ldi	r20, 0x7F	; 127
    239e:	57 e4       	ldi	r21, 0x47	; 71
    23a0:	0e 94 96 23 	call	0x472c	; 0x472c <__gesf2>
    23a4:	18 16       	cp	r1, r24
    23a6:	b4 f4       	brge	.+44     	; 0x23d4 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    23a8:	c6 01       	movw	r24, r12
    23aa:	b5 01       	movw	r22, r10
    23ac:	20 e0       	ldi	r18, 0x00	; 0
    23ae:	30 e0       	ldi	r19, 0x00	; 0
    23b0:	40 e2       	ldi	r20, 0x20	; 32
    23b2:	51 e4       	ldi	r21, 0x41	; 65
    23b4:	0e 94 9a 23 	call	0x4734	; 0x4734 <__mulsf3>
    23b8:	0e 94 b8 22 	call	0x4570	; 0x4570 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23bc:	80 e9       	ldi	r24, 0x90	; 144
    23be:	91 e0       	ldi	r25, 0x01	; 1
    23c0:	05 c0       	rjmp	.+10     	; 0x23cc <sleep+0x7e>
    23c2:	fc 01       	movw	r30, r24
    23c4:	31 97       	sbiw	r30, 0x01	; 1
    23c6:	f1 f7       	brne	.-4      	; 0x23c4 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23c8:	61 50       	subi	r22, 0x01	; 1
    23ca:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    23cc:	61 15       	cp	r22, r1
    23ce:	71 05       	cpc	r23, r1
    23d0:	c1 f7       	brne	.-16     	; 0x23c2 <sleep+0x74>
    23d2:	07 c0       	rjmp	.+14     	; 0x23e2 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    23d4:	c8 01       	movw	r24, r16
    23d6:	b7 01       	movw	r22, r14
    23d8:	0e 94 b8 22 	call	0x4570	; 0x4570 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23dc:	cb 01       	movw	r24, r22
    23de:	01 97       	sbiw	r24, 0x01	; 1
    23e0:	f1 f7       	brne	.-4      	; 0x23de <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	ff 90       	pop	r15
    23e8:	ef 90       	pop	r14
    23ea:	df 90       	pop	r13
    23ec:	cf 90       	pop	r12
    23ee:	bf 90       	pop	r11
    23f0:	af 90       	pop	r10
    23f2:	08 95       	ret

000023f4 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    23f4:	1f 92       	push	r1
    23f6:	0f 92       	push	r0
    23f8:	0f b6       	in	r0, 0x3f	; 63
    23fa:	0f 92       	push	r0
    23fc:	11 24       	eor	r1, r1
    23fe:	2f 93       	push	r18
    2400:	3f 93       	push	r19
    2402:	4f 93       	push	r20
    2404:	5f 93       	push	r21
    2406:	6f 93       	push	r22
    2408:	7f 93       	push	r23
    240a:	8f 93       	push	r24
    240c:	9f 93       	push	r25
    240e:	af 93       	push	r26
    2410:	bf 93       	push	r27
    2412:	ef 93       	push	r30
    2414:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    2416:	80 91 82 1f 	lds	r24, 0x1F82
    241a:	90 91 83 1f 	lds	r25, 0x1F83
    241e:	a0 91 84 1f 	lds	r26, 0x1F84
    2422:	b0 91 85 1f 	lds	r27, 0x1F85
    2426:	01 96       	adiw	r24, 0x01	; 1
    2428:	a1 1d       	adc	r26, r1
    242a:	b1 1d       	adc	r27, r1
    242c:	80 93 82 1f 	sts	0x1F82, r24
    2430:	90 93 83 1f 	sts	0x1F83, r25
    2434:	a0 93 84 1f 	sts	0x1F84, r26
    2438:	b0 93 85 1f 	sts	0x1F85, r27
  timer_sleep_cnt++;
    243c:	80 91 8a 1f 	lds	r24, 0x1F8A
    2440:	90 91 8b 1f 	lds	r25, 0x1F8B
    2444:	a0 91 8c 1f 	lds	r26, 0x1F8C
    2448:	b0 91 8d 1f 	lds	r27, 0x1F8D
    244c:	01 96       	adiw	r24, 0x01	; 1
    244e:	a1 1d       	adc	r26, r1
    2450:	b1 1d       	adc	r27, r1
    2452:	80 93 8a 1f 	sts	0x1F8A, r24
    2456:	90 93 8b 1f 	sts	0x1F8B, r25
    245a:	a0 93 8c 1f 	sts	0x1F8C, r26
    245e:	b0 93 8d 1f 	sts	0x1F8D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    2462:	80 91 08 0f 	lds	r24, 0x0F08
    2466:	90 91 09 0f 	lds	r25, 0x0F09
    246a:	89 2b       	or	r24, r25
    246c:	29 f0       	breq	.+10     	; 0x2478 <__vector_23+0x84>
    246e:	e0 91 08 0f 	lds	r30, 0x0F08
    2472:	f0 91 09 0f 	lds	r31, 0x0F09
    2476:	09 95       	icall
}
    2478:	ff 91       	pop	r31
    247a:	ef 91       	pop	r30
    247c:	bf 91       	pop	r27
    247e:	af 91       	pop	r26
    2480:	9f 91       	pop	r25
    2482:	8f 91       	pop	r24
    2484:	7f 91       	pop	r23
    2486:	6f 91       	pop	r22
    2488:	5f 91       	pop	r21
    248a:	4f 91       	pop	r20
    248c:	3f 91       	pop	r19
    248e:	2f 91       	pop	r18
    2490:	0f 90       	pop	r0
    2492:	0f be       	out	0x3f, r0	; 63
    2494:	0f 90       	pop	r0
    2496:	1f 90       	pop	r1
    2498:	18 95       	reti

0000249a <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    249a:	1f 92       	push	r1
    249c:	0f 92       	push	r0
    249e:	0f b6       	in	r0, 0x3f	; 63
    24a0:	0f 92       	push	r0
    24a2:	11 24       	eor	r1, r1
    24a4:	2f 93       	push	r18
    24a6:	3f 93       	push	r19
    24a8:	4f 93       	push	r20
    24aa:	5f 93       	push	r21
    24ac:	6f 93       	push	r22
    24ae:	7f 93       	push	r23
    24b0:	8f 93       	push	r24
    24b2:	9f 93       	push	r25
    24b4:	af 93       	push	r26
    24b6:	bf 93       	push	r27
    24b8:	ef 93       	push	r30
    24ba:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    24bc:	80 91 7e 1f 	lds	r24, 0x1F7E
    24c0:	90 91 7f 1f 	lds	r25, 0x1F7F
    24c4:	a0 91 80 1f 	lds	r26, 0x1F80
    24c8:	b0 91 81 1f 	lds	r27, 0x1F81
    24cc:	01 96       	adiw	r24, 0x01	; 1
    24ce:	a1 1d       	adc	r26, r1
    24d0:	b1 1d       	adc	r27, r1
    24d2:	80 93 7e 1f 	sts	0x1F7E, r24
    24d6:	90 93 7f 1f 	sts	0x1F7F, r25
    24da:	a0 93 80 1f 	sts	0x1F80, r26
    24de:	b0 93 81 1f 	sts	0x1F81, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    24e2:	80 91 12 0f 	lds	r24, 0x0F12
    24e6:	90 91 13 0f 	lds	r25, 0x0F13
    24ea:	89 2b       	or	r24, r25
    24ec:	29 f0       	breq	.+10     	; 0x24f8 <__vector_20+0x5e>
    24ee:	e0 91 12 0f 	lds	r30, 0x0F12
    24f2:	f0 91 13 0f 	lds	r31, 0x0F13
    24f6:	09 95       	icall
}
    24f8:	ff 91       	pop	r31
    24fa:	ef 91       	pop	r30
    24fc:	bf 91       	pop	r27
    24fe:	af 91       	pop	r26
    2500:	9f 91       	pop	r25
    2502:	8f 91       	pop	r24
    2504:	7f 91       	pop	r23
    2506:	6f 91       	pop	r22
    2508:	5f 91       	pop	r21
    250a:	4f 91       	pop	r20
    250c:	3f 91       	pop	r19
    250e:	2f 91       	pop	r18
    2510:	0f 90       	pop	r0
    2512:	0f be       	out	0x3f, r0	; 63
    2514:	0f 90       	pop	r0
    2516:	1f 90       	pop	r1
    2518:	18 95       	reti

0000251a <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    251a:	1f 92       	push	r1
    251c:	0f 92       	push	r0
    251e:	0f b6       	in	r0, 0x3f	; 63
    2520:	0f 92       	push	r0
    2522:	11 24       	eor	r1, r1
    2524:	2f 93       	push	r18
    2526:	3f 93       	push	r19
    2528:	4f 93       	push	r20
    252a:	5f 93       	push	r21
    252c:	6f 93       	push	r22
    252e:	7f 93       	push	r23
    2530:	8f 93       	push	r24
    2532:	9f 93       	push	r25
    2534:	af 93       	push	r26
    2536:	bf 93       	push	r27
    2538:	ef 93       	push	r30
    253a:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    253c:	80 91 86 1f 	lds	r24, 0x1F86
    2540:	90 91 87 1f 	lds	r25, 0x1F87
    2544:	a0 91 88 1f 	lds	r26, 0x1F88
    2548:	b0 91 89 1f 	lds	r27, 0x1F89
    254c:	01 96       	adiw	r24, 0x01	; 1
    254e:	a1 1d       	adc	r26, r1
    2550:	b1 1d       	adc	r27, r1
    2552:	80 93 86 1f 	sts	0x1F86, r24
    2556:	90 93 87 1f 	sts	0x1F87, r25
    255a:	a0 93 88 1f 	sts	0x1F88, r26
    255e:	b0 93 89 1f 	sts	0x1F89, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    2562:	80 91 18 0f 	lds	r24, 0x0F18
    2566:	90 91 19 0f 	lds	r25, 0x0F19
    256a:	89 2b       	or	r24, r25
    256c:	29 f0       	breq	.+10     	; 0x2578 <__vector_15+0x5e>
    256e:	e0 91 18 0f 	lds	r30, 0x0F18
    2572:	f0 91 19 0f 	lds	r31, 0x0F19
    2576:	09 95       	icall
}
    2578:	ff 91       	pop	r31
    257a:	ef 91       	pop	r30
    257c:	bf 91       	pop	r27
    257e:	af 91       	pop	r26
    2580:	9f 91       	pop	r25
    2582:	8f 91       	pop	r24
    2584:	7f 91       	pop	r23
    2586:	6f 91       	pop	r22
    2588:	5f 91       	pop	r21
    258a:	4f 91       	pop	r20
    258c:	3f 91       	pop	r19
    258e:	2f 91       	pop	r18
    2590:	0f 90       	pop	r0
    2592:	0f be       	out	0x3f, r0	; 63
    2594:	0f 90       	pop	r0
    2596:	1f 90       	pop	r1
    2598:	18 95       	reti

0000259a <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    259a:	1f 92       	push	r1
    259c:	0f 92       	push	r0
    259e:	0f b6       	in	r0, 0x3f	; 63
    25a0:	0f 92       	push	r0
    25a2:	11 24       	eor	r1, r1
    25a4:	2f 93       	push	r18
    25a6:	3f 93       	push	r19
    25a8:	4f 93       	push	r20
    25aa:	5f 93       	push	r21
    25ac:	6f 93       	push	r22
    25ae:	7f 93       	push	r23
    25b0:	8f 93       	push	r24
    25b2:	9f 93       	push	r25
    25b4:	af 93       	push	r26
    25b6:	bf 93       	push	r27
    25b8:	ef 93       	push	r30
    25ba:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    25bc:	80 91 8e 1f 	lds	r24, 0x1F8E
    25c0:	90 91 8f 1f 	lds	r25, 0x1F8F
    25c4:	a0 91 90 1f 	lds	r26, 0x1F90
    25c8:	b0 91 91 1f 	lds	r27, 0x1F91
    25cc:	01 96       	adiw	r24, 0x01	; 1
    25ce:	a1 1d       	adc	r26, r1
    25d0:	b1 1d       	adc	r27, r1
    25d2:	80 93 8e 1f 	sts	0x1F8E, r24
    25d6:	90 93 8f 1f 	sts	0x1F8F, r25
    25da:	a0 93 90 1f 	sts	0x1F90, r26
    25de:	b0 93 91 1f 	sts	0x1F91, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    25e2:	80 91 22 0f 	lds	r24, 0x0F22
    25e6:	90 91 23 0f 	lds	r25, 0x0F23
    25ea:	89 2b       	or	r24, r25
    25ec:	29 f0       	breq	.+10     	; 0x25f8 <__vector_35+0x5e>
    25ee:	e0 91 22 0f 	lds	r30, 0x0F22
    25f2:	f0 91 23 0f 	lds	r31, 0x0F23
    25f6:	09 95       	icall
}
    25f8:	ff 91       	pop	r31
    25fa:	ef 91       	pop	r30
    25fc:	bf 91       	pop	r27
    25fe:	af 91       	pop	r26
    2600:	9f 91       	pop	r25
    2602:	8f 91       	pop	r24
    2604:	7f 91       	pop	r23
    2606:	6f 91       	pop	r22
    2608:	5f 91       	pop	r21
    260a:	4f 91       	pop	r20
    260c:	3f 91       	pop	r19
    260e:	2f 91       	pop	r18
    2610:	0f 90       	pop	r0
    2612:	0f be       	out	0x3f, r0	; 63
    2614:	0f 90       	pop	r0
    2616:	1f 90       	pop	r1
    2618:	18 95       	reti

0000261a <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    261a:	1f 92       	push	r1
    261c:	0f 92       	push	r0
    261e:	0f b6       	in	r0, 0x3f	; 63
    2620:	0f 92       	push	r0
    2622:	11 24       	eor	r1, r1
    2624:	2f 93       	push	r18
    2626:	3f 93       	push	r19
    2628:	4f 93       	push	r20
    262a:	5f 93       	push	r21
    262c:	6f 93       	push	r22
    262e:	7f 93       	push	r23
    2630:	8f 93       	push	r24
    2632:	9f 93       	push	r25
    2634:	af 93       	push	r26
    2636:	bf 93       	push	r27
    2638:	ef 93       	push	r30
    263a:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    263c:	80 91 7a 1f 	lds	r24, 0x1F7A
    2640:	90 91 7b 1f 	lds	r25, 0x1F7B
    2644:	a0 91 7c 1f 	lds	r26, 0x1F7C
    2648:	b0 91 7d 1f 	lds	r27, 0x1F7D
    264c:	01 96       	adiw	r24, 0x01	; 1
    264e:	a1 1d       	adc	r26, r1
    2650:	b1 1d       	adc	r27, r1
    2652:	80 93 7a 1f 	sts	0x1F7A, r24
    2656:	90 93 7b 1f 	sts	0x1F7B, r25
    265a:	a0 93 7c 1f 	sts	0x1F7C, r26
    265e:	b0 93 7d 1f 	sts	0x1F7D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    2662:	80 91 2c 0f 	lds	r24, 0x0F2C
    2666:	90 91 2d 0f 	lds	r25, 0x0F2D
    266a:	89 2b       	or	r24, r25
    266c:	29 f0       	breq	.+10     	; 0x2678 <__vector_45+0x5e>
    266e:	e0 91 2c 0f 	lds	r30, 0x0F2C
    2672:	f0 91 2d 0f 	lds	r31, 0x0F2D
    2676:	09 95       	icall
}
    2678:	ff 91       	pop	r31
    267a:	ef 91       	pop	r30
    267c:	bf 91       	pop	r27
    267e:	af 91       	pop	r26
    2680:	9f 91       	pop	r25
    2682:	8f 91       	pop	r24
    2684:	7f 91       	pop	r23
    2686:	6f 91       	pop	r22
    2688:	5f 91       	pop	r21
    268a:	4f 91       	pop	r20
    268c:	3f 91       	pop	r19
    268e:	2f 91       	pop	r18
    2690:	0f 90       	pop	r0
    2692:	0f be       	out	0x3f, r0	; 63
    2694:	0f 90       	pop	r0
    2696:	1f 90       	pop	r1
    2698:	18 95       	reti

0000269a <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    269a:	1f 92       	push	r1
    269c:	0f 92       	push	r0
    269e:	0f b6       	in	r0, 0x3f	; 63
    26a0:	0f 92       	push	r0
    26a2:	11 24       	eor	r1, r1
    26a4:	2f 93       	push	r18
    26a6:	3f 93       	push	r19
    26a8:	4f 93       	push	r20
    26aa:	5f 93       	push	r21
    26ac:	6f 93       	push	r22
    26ae:	7f 93       	push	r23
    26b0:	8f 93       	push	r24
    26b2:	9f 93       	push	r25
    26b4:	af 93       	push	r26
    26b6:	bf 93       	push	r27
    26b8:	ef 93       	push	r30
    26ba:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    26bc:	80 91 92 1f 	lds	r24, 0x1F92
    26c0:	90 91 93 1f 	lds	r25, 0x1F93
    26c4:	a0 91 94 1f 	lds	r26, 0x1F94
    26c8:	b0 91 95 1f 	lds	r27, 0x1F95
    26cc:	01 96       	adiw	r24, 0x01	; 1
    26ce:	a1 1d       	adc	r26, r1
    26d0:	b1 1d       	adc	r27, r1
    26d2:	80 93 92 1f 	sts	0x1F92, r24
    26d6:	90 93 93 1f 	sts	0x1F93, r25
    26da:	a0 93 94 1f 	sts	0x1F94, r26
    26de:	b0 93 95 1f 	sts	0x1F95, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    26e2:	80 91 36 0f 	lds	r24, 0x0F36
    26e6:	90 91 37 0f 	lds	r25, 0x0F37
    26ea:	89 2b       	or	r24, r25
    26ec:	29 f0       	breq	.+10     	; 0x26f8 <__vector_50+0x5e>
    26ee:	e0 91 36 0f 	lds	r30, 0x0F36
    26f2:	f0 91 37 0f 	lds	r31, 0x0F37
    26f6:	09 95       	icall
}
    26f8:	ff 91       	pop	r31
    26fa:	ef 91       	pop	r30
    26fc:	bf 91       	pop	r27
    26fe:	af 91       	pop	r26
    2700:	9f 91       	pop	r25
    2702:	8f 91       	pop	r24
    2704:	7f 91       	pop	r23
    2706:	6f 91       	pop	r22
    2708:	5f 91       	pop	r21
    270a:	4f 91       	pop	r20
    270c:	3f 91       	pop	r19
    270e:	2f 91       	pop	r18
    2710:	0f 90       	pop	r0
    2712:	0f be       	out	0x3f, r0	; 63
    2714:	0f 90       	pop	r0
    2716:	1f 90       	pop	r1
    2718:	18 95       	reti

0000271a <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    271a:	1f 92       	push	r1
    271c:	0f 92       	push	r0
    271e:	0f b6       	in	r0, 0x3f	; 63
    2720:	0f 92       	push	r0
    2722:	11 24       	eor	r1, r1
    2724:	2f 93       	push	r18
    2726:	3f 93       	push	r19
    2728:	4f 93       	push	r20
    272a:	5f 93       	push	r21
    272c:	6f 93       	push	r22
    272e:	7f 93       	push	r23
    2730:	8f 93       	push	r24
    2732:	9f 93       	push	r25
    2734:	af 93       	push	r26
    2736:	bf 93       	push	r27
    2738:	ef 93       	push	r30
    273a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    273c:	80 91 04 0f 	lds	r24, 0x0F04
    2740:	90 91 05 0f 	lds	r25, 0x0F05
    2744:	89 2b       	or	r24, r25
    2746:	29 f0       	breq	.+10     	; 0x2752 <__vector_21+0x38>
    2748:	e0 91 04 0f 	lds	r30, 0x0F04
    274c:	f0 91 05 0f 	lds	r31, 0x0F05
    2750:	09 95       	icall
}
    2752:	ff 91       	pop	r31
    2754:	ef 91       	pop	r30
    2756:	bf 91       	pop	r27
    2758:	af 91       	pop	r26
    275a:	9f 91       	pop	r25
    275c:	8f 91       	pop	r24
    275e:	7f 91       	pop	r23
    2760:	6f 91       	pop	r22
    2762:	5f 91       	pop	r21
    2764:	4f 91       	pop	r20
    2766:	3f 91       	pop	r19
    2768:	2f 91       	pop	r18
    276a:	0f 90       	pop	r0
    276c:	0f be       	out	0x3f, r0	; 63
    276e:	0f 90       	pop	r0
    2770:	1f 90       	pop	r1
    2772:	18 95       	reti

00002774 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    2774:	1f 92       	push	r1
    2776:	0f 92       	push	r0
    2778:	0f b6       	in	r0, 0x3f	; 63
    277a:	0f 92       	push	r0
    277c:	11 24       	eor	r1, r1
    277e:	2f 93       	push	r18
    2780:	3f 93       	push	r19
    2782:	4f 93       	push	r20
    2784:	5f 93       	push	r21
    2786:	6f 93       	push	r22
    2788:	7f 93       	push	r23
    278a:	8f 93       	push	r24
    278c:	9f 93       	push	r25
    278e:	af 93       	push	r26
    2790:	bf 93       	push	r27
    2792:	ef 93       	push	r30
    2794:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    2796:	80 91 06 0f 	lds	r24, 0x0F06
    279a:	90 91 07 0f 	lds	r25, 0x0F07
    279e:	89 2b       	or	r24, r25
    27a0:	29 f0       	breq	.+10     	; 0x27ac <__vector_22+0x38>
    27a2:	e0 91 06 0f 	lds	r30, 0x0F06
    27a6:	f0 91 07 0f 	lds	r31, 0x0F07
    27aa:	09 95       	icall
}
    27ac:	ff 91       	pop	r31
    27ae:	ef 91       	pop	r30
    27b0:	bf 91       	pop	r27
    27b2:	af 91       	pop	r26
    27b4:	9f 91       	pop	r25
    27b6:	8f 91       	pop	r24
    27b8:	7f 91       	pop	r23
    27ba:	6f 91       	pop	r22
    27bc:	5f 91       	pop	r21
    27be:	4f 91       	pop	r20
    27c0:	3f 91       	pop	r19
    27c2:	2f 91       	pop	r18
    27c4:	0f 90       	pop	r0
    27c6:	0f be       	out	0x3f, r0	; 63
    27c8:	0f 90       	pop	r0
    27ca:	1f 90       	pop	r1
    27cc:	18 95       	reti

000027ce <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    27ce:	1f 92       	push	r1
    27d0:	0f 92       	push	r0
    27d2:	0f b6       	in	r0, 0x3f	; 63
    27d4:	0f 92       	push	r0
    27d6:	11 24       	eor	r1, r1
    27d8:	2f 93       	push	r18
    27da:	3f 93       	push	r19
    27dc:	4f 93       	push	r20
    27de:	5f 93       	push	r21
    27e0:	6f 93       	push	r22
    27e2:	7f 93       	push	r23
    27e4:	8f 93       	push	r24
    27e6:	9f 93       	push	r25
    27e8:	af 93       	push	r26
    27ea:	bf 93       	push	r27
    27ec:	ef 93       	push	r30
    27ee:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    27f0:	80 91 0a 0f 	lds	r24, 0x0F0A
    27f4:	90 91 0b 0f 	lds	r25, 0x0F0B
    27f8:	89 2b       	or	r24, r25
    27fa:	29 f0       	breq	.+10     	; 0x2806 <__vector_16+0x38>
    27fc:	e0 91 0a 0f 	lds	r30, 0x0F0A
    2800:	f0 91 0b 0f 	lds	r31, 0x0F0B
    2804:	09 95       	icall
}
    2806:	ff 91       	pop	r31
    2808:	ef 91       	pop	r30
    280a:	bf 91       	pop	r27
    280c:	af 91       	pop	r26
    280e:	9f 91       	pop	r25
    2810:	8f 91       	pop	r24
    2812:	7f 91       	pop	r23
    2814:	6f 91       	pop	r22
    2816:	5f 91       	pop	r21
    2818:	4f 91       	pop	r20
    281a:	3f 91       	pop	r19
    281c:	2f 91       	pop	r18
    281e:	0f 90       	pop	r0
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	0f 90       	pop	r0
    2824:	1f 90       	pop	r1
    2826:	18 95       	reti

00002828 <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    2828:	1f 92       	push	r1
    282a:	0f 92       	push	r0
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	0f 92       	push	r0
    2830:	11 24       	eor	r1, r1
    2832:	2f 93       	push	r18
    2834:	3f 93       	push	r19
    2836:	4f 93       	push	r20
    2838:	5f 93       	push	r21
    283a:	6f 93       	push	r22
    283c:	7f 93       	push	r23
    283e:	8f 93       	push	r24
    2840:	9f 93       	push	r25
    2842:	af 93       	push	r26
    2844:	bf 93       	push	r27
    2846:	ef 93       	push	r30
    2848:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    284a:	80 91 0e 0f 	lds	r24, 0x0F0E
    284e:	90 91 0f 0f 	lds	r25, 0x0F0F
    2852:	89 2b       	or	r24, r25
    2854:	29 f0       	breq	.+10     	; 0x2860 <__vector_18+0x38>
    2856:	e0 91 0e 0f 	lds	r30, 0x0F0E
    285a:	f0 91 0f 0f 	lds	r31, 0x0F0F
    285e:	09 95       	icall
}
    2860:	ff 91       	pop	r31
    2862:	ef 91       	pop	r30
    2864:	bf 91       	pop	r27
    2866:	af 91       	pop	r26
    2868:	9f 91       	pop	r25
    286a:	8f 91       	pop	r24
    286c:	7f 91       	pop	r23
    286e:	6f 91       	pop	r22
    2870:	5f 91       	pop	r21
    2872:	4f 91       	pop	r20
    2874:	3f 91       	pop	r19
    2876:	2f 91       	pop	r18
    2878:	0f 90       	pop	r0
    287a:	0f be       	out	0x3f, r0	; 63
    287c:	0f 90       	pop	r0
    287e:	1f 90       	pop	r1
    2880:	18 95       	reti

00002882 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    2882:	1f 92       	push	r1
    2884:	0f 92       	push	r0
    2886:	0f b6       	in	r0, 0x3f	; 63
    2888:	0f 92       	push	r0
    288a:	11 24       	eor	r1, r1
    288c:	2f 93       	push	r18
    288e:	3f 93       	push	r19
    2890:	4f 93       	push	r20
    2892:	5f 93       	push	r21
    2894:	6f 93       	push	r22
    2896:	7f 93       	push	r23
    2898:	8f 93       	push	r24
    289a:	9f 93       	push	r25
    289c:	af 93       	push	r26
    289e:	bf 93       	push	r27
    28a0:	ef 93       	push	r30
    28a2:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    28a4:	80 91 10 0f 	lds	r24, 0x0F10
    28a8:	90 91 11 0f 	lds	r25, 0x0F11
    28ac:	89 2b       	or	r24, r25
    28ae:	29 f0       	breq	.+10     	; 0x28ba <__vector_19+0x38>
    28b0:	e0 91 10 0f 	lds	r30, 0x0F10
    28b4:	f0 91 11 0f 	lds	r31, 0x0F11
    28b8:	09 95       	icall
}
    28ba:	ff 91       	pop	r31
    28bc:	ef 91       	pop	r30
    28be:	bf 91       	pop	r27
    28c0:	af 91       	pop	r26
    28c2:	9f 91       	pop	r25
    28c4:	8f 91       	pop	r24
    28c6:	7f 91       	pop	r23
    28c8:	6f 91       	pop	r22
    28ca:	5f 91       	pop	r21
    28cc:	4f 91       	pop	r20
    28ce:	3f 91       	pop	r19
    28d0:	2f 91       	pop	r18
    28d2:	0f 90       	pop	r0
    28d4:	0f be       	out	0x3f, r0	; 63
    28d6:	0f 90       	pop	r0
    28d8:	1f 90       	pop	r1
    28da:	18 95       	reti

000028dc <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    28dc:	1f 92       	push	r1
    28de:	0f 92       	push	r0
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	0f 92       	push	r0
    28e4:	11 24       	eor	r1, r1
    28e6:	2f 93       	push	r18
    28e8:	3f 93       	push	r19
    28ea:	4f 93       	push	r20
    28ec:	5f 93       	push	r21
    28ee:	6f 93       	push	r22
    28f0:	7f 93       	push	r23
    28f2:	8f 93       	push	r24
    28f4:	9f 93       	push	r25
    28f6:	af 93       	push	r26
    28f8:	bf 93       	push	r27
    28fa:	ef 93       	push	r30
    28fc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    28fe:	80 91 14 0f 	lds	r24, 0x0F14
    2902:	90 91 15 0f 	lds	r25, 0x0F15
    2906:	89 2b       	or	r24, r25
    2908:	29 f0       	breq	.+10     	; 0x2914 <__vector_13+0x38>
    290a:	e0 91 14 0f 	lds	r30, 0x0F14
    290e:	f0 91 15 0f 	lds	r31, 0x0F15
    2912:	09 95       	icall
}
    2914:	ff 91       	pop	r31
    2916:	ef 91       	pop	r30
    2918:	bf 91       	pop	r27
    291a:	af 91       	pop	r26
    291c:	9f 91       	pop	r25
    291e:	8f 91       	pop	r24
    2920:	7f 91       	pop	r23
    2922:	6f 91       	pop	r22
    2924:	5f 91       	pop	r21
    2926:	4f 91       	pop	r20
    2928:	3f 91       	pop	r19
    292a:	2f 91       	pop	r18
    292c:	0f 90       	pop	r0
    292e:	0f be       	out	0x3f, r0	; 63
    2930:	0f 90       	pop	r0
    2932:	1f 90       	pop	r1
    2934:	18 95       	reti

00002936 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    2936:	1f 92       	push	r1
    2938:	0f 92       	push	r0
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	0f 92       	push	r0
    293e:	11 24       	eor	r1, r1
    2940:	2f 93       	push	r18
    2942:	3f 93       	push	r19
    2944:	4f 93       	push	r20
    2946:	5f 93       	push	r21
    2948:	6f 93       	push	r22
    294a:	7f 93       	push	r23
    294c:	8f 93       	push	r24
    294e:	9f 93       	push	r25
    2950:	af 93       	push	r26
    2952:	bf 93       	push	r27
    2954:	ef 93       	push	r30
    2956:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    2958:	80 91 16 0f 	lds	r24, 0x0F16
    295c:	90 91 17 0f 	lds	r25, 0x0F17
    2960:	89 2b       	or	r24, r25
    2962:	29 f0       	breq	.+10     	; 0x296e <__vector_14+0x38>
    2964:	e0 91 16 0f 	lds	r30, 0x0F16
    2968:	f0 91 17 0f 	lds	r31, 0x0F17
    296c:	09 95       	icall
}
    296e:	ff 91       	pop	r31
    2970:	ef 91       	pop	r30
    2972:	bf 91       	pop	r27
    2974:	af 91       	pop	r26
    2976:	9f 91       	pop	r25
    2978:	8f 91       	pop	r24
    297a:	7f 91       	pop	r23
    297c:	6f 91       	pop	r22
    297e:	5f 91       	pop	r21
    2980:	4f 91       	pop	r20
    2982:	3f 91       	pop	r19
    2984:	2f 91       	pop	r18
    2986:	0f 90       	pop	r0
    2988:	0f be       	out	0x3f, r0	; 63
    298a:	0f 90       	pop	r0
    298c:	1f 90       	pop	r1
    298e:	18 95       	reti

00002990 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    2990:	1f 92       	push	r1
    2992:	0f 92       	push	r0
    2994:	0f b6       	in	r0, 0x3f	; 63
    2996:	0f 92       	push	r0
    2998:	11 24       	eor	r1, r1
    299a:	2f 93       	push	r18
    299c:	3f 93       	push	r19
    299e:	4f 93       	push	r20
    29a0:	5f 93       	push	r21
    29a2:	6f 93       	push	r22
    29a4:	7f 93       	push	r23
    29a6:	8f 93       	push	r24
    29a8:	9f 93       	push	r25
    29aa:	af 93       	push	r26
    29ac:	bf 93       	push	r27
    29ae:	ef 93       	push	r30
    29b0:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    29b2:	80 91 1a 0f 	lds	r24, 0x0F1A
    29b6:	90 91 1b 0f 	lds	r25, 0x0F1B
    29ba:	89 2b       	or	r24, r25
    29bc:	29 f0       	breq	.+10     	; 0x29c8 <__vector_31+0x38>
    29be:	e0 91 1a 0f 	lds	r30, 0x0F1A
    29c2:	f0 91 1b 0f 	lds	r31, 0x0F1B
    29c6:	09 95       	icall
}
    29c8:	ff 91       	pop	r31
    29ca:	ef 91       	pop	r30
    29cc:	bf 91       	pop	r27
    29ce:	af 91       	pop	r26
    29d0:	9f 91       	pop	r25
    29d2:	8f 91       	pop	r24
    29d4:	7f 91       	pop	r23
    29d6:	6f 91       	pop	r22
    29d8:	5f 91       	pop	r21
    29da:	4f 91       	pop	r20
    29dc:	3f 91       	pop	r19
    29de:	2f 91       	pop	r18
    29e0:	0f 90       	pop	r0
    29e2:	0f be       	out	0x3f, r0	; 63
    29e4:	0f 90       	pop	r0
    29e6:	1f 90       	pop	r1
    29e8:	18 95       	reti

000029ea <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    29ea:	1f 92       	push	r1
    29ec:	0f 92       	push	r0
    29ee:	0f b6       	in	r0, 0x3f	; 63
    29f0:	0f 92       	push	r0
    29f2:	11 24       	eor	r1, r1
    29f4:	2f 93       	push	r18
    29f6:	3f 93       	push	r19
    29f8:	4f 93       	push	r20
    29fa:	5f 93       	push	r21
    29fc:	6f 93       	push	r22
    29fe:	7f 93       	push	r23
    2a00:	8f 93       	push	r24
    2a02:	9f 93       	push	r25
    2a04:	af 93       	push	r26
    2a06:	bf 93       	push	r27
    2a08:	ef 93       	push	r30
    2a0a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    2a0c:	80 91 1c 0f 	lds	r24, 0x0F1C
    2a10:	90 91 1d 0f 	lds	r25, 0x0F1D
    2a14:	89 2b       	or	r24, r25
    2a16:	29 f0       	breq	.+10     	; 0x2a22 <__vector_32+0x38>
    2a18:	e0 91 1c 0f 	lds	r30, 0x0F1C
    2a1c:	f0 91 1d 0f 	lds	r31, 0x0F1D
    2a20:	09 95       	icall
}
    2a22:	ff 91       	pop	r31
    2a24:	ef 91       	pop	r30
    2a26:	bf 91       	pop	r27
    2a28:	af 91       	pop	r26
    2a2a:	9f 91       	pop	r25
    2a2c:	8f 91       	pop	r24
    2a2e:	7f 91       	pop	r23
    2a30:	6f 91       	pop	r22
    2a32:	5f 91       	pop	r21
    2a34:	4f 91       	pop	r20
    2a36:	3f 91       	pop	r19
    2a38:	2f 91       	pop	r18
    2a3a:	0f 90       	pop	r0
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	0f 90       	pop	r0
    2a40:	1f 90       	pop	r1
    2a42:	18 95       	reti

00002a44 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    2a44:	1f 92       	push	r1
    2a46:	0f 92       	push	r0
    2a48:	0f b6       	in	r0, 0x3f	; 63
    2a4a:	0f 92       	push	r0
    2a4c:	11 24       	eor	r1, r1
    2a4e:	2f 93       	push	r18
    2a50:	3f 93       	push	r19
    2a52:	4f 93       	push	r20
    2a54:	5f 93       	push	r21
    2a56:	6f 93       	push	r22
    2a58:	7f 93       	push	r23
    2a5a:	8f 93       	push	r24
    2a5c:	9f 93       	push	r25
    2a5e:	af 93       	push	r26
    2a60:	bf 93       	push	r27
    2a62:	ef 93       	push	r30
    2a64:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    2a66:	80 91 1e 0f 	lds	r24, 0x0F1E
    2a6a:	90 91 1f 0f 	lds	r25, 0x0F1F
    2a6e:	89 2b       	or	r24, r25
    2a70:	29 f0       	breq	.+10     	; 0x2a7c <__vector_33+0x38>
    2a72:	e0 91 1e 0f 	lds	r30, 0x0F1E
    2a76:	f0 91 1f 0f 	lds	r31, 0x0F1F
    2a7a:	09 95       	icall
}
    2a7c:	ff 91       	pop	r31
    2a7e:	ef 91       	pop	r30
    2a80:	bf 91       	pop	r27
    2a82:	af 91       	pop	r26
    2a84:	9f 91       	pop	r25
    2a86:	8f 91       	pop	r24
    2a88:	7f 91       	pop	r23
    2a8a:	6f 91       	pop	r22
    2a8c:	5f 91       	pop	r21
    2a8e:	4f 91       	pop	r20
    2a90:	3f 91       	pop	r19
    2a92:	2f 91       	pop	r18
    2a94:	0f 90       	pop	r0
    2a96:	0f be       	out	0x3f, r0	; 63
    2a98:	0f 90       	pop	r0
    2a9a:	1f 90       	pop	r1
    2a9c:	18 95       	reti

00002a9e <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    2a9e:	1f 92       	push	r1
    2aa0:	0f 92       	push	r0
    2aa2:	0f b6       	in	r0, 0x3f	; 63
    2aa4:	0f 92       	push	r0
    2aa6:	11 24       	eor	r1, r1
    2aa8:	2f 93       	push	r18
    2aaa:	3f 93       	push	r19
    2aac:	4f 93       	push	r20
    2aae:	5f 93       	push	r21
    2ab0:	6f 93       	push	r22
    2ab2:	7f 93       	push	r23
    2ab4:	8f 93       	push	r24
    2ab6:	9f 93       	push	r25
    2ab8:	af 93       	push	r26
    2aba:	bf 93       	push	r27
    2abc:	ef 93       	push	r30
    2abe:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    2ac0:	80 91 20 0f 	lds	r24, 0x0F20
    2ac4:	90 91 21 0f 	lds	r25, 0x0F21
    2ac8:	89 2b       	or	r24, r25
    2aca:	29 f0       	breq	.+10     	; 0x2ad6 <__vector_34+0x38>
    2acc:	e0 91 20 0f 	lds	r30, 0x0F20
    2ad0:	f0 91 21 0f 	lds	r31, 0x0F21
    2ad4:	09 95       	icall
}
    2ad6:	ff 91       	pop	r31
    2ad8:	ef 91       	pop	r30
    2ada:	bf 91       	pop	r27
    2adc:	af 91       	pop	r26
    2ade:	9f 91       	pop	r25
    2ae0:	8f 91       	pop	r24
    2ae2:	7f 91       	pop	r23
    2ae4:	6f 91       	pop	r22
    2ae6:	5f 91       	pop	r21
    2ae8:	4f 91       	pop	r20
    2aea:	3f 91       	pop	r19
    2aec:	2f 91       	pop	r18
    2aee:	0f 90       	pop	r0
    2af0:	0f be       	out	0x3f, r0	; 63
    2af2:	0f 90       	pop	r0
    2af4:	1f 90       	pop	r1
    2af6:	18 95       	reti

00002af8 <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    2af8:	1f 92       	push	r1
    2afa:	0f 92       	push	r0
    2afc:	0f b6       	in	r0, 0x3f	; 63
    2afe:	0f 92       	push	r0
    2b00:	11 24       	eor	r1, r1
    2b02:	2f 93       	push	r18
    2b04:	3f 93       	push	r19
    2b06:	4f 93       	push	r20
    2b08:	5f 93       	push	r21
    2b0a:	6f 93       	push	r22
    2b0c:	7f 93       	push	r23
    2b0e:	8f 93       	push	r24
    2b10:	9f 93       	push	r25
    2b12:	af 93       	push	r26
    2b14:	bf 93       	push	r27
    2b16:	ef 93       	push	r30
    2b18:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    2b1a:	80 91 24 0f 	lds	r24, 0x0F24
    2b1e:	90 91 25 0f 	lds	r25, 0x0F25
    2b22:	89 2b       	or	r24, r25
    2b24:	29 f0       	breq	.+10     	; 0x2b30 <__vector_41+0x38>
    2b26:	e0 91 24 0f 	lds	r30, 0x0F24
    2b2a:	f0 91 25 0f 	lds	r31, 0x0F25
    2b2e:	09 95       	icall
}
    2b30:	ff 91       	pop	r31
    2b32:	ef 91       	pop	r30
    2b34:	bf 91       	pop	r27
    2b36:	af 91       	pop	r26
    2b38:	9f 91       	pop	r25
    2b3a:	8f 91       	pop	r24
    2b3c:	7f 91       	pop	r23
    2b3e:	6f 91       	pop	r22
    2b40:	5f 91       	pop	r21
    2b42:	4f 91       	pop	r20
    2b44:	3f 91       	pop	r19
    2b46:	2f 91       	pop	r18
    2b48:	0f 90       	pop	r0
    2b4a:	0f be       	out	0x3f, r0	; 63
    2b4c:	0f 90       	pop	r0
    2b4e:	1f 90       	pop	r1
    2b50:	18 95       	reti

00002b52 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    2b52:	1f 92       	push	r1
    2b54:	0f 92       	push	r0
    2b56:	0f b6       	in	r0, 0x3f	; 63
    2b58:	0f 92       	push	r0
    2b5a:	11 24       	eor	r1, r1
    2b5c:	2f 93       	push	r18
    2b5e:	3f 93       	push	r19
    2b60:	4f 93       	push	r20
    2b62:	5f 93       	push	r21
    2b64:	6f 93       	push	r22
    2b66:	7f 93       	push	r23
    2b68:	8f 93       	push	r24
    2b6a:	9f 93       	push	r25
    2b6c:	af 93       	push	r26
    2b6e:	bf 93       	push	r27
    2b70:	ef 93       	push	r30
    2b72:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    2b74:	80 91 26 0f 	lds	r24, 0x0F26
    2b78:	90 91 27 0f 	lds	r25, 0x0F27
    2b7c:	89 2b       	or	r24, r25
    2b7e:	29 f0       	breq	.+10     	; 0x2b8a <__vector_42+0x38>
    2b80:	e0 91 26 0f 	lds	r30, 0x0F26
    2b84:	f0 91 27 0f 	lds	r31, 0x0F27
    2b88:	09 95       	icall
}
    2b8a:	ff 91       	pop	r31
    2b8c:	ef 91       	pop	r30
    2b8e:	bf 91       	pop	r27
    2b90:	af 91       	pop	r26
    2b92:	9f 91       	pop	r25
    2b94:	8f 91       	pop	r24
    2b96:	7f 91       	pop	r23
    2b98:	6f 91       	pop	r22
    2b9a:	5f 91       	pop	r21
    2b9c:	4f 91       	pop	r20
    2b9e:	3f 91       	pop	r19
    2ba0:	2f 91       	pop	r18
    2ba2:	0f 90       	pop	r0
    2ba4:	0f be       	out	0x3f, r0	; 63
    2ba6:	0f 90       	pop	r0
    2ba8:	1f 90       	pop	r1
    2baa:	18 95       	reti

00002bac <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    2bac:	1f 92       	push	r1
    2bae:	0f 92       	push	r0
    2bb0:	0f b6       	in	r0, 0x3f	; 63
    2bb2:	0f 92       	push	r0
    2bb4:	11 24       	eor	r1, r1
    2bb6:	2f 93       	push	r18
    2bb8:	3f 93       	push	r19
    2bba:	4f 93       	push	r20
    2bbc:	5f 93       	push	r21
    2bbe:	6f 93       	push	r22
    2bc0:	7f 93       	push	r23
    2bc2:	8f 93       	push	r24
    2bc4:	9f 93       	push	r25
    2bc6:	af 93       	push	r26
    2bc8:	bf 93       	push	r27
    2bca:	ef 93       	push	r30
    2bcc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    2bce:	80 91 28 0f 	lds	r24, 0x0F28
    2bd2:	90 91 29 0f 	lds	r25, 0x0F29
    2bd6:	89 2b       	or	r24, r25
    2bd8:	29 f0       	breq	.+10     	; 0x2be4 <__vector_43+0x38>
    2bda:	e0 91 28 0f 	lds	r30, 0x0F28
    2bde:	f0 91 29 0f 	lds	r31, 0x0F29
    2be2:	09 95       	icall
}
    2be4:	ff 91       	pop	r31
    2be6:	ef 91       	pop	r30
    2be8:	bf 91       	pop	r27
    2bea:	af 91       	pop	r26
    2bec:	9f 91       	pop	r25
    2bee:	8f 91       	pop	r24
    2bf0:	7f 91       	pop	r23
    2bf2:	6f 91       	pop	r22
    2bf4:	5f 91       	pop	r21
    2bf6:	4f 91       	pop	r20
    2bf8:	3f 91       	pop	r19
    2bfa:	2f 91       	pop	r18
    2bfc:	0f 90       	pop	r0
    2bfe:	0f be       	out	0x3f, r0	; 63
    2c00:	0f 90       	pop	r0
    2c02:	1f 90       	pop	r1
    2c04:	18 95       	reti

00002c06 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    2c06:	1f 92       	push	r1
    2c08:	0f 92       	push	r0
    2c0a:	0f b6       	in	r0, 0x3f	; 63
    2c0c:	0f 92       	push	r0
    2c0e:	11 24       	eor	r1, r1
    2c10:	2f 93       	push	r18
    2c12:	3f 93       	push	r19
    2c14:	4f 93       	push	r20
    2c16:	5f 93       	push	r21
    2c18:	6f 93       	push	r22
    2c1a:	7f 93       	push	r23
    2c1c:	8f 93       	push	r24
    2c1e:	9f 93       	push	r25
    2c20:	af 93       	push	r26
    2c22:	bf 93       	push	r27
    2c24:	ef 93       	push	r30
    2c26:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    2c28:	80 91 2a 0f 	lds	r24, 0x0F2A
    2c2c:	90 91 2b 0f 	lds	r25, 0x0F2B
    2c30:	89 2b       	or	r24, r25
    2c32:	29 f0       	breq	.+10     	; 0x2c3e <__vector_44+0x38>
    2c34:	e0 91 2a 0f 	lds	r30, 0x0F2A
    2c38:	f0 91 2b 0f 	lds	r31, 0x0F2B
    2c3c:	09 95       	icall
}
    2c3e:	ff 91       	pop	r31
    2c40:	ef 91       	pop	r30
    2c42:	bf 91       	pop	r27
    2c44:	af 91       	pop	r26
    2c46:	9f 91       	pop	r25
    2c48:	8f 91       	pop	r24
    2c4a:	7f 91       	pop	r23
    2c4c:	6f 91       	pop	r22
    2c4e:	5f 91       	pop	r21
    2c50:	4f 91       	pop	r20
    2c52:	3f 91       	pop	r19
    2c54:	2f 91       	pop	r18
    2c56:	0f 90       	pop	r0
    2c58:	0f be       	out	0x3f, r0	; 63
    2c5a:	0f 90       	pop	r0
    2c5c:	1f 90       	pop	r1
    2c5e:	18 95       	reti

00002c60 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    2c60:	1f 92       	push	r1
    2c62:	0f 92       	push	r0
    2c64:	0f b6       	in	r0, 0x3f	; 63
    2c66:	0f 92       	push	r0
    2c68:	11 24       	eor	r1, r1
    2c6a:	2f 93       	push	r18
    2c6c:	3f 93       	push	r19
    2c6e:	4f 93       	push	r20
    2c70:	5f 93       	push	r21
    2c72:	6f 93       	push	r22
    2c74:	7f 93       	push	r23
    2c76:	8f 93       	push	r24
    2c78:	9f 93       	push	r25
    2c7a:	af 93       	push	r26
    2c7c:	bf 93       	push	r27
    2c7e:	ef 93       	push	r30
    2c80:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    2c82:	80 91 2e 0f 	lds	r24, 0x0F2E
    2c86:	90 91 2f 0f 	lds	r25, 0x0F2F
    2c8a:	89 2b       	or	r24, r25
    2c8c:	29 f0       	breq	.+10     	; 0x2c98 <__vector_46+0x38>
    2c8e:	e0 91 2e 0f 	lds	r30, 0x0F2E
    2c92:	f0 91 2f 0f 	lds	r31, 0x0F2F
    2c96:	09 95       	icall
}
    2c98:	ff 91       	pop	r31
    2c9a:	ef 91       	pop	r30
    2c9c:	bf 91       	pop	r27
    2c9e:	af 91       	pop	r26
    2ca0:	9f 91       	pop	r25
    2ca2:	8f 91       	pop	r24
    2ca4:	7f 91       	pop	r23
    2ca6:	6f 91       	pop	r22
    2ca8:	5f 91       	pop	r21
    2caa:	4f 91       	pop	r20
    2cac:	3f 91       	pop	r19
    2cae:	2f 91       	pop	r18
    2cb0:	0f 90       	pop	r0
    2cb2:	0f be       	out	0x3f, r0	; 63
    2cb4:	0f 90       	pop	r0
    2cb6:	1f 90       	pop	r1
    2cb8:	18 95       	reti

00002cba <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    2cba:	1f 92       	push	r1
    2cbc:	0f 92       	push	r0
    2cbe:	0f b6       	in	r0, 0x3f	; 63
    2cc0:	0f 92       	push	r0
    2cc2:	11 24       	eor	r1, r1
    2cc4:	2f 93       	push	r18
    2cc6:	3f 93       	push	r19
    2cc8:	4f 93       	push	r20
    2cca:	5f 93       	push	r21
    2ccc:	6f 93       	push	r22
    2cce:	7f 93       	push	r23
    2cd0:	8f 93       	push	r24
    2cd2:	9f 93       	push	r25
    2cd4:	af 93       	push	r26
    2cd6:	bf 93       	push	r27
    2cd8:	ef 93       	push	r30
    2cda:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    2cdc:	80 91 30 0f 	lds	r24, 0x0F30
    2ce0:	90 91 31 0f 	lds	r25, 0x0F31
    2ce4:	89 2b       	or	r24, r25
    2ce6:	29 f0       	breq	.+10     	; 0x2cf2 <__vector_47+0x38>
    2ce8:	e0 91 30 0f 	lds	r30, 0x0F30
    2cec:	f0 91 31 0f 	lds	r31, 0x0F31
    2cf0:	09 95       	icall
}
    2cf2:	ff 91       	pop	r31
    2cf4:	ef 91       	pop	r30
    2cf6:	bf 91       	pop	r27
    2cf8:	af 91       	pop	r26
    2cfa:	9f 91       	pop	r25
    2cfc:	8f 91       	pop	r24
    2cfe:	7f 91       	pop	r23
    2d00:	6f 91       	pop	r22
    2d02:	5f 91       	pop	r21
    2d04:	4f 91       	pop	r20
    2d06:	3f 91       	pop	r19
    2d08:	2f 91       	pop	r18
    2d0a:	0f 90       	pop	r0
    2d0c:	0f be       	out	0x3f, r0	; 63
    2d0e:	0f 90       	pop	r0
    2d10:	1f 90       	pop	r1
    2d12:	18 95       	reti

00002d14 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    2d14:	1f 92       	push	r1
    2d16:	0f 92       	push	r0
    2d18:	0f b6       	in	r0, 0x3f	; 63
    2d1a:	0f 92       	push	r0
    2d1c:	11 24       	eor	r1, r1
    2d1e:	2f 93       	push	r18
    2d20:	3f 93       	push	r19
    2d22:	4f 93       	push	r20
    2d24:	5f 93       	push	r21
    2d26:	6f 93       	push	r22
    2d28:	7f 93       	push	r23
    2d2a:	8f 93       	push	r24
    2d2c:	9f 93       	push	r25
    2d2e:	af 93       	push	r26
    2d30:	bf 93       	push	r27
    2d32:	ef 93       	push	r30
    2d34:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    2d36:	80 91 32 0f 	lds	r24, 0x0F32
    2d3a:	90 91 33 0f 	lds	r25, 0x0F33
    2d3e:	89 2b       	or	r24, r25
    2d40:	29 f0       	breq	.+10     	; 0x2d4c <__vector_48+0x38>
    2d42:	e0 91 32 0f 	lds	r30, 0x0F32
    2d46:	f0 91 33 0f 	lds	r31, 0x0F33
    2d4a:	09 95       	icall
}
    2d4c:	ff 91       	pop	r31
    2d4e:	ef 91       	pop	r30
    2d50:	bf 91       	pop	r27
    2d52:	af 91       	pop	r26
    2d54:	9f 91       	pop	r25
    2d56:	8f 91       	pop	r24
    2d58:	7f 91       	pop	r23
    2d5a:	6f 91       	pop	r22
    2d5c:	5f 91       	pop	r21
    2d5e:	4f 91       	pop	r20
    2d60:	3f 91       	pop	r19
    2d62:	2f 91       	pop	r18
    2d64:	0f 90       	pop	r0
    2d66:	0f be       	out	0x3f, r0	; 63
    2d68:	0f 90       	pop	r0
    2d6a:	1f 90       	pop	r1
    2d6c:	18 95       	reti

00002d6e <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    2d6e:	1f 92       	push	r1
    2d70:	0f 92       	push	r0
    2d72:	0f b6       	in	r0, 0x3f	; 63
    2d74:	0f 92       	push	r0
    2d76:	11 24       	eor	r1, r1
    2d78:	2f 93       	push	r18
    2d7a:	3f 93       	push	r19
    2d7c:	4f 93       	push	r20
    2d7e:	5f 93       	push	r21
    2d80:	6f 93       	push	r22
    2d82:	7f 93       	push	r23
    2d84:	8f 93       	push	r24
    2d86:	9f 93       	push	r25
    2d88:	af 93       	push	r26
    2d8a:	bf 93       	push	r27
    2d8c:	ef 93       	push	r30
    2d8e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    2d90:	80 91 34 0f 	lds	r24, 0x0F34
    2d94:	90 91 35 0f 	lds	r25, 0x0F35
    2d98:	89 2b       	or	r24, r25
    2d9a:	29 f0       	breq	.+10     	; 0x2da6 <__vector_49+0x38>
    2d9c:	e0 91 34 0f 	lds	r30, 0x0F34
    2da0:	f0 91 35 0f 	lds	r31, 0x0F35
    2da4:	09 95       	icall
}
    2da6:	ff 91       	pop	r31
    2da8:	ef 91       	pop	r30
    2daa:	bf 91       	pop	r27
    2dac:	af 91       	pop	r26
    2dae:	9f 91       	pop	r25
    2db0:	8f 91       	pop	r24
    2db2:	7f 91       	pop	r23
    2db4:	6f 91       	pop	r22
    2db6:	5f 91       	pop	r21
    2db8:	4f 91       	pop	r20
    2dba:	3f 91       	pop	r19
    2dbc:	2f 91       	pop	r18
    2dbe:	0f 90       	pop	r0
    2dc0:	0f be       	out	0x3f, r0	; 63
    2dc2:	0f 90       	pop	r0
    2dc4:	1f 90       	pop	r1
    2dc6:	18 95       	reti

00002dc8 <__vector_default>:

ISR(BADISR_vect)
{
    2dc8:	1f 92       	push	r1
    2dca:	0f 92       	push	r0
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	0f 92       	push	r0
    2dd0:	11 24       	eor	r1, r1
    2dd2:	2f 93       	push	r18
    2dd4:	3f 93       	push	r19
    2dd6:	4f 93       	push	r20
    2dd8:	5f 93       	push	r21
    2dda:	6f 93       	push	r22
    2ddc:	7f 93       	push	r23
    2dde:	8f 93       	push	r24
    2de0:	9f 93       	push	r25
    2de2:	af 93       	push	r26
    2de4:	bf 93       	push	r27
    2de6:	ef 93       	push	r30
    2de8:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    2dea:	00 d0       	rcall	.+0      	; 0x2dec <__vector_default+0x24>
    2dec:	0f 92       	push	r0
    2dee:	81 e0       	ldi	r24, 0x01	; 1
    2df0:	ed b7       	in	r30, 0x3d	; 61
    2df2:	fe b7       	in	r31, 0x3e	; 62
    2df4:	81 83       	std	Z+1, r24	; 0x01
    2df6:	80 e3       	ldi	r24, 0x30	; 48
    2df8:	91 e0       	ldi	r25, 0x01	; 1
    2dfa:	93 83       	std	Z+3, r25	; 0x03
    2dfc:	82 83       	std	Z+2, r24	; 0x02
    2dfe:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <rprintf1RamRom>
    2e02:	0f 90       	pop	r0
    2e04:	0f 90       	pop	r0
    2e06:	0f 90       	pop	r0
}
    2e08:	ff 91       	pop	r31
    2e0a:	ef 91       	pop	r30
    2e0c:	bf 91       	pop	r27
    2e0e:	af 91       	pop	r26
    2e10:	9f 91       	pop	r25
    2e12:	8f 91       	pop	r24
    2e14:	7f 91       	pop	r23
    2e16:	6f 91       	pop	r22
    2e18:	5f 91       	pop	r21
    2e1a:	4f 91       	pop	r20
    2e1c:	3f 91       	pop	r19
    2e1e:	2f 91       	pop	r18
    2e20:	0f 90       	pop	r0
    2e22:	0f be       	out	0x3f, r0	; 63
    2e24:	0f 90       	pop	r0
    2e26:	1f 90       	pop	r1
    2e28:	18 95       	reti

00002e2a <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    2e2a:	84 30       	cpi	r24, 0x04	; 4
    2e2c:	40 f4       	brcc	.+16     	; 0x2e3e <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    2e2e:	e8 2f       	mov	r30, r24
    2e30:	f0 e0       	ldi	r31, 0x00	; 0
    2e32:	ee 0f       	add	r30, r30
    2e34:	ff 1f       	adc	r31, r31
    2e36:	e8 58       	subi	r30, 0x88	; 136
    2e38:	fe 4e       	sbci	r31, 0xEE	; 238
    2e3a:	71 83       	std	Z+1, r23	; 0x01
    2e3c:	60 83       	st	Z, r22
    2e3e:	08 95       	ret

00002e40 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    2e40:	1f 93       	push	r17
    2e42:	18 2f       	mov	r17, r24
    2e44:	9a 01       	movw	r18, r20
    2e46:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    2e48:	ca 01       	movw	r24, r20
    2e4a:	b9 01       	movw	r22, r18
    2e4c:	60 58       	subi	r22, 0x80	; 128
    2e4e:	7b 47       	sbci	r23, 0x7B	; 123
    2e50:	81 4e       	sbci	r24, 0xE1	; 225
    2e52:	9f 4f       	sbci	r25, 0xFF	; 255
    2e54:	f3 e0       	ldi	r31, 0x03	; 3
    2e56:	66 0f       	add	r22, r22
    2e58:	77 1f       	adc	r23, r23
    2e5a:	88 1f       	adc	r24, r24
    2e5c:	99 1f       	adc	r25, r25
    2e5e:	fa 95       	dec	r31
    2e60:	d1 f7       	brne	.-12     	; 0x2e56 <uartSetBaudRate+0x16>
    2e62:	e4 e0       	ldi	r30, 0x04	; 4
    2e64:	22 0f       	add	r18, r18
    2e66:	33 1f       	adc	r19, r19
    2e68:	44 1f       	adc	r20, r20
    2e6a:	55 1f       	adc	r21, r21
    2e6c:	ea 95       	dec	r30
    2e6e:	d1 f7       	brne	.-12     	; 0x2e64 <uartSetBaudRate+0x24>
    2e70:	0e 94 24 24 	call	0x4848	; 0x4848 <__udivmodsi4>
    2e74:	21 50       	subi	r18, 0x01	; 1
    2e76:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    2e78:	13 30       	cpi	r17, 0x03	; 3
    2e7a:	29 f4       	brne	.+10     	; 0x2e86 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    2e7c:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    2e80:	30 93 35 01 	sts	0x0135, r19
    2e84:	12 c0       	rjmp	.+36     	; 0x2eaa <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    2e86:	12 30       	cpi	r17, 0x02	; 2
    2e88:	29 f4       	brne	.+10     	; 0x2e94 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    2e8a:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    2e8e:	30 93 d5 00 	sts	0x00D5, r19
    2e92:	0b c0       	rjmp	.+22     	; 0x2eaa <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    2e94:	11 30       	cpi	r17, 0x01	; 1
    2e96:	29 f4       	brne	.+10     	; 0x2ea2 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    2e98:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    2e9c:	30 93 cd 00 	sts	0x00CD, r19
    2ea0:	04 c0       	rjmp	.+8      	; 0x2eaa <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    2ea2:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    2ea6:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    2eaa:	1f 91       	pop	r17
    2eac:	08 95       	ret

00002eae <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    2eae:	28 2f       	mov	r18, r24
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	a3 e0       	ldi	r26, 0x03	; 3
    2eb4:	22 0f       	add	r18, r18
    2eb6:	33 1f       	adc	r19, r19
    2eb8:	aa 95       	dec	r26
    2eba:	e1 f7       	brne	.-8      	; 0x2eb4 <uartGetRxBuffer+0x6>
    2ebc:	26 56       	subi	r18, 0x66	; 102
    2ebe:	30 4e       	sbci	r19, 0xE0	; 224
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    2ec0:	c9 01       	movw	r24, r18
    2ec2:	08 95       	ret

00002ec4 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    2ec4:	28 2f       	mov	r18, r24
    2ec6:	30 e0       	ldi	r19, 0x00	; 0
    2ec8:	b3 e0       	ldi	r27, 0x03	; 3
    2eca:	22 0f       	add	r18, r18
    2ecc:	33 1f       	adc	r19, r19
    2ece:	ba 95       	dec	r27
    2ed0:	e1 f7       	brne	.-8      	; 0x2eca <uartGetTxBuffer+0x6>
    2ed2:	22 54       	subi	r18, 0x42	; 66
    2ed4:	30 4e       	sbci	r19, 0xE0	; 224
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    2ed6:	c9 01       	movw	r24, r18
    2ed8:	08 95       	ret

00002eda <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    2eda:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    2edc:	83 30       	cpi	r24, 0x03	; 3
    2ede:	39 f4       	brne	.+14     	; 0x2eee <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    2ee0:	80 91 30 01 	lds	r24, 0x0130
    2ee4:	85 ff       	sbrs	r24, 5
    2ee6:	fc cf       	rjmp	.-8      	; 0x2ee0 <uartSendByte+0x6>
		outb(UDR3, txData);
    2ee8:	60 93 36 01 	sts	0x0136, r22
    2eec:	18 c0       	rjmp	.+48     	; 0x2f1e <uartSendByte+0x44>
	}
	else if(nUart==2)
    2eee:	82 30       	cpi	r24, 0x02	; 2
    2ef0:	39 f4       	brne	.+14     	; 0x2f00 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    2ef2:	80 91 d0 00 	lds	r24, 0x00D0
    2ef6:	85 ff       	sbrs	r24, 5
    2ef8:	fc cf       	rjmp	.-8      	; 0x2ef2 <uartSendByte+0x18>
		outb(UDR2, txData);
    2efa:	60 93 d6 00 	sts	0x00D6, r22
    2efe:	0f c0       	rjmp	.+30     	; 0x2f1e <uartSendByte+0x44>
	}
	else if(nUart==1)
    2f00:	81 30       	cpi	r24, 0x01	; 1
    2f02:	39 f4       	brne	.+14     	; 0x2f12 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    2f04:	80 91 c8 00 	lds	r24, 0x00C8
    2f08:	85 ff       	sbrs	r24, 5
    2f0a:	fc cf       	rjmp	.-8      	; 0x2f04 <uartSendByte+0x2a>
		outb(UDR1, txData);
    2f0c:	60 93 ce 00 	sts	0x00CE, r22
    2f10:	06 c0       	rjmp	.+12     	; 0x2f1e <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    2f12:	80 91 c0 00 	lds	r24, 0x00C0
    2f16:	85 ff       	sbrs	r24, 5
    2f18:	fc cf       	rjmp	.-8      	; 0x2f12 <uartSendByte+0x38>
		outb(UDR0, txData);
    2f1a:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    2f1e:	f0 e0       	ldi	r31, 0x00	; 0
    2f20:	ea 56       	subi	r30, 0x6A	; 106
    2f22:	f0 4e       	sbci	r31, 0xE0	; 224
    2f24:	10 82       	st	Z, r1
}
    2f26:	08 95       	ret

00002f28 <uart0SendByte>:

void uart0SendByte(u08 data)
{
    2f28:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    2f2a:	80 e0       	ldi	r24, 0x00	; 0
    2f2c:	0e 94 6d 17 	call	0x2eda	; 0x2eda <uartSendByte>
}
    2f30:	08 95       	ret

00002f32 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    2f32:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	0e 94 6d 17 	call	0x2eda	; 0x2eda <uartSendByte>
}
    2f3a:	08 95       	ret

00002f3c <uart2SendByte>:

void uart2SendByte(u08 data)
{
    2f3c:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    2f3e:	82 e0       	ldi	r24, 0x02	; 2
    2f40:	0e 94 6d 17 	call	0x2eda	; 0x2eda <uartSendByte>
}
    2f44:	08 95       	ret

00002f46 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    2f46:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    2f48:	83 e0       	ldi	r24, 0x03	; 3
    2f4a:	0e 94 6d 17 	call	0x2eda	; 0x2eda <uartSendByte>
}
    2f4e:	08 95       	ret

00002f50 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    2f50:	20 e0       	ldi	r18, 0x00	; 0
    2f52:	e8 2f       	mov	r30, r24
    2f54:	f0 e0       	ldi	r31, 0x00	; 0
    2f56:	83 e0       	ldi	r24, 0x03	; 3
    2f58:	ee 0f       	add	r30, r30
    2f5a:	ff 1f       	adc	r31, r31
    2f5c:	8a 95       	dec	r24
    2f5e:	e1 f7       	brne	.-8      	; 0x2f58 <uartReceiveBufferIsEmpty+0x8>
    2f60:	e2 56       	subi	r30, 0x62	; 98
    2f62:	f0 4e       	sbci	r31, 0xE0	; 224
    2f64:	80 81       	ld	r24, Z
    2f66:	91 81       	ldd	r25, Z+1	; 0x01
    2f68:	89 2b       	or	r24, r25
    2f6a:	09 f4       	brne	.+2      	; 0x2f6e <uartReceiveBufferIsEmpty+0x1e>
    2f6c:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    2f6e:	82 2f       	mov	r24, r18
    2f70:	08 95       	ret

00002f72 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    2f72:	cf 93       	push	r28
    2f74:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    2f76:	83 30       	cpi	r24, 0x03	; 3
    2f78:	19 f4       	brne	.+6      	; 0x2f80 <uartReceiveService+0xe>
		c = inb(UDR3);
    2f7a:	60 91 36 01 	lds	r22, 0x0136
    2f7e:	0c c0       	rjmp	.+24     	; 0x2f98 <uartReceiveService+0x26>
	else if(nUart==2)
    2f80:	82 30       	cpi	r24, 0x02	; 2
    2f82:	19 f4       	brne	.+6      	; 0x2f8a <uartReceiveService+0x18>
		c = inb(UDR2);
    2f84:	60 91 d6 00 	lds	r22, 0x00D6
    2f88:	07 c0       	rjmp	.+14     	; 0x2f98 <uartReceiveService+0x26>
	else if(nUart==1)
    2f8a:	81 30       	cpi	r24, 0x01	; 1
    2f8c:	19 f4       	brne	.+6      	; 0x2f94 <uartReceiveService+0x22>
		c = inb(UDR1);
    2f8e:	60 91 ce 00 	lds	r22, 0x00CE
    2f92:	02 c0       	rjmp	.+4      	; 0x2f98 <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    2f94:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    2f98:	28 2f       	mov	r18, r24
    2f9a:	30 e0       	ldi	r19, 0x00	; 0
    2f9c:	e9 01       	movw	r28, r18
    2f9e:	cc 0f       	add	r28, r28
    2fa0:	dd 1f       	adc	r29, r29
    2fa2:	fe 01       	movw	r30, r28
    2fa4:	e8 58       	subi	r30, 0x88	; 136
    2fa6:	fe 4e       	sbci	r31, 0xEE	; 238
    2fa8:	80 81       	ld	r24, Z
    2faa:	91 81       	ldd	r25, Z+1	; 0x01
    2fac:	89 2b       	or	r24, r25
    2fae:	31 f0       	breq	.+12     	; 0x2fbc <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    2fb0:	01 90       	ld	r0, Z+
    2fb2:	f0 81       	ld	r31, Z
    2fb4:	e0 2d       	mov	r30, r0
    2fb6:	86 2f       	mov	r24, r22
    2fb8:	09 95       	icall
    2fba:	14 c0       	rjmp	.+40     	; 0x2fe4 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    2fbc:	93 e0       	ldi	r25, 0x03	; 3
    2fbe:	22 0f       	add	r18, r18
    2fc0:	33 1f       	adc	r19, r19
    2fc2:	9a 95       	dec	r25
    2fc4:	e1 f7       	brne	.-8      	; 0x2fbe <uartReceiveService+0x4c>
    2fc6:	c9 01       	movw	r24, r18
    2fc8:	86 56       	subi	r24, 0x66	; 102
    2fca:	90 4e       	sbci	r25, 0xE0	; 224
    2fcc:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
    2fd0:	88 23       	and	r24, r24
    2fd2:	41 f4       	brne	.+16     	; 0x2fe4 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    2fd4:	fe 01       	movw	r30, r28
    2fd6:	e2 52       	subi	r30, 0x22	; 34
    2fd8:	f0 4e       	sbci	r31, 0xE0	; 224
    2fda:	80 81       	ld	r24, Z
    2fdc:	91 81       	ldd	r25, Z+1	; 0x01
    2fde:	01 96       	adiw	r24, 0x01	; 1
    2fe0:	91 83       	std	Z+1, r25	; 0x01
    2fe2:	80 83       	st	Z, r24
		}
	}
}
    2fe4:	df 91       	pop	r29
    2fe6:	cf 91       	pop	r28
    2fe8:	08 95       	ret

00002fea <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    2fea:	1f 92       	push	r1
    2fec:	0f 92       	push	r0
    2fee:	0f b6       	in	r0, 0x3f	; 63
    2ff0:	0f 92       	push	r0
    2ff2:	11 24       	eor	r1, r1
    2ff4:	2f 93       	push	r18
    2ff6:	3f 93       	push	r19
    2ff8:	4f 93       	push	r20
    2ffa:	5f 93       	push	r21
    2ffc:	6f 93       	push	r22
    2ffe:	7f 93       	push	r23
    3000:	8f 93       	push	r24
    3002:	9f 93       	push	r25
    3004:	af 93       	push	r26
    3006:	bf 93       	push	r27
    3008:	ef 93       	push	r30
    300a:	ff 93       	push	r31
	uartReceiveService(3);
    300c:	83 e0       	ldi	r24, 0x03	; 3
    300e:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <uartReceiveService>
}
    3012:	ff 91       	pop	r31
    3014:	ef 91       	pop	r30
    3016:	bf 91       	pop	r27
    3018:	af 91       	pop	r26
    301a:	9f 91       	pop	r25
    301c:	8f 91       	pop	r24
    301e:	7f 91       	pop	r23
    3020:	6f 91       	pop	r22
    3022:	5f 91       	pop	r21
    3024:	4f 91       	pop	r20
    3026:	3f 91       	pop	r19
    3028:	2f 91       	pop	r18
    302a:	0f 90       	pop	r0
    302c:	0f be       	out	0x3f, r0	; 63
    302e:	0f 90       	pop	r0
    3030:	1f 90       	pop	r1
    3032:	18 95       	reti

00003034 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    3034:	1f 92       	push	r1
    3036:	0f 92       	push	r0
    3038:	0f b6       	in	r0, 0x3f	; 63
    303a:	0f 92       	push	r0
    303c:	11 24       	eor	r1, r1
    303e:	2f 93       	push	r18
    3040:	3f 93       	push	r19
    3042:	4f 93       	push	r20
    3044:	5f 93       	push	r21
    3046:	6f 93       	push	r22
    3048:	7f 93       	push	r23
    304a:	8f 93       	push	r24
    304c:	9f 93       	push	r25
    304e:	af 93       	push	r26
    3050:	bf 93       	push	r27
    3052:	ef 93       	push	r30
    3054:	ff 93       	push	r31
	uartReceiveService(2);
    3056:	82 e0       	ldi	r24, 0x02	; 2
    3058:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <uartReceiveService>
}
    305c:	ff 91       	pop	r31
    305e:	ef 91       	pop	r30
    3060:	bf 91       	pop	r27
    3062:	af 91       	pop	r26
    3064:	9f 91       	pop	r25
    3066:	8f 91       	pop	r24
    3068:	7f 91       	pop	r23
    306a:	6f 91       	pop	r22
    306c:	5f 91       	pop	r21
    306e:	4f 91       	pop	r20
    3070:	3f 91       	pop	r19
    3072:	2f 91       	pop	r18
    3074:	0f 90       	pop	r0
    3076:	0f be       	out	0x3f, r0	; 63
    3078:	0f 90       	pop	r0
    307a:	1f 90       	pop	r1
    307c:	18 95       	reti

0000307e <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    307e:	1f 92       	push	r1
    3080:	0f 92       	push	r0
    3082:	0f b6       	in	r0, 0x3f	; 63
    3084:	0f 92       	push	r0
    3086:	11 24       	eor	r1, r1
    3088:	2f 93       	push	r18
    308a:	3f 93       	push	r19
    308c:	4f 93       	push	r20
    308e:	5f 93       	push	r21
    3090:	6f 93       	push	r22
    3092:	7f 93       	push	r23
    3094:	8f 93       	push	r24
    3096:	9f 93       	push	r25
    3098:	af 93       	push	r26
    309a:	bf 93       	push	r27
    309c:	ef 93       	push	r30
    309e:	ff 93       	push	r31
	uartReceiveService(1);
    30a0:	81 e0       	ldi	r24, 0x01	; 1
    30a2:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <uartReceiveService>
}
    30a6:	ff 91       	pop	r31
    30a8:	ef 91       	pop	r30
    30aa:	bf 91       	pop	r27
    30ac:	af 91       	pop	r26
    30ae:	9f 91       	pop	r25
    30b0:	8f 91       	pop	r24
    30b2:	7f 91       	pop	r23
    30b4:	6f 91       	pop	r22
    30b6:	5f 91       	pop	r21
    30b8:	4f 91       	pop	r20
    30ba:	3f 91       	pop	r19
    30bc:	2f 91       	pop	r18
    30be:	0f 90       	pop	r0
    30c0:	0f be       	out	0x3f, r0	; 63
    30c2:	0f 90       	pop	r0
    30c4:	1f 90       	pop	r1
    30c6:	18 95       	reti

000030c8 <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    30c8:	1f 92       	push	r1
    30ca:	0f 92       	push	r0
    30cc:	0f b6       	in	r0, 0x3f	; 63
    30ce:	0f 92       	push	r0
    30d0:	11 24       	eor	r1, r1
    30d2:	2f 93       	push	r18
    30d4:	3f 93       	push	r19
    30d6:	4f 93       	push	r20
    30d8:	5f 93       	push	r21
    30da:	6f 93       	push	r22
    30dc:	7f 93       	push	r23
    30de:	8f 93       	push	r24
    30e0:	9f 93       	push	r25
    30e2:	af 93       	push	r26
    30e4:	bf 93       	push	r27
    30e6:	ef 93       	push	r30
    30e8:	ff 93       	push	r31
	uartReceiveService(0);
    30ea:	80 e0       	ldi	r24, 0x00	; 0
    30ec:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <uartReceiveService>
}
    30f0:	ff 91       	pop	r31
    30f2:	ef 91       	pop	r30
    30f4:	bf 91       	pop	r27
    30f6:	af 91       	pop	r26
    30f8:	9f 91       	pop	r25
    30fa:	8f 91       	pop	r24
    30fc:	7f 91       	pop	r23
    30fe:	6f 91       	pop	r22
    3100:	5f 91       	pop	r21
    3102:	4f 91       	pop	r20
    3104:	3f 91       	pop	r19
    3106:	2f 91       	pop	r18
    3108:	0f 90       	pop	r0
    310a:	0f be       	out	0x3f, r0	; 63
    310c:	0f 90       	pop	r0
    310e:	1f 90       	pop	r1
    3110:	18 95       	reti

00003112 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    3112:	8f 92       	push	r8
    3114:	9f 92       	push	r9
    3116:	af 92       	push	r10
    3118:	bf 92       	push	r11
    311a:	cf 92       	push	r12
    311c:	df 92       	push	r13
    311e:	ef 92       	push	r14
    3120:	ff 92       	push	r15
    3122:	0f 93       	push	r16
    3124:	1f 93       	push	r17
    3126:	cf 93       	push	r28
    3128:	df 93       	push	r29
    312a:	88 2e       	mov	r8, r24
    312c:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    312e:	c8 2e       	mov	r12, r24
    3130:	dd 24       	eor	r13, r13
    3132:	f6 01       	movw	r30, r12
    3134:	13 e0       	ldi	r17, 0x03	; 3
    3136:	ee 0f       	add	r30, r30
    3138:	ff 1f       	adc	r31, r31
    313a:	1a 95       	dec	r17
    313c:	e1 f7       	brne	.-8      	; 0x3136 <uartSendBuffer+0x24>
    313e:	ee 53       	subi	r30, 0x3E	; 62
    3140:	f0 4e       	sbci	r31, 0xE0	; 224
    3142:	20 81       	ld	r18, Z
    3144:	31 81       	ldd	r19, Z+1	; 0x01
    3146:	24 0f       	add	r18, r20
    3148:	35 1f       	adc	r19, r21
    314a:	f6 01       	movw	r30, r12
    314c:	73 e0       	ldi	r23, 0x03	; 3
    314e:	ee 0f       	add	r30, r30
    3150:	ff 1f       	adc	r31, r31
    3152:	7a 95       	dec	r23
    3154:	e1 f7       	brne	.-8      	; 0x314e <uartSendBuffer+0x3c>
    3156:	e0 54       	subi	r30, 0x40	; 64
    3158:	f0 4e       	sbci	r31, 0xE0	; 224
    315a:	80 81       	ld	r24, Z
    315c:	91 81       	ldd	r25, Z+1	; 0x01
    315e:	28 17       	cp	r18, r24
    3160:	39 07       	cpc	r19, r25
    3162:	70 f5       	brcc	.+92     	; 0x31c0 <uartSendBuffer+0xae>
    3164:	41 15       	cp	r20, r1
    3166:	51 05       	cpc	r21, r1
    3168:	59 f1       	breq	.+86     	; 0x31c0 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    316a:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    316c:	76 01       	movw	r14, r12
    316e:	63 e0       	ldi	r22, 0x03	; 3
    3170:	ee 0c       	add	r14, r14
    3172:	ff 1c       	adc	r15, r15
    3174:	6a 95       	dec	r22
    3176:	e1 f7       	brne	.-8      	; 0x3170 <uartSendBuffer+0x5e>
    3178:	8e eb       	ldi	r24, 0xBE	; 190
    317a:	9f e1       	ldi	r25, 0x1F	; 31
    317c:	e8 0e       	add	r14, r24
    317e:	f9 1e       	adc	r15, r25
    3180:	8d 01       	movw	r16, r26
    3182:	c0 e0       	ldi	r28, 0x00	; 0
    3184:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    3186:	5a 01       	movw	r10, r20
    3188:	08 94       	sec
    318a:	a1 08       	sbc	r10, r1
    318c:	b1 08       	sbc	r11, r1
    318e:	06 c0       	rjmp	.+12     	; 0x319c <uartSendBuffer+0x8a>
    3190:	c7 01       	movw	r24, r14
    3192:	f8 01       	movw	r30, r16
    3194:	60 81       	ld	r22, Z
    3196:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
    319a:	21 96       	adiw	r28, 0x01	; 1
    319c:	0f 5f       	subi	r16, 0xFF	; 255
    319e:	1f 4f       	sbci	r17, 0xFF	; 255
    31a0:	ca 15       	cp	r28, r10
    31a2:	db 05       	cpc	r29, r11
    31a4:	a8 f3       	brcs	.-22     	; 0x3190 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    31a6:	8a eb       	ldi	r24, 0xBA	; 186
    31a8:	9f e1       	ldi	r25, 0x1F	; 31
    31aa:	c8 0e       	add	r12, r24
    31ac:	d9 1e       	adc	r13, r25
    31ae:	8f ef       	ldi	r24, 0xFF	; 255
    31b0:	f6 01       	movw	r30, r12
    31b2:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    31b4:	88 2d       	mov	r24, r8
    31b6:	69 2d       	mov	r22, r9
    31b8:	0e 94 6d 17 	call	0x2eda	; 0x2eda <uartSendByte>
    31bc:	8f ef       	ldi	r24, 0xFF	; 255
    31be:	01 c0       	rjmp	.+2      	; 0x31c2 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    31c0:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    31c2:	df 91       	pop	r29
    31c4:	cf 91       	pop	r28
    31c6:	1f 91       	pop	r17
    31c8:	0f 91       	pop	r16
    31ca:	ff 90       	pop	r15
    31cc:	ef 90       	pop	r14
    31ce:	df 90       	pop	r13
    31d0:	cf 90       	pop	r12
    31d2:	bf 90       	pop	r11
    31d4:	af 90       	pop	r10
    31d6:	9f 90       	pop	r9
    31d8:	8f 90       	pop	r8
    31da:	08 95       	ret

000031dc <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    31dc:	90 e0       	ldi	r25, 0x00	; 0
    31de:	23 e0       	ldi	r18, 0x03	; 3
    31e0:	88 0f       	add	r24, r24
    31e2:	99 1f       	adc	r25, r25
    31e4:	2a 95       	dec	r18
    31e6:	e1 f7       	brne	.-8      	; 0x31e0 <uartAddToTxBuffer+0x4>
    31e8:	82 54       	subi	r24, 0x42	; 66
    31ea:	90 4e       	sbci	r25, 0xE0	; 224
    31ec:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
}
    31f0:	08 95       	ret

000031f2 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    31f2:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    31f4:	86 ed       	ldi	r24, 0xD6	; 214
    31f6:	9f e1       	ldi	r25, 0x1F	; 31
    31f8:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    31fc:	08 95       	ret

000031fe <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    31fe:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3200:	8e ec       	ldi	r24, 0xCE	; 206
    3202:	9f e1       	ldi	r25, 0x1F	; 31
    3204:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    3208:	08 95       	ret

0000320a <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    320a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    320c:	86 ec       	ldi	r24, 0xC6	; 198
    320e:	9f e1       	ldi	r25, 0x1F	; 31
    3210:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    3214:	08 95       	ret

00003216 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    3216:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3218:	8e eb       	ldi	r24, 0xBE	; 190
    321a:	9f e1       	ldi	r25, 0x1F	; 31
    321c:	0e 94 c5 1b 	call	0x378a	; 0x378a <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    3220:	08 95       	ret

00003222 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    3222:	cf 93       	push	r28
    3224:	df 93       	push	r29
    3226:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    3228:	a8 2f       	mov	r26, r24
    322a:	b0 e0       	ldi	r27, 0x00	; 0
    322c:	ed 01       	movw	r28, r26
    322e:	c6 54       	subi	r28, 0x46	; 70
    3230:	d0 4e       	sbci	r29, 0xE0	; 224
    3232:	88 81       	ld	r24, Y
    3234:	88 23       	and	r24, r24
    3236:	79 f1       	breq	.+94     	; 0x3296 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    3238:	fd 01       	movw	r30, r26
    323a:	33 e0       	ldi	r19, 0x03	; 3
    323c:	ee 0f       	add	r30, r30
    323e:	ff 1f       	adc	r31, r31
    3240:	3a 95       	dec	r19
    3242:	e1 f7       	brne	.-8      	; 0x323c <uartTransmitService+0x1a>
    3244:	ee 53       	subi	r30, 0x3E	; 62
    3246:	f0 4e       	sbci	r31, 0xE0	; 224
    3248:	80 81       	ld	r24, Z
    324a:	91 81       	ldd	r25, Z+1	; 0x01
    324c:	89 2b       	or	r24, r25
    324e:	11 f1       	breq	.+68     	; 0x3294 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    3250:	23 30       	cpi	r18, 0x03	; 3
    3252:	39 f4       	brne	.+14     	; 0x3262 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    3254:	86 ed       	ldi	r24, 0xD6	; 214
    3256:	9f e1       	ldi	r25, 0x1F	; 31
    3258:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <bufferGetFromFront>
    325c:	80 93 36 01 	sts	0x0136, r24
    3260:	1e c0       	rjmp	.+60     	; 0x329e <uartTransmitService+0x7c>
			else if(nUart==2)
    3262:	22 30       	cpi	r18, 0x02	; 2
    3264:	39 f4       	brne	.+14     	; 0x3274 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    3266:	8e ec       	ldi	r24, 0xCE	; 206
    3268:	9f e1       	ldi	r25, 0x1F	; 31
    326a:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <bufferGetFromFront>
    326e:	80 93 d6 00 	sts	0x00D6, r24
    3272:	15 c0       	rjmp	.+42     	; 0x329e <uartTransmitService+0x7c>
			else if(nUart==1)
    3274:	21 30       	cpi	r18, 0x01	; 1
    3276:	39 f4       	brne	.+14     	; 0x3286 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    3278:	86 ec       	ldi	r24, 0xC6	; 198
    327a:	9f e1       	ldi	r25, 0x1F	; 31
    327c:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <bufferGetFromFront>
    3280:	80 93 ce 00 	sts	0x00CE, r24
    3284:	0c c0       	rjmp	.+24     	; 0x329e <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    3286:	8e eb       	ldi	r24, 0xBE	; 190
    3288:	9f e1       	ldi	r25, 0x1F	; 31
    328a:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <bufferGetFromFront>
    328e:	80 93 c6 00 	sts	0x00C6, r24
    3292:	05 c0       	rjmp	.+10     	; 0x329e <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    3294:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    3296:	aa 56       	subi	r26, 0x6A	; 106
    3298:	b0 4e       	sbci	r27, 0xE0	; 224
    329a:	8f ef       	ldi	r24, 0xFF	; 255
    329c:	8c 93       	st	X, r24
	}
}
    329e:	df 91       	pop	r29
    32a0:	cf 91       	pop	r28
    32a2:	08 95       	ret

000032a4 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    32a4:	1f 92       	push	r1
    32a6:	0f 92       	push	r0
    32a8:	0f b6       	in	r0, 0x3f	; 63
    32aa:	0f 92       	push	r0
    32ac:	11 24       	eor	r1, r1
    32ae:	2f 93       	push	r18
    32b0:	3f 93       	push	r19
    32b2:	4f 93       	push	r20
    32b4:	5f 93       	push	r21
    32b6:	6f 93       	push	r22
    32b8:	7f 93       	push	r23
    32ba:	8f 93       	push	r24
    32bc:	9f 93       	push	r25
    32be:	af 93       	push	r26
    32c0:	bf 93       	push	r27
    32c2:	ef 93       	push	r30
    32c4:	ff 93       	push	r31
	uartTransmitService(3);
    32c6:	83 e0       	ldi	r24, 0x03	; 3
    32c8:	0e 94 11 19 	call	0x3222	; 0x3222 <uartTransmitService>
}
    32cc:	ff 91       	pop	r31
    32ce:	ef 91       	pop	r30
    32d0:	bf 91       	pop	r27
    32d2:	af 91       	pop	r26
    32d4:	9f 91       	pop	r25
    32d6:	8f 91       	pop	r24
    32d8:	7f 91       	pop	r23
    32da:	6f 91       	pop	r22
    32dc:	5f 91       	pop	r21
    32de:	4f 91       	pop	r20
    32e0:	3f 91       	pop	r19
    32e2:	2f 91       	pop	r18
    32e4:	0f 90       	pop	r0
    32e6:	0f be       	out	0x3f, r0	; 63
    32e8:	0f 90       	pop	r0
    32ea:	1f 90       	pop	r1
    32ec:	18 95       	reti

000032ee <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    32ee:	1f 92       	push	r1
    32f0:	0f 92       	push	r0
    32f2:	0f b6       	in	r0, 0x3f	; 63
    32f4:	0f 92       	push	r0
    32f6:	11 24       	eor	r1, r1
    32f8:	2f 93       	push	r18
    32fa:	3f 93       	push	r19
    32fc:	4f 93       	push	r20
    32fe:	5f 93       	push	r21
    3300:	6f 93       	push	r22
    3302:	7f 93       	push	r23
    3304:	8f 93       	push	r24
    3306:	9f 93       	push	r25
    3308:	af 93       	push	r26
    330a:	bf 93       	push	r27
    330c:	ef 93       	push	r30
    330e:	ff 93       	push	r31
	uartTransmitService(2);
    3310:	82 e0       	ldi	r24, 0x02	; 2
    3312:	0e 94 11 19 	call	0x3222	; 0x3222 <uartTransmitService>
}
    3316:	ff 91       	pop	r31
    3318:	ef 91       	pop	r30
    331a:	bf 91       	pop	r27
    331c:	af 91       	pop	r26
    331e:	9f 91       	pop	r25
    3320:	8f 91       	pop	r24
    3322:	7f 91       	pop	r23
    3324:	6f 91       	pop	r22
    3326:	5f 91       	pop	r21
    3328:	4f 91       	pop	r20
    332a:	3f 91       	pop	r19
    332c:	2f 91       	pop	r18
    332e:	0f 90       	pop	r0
    3330:	0f be       	out	0x3f, r0	; 63
    3332:	0f 90       	pop	r0
    3334:	1f 90       	pop	r1
    3336:	18 95       	reti

00003338 <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    3338:	1f 92       	push	r1
    333a:	0f 92       	push	r0
    333c:	0f b6       	in	r0, 0x3f	; 63
    333e:	0f 92       	push	r0
    3340:	11 24       	eor	r1, r1
    3342:	2f 93       	push	r18
    3344:	3f 93       	push	r19
    3346:	4f 93       	push	r20
    3348:	5f 93       	push	r21
    334a:	6f 93       	push	r22
    334c:	7f 93       	push	r23
    334e:	8f 93       	push	r24
    3350:	9f 93       	push	r25
    3352:	af 93       	push	r26
    3354:	bf 93       	push	r27
    3356:	ef 93       	push	r30
    3358:	ff 93       	push	r31
	uartTransmitService(1);
    335a:	81 e0       	ldi	r24, 0x01	; 1
    335c:	0e 94 11 19 	call	0x3222	; 0x3222 <uartTransmitService>
}
    3360:	ff 91       	pop	r31
    3362:	ef 91       	pop	r30
    3364:	bf 91       	pop	r27
    3366:	af 91       	pop	r26
    3368:	9f 91       	pop	r25
    336a:	8f 91       	pop	r24
    336c:	7f 91       	pop	r23
    336e:	6f 91       	pop	r22
    3370:	5f 91       	pop	r21
    3372:	4f 91       	pop	r20
    3374:	3f 91       	pop	r19
    3376:	2f 91       	pop	r18
    3378:	0f 90       	pop	r0
    337a:	0f be       	out	0x3f, r0	; 63
    337c:	0f 90       	pop	r0
    337e:	1f 90       	pop	r1
    3380:	18 95       	reti

00003382 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    3382:	1f 92       	push	r1
    3384:	0f 92       	push	r0
    3386:	0f b6       	in	r0, 0x3f	; 63
    3388:	0f 92       	push	r0
    338a:	11 24       	eor	r1, r1
    338c:	2f 93       	push	r18
    338e:	3f 93       	push	r19
    3390:	4f 93       	push	r20
    3392:	5f 93       	push	r21
    3394:	6f 93       	push	r22
    3396:	7f 93       	push	r23
    3398:	8f 93       	push	r24
    339a:	9f 93       	push	r25
    339c:	af 93       	push	r26
    339e:	bf 93       	push	r27
    33a0:	ef 93       	push	r30
    33a2:	ff 93       	push	r31
	uartTransmitService(0);
    33a4:	80 e0       	ldi	r24, 0x00	; 0
    33a6:	0e 94 11 19 	call	0x3222	; 0x3222 <uartTransmitService>
}
    33aa:	ff 91       	pop	r31
    33ac:	ef 91       	pop	r30
    33ae:	bf 91       	pop	r27
    33b0:	af 91       	pop	r26
    33b2:	9f 91       	pop	r25
    33b4:	8f 91       	pop	r24
    33b6:	7f 91       	pop	r23
    33b8:	6f 91       	pop	r22
    33ba:	5f 91       	pop	r21
    33bc:	4f 91       	pop	r20
    33be:	3f 91       	pop	r19
    33c0:	2f 91       	pop	r18
    33c2:	0f 90       	pop	r0
    33c4:	0f be       	out	0x3f, r0	; 63
    33c6:	0f 90       	pop	r0
    33c8:	1f 90       	pop	r1
    33ca:	18 95       	reti

000033cc <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    33cc:	1f 93       	push	r17
    33ce:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    33d0:	90 e0       	ldi	r25, 0x00	; 0
    33d2:	fc 01       	movw	r30, r24
    33d4:	e6 54       	subi	r30, 0x46	; 70
    33d6:	f0 4e       	sbci	r31, 0xE0	; 224
    33d8:	2f ef       	ldi	r18, 0xFF	; 255
    33da:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    33dc:	43 e0       	ldi	r20, 0x03	; 3
    33de:	88 0f       	add	r24, r24
    33e0:	99 1f       	adc	r25, r25
    33e2:	4a 95       	dec	r20
    33e4:	e1 f7       	brne	.-8      	; 0x33de <uartSendTxBuffer+0x12>
    33e6:	82 54       	subi	r24, 0x42	; 66
    33e8:	90 4e       	sbci	r25, 0xE0	; 224
    33ea:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <bufferGetFromFront>
    33ee:	68 2f       	mov	r22, r24
    33f0:	81 2f       	mov	r24, r17
    33f2:	0e 94 6d 17 	call	0x2eda	; 0x2eda <uartSendByte>
}
    33f6:	1f 91       	pop	r17
    33f8:	08 95       	ret

000033fa <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    33fa:	cf 93       	push	r28
    33fc:	df 93       	push	r29
    33fe:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    3400:	28 2f       	mov	r18, r24
    3402:	30 e0       	ldi	r19, 0x00	; 0
    3404:	f9 01       	movw	r30, r18
    3406:	73 e0       	ldi	r23, 0x03	; 3
    3408:	ee 0f       	add	r30, r30
    340a:	ff 1f       	adc	r31, r31
    340c:	7a 95       	dec	r23
    340e:	e1 f7       	brne	.-8      	; 0x3408 <uartReceiveByte+0xe>
    3410:	e4 56       	subi	r30, 0x64	; 100
    3412:	f0 4e       	sbci	r31, 0xE0	; 224
    3414:	80 81       	ld	r24, Z
    3416:	91 81       	ldd	r25, Z+1	; 0x01
    3418:	89 2b       	or	r24, r25
    341a:	c9 f0       	breq	.+50     	; 0x344e <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    341c:	f9 01       	movw	r30, r18
    341e:	63 e0       	ldi	r22, 0x03	; 3
    3420:	ee 0f       	add	r30, r30
    3422:	ff 1f       	adc	r31, r31
    3424:	6a 95       	dec	r22
    3426:	e1 f7       	brne	.-8      	; 0x3420 <uartReceiveByte+0x26>
    3428:	e2 56       	subi	r30, 0x62	; 98
    342a:	f0 4e       	sbci	r31, 0xE0	; 224
    342c:	80 81       	ld	r24, Z
    342e:	91 81       	ldd	r25, Z+1	; 0x01
    3430:	89 2b       	or	r24, r25
    3432:	69 f0       	breq	.+26     	; 0x344e <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    3434:	53 e0       	ldi	r21, 0x03	; 3
    3436:	22 0f       	add	r18, r18
    3438:	33 1f       	adc	r19, r19
    343a:	5a 95       	dec	r21
    343c:	e1 f7       	brne	.-8      	; 0x3436 <uartReceiveByte+0x3c>
    343e:	c9 01       	movw	r24, r18
    3440:	86 56       	subi	r24, 0x66	; 102
    3442:	90 4e       	sbci	r25, 0xE0	; 224
    3444:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <bufferGetFromFront>
    3448:	88 83       	st	Y, r24
    344a:	8f ef       	ldi	r24, 0xFF	; 255
    344c:	01 c0       	rjmp	.+2      	; 0x3450 <uartReceiveByte+0x56>
			return TRUE;
    344e:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    3450:	df 91       	pop	r29
    3452:	cf 91       	pop	r28
    3454:	08 95       	ret

00003456 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    3456:	df 93       	push	r29
    3458:	cf 93       	push	r28
    345a:	0f 92       	push	r0
    345c:	cd b7       	in	r28, 0x3d	; 61
    345e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    3460:	83 e0       	ldi	r24, 0x03	; 3
    3462:	be 01       	movw	r22, r28
    3464:	6f 5f       	subi	r22, 0xFF	; 255
    3466:	7f 4f       	sbci	r23, 0xFF	; 255
    3468:	0e 94 fd 19 	call	0x33fa	; 0x33fa <uartReceiveByte>
    346c:	88 23       	and	r24, r24
    346e:	19 f4       	brne	.+6      	; 0x3476 <uart3GetByte+0x20>
    3470:	2f ef       	ldi	r18, 0xFF	; 255
    3472:	3f ef       	ldi	r19, 0xFF	; 255
    3474:	03 c0       	rjmp	.+6      	; 0x347c <uart3GetByte+0x26>
		return c;
    3476:	89 81       	ldd	r24, Y+1	; 0x01
    3478:	28 2f       	mov	r18, r24
    347a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    347c:	c9 01       	movw	r24, r18
    347e:	0f 90       	pop	r0
    3480:	cf 91       	pop	r28
    3482:	df 91       	pop	r29
    3484:	08 95       	ret

00003486 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    3486:	df 93       	push	r29
    3488:	cf 93       	push	r28
    348a:	0f 92       	push	r0
    348c:	cd b7       	in	r28, 0x3d	; 61
    348e:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    3490:	82 e0       	ldi	r24, 0x02	; 2
    3492:	be 01       	movw	r22, r28
    3494:	6f 5f       	subi	r22, 0xFF	; 255
    3496:	7f 4f       	sbci	r23, 0xFF	; 255
    3498:	0e 94 fd 19 	call	0x33fa	; 0x33fa <uartReceiveByte>
    349c:	88 23       	and	r24, r24
    349e:	19 f4       	brne	.+6      	; 0x34a6 <uart2GetByte+0x20>
    34a0:	2f ef       	ldi	r18, 0xFF	; 255
    34a2:	3f ef       	ldi	r19, 0xFF	; 255
    34a4:	03 c0       	rjmp	.+6      	; 0x34ac <uart2GetByte+0x26>
		return c;
    34a6:	89 81       	ldd	r24, Y+1	; 0x01
    34a8:	28 2f       	mov	r18, r24
    34aa:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    34ac:	c9 01       	movw	r24, r18
    34ae:	0f 90       	pop	r0
    34b0:	cf 91       	pop	r28
    34b2:	df 91       	pop	r29
    34b4:	08 95       	ret

000034b6 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    34b6:	df 93       	push	r29
    34b8:	cf 93       	push	r28
    34ba:	0f 92       	push	r0
    34bc:	cd b7       	in	r28, 0x3d	; 61
    34be:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    34c0:	81 e0       	ldi	r24, 0x01	; 1
    34c2:	be 01       	movw	r22, r28
    34c4:	6f 5f       	subi	r22, 0xFF	; 255
    34c6:	7f 4f       	sbci	r23, 0xFF	; 255
    34c8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <uartReceiveByte>
    34cc:	88 23       	and	r24, r24
    34ce:	19 f4       	brne	.+6      	; 0x34d6 <uart1GetByte+0x20>
    34d0:	2f ef       	ldi	r18, 0xFF	; 255
    34d2:	3f ef       	ldi	r19, 0xFF	; 255
    34d4:	03 c0       	rjmp	.+6      	; 0x34dc <uart1GetByte+0x26>
		return c;
    34d6:	89 81       	ldd	r24, Y+1	; 0x01
    34d8:	28 2f       	mov	r18, r24
    34da:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    34dc:	c9 01       	movw	r24, r18
    34de:	0f 90       	pop	r0
    34e0:	cf 91       	pop	r28
    34e2:	df 91       	pop	r29
    34e4:	08 95       	ret

000034e6 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    34e6:	df 93       	push	r29
    34e8:	cf 93       	push	r28
    34ea:	0f 92       	push	r0
    34ec:	cd b7       	in	r28, 0x3d	; 61
    34ee:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    34f0:	80 e0       	ldi	r24, 0x00	; 0
    34f2:	be 01       	movw	r22, r28
    34f4:	6f 5f       	subi	r22, 0xFF	; 255
    34f6:	7f 4f       	sbci	r23, 0xFF	; 255
    34f8:	0e 94 fd 19 	call	0x33fa	; 0x33fa <uartReceiveByte>
    34fc:	88 23       	and	r24, r24
    34fe:	19 f4       	brne	.+6      	; 0x3506 <uart0GetByte+0x20>
    3500:	2f ef       	ldi	r18, 0xFF	; 255
    3502:	3f ef       	ldi	r19, 0xFF	; 255
    3504:	03 c0       	rjmp	.+6      	; 0x350c <uart0GetByte+0x26>
		return c;
    3506:	89 81       	ldd	r24, Y+1	; 0x01
    3508:	28 2f       	mov	r18, r24
    350a:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    350c:	c9 01       	movw	r24, r18
    350e:	0f 90       	pop	r0
    3510:	cf 91       	pop	r28
    3512:	df 91       	pop	r29
    3514:	08 95       	ret

00003516 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    3516:	90 e0       	ldi	r25, 0x00	; 0
    3518:	e3 e0       	ldi	r30, 0x03	; 3
    351a:	88 0f       	add	r24, r24
    351c:	99 1f       	adc	r25, r25
    351e:	ea 95       	dec	r30
    3520:	e1 f7       	brne	.-8      	; 0x351a <uartFlushReceiveBuffer+0x4>
    3522:	86 56       	subi	r24, 0x66	; 102
    3524:	90 4e       	sbci	r25, 0xE0	; 224
    3526:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <bufferFlush>
}
    352a:	08 95       	ret

0000352c <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    352c:	82 eb       	ldi	r24, 0xB2	; 178
    352e:	9f e1       	ldi	r25, 0x1F	; 31
    3530:	68 ee       	ldi	r22, 0xE8	; 232
    3532:	70 e1       	ldi	r23, 0x10	; 16
    3534:	40 e8       	ldi	r20, 0x80	; 128
    3536:	50 e0       	ldi	r21, 0x00	; 0
    3538:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    353c:	86 ed       	ldi	r24, 0xD6	; 214
    353e:	9f e1       	ldi	r25, 0x1F	; 31
    3540:	68 e6       	ldi	r22, 0x68	; 104
    3542:	71 e1       	ldi	r23, 0x11	; 17
    3544:	40 e1       	ldi	r20, 0x10	; 16
    3546:	50 e0       	ldi	r21, 0x00	; 0
    3548:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    354c:	08 95       	ret

0000354e <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    354e:	0e 94 96 1a 	call	0x352c	; 0x352c <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    3552:	10 92 7f 11 	sts	0x117F, r1
    3556:	10 92 7e 11 	sts	0x117E, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    355a:	88 ed       	ldi	r24, 0xD8	; 216
    355c:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    3560:	83 e0       	ldi	r24, 0x03	; 3
    3562:	40 e8       	ldi	r20, 0x80	; 128
    3564:	55 e2       	ldi	r21, 0x25	; 37
    3566:	60 e0       	ldi	r22, 0x00	; 0
    3568:	70 e0       	ldi	r23, 0x00	; 0
    356a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    356e:	8f ef       	ldi	r24, 0xFF	; 255
    3570:	80 93 99 1f 	sts	0x1F99, r24
	uartBufferedTx[3] = FALSE;
    3574:	10 92 bd 1f 	sts	0x1FBD, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    3578:	10 92 e5 1f 	sts	0x1FE5, r1
    357c:	10 92 e4 1f 	sts	0x1FE4, r1
	// enable interrupts
	sei();
    3580:	78 94       	sei
}
    3582:	08 95       	ret

00003584 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    3584:	8a ea       	ldi	r24, 0xAA	; 170
    3586:	9f e1       	ldi	r25, 0x1F	; 31
    3588:	68 e5       	ldi	r22, 0x58	; 88
    358a:	70 e1       	ldi	r23, 0x10	; 16
    358c:	40 e8       	ldi	r20, 0x80	; 128
    358e:	50 e0       	ldi	r21, 0x00	; 0
    3590:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    3594:	8e ec       	ldi	r24, 0xCE	; 206
    3596:	9f e1       	ldi	r25, 0x1F	; 31
    3598:	68 ed       	ldi	r22, 0xD8	; 216
    359a:	70 e1       	ldi	r23, 0x10	; 16
    359c:	40 e1       	ldi	r20, 0x10	; 16
    359e:	50 e0       	ldi	r21, 0x00	; 0
    35a0:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    35a4:	08 95       	ret

000035a6 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    35a6:	0e 94 c2 1a 	call	0x3584	; 0x3584 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    35aa:	10 92 7d 11 	sts	0x117D, r1
    35ae:	10 92 7c 11 	sts	0x117C, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    35b2:	88 ed       	ldi	r24, 0xD8	; 216
    35b4:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    35b8:	82 e0       	ldi	r24, 0x02	; 2
    35ba:	40 e8       	ldi	r20, 0x80	; 128
    35bc:	55 e2       	ldi	r21, 0x25	; 37
    35be:	60 e0       	ldi	r22, 0x00	; 0
    35c0:	70 e0       	ldi	r23, 0x00	; 0
    35c2:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    35c6:	8f ef       	ldi	r24, 0xFF	; 255
    35c8:	80 93 98 1f 	sts	0x1F98, r24
	uartBufferedTx[2] = FALSE;
    35cc:	10 92 bc 1f 	sts	0x1FBC, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    35d0:	10 92 e3 1f 	sts	0x1FE3, r1
    35d4:	10 92 e2 1f 	sts	0x1FE2, r1
	// enable interrupts
	sei();
    35d8:	78 94       	sei
}
    35da:	08 95       	ret

000035dc <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    35dc:	82 ea       	ldi	r24, 0xA2	; 162
    35de:	9f e1       	ldi	r25, 0x1F	; 31
    35e0:	68 ec       	ldi	r22, 0xC8	; 200
    35e2:	7f e0       	ldi	r23, 0x0F	; 15
    35e4:	40 e8       	ldi	r20, 0x80	; 128
    35e6:	50 e0       	ldi	r21, 0x00	; 0
    35e8:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    35ec:	86 ec       	ldi	r24, 0xC6	; 198
    35ee:	9f e1       	ldi	r25, 0x1F	; 31
    35f0:	68 e4       	ldi	r22, 0x48	; 72
    35f2:	70 e1       	ldi	r23, 0x10	; 16
    35f4:	40 e1       	ldi	r20, 0x10	; 16
    35f6:	50 e0       	ldi	r21, 0x00	; 0
    35f8:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    35fc:	08 95       	ret

000035fe <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    35fe:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    3602:	10 92 7b 11 	sts	0x117B, r1
    3606:	10 92 7a 11 	sts	0x117A, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    360a:	88 ed       	ldi	r24, 0xD8	; 216
    360c:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    3610:	81 e0       	ldi	r24, 0x01	; 1
    3612:	40 e8       	ldi	r20, 0x80	; 128
    3614:	55 e2       	ldi	r21, 0x25	; 37
    3616:	60 e0       	ldi	r22, 0x00	; 0
    3618:	70 e0       	ldi	r23, 0x00	; 0
    361a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    361e:	8f ef       	ldi	r24, 0xFF	; 255
    3620:	80 93 97 1f 	sts	0x1F97, r24
	uartBufferedTx[1] = FALSE;
    3624:	10 92 bb 1f 	sts	0x1FBB, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    3628:	10 92 e1 1f 	sts	0x1FE1, r1
    362c:	10 92 e0 1f 	sts	0x1FE0, r1
	// enable interrupts
	sei();
    3630:	78 94       	sei
}
    3632:	08 95       	ret

00003634 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    3634:	8a e9       	ldi	r24, 0x9A	; 154
    3636:	9f e1       	ldi	r25, 0x1F	; 31
    3638:	68 e3       	ldi	r22, 0x38	; 56
    363a:	7f e0       	ldi	r23, 0x0F	; 15
    363c:	40 e8       	ldi	r20, 0x80	; 128
    363e:	50 e0       	ldi	r21, 0x00	; 0
    3640:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    3644:	8e eb       	ldi	r24, 0xBE	; 190
    3646:	9f e1       	ldi	r25, 0x1F	; 31
    3648:	68 eb       	ldi	r22, 0xB8	; 184
    364a:	7f e0       	ldi	r23, 0x0F	; 15
    364c:	40 e1       	ldi	r20, 0x10	; 16
    364e:	50 e0       	ldi	r21, 0x00	; 0
    3650:	0e 94 4f 1b 	call	0x369e	; 0x369e <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    3654:	08 95       	ret

00003656 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    3656:	0e 94 1a 1b 	call	0x3634	; 0x3634 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    365a:	10 92 79 11 	sts	0x1179, r1
    365e:	10 92 78 11 	sts	0x1178, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3662:	88 ed       	ldi	r24, 0xD8	; 216
    3664:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    3668:	80 e0       	ldi	r24, 0x00	; 0
    366a:	40 e8       	ldi	r20, 0x80	; 128
    366c:	55 e2       	ldi	r21, 0x25	; 37
    366e:	60 e0       	ldi	r22, 0x00	; 0
    3670:	70 e0       	ldi	r23, 0x00	; 0
    3672:	0e 94 20 17 	call	0x2e40	; 0x2e40 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    3676:	8f ef       	ldi	r24, 0xFF	; 255
    3678:	80 93 96 1f 	sts	0x1F96, r24
	uartBufferedTx[0] = FALSE;
    367c:	10 92 ba 1f 	sts	0x1FBA, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    3680:	10 92 df 1f 	sts	0x1FDF, r1
    3684:	10 92 de 1f 	sts	0x1FDE, r1
	// enable interrupts
	sei();
    3688:	78 94       	sei
}
    368a:	08 95       	ret

0000368c <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    368c:	0e 94 2b 1b 	call	0x3656	; 0x3656 <uart0Init>
	uart1Init();
    3690:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <uart1Init>
	uart2Init();
    3694:	0e 94 d3 1a 	call	0x35a6	; 0x35a6 <uart2Init>
	uart3Init();
    3698:	0e 94 a7 1a 	call	0x354e	; 0x354e <uart3Init>
}
    369c:	08 95       	ret

0000369e <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    369e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    36a0:	8f b7       	in	r24, 0x3f	; 63
    36a2:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    36a4:	71 83       	std	Z+1, r23	; 0x01
    36a6:	60 83       	st	Z, r22
	buffer->size = size;
    36a8:	53 83       	std	Z+3, r21	; 0x03
    36aa:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    36ac:	17 82       	std	Z+7, r1	; 0x07
    36ae:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    36b0:	15 82       	std	Z+5, r1	; 0x05
    36b2:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    36b4:	8f bf       	out	0x3f, r24	; 63
}
    36b6:	08 95       	ret

000036b8 <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    36b8:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    36ba:	4f b7       	in	r20, 0x3f	; 63
    36bc:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    36be:	14 96       	adiw	r26, 0x04	; 4
    36c0:	8d 91       	ld	r24, X+
    36c2:	9c 91       	ld	r25, X
    36c4:	15 97       	sbiw	r26, 0x05	; 5
    36c6:	89 2b       	or	r24, r25
    36c8:	11 f4       	brne	.+4      	; 0x36ce <bufferGetFromFront+0x16>
    36ca:	e0 e0       	ldi	r30, 0x00	; 0
    36cc:	25 c0       	rjmp	.+74     	; 0x3718 <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    36ce:	16 96       	adiw	r26, 0x06	; 6
    36d0:	8d 91       	ld	r24, X+
    36d2:	9c 91       	ld	r25, X
    36d4:	17 97       	sbiw	r26, 0x07	; 7
    36d6:	ed 91       	ld	r30, X+
    36d8:	fc 91       	ld	r31, X
    36da:	11 97       	sbiw	r26, 0x01	; 1
    36dc:	e8 0f       	add	r30, r24
    36de:	f9 1f       	adc	r31, r25
    36e0:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    36e2:	01 96       	adiw	r24, 0x01	; 1
    36e4:	17 96       	adiw	r26, 0x07	; 7
    36e6:	9c 93       	st	X, r25
    36e8:	8e 93       	st	-X, r24
    36ea:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    36ec:	12 96       	adiw	r26, 0x02	; 2
    36ee:	2d 91       	ld	r18, X+
    36f0:	3c 91       	ld	r19, X
    36f2:	13 97       	sbiw	r26, 0x03	; 3
    36f4:	82 17       	cp	r24, r18
    36f6:	93 07       	cpc	r25, r19
    36f8:	30 f0       	brcs	.+12     	; 0x3706 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    36fa:	82 1b       	sub	r24, r18
    36fc:	93 0b       	sbc	r25, r19
    36fe:	17 96       	adiw	r26, 0x07	; 7
    3700:	9c 93       	st	X, r25
    3702:	8e 93       	st	-X, r24
    3704:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    3706:	14 96       	adiw	r26, 0x04	; 4
    3708:	8d 91       	ld	r24, X+
    370a:	9c 91       	ld	r25, X
    370c:	15 97       	sbiw	r26, 0x05	; 5
    370e:	01 97       	sbiw	r24, 0x01	; 1
    3710:	15 96       	adiw	r26, 0x05	; 5
    3712:	9c 93       	st	X, r25
    3714:	8e 93       	st	-X, r24
    3716:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    3718:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    371a:	8e 2f       	mov	r24, r30
    371c:	08 95       	ret

0000371e <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    371e:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3720:	4f b7       	in	r20, 0x3f	; 63
    3722:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    3724:	84 81       	ldd	r24, Z+4	; 0x04
    3726:	95 81       	ldd	r25, Z+5	; 0x05
    3728:	68 17       	cp	r22, r24
    372a:	79 07       	cpc	r23, r25
    372c:	b0 f4       	brcc	.+44     	; 0x375a <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    372e:	86 81       	ldd	r24, Z+6	; 0x06
    3730:	97 81       	ldd	r25, Z+7	; 0x07
    3732:	86 0f       	add	r24, r22
    3734:	97 1f       	adc	r25, r23
    3736:	97 83       	std	Z+7, r25	; 0x07
    3738:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    373a:	22 81       	ldd	r18, Z+2	; 0x02
    373c:	33 81       	ldd	r19, Z+3	; 0x03
    373e:	82 17       	cp	r24, r18
    3740:	93 07       	cpc	r25, r19
    3742:	20 f0       	brcs	.+8      	; 0x374c <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    3744:	82 1b       	sub	r24, r18
    3746:	93 0b       	sbc	r25, r19
    3748:	97 83       	std	Z+7, r25	; 0x07
    374a:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    374c:	84 81       	ldd	r24, Z+4	; 0x04
    374e:	95 81       	ldd	r25, Z+5	; 0x05
    3750:	86 1b       	sub	r24, r22
    3752:	97 0b       	sbc	r25, r23
    3754:	95 83       	std	Z+5, r25	; 0x05
    3756:	84 83       	std	Z+4, r24	; 0x04
    3758:	02 c0       	rjmp	.+4      	; 0x375e <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    375a:	15 82       	std	Z+5, r1	; 0x05
    375c:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    375e:	4f bf       	out	0x3f, r20	; 63
}
    3760:	08 95       	ret

00003762 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    3762:	fc 01       	movw	r30, r24
    3764:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    3766:	2f b7       	in	r18, 0x3f	; 63
    3768:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    376a:	2f bf       	out	0x3f, r18	; 63
    376c:	26 81       	ldd	r18, Z+6	; 0x06
    376e:	37 81       	ldd	r19, Z+7	; 0x07
    3770:	62 81       	ldd	r22, Z+2	; 0x02
    3772:	73 81       	ldd	r23, Z+3	; 0x03
    3774:	82 0f       	add	r24, r18
    3776:	93 1f       	adc	r25, r19
    3778:	0e 94 fd 23 	call	0x47fa	; 0x47fa <__udivmodhi4>
    377c:	01 90       	ld	r0, Z+
    377e:	f0 81       	ld	r31, Z
    3780:	e0 2d       	mov	r30, r0
    3782:	e8 0f       	add	r30, r24
    3784:	f9 1f       	adc	r31, r25
	return data;
}
    3786:	80 81       	ld	r24, Z
    3788:	08 95       	ret

0000378a <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    378a:	1f 93       	push	r17
    378c:	cf 93       	push	r28
    378e:	df 93       	push	r29
    3790:	ec 01       	movw	r28, r24
    3792:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    3794:	4f b7       	in	r20, 0x3f	; 63
    3796:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    3798:	2c 81       	ldd	r18, Y+4	; 0x04
    379a:	3d 81       	ldd	r19, Y+5	; 0x05
    379c:	6a 81       	ldd	r22, Y+2	; 0x02
    379e:	7b 81       	ldd	r23, Y+3	; 0x03
    37a0:	26 17       	cp	r18, r22
    37a2:	37 07       	cpc	r19, r23
    37a4:	98 f4       	brcc	.+38     	; 0x37cc <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    37a6:	8e 81       	ldd	r24, Y+6	; 0x06
    37a8:	9f 81       	ldd	r25, Y+7	; 0x07
    37aa:	82 0f       	add	r24, r18
    37ac:	93 1f       	adc	r25, r19
    37ae:	0e 94 fd 23 	call	0x47fa	; 0x47fa <__udivmodhi4>
    37b2:	e8 81       	ld	r30, Y
    37b4:	f9 81       	ldd	r31, Y+1	; 0x01
    37b6:	e8 0f       	add	r30, r24
    37b8:	f9 1f       	adc	r31, r25
    37ba:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    37bc:	8c 81       	ldd	r24, Y+4	; 0x04
    37be:	9d 81       	ldd	r25, Y+5	; 0x05
    37c0:	01 96       	adiw	r24, 0x01	; 1
    37c2:	9d 83       	std	Y+5, r25	; 0x05
    37c4:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    37c6:	4f bf       	out	0x3f, r20	; 63
    37c8:	8f ef       	ldi	r24, 0xFF	; 255
    37ca:	02 c0       	rjmp	.+4      	; 0x37d0 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    37cc:	4f bf       	out	0x3f, r20	; 63
    37ce:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    37d0:	df 91       	pop	r29
    37d2:	cf 91       	pop	r28
    37d4:	1f 91       	pop	r17
    37d6:	08 95       	ret

000037d8 <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    37d8:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    37da:	8f b7       	in	r24, 0x3f	; 63
    37dc:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    37de:	8f bf       	out	0x3f, r24	; 63
    37e0:	22 81       	ldd	r18, Z+2	; 0x02
    37e2:	33 81       	ldd	r19, Z+3	; 0x03
    37e4:	84 81       	ldd	r24, Z+4	; 0x04
    37e6:	95 81       	ldd	r25, Z+5	; 0x05
    37e8:	28 1b       	sub	r18, r24
    37ea:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    37ec:	c9 01       	movw	r24, r18
    37ee:	08 95       	ret

000037f0 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    37f0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    37f2:	8f b7       	in	r24, 0x3f	; 63
    37f4:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    37f6:	15 82       	std	Z+5, r1	; 0x05
    37f8:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    37fa:	8f bf       	out	0x3f, r24	; 63
}
    37fc:	08 95       	ret

000037fe <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    37fe:	aa e7       	ldi	r26, 0x7A	; 122
    3800:	b0 e0       	ldi	r27, 0x00	; 0
    3802:	8c 91       	ld	r24, X
    3804:	80 68       	ori	r24, 0x80	; 128
    3806:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    3808:	8c 91       	ld	r24, X
    380a:	8f 7d       	andi	r24, 0xDF	; 223
    380c:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    380e:	8c 91       	ld	r24, X
    3810:	88 7f       	andi	r24, 0xF8	; 248
    3812:	86 60       	ori	r24, 0x06	; 6
    3814:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    3816:	ec e7       	ldi	r30, 0x7C	; 124
    3818:	f0 e0       	ldi	r31, 0x00	; 0
    381a:	80 81       	ld	r24, Z
    381c:	8f 73       	andi	r24, 0x3F	; 63
    381e:	80 64       	ori	r24, 0x40	; 64
    3820:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    3822:	80 81       	ld	r24, Z
    3824:	8f 7d       	andi	r24, 0xDF	; 223
    3826:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    3828:	8c 91       	ld	r24, X
    382a:	88 60       	ori	r24, 0x08	; 8
    382c:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    382e:	10 92 e6 1f 	sts	0x1FE6, r1
	sei();							// turn on interrupts (if not already on)
    3832:	78 94       	sei
}
    3834:	08 95       	ret

00003836 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    3836:	ea e7       	ldi	r30, 0x7A	; 122
    3838:	f0 e0       	ldi	r31, 0x00	; 0
    383a:	80 81       	ld	r24, Z
    383c:	87 7f       	andi	r24, 0xF7	; 247
    383e:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    3840:	80 81       	ld	r24, Z
    3842:	8f 77       	andi	r24, 0x7F	; 127
    3844:	80 83       	st	Z, r24
}
    3846:	08 95       	ret

00003848 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    3848:	ea e7       	ldi	r30, 0x7A	; 122
    384a:	f0 e0       	ldi	r31, 0x00	; 0
    384c:	90 81       	ld	r25, Z
    384e:	98 7f       	andi	r25, 0xF8	; 248
    3850:	98 2b       	or	r25, r24
    3852:	90 83       	st	Z, r25
}
    3854:	08 95       	ret

00003856 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    3856:	ec e7       	ldi	r30, 0x7C	; 124
    3858:	f0 e0       	ldi	r31, 0x00	; 0
    385a:	90 81       	ld	r25, Z
    385c:	82 95       	swap	r24
    385e:	88 0f       	add	r24, r24
    3860:	88 0f       	add	r24, r24
    3862:	80 7c       	andi	r24, 0xC0	; 192
    3864:	9f 73       	andi	r25, 0x3F	; 63
    3866:	98 2b       	or	r25, r24
    3868:	90 83       	st	Z, r25
}
    386a:	08 95       	ret

0000386c <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    386c:	ec e7       	ldi	r30, 0x7C	; 124
    386e:	f0 e0       	ldi	r31, 0x00	; 0
    3870:	90 81       	ld	r25, Z
    3872:	8f 71       	andi	r24, 0x1F	; 31
    3874:	90 7e       	andi	r25, 0xE0	; 224
    3876:	89 2b       	or	r24, r25
    3878:	80 83       	st	Z, r24
}
    387a:	08 95       	ret

0000387c <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    387c:	ea e7       	ldi	r30, 0x7A	; 122
    387e:	f0 e0       	ldi	r31, 0x00	; 0
    3880:	80 81       	ld	r24, Z
    3882:	80 61       	ori	r24, 0x10	; 16
    3884:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    3886:	80 81       	ld	r24, Z
    3888:	80 64       	ori	r24, 0x40	; 64
    388a:	80 83       	st	Z, r24
}
    388c:	08 95       	ret

0000388e <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    388e:	80 91 7a 00 	lds	r24, 0x007A
}
    3892:	80 74       	andi	r24, 0x40	; 64
    3894:	08 95       	ret

00003896 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    3896:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    3898:	10 92 e6 1f 	sts	0x1FE6, r1

if (ch >= 8)
    389c:	88 30       	cpi	r24, 0x08	; 8
    389e:	20 f0       	brcs	.+8      	; 0x38a8 <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    38a0:	80 91 7b 00 	lds	r24, 0x007B
    38a4:	88 60       	ori	r24, 0x08	; 8
    38a6:	03 c0       	rjmp	.+6      	; 0x38ae <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    38a8:	80 91 7b 00 	lds	r24, 0x007B
    38ac:	87 7f       	andi	r24, 0xF7	; 247
    38ae:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    38b2:	80 91 7c 00 	lds	r24, 0x007C
    38b6:	97 70       	andi	r25, 0x07	; 7
    38b8:	88 7f       	andi	r24, 0xF8	; 248
    38ba:	89 2b       	or	r24, r25
    38bc:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    38c0:	80 91 7a 00 	lds	r24, 0x007A
    38c4:	80 61       	ori	r24, 0x10	; 16
    38c6:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    38ca:	80 91 7a 00 	lds	r24, 0x007A
    38ce:	80 64       	ori	r24, 0x40	; 64
    38d0:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    38d4:	80 91 7a 00 	lds	r24, 0x007A
    38d8:	86 fd       	sbrc	r24, 6
    38da:	fc cf       	rjmp	.-8      	; 0x38d4 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    38dc:	20 91 78 00 	lds	r18, 0x0078
    38e0:	30 91 79 00 	lds	r19, 0x0079
}
    38e4:	c9 01       	movw	r24, r18
    38e6:	08 95       	ret

000038e8 <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    38e8:	0e 94 4b 1c 	call	0x3896	; 0x3896 <a2dConvert10bit>
    38ec:	96 95       	lsr	r25
    38ee:	87 95       	ror	r24
    38f0:	96 95       	lsr	r25
    38f2:	87 95       	ror	r24
}
    38f4:	08 95       	ret

000038f6 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    38f6:	1f 92       	push	r1
    38f8:	0f 92       	push	r0
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	0f 92       	push	r0
    38fe:	11 24       	eor	r1, r1
    3900:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    3902:	8f ef       	ldi	r24, 0xFF	; 255
    3904:	80 93 e6 1f 	sts	0x1FE6, r24
}
    3908:	8f 91       	pop	r24
    390a:	0f 90       	pop	r0
    390c:	0f be       	out	0x3f, r0	; 63
    390e:	0f 90       	pop	r0
    3910:	1f 90       	pop	r1
    3912:	18 95       	reti

00003914 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    3914:	90 93 81 11 	sts	0x1181, r25
    3918:	80 93 80 11 	sts	0x1180, r24
}
    391c:	08 95       	ret

0000391e <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    391e:	1f 93       	push	r17
    3920:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    3922:	8a 30       	cpi	r24, 0x0A	; 10
    3924:	31 f4       	brne	.+12     	; 0x3932 <rprintfChar+0x14>
		rputchar('\r');
    3926:	e0 91 80 11 	lds	r30, 0x1180
    392a:	f0 91 81 11 	lds	r31, 0x1181
    392e:	8d e0       	ldi	r24, 0x0D	; 13
    3930:	09 95       	icall
	// send character
	rputchar(c);
    3932:	e0 91 80 11 	lds	r30, 0x1180
    3936:	f0 91 81 11 	lds	r31, 0x1181
    393a:	81 2f       	mov	r24, r17
    393c:	09 95       	icall
}
    393e:	1f 91       	pop	r17
    3940:	08 95       	ret

00003942 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    3942:	cf 93       	push	r28
    3944:	df 93       	push	r29
    3946:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    3948:	00 97       	sbiw	r24, 0x00	; 0
    394a:	21 f4       	brne	.+8      	; 0x3954 <rprintfStr+0x12>
    394c:	06 c0       	rjmp	.+12     	; 0x395a <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    394e:	21 96       	adiw	r28, 0x01	; 1
    3950:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    3954:	88 81       	ld	r24, Y
    3956:	88 23       	and	r24, r24
    3958:	d1 f7       	brne	.-12     	; 0x394e <rprintfStr+0xc>
		rprintfChar(*str++);
}
    395a:	df 91       	pop	r29
    395c:	cf 91       	pop	r28
    395e:	08 95       	ret

00003960 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    3960:	ef 92       	push	r14
    3962:	ff 92       	push	r15
    3964:	0f 93       	push	r16
    3966:	1f 93       	push	r17
    3968:	cf 93       	push	r28
    396a:	df 93       	push	r29
    396c:	8c 01       	movw	r16, r24
    396e:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    3970:	00 97       	sbiw	r24, 0x00	; 0
    3972:	e9 f0       	breq	.+58     	; 0x39ae <rprintfStrLen+0x4e>
    3974:	20 e0       	ldi	r18, 0x00	; 0
    3976:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    3978:	26 17       	cp	r18, r22
    397a:	37 07       	cpc	r19, r23
    397c:	38 f4       	brcc	.+14     	; 0x398c <rprintfStrLen+0x2c>
    397e:	f8 01       	movw	r30, r16
    3980:	81 91       	ld	r24, Z+
    3982:	8f 01       	movw	r16, r30
    3984:	2f 5f       	subi	r18, 0xFF	; 255
    3986:	3f 4f       	sbci	r19, 0xFF	; 255
    3988:	88 23       	and	r24, r24
    398a:	b1 f7       	brne	.-20     	; 0x3978 <rprintfStrLen+0x18>
    398c:	c0 e0       	ldi	r28, 0x00	; 0
    398e:	d0 e0       	ldi	r29, 0x00	; 0
    3990:	0b c0       	rjmp	.+22     	; 0x39a8 <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    3992:	f8 01       	movw	r30, r16
    3994:	80 81       	ld	r24, Z
    3996:	88 23       	and	r24, r24
    3998:	19 f0       	breq	.+6      	; 0x39a0 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    399a:	0f 5f       	subi	r16, 0xFF	; 255
    399c:	1f 4f       	sbci	r17, 0xFF	; 255
    399e:	01 c0       	rjmp	.+2      	; 0x39a2 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    39a0:	80 e2       	ldi	r24, 0x20	; 32
    39a2:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    39a6:	21 96       	adiw	r28, 0x01	; 1
    39a8:	ce 15       	cp	r28, r14
    39aa:	df 05       	cpc	r29, r15
    39ac:	90 f3       	brcs	.-28     	; 0x3992 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    39ae:	df 91       	pop	r29
    39b0:	cf 91       	pop	r28
    39b2:	1f 91       	pop	r17
    39b4:	0f 91       	pop	r16
    39b6:	ff 90       	pop	r15
    39b8:	ef 90       	pop	r14
    39ba:	08 95       	ret

000039bc <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    39bc:	cf 93       	push	r28
    39be:	df 93       	push	r29
    39c0:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    39c2:	00 97       	sbiw	r24, 0x00	; 0
    39c4:	19 f4       	brne	.+6      	; 0x39cc <rprintfProgStr+0x10>
    39c6:	07 c0       	rjmp	.+14     	; 0x39d6 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    39c8:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    39cc:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    39ce:	21 96       	adiw	r28, 0x01	; 1
    39d0:	84 91       	lpm	r24, Z+
    39d2:	88 23       	and	r24, r24
    39d4:	c9 f7       	brne	.-14     	; 0x39c8 <rprintfProgStr+0xc>
		rprintfChar(c);
}
    39d6:	df 91       	pop	r29
    39d8:	cf 91       	pop	r28
    39da:	08 95       	ret

000039dc <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    39dc:	8a e0       	ldi	r24, 0x0A	; 10
    39de:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
}
    39e2:	08 95       	ret

000039e4 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    39e4:	e8 2f       	mov	r30, r24
    39e6:	f0 e0       	ldi	r31, 0x00	; 0
    39e8:	ef 70       	andi	r30, 0x0F	; 15
    39ea:	f0 70       	andi	r31, 0x00	; 0
    39ec:	ef 5b       	subi	r30, 0xBF	; 191
    39ee:	fe 4f       	sbci	r31, 0xFE	; 254
    39f0:	e4 91       	lpm	r30, Z+
    39f2:	8e 2f       	mov	r24, r30
    39f4:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
}
    39f8:	08 95       	ret

000039fa <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    39fa:	1f 93       	push	r17
    39fc:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    39fe:	82 95       	swap	r24
    3a00:	8f 70       	andi	r24, 0x0F	; 15
    3a02:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <rprintfu04>
	rprintfu04(data);
    3a06:	81 2f       	mov	r24, r17
    3a08:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <rprintfu04>
}
    3a0c:	1f 91       	pop	r17
    3a0e:	08 95       	ret

00003a10 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    3a10:	1f 93       	push	r17
    3a12:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    3a14:	89 2f       	mov	r24, r25
    3a16:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <rprintfu08>
	rprintfu08(data);
    3a1a:	81 2f       	mov	r24, r17
    3a1c:	0e 94 fd 1c 	call	0x39fa	; 0x39fa <rprintfu08>
}
    3a20:	1f 91       	pop	r17
    3a22:	08 95       	ret

00003a24 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    3a24:	ef 92       	push	r14
    3a26:	ff 92       	push	r15
    3a28:	0f 93       	push	r16
    3a2a:	1f 93       	push	r17
    3a2c:	7b 01       	movw	r14, r22
    3a2e:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    3a30:	c8 01       	movw	r24, r16
    3a32:	aa 27       	eor	r26, r26
    3a34:	bb 27       	eor	r27, r27
    3a36:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <rprintfu16>
	rprintfu16(data);
    3a3a:	c7 01       	movw	r24, r14
    3a3c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <rprintfu16>
}
    3a40:	1f 91       	pop	r17
    3a42:	0f 91       	pop	r16
    3a44:	ff 90       	pop	r15
    3a46:	ef 90       	pop	r14
    3a48:	08 95       	ret

00003a4a <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    3a4a:	2f 92       	push	r2
    3a4c:	3f 92       	push	r3
    3a4e:	4f 92       	push	r4
    3a50:	5f 92       	push	r5
    3a52:	6f 92       	push	r6
    3a54:	7f 92       	push	r7
    3a56:	8f 92       	push	r8
    3a58:	9f 92       	push	r9
    3a5a:	af 92       	push	r10
    3a5c:	bf 92       	push	r11
    3a5e:	cf 92       	push	r12
    3a60:	df 92       	push	r13
    3a62:	ef 92       	push	r14
    3a64:	ff 92       	push	r15
    3a66:	0f 93       	push	r16
    3a68:	1f 93       	push	r17
    3a6a:	df 93       	push	r29
    3a6c:	cf 93       	push	r28
    3a6e:	cd b7       	in	r28, 0x3d	; 61
    3a70:	de b7       	in	r29, 0x3e	; 62
    3a72:	a3 97       	sbiw	r28, 0x23	; 35
    3a74:	0f b6       	in	r0, 0x3f	; 63
    3a76:	f8 94       	cli
    3a78:	de bf       	out	0x3e, r29	; 62
    3a7a:	0f be       	out	0x3f, r0	; 63
    3a7c:	cd bf       	out	0x3d, r28	; 61
    3a7e:	6a a3       	std	Y+34, r22	; 0x22
    3a80:	24 2e       	mov	r2, r20
    3a82:	2b a3       	std	Y+35, r18	; 0x23
    3a84:	37 01       	movw	r6, r14
    3a86:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    3a88:	44 23       	and	r20, r20
    3a8a:	51 f0       	breq	.+20     	; 0x3aa0 <rprintfNum+0x56>
    3a8c:	17 ff       	sbrs	r17, 7
    3a8e:	08 c0       	rjmp	.+16     	; 0x3aa0 <rprintfNum+0x56>
	{
		x = -n;
    3a90:	ee 24       	eor	r14, r14
    3a92:	ff 24       	eor	r15, r15
    3a94:	87 01       	movw	r16, r14
    3a96:	e6 18       	sub	r14, r6
    3a98:	f7 08       	sbc	r15, r7
    3a9a:	08 09       	sbc	r16, r8
    3a9c:	19 09       	sbc	r17, r9
    3a9e:	02 c0       	rjmp	.+4      	; 0x3aa4 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    3aa0:	84 01       	movw	r16, r8
    3aa2:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    3aa4:	2a a1       	ldd	r18, Y+34	; 0x22
    3aa6:	21 50       	subi	r18, 0x01	; 1
    3aa8:	90 e0       	ldi	r25, 0x00	; 0
    3aaa:	21 10       	cpse	r2, r1
    3aac:	91 e0       	ldi	r25, 0x01	; 1
    3aae:	29 1b       	sub	r18, r25
    3ab0:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    3ab2:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    3ab4:	a8 2e       	mov	r10, r24
    3ab6:	bb 24       	eor	r11, r11
    3ab8:	cc 24       	eor	r12, r12
    3aba:	dd 24       	eor	r13, r13
    3abc:	c8 01       	movw	r24, r16
    3abe:	b7 01       	movw	r22, r14
    3ac0:	a6 01       	movw	r20, r12
    3ac2:	95 01       	movw	r18, r10
    3ac4:	0e 94 24 24 	call	0x4848	; 0x4848 <__udivmodsi4>
    3ac8:	fb 01       	movw	r30, r22
    3aca:	ef 70       	andi	r30, 0x0F	; 15
    3acc:	f0 70       	andi	r31, 0x00	; 0
    3ace:	ef 5b       	subi	r30, 0xBF	; 191
    3ad0:	fe 4f       	sbci	r31, 0xFE	; 254
    3ad2:	64 91       	lpm	r22, Z+
    3ad4:	6f 8f       	std	Y+31, r22	; 0x1f
    3ad6:	c8 01       	movw	r24, r16
    3ad8:	b7 01       	movw	r22, r14
    3ada:	a6 01       	movw	r20, r12
    3adc:	95 01       	movw	r18, r10
    3ade:	0e 94 24 24 	call	0x4848	; 0x4848 <__udivmodsi4>
    3ae2:	c9 01       	movw	r24, r18
    3ae4:	da 01       	movw	r26, r20
    3ae6:	7c 01       	movw	r14, r24
    3ae8:	8d 01       	movw	r16, r26
    3aea:	9e e1       	ldi	r25, 0x1E	; 30
    3aec:	49 2e       	mov	r4, r25
    3aee:	51 2c       	mov	r5, r1
    3af0:	4c 0e       	add	r4, r28
    3af2:	5d 1e       	adc	r5, r29
    3af4:	39 a0       	ldd	r3, Y+33	; 0x21
    3af6:	25 c0       	rjmp	.+74     	; 0x3b42 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    3af8:	e1 14       	cp	r14, r1
    3afa:	f1 04       	cpc	r15, r1
    3afc:	01 05       	cpc	r16, r1
    3afe:	11 05       	cpc	r17, r1
    3b00:	c9 f0       	breq	.+50     	; 0x3b34 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    3b02:	c8 01       	movw	r24, r16
    3b04:	b7 01       	movw	r22, r14
    3b06:	a6 01       	movw	r20, r12
    3b08:	95 01       	movw	r18, r10
    3b0a:	0e 94 24 24 	call	0x4848	; 0x4848 <__udivmodsi4>
    3b0e:	fb 01       	movw	r30, r22
    3b10:	ef 70       	andi	r30, 0x0F	; 15
    3b12:	f0 70       	andi	r31, 0x00	; 0
    3b14:	ef 5b       	subi	r30, 0xBF	; 191
    3b16:	fe 4f       	sbci	r31, 0xFE	; 254
    3b18:	64 91       	lpm	r22, Z+
    3b1a:	f2 01       	movw	r30, r4
    3b1c:	60 83       	st	Z, r22
    3b1e:	c8 01       	movw	r24, r16
    3b20:	b7 01       	movw	r22, r14
    3b22:	a6 01       	movw	r20, r12
    3b24:	95 01       	movw	r18, r10
    3b26:	0e 94 24 24 	call	0x4848	; 0x4848 <__udivmodsi4>
    3b2a:	c9 01       	movw	r24, r18
    3b2c:	da 01       	movw	r26, r20
    3b2e:	7c 01       	movw	r14, r24
    3b30:	8d 01       	movw	r16, r26
    3b32:	03 c0       	rjmp	.+6      	; 0x3b3a <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    3b34:	2b a1       	ldd	r18, Y+35	; 0x23
    3b36:	f2 01       	movw	r30, r4
    3b38:	20 83       	st	Z, r18
    3b3a:	3a 94       	dec	r3
    3b3c:	08 94       	sec
    3b3e:	41 08       	sbc	r4, r1
    3b40:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    3b42:	33 20       	and	r3, r3
    3b44:	c9 f6       	brne	.-78     	; 0x3af8 <rprintfNum+0xae>
    3b46:	ce 01       	movw	r24, r28
    3b48:	4f 96       	adiw	r24, 0x1f	; 31
    3b4a:	8c 01       	movw	r16, r24
    3b4c:	e9 a1       	ldd	r30, Y+33	; 0x21
    3b4e:	0e 1b       	sub	r16, r30
    3b50:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    3b52:	22 20       	and	r2, r2
    3b54:	f1 f0       	breq	.+60     	; 0x3b92 <rprintfNum+0x148>
	{
		if(n < 0)
    3b56:	97 fe       	sbrs	r9, 7
    3b58:	05 c0       	rjmp	.+10     	; 0x3b64 <rprintfNum+0x11a>
		{
   			*--p = '-';
    3b5a:	8d e2       	ldi	r24, 0x2D	; 45
    3b5c:	f8 01       	movw	r30, r16
    3b5e:	82 93       	st	-Z, r24
    3b60:	8f 01       	movw	r16, r30
    3b62:	17 c0       	rjmp	.+46     	; 0x3b92 <rprintfNum+0x148>
    3b64:	c8 01       	movw	r24, r16
    3b66:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    3b68:	61 14       	cp	r6, r1
    3b6a:	71 04       	cpc	r7, r1
    3b6c:	81 04       	cpc	r8, r1
    3b6e:	91 04       	cpc	r9, r1
    3b70:	19 f0       	breq	.+6      	; 0x3b78 <rprintfNum+0x12e>
		{
	   		*--p = '+';
    3b72:	8c 01       	movw	r16, r24
    3b74:	8b e2       	ldi	r24, 0x2B	; 43
    3b76:	02 c0       	rjmp	.+4      	; 0x3b7c <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    3b78:	8c 01       	movw	r16, r24
    3b7a:	80 e2       	ldi	r24, 0x20	; 32
    3b7c:	f8 01       	movw	r30, r16
    3b7e:	80 83       	st	Z, r24
    3b80:	08 c0       	rjmp	.+16     	; 0x3b92 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    3b82:	f8 01       	movw	r30, r16
    3b84:	81 91       	ld	r24, Z+
    3b86:	8f 01       	movw	r16, r30
    3b88:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    3b8c:	fa a1       	ldd	r31, Y+34	; 0x22
    3b8e:	f1 50       	subi	r31, 0x01	; 1
    3b90:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    3b92:	2a a1       	ldd	r18, Y+34	; 0x22
    3b94:	22 23       	and	r18, r18
    3b96:	a9 f7       	brne	.-22     	; 0x3b82 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    3b98:	a3 96       	adiw	r28, 0x23	; 35
    3b9a:	0f b6       	in	r0, 0x3f	; 63
    3b9c:	f8 94       	cli
    3b9e:	de bf       	out	0x3e, r29	; 62
    3ba0:	0f be       	out	0x3f, r0	; 63
    3ba2:	cd bf       	out	0x3d, r28	; 61
    3ba4:	cf 91       	pop	r28
    3ba6:	df 91       	pop	r29
    3ba8:	1f 91       	pop	r17
    3baa:	0f 91       	pop	r16
    3bac:	ff 90       	pop	r15
    3bae:	ef 90       	pop	r14
    3bb0:	df 90       	pop	r13
    3bb2:	cf 90       	pop	r12
    3bb4:	bf 90       	pop	r11
    3bb6:	af 90       	pop	r10
    3bb8:	9f 90       	pop	r9
    3bba:	8f 90       	pop	r8
    3bbc:	7f 90       	pop	r7
    3bbe:	6f 90       	pop	r6
    3bc0:	5f 90       	pop	r5
    3bc2:	4f 90       	pop	r4
    3bc4:	3f 90       	pop	r3
    3bc6:	2f 90       	pop	r2
    3bc8:	08 95       	ret

00003bca <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    3bca:	4f 92       	push	r4
    3bcc:	5f 92       	push	r5
    3bce:	6f 92       	push	r6
    3bd0:	7f 92       	push	r7
    3bd2:	8f 92       	push	r8
    3bd4:	9f 92       	push	r9
    3bd6:	af 92       	push	r10
    3bd8:	bf 92       	push	r11
    3bda:	cf 92       	push	r12
    3bdc:	df 92       	push	r13
    3bde:	ef 92       	push	r14
    3be0:	ff 92       	push	r15
    3be2:	0f 93       	push	r16
    3be4:	1f 93       	push	r17
    3be6:	cf 93       	push	r28
    3be8:	df 93       	push	r29
    3bea:	48 2e       	mov	r4, r24
    3bec:	5a 01       	movw	r10, r20
    3bee:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    3bf0:	cb 01       	movw	r24, r22
    3bf2:	ba 01       	movw	r22, r20
    3bf4:	20 e0       	ldi	r18, 0x00	; 0
    3bf6:	30 e0       	ldi	r19, 0x00	; 0
    3bf8:	40 e0       	ldi	r20, 0x00	; 0
    3bfa:	50 e0       	ldi	r21, 0x00	; 0
    3bfc:	0e 94 96 23 	call	0x472c	; 0x472c <__gesf2>
    3c00:	18 16       	cp	r1, r24
    3c02:	1c f4       	brge	.+6      	; 0x3c0a <rprintfFloat+0x40>
    3c04:	35 01       	movw	r6, r10
    3c06:	46 01       	movw	r8, r12
    3c08:	06 c0       	rjmp	.+12     	; 0x3c16 <rprintfFloat+0x4c>
    3c0a:	35 01       	movw	r6, r10
    3c0c:	46 01       	movw	r8, r12
    3c0e:	97 fa       	bst	r9, 7
    3c10:	90 94       	com	r9
    3c12:	97 f8       	bld	r9, 7
    3c14:	90 94       	com	r9
    3c16:	0f 2e       	mov	r0, r31
    3c18:	f0 e0       	ldi	r31, 0x00	; 0
    3c1a:	ef 2e       	mov	r14, r31
    3c1c:	f0 e0       	ldi	r31, 0x00	; 0
    3c1e:	ff 2e       	mov	r15, r31
    3c20:	f0 e8       	ldi	r31, 0x80	; 128
    3c22:	0f 2f       	mov	r16, r31
    3c24:	ff e3       	ldi	r31, 0x3F	; 63
    3c26:	1f 2f       	mov	r17, r31
    3c28:	f0 2d       	mov	r31, r0
    3c2a:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    3c2c:	c4 01       	movw	r24, r8
    3c2e:	b3 01       	movw	r22, r6
    3c30:	a8 01       	movw	r20, r16
    3c32:	97 01       	movw	r18, r14
    3c34:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__divsf3>
    3c38:	20 e0       	ldi	r18, 0x00	; 0
    3c3a:	30 e0       	ldi	r19, 0x00	; 0
    3c3c:	40 e2       	ldi	r20, 0x20	; 32
    3c3e:	51 e4       	ldi	r21, 0x41	; 65
    3c40:	0e 94 4c 22 	call	0x4498	; 0x4498 <__cmpsf2>
    3c44:	87 fd       	sbrc	r24, 7
    3c46:	0e c0       	rjmp	.+28     	; 0x3c64 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    3c48:	c8 01       	movw	r24, r16
    3c4a:	b7 01       	movw	r22, r14
    3c4c:	20 e0       	ldi	r18, 0x00	; 0
    3c4e:	30 e0       	ldi	r19, 0x00	; 0
    3c50:	40 e2       	ldi	r20, 0x20	; 32
    3c52:	51 e4       	ldi	r21, 0x41	; 65
    3c54:	0e 94 9a 23 	call	0x4734	; 0x4734 <__mulsf3>
    3c58:	7b 01       	movw	r14, r22
    3c5a:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    3c5c:	53 94       	inc	r5
    3c5e:	8f e0       	ldi	r24, 0x0F	; 15
    3c60:	58 16       	cp	r5, r24
    3c62:	21 f7       	brne	.-56     	; 0x3c2c <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    3c64:	c6 01       	movw	r24, r12
    3c66:	b5 01       	movw	r22, r10
    3c68:	20 e0       	ldi	r18, 0x00	; 0
    3c6a:	30 e0       	ldi	r19, 0x00	; 0
    3c6c:	40 e0       	ldi	r20, 0x00	; 0
    3c6e:	50 e0       	ldi	r21, 0x00	; 0
    3c70:	0e 94 4c 22 	call	0x4498	; 0x4498 <__cmpsf2>
    3c74:	88 23       	and	r24, r24
    3c76:	14 f4       	brge	.+4      	; 0x3c7c <rprintfFloat+0xb2>
		rprintfChar('-');
    3c78:	8d e2       	ldi	r24, 0x2D	; 45
    3c7a:	01 c0       	rjmp	.+2      	; 0x3c7e <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    3c7c:	8b e2       	ldi	r24, 0x2B	; 43
    3c7e:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    3c82:	dd 24       	eor	r13, r13
    3c84:	aa 24       	eor	r10, r10
    3c86:	56 c0       	rjmp	.+172    	; 0x3d34 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    3c88:	c4 01       	movw	r24, r8
    3c8a:	b3 01       	movw	r22, r6
    3c8c:	a8 01       	movw	r20, r16
    3c8e:	97 01       	movw	r18, r14
    3c90:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__divsf3>
    3c94:	0e 94 b8 22 	call	0x4570	; 0x4570 <__fixunssfsi>
    3c98:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    3c9a:	d6 2a       	or	r13, r22
    3c9c:	cd 2d       	mov	r28, r13
    3c9e:	d0 e0       	ldi	r29, 0x00	; 0
    3ca0:	cc 24       	eor	r12, r12
    3ca2:	dd 24       	eor	r13, r13
    3ca4:	c8 01       	movw	r24, r16
    3ca6:	b7 01       	movw	r22, r14
    3ca8:	20 e0       	ldi	r18, 0x00	; 0
    3caa:	30 e0       	ldi	r19, 0x00	; 0
    3cac:	40 e8       	ldi	r20, 0x80	; 128
    3cae:	5f e3       	ldi	r21, 0x3F	; 63
    3cb0:	0e 94 4c 22 	call	0x4498	; 0x4498 <__cmpsf2>
    3cb4:	88 23       	and	r24, r24
    3cb6:	19 f4       	brne	.+6      	; 0x3cbe <rprintfFloat+0xf4>
    3cb8:	21 e0       	ldi	r18, 0x01	; 1
    3cba:	c2 2e       	mov	r12, r18
    3cbc:	d1 2c       	mov	r13, r1
    3cbe:	cc 29       	or	r28, r12
    3cc0:	dd 29       	or	r29, r13
    3cc2:	cd 2b       	or	r28, r29
    3cc4:	39 f0       	breq	.+14     	; 0x3cd4 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    3cc6:	8b 2d       	mov	r24, r11
    3cc8:	80 5d       	subi	r24, 0xD0	; 208
    3cca:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    3cce:	dd 24       	eor	r13, r13
    3cd0:	da 94       	dec	r13
    3cd2:	04 c0       	rjmp	.+8      	; 0x3cdc <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    3cd4:	80 e2       	ldi	r24, 0x20	; 32
    3cd6:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    3cda:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    3cdc:	c8 01       	movw	r24, r16
    3cde:	b7 01       	movw	r22, r14
    3ce0:	20 e0       	ldi	r18, 0x00	; 0
    3ce2:	30 e0       	ldi	r19, 0x00	; 0
    3ce4:	40 e8       	ldi	r20, 0x80	; 128
    3ce6:	5f e3       	ldi	r21, 0x3F	; 63
    3ce8:	0e 94 4c 22 	call	0x4498	; 0x4498 <__cmpsf2>
    3cec:	88 23       	and	r24, r24
    3cee:	19 f4       	brne	.+6      	; 0x3cf6 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    3cf0:	8e e2       	ldi	r24, 0x2E	; 46
    3cf2:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
		}
		
		x -= (digit*place);
    3cf6:	6b 2d       	mov	r22, r11
    3cf8:	70 e0       	ldi	r23, 0x00	; 0
    3cfa:	88 27       	eor	r24, r24
    3cfc:	77 fd       	sbrc	r23, 7
    3cfe:	80 95       	com	r24
    3d00:	98 2f       	mov	r25, r24
    3d02:	0e 94 e6 22 	call	0x45cc	; 0x45cc <__floatsisf>
    3d06:	a8 01       	movw	r20, r16
    3d08:	97 01       	movw	r18, r14
    3d0a:	0e 94 9a 23 	call	0x4734	; 0x4734 <__mulsf3>
    3d0e:	9b 01       	movw	r18, r22
    3d10:	ac 01       	movw	r20, r24
    3d12:	c4 01       	movw	r24, r8
    3d14:	b3 01       	movw	r22, r6
    3d16:	0e 94 e7 21 	call	0x43ce	; 0x43ce <__subsf3>
    3d1a:	3b 01       	movw	r6, r22
    3d1c:	4c 01       	movw	r8, r24
		place /= 10.0;
    3d1e:	c8 01       	movw	r24, r16
    3d20:	b7 01       	movw	r22, r14
    3d22:	20 e0       	ldi	r18, 0x00	; 0
    3d24:	30 e0       	ldi	r19, 0x00	; 0
    3d26:	40 e2       	ldi	r20, 0x20	; 32
    3d28:	51 e4       	ldi	r21, 0x41	; 65
    3d2a:	0e 94 50 22 	call	0x44a0	; 0x44a0 <__divsf3>
    3d2e:	7b 01       	movw	r14, r22
    3d30:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    3d32:	a3 94       	inc	r10
    3d34:	a4 14       	cp	r10, r4
    3d36:	08 f4       	brcc	.+2      	; 0x3d3a <rprintfFloat+0x170>
    3d38:	a7 cf       	rjmp	.-178    	; 0x3c88 <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    3d3a:	df 91       	pop	r29
    3d3c:	cf 91       	pop	r28
    3d3e:	1f 91       	pop	r17
    3d40:	0f 91       	pop	r16
    3d42:	ff 90       	pop	r15
    3d44:	ef 90       	pop	r14
    3d46:	df 90       	pop	r13
    3d48:	cf 90       	pop	r12
    3d4a:	bf 90       	pop	r11
    3d4c:	af 90       	pop	r10
    3d4e:	9f 90       	pop	r9
    3d50:	8f 90       	pop	r8
    3d52:	7f 90       	pop	r7
    3d54:	6f 90       	pop	r6
    3d56:	5f 90       	pop	r5
    3d58:	4f 90       	pop	r4
    3d5a:	08 95       	ret

00003d5c <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    3d5c:	7f 92       	push	r7
    3d5e:	8f 92       	push	r8
    3d60:	9f 92       	push	r9
    3d62:	af 92       	push	r10
    3d64:	bf 92       	push	r11
    3d66:	cf 92       	push	r12
    3d68:	df 92       	push	r13
    3d6a:	ef 92       	push	r14
    3d6c:	ff 92       	push	r15
    3d6e:	0f 93       	push	r16
    3d70:	1f 93       	push	r17
    3d72:	df 93       	push	r29
    3d74:	cf 93       	push	r28
    3d76:	cd b7       	in	r28, 0x3d	; 61
    3d78:	de b7       	in	r29, 0x3e	; 62
    3d7a:	78 88       	ldd	r7, Y+16	; 0x10
    3d7c:	c9 88       	ldd	r12, Y+17	; 0x11
    3d7e:	da 88       	ldd	r13, Y+18	; 0x12
    3d80:	63 e1       	ldi	r22, 0x13	; 19
    3d82:	e6 2e       	mov	r14, r22
    3d84:	f1 2c       	mov	r15, r1
    3d86:	ec 0e       	add	r14, r28
    3d88:	fd 1e       	adc	r15, r29
    3d8a:	14 c0       	rjmp	.+40     	; 0x3db4 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    3d8c:	88 23       	and	r24, r24
    3d8e:	81 f4       	brne	.+32     	; 0x3db0 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    3d90:	80 e0       	ldi	r24, 0x00	; 0
    3d92:	90 e0       	ldi	r25, 0x00	; 0
    3d94:	cf 91       	pop	r28
    3d96:	df 91       	pop	r29
    3d98:	1f 91       	pop	r17
    3d9a:	0f 91       	pop	r16
    3d9c:	ff 90       	pop	r15
    3d9e:	ef 90       	pop	r14
    3da0:	df 90       	pop	r13
    3da2:	cf 90       	pop	r12
    3da4:	bf 90       	pop	r11
    3da6:	af 90       	pop	r10
    3da8:	9f 90       	pop	r9
    3daa:	8f 90       	pop	r8
    3dac:	7f 90       	pop	r7
    3dae:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    3db0:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    3db4:	96 01       	movw	r18, r12
    3db6:	2f 5f       	subi	r18, 0xFF	; 255
    3db8:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    3dba:	77 20       	and	r7, r7
    3dbc:	21 f0       	breq	.+8      	; 0x3dc6 <rprintf1RamRom+0x6a>
    3dbe:	f6 01       	movw	r30, r12
    3dc0:	69 01       	movw	r12, r18
    3dc2:	84 91       	lpm	r24, Z+
    3dc4:	03 c0       	rjmp	.+6      	; 0x3dcc <rprintf1RamRom+0x70>
    3dc6:	f6 01       	movw	r30, r12
    3dc8:	80 81       	ld	r24, Z
    3dca:	69 01       	movw	r12, r18
    3dcc:	85 32       	cpi	r24, 0x25	; 37
    3dce:	f1 f6       	brne	.-68     	; 0x3d8c <rprintf1RamRom+0x30>
    3dd0:	2f 5f       	subi	r18, 0xFF	; 255
    3dd2:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    3dd4:	77 20       	and	r7, r7
    3dd6:	21 f0       	breq	.+8      	; 0x3de0 <rprintf1RamRom+0x84>
    3dd8:	f6 01       	movw	r30, r12
    3dda:	69 01       	movw	r12, r18
    3ddc:	84 91       	lpm	r24, Z+
    3dde:	03 c0       	rjmp	.+6      	; 0x3de6 <rprintf1RamRom+0x8a>
    3de0:	f6 01       	movw	r30, r12
    3de2:	80 81       	ld	r24, Z
    3de4:	69 01       	movw	r12, r18
    3de6:	84 36       	cpi	r24, 0x64	; 100
    3de8:	29 f0       	breq	.+10     	; 0x3df4 <rprintf1RamRom+0x98>
    3dea:	88 37       	cpi	r24, 0x78	; 120
    3dec:	81 f0       	breq	.+32     	; 0x3e0e <rprintf1RamRom+0xb2>
    3dee:	83 36       	cpi	r24, 0x63	; 99
    3df0:	f9 f6       	brne	.-66     	; 0x3db0 <rprintf1RamRom+0x54>
    3df2:	06 c0       	rjmp	.+12     	; 0x3e00 <rprintf1RamRom+0xa4>
    3df4:	00 e1       	ldi	r16, 0x10	; 16
    3df6:	17 e2       	ldi	r17, 0x27	; 39
    3df8:	5a e0       	ldi	r21, 0x0A	; 10
    3dfa:	a5 2e       	mov	r10, r21
    3dfc:	b1 2c       	mov	r11, r1
    3dfe:	0c c0       	rjmp	.+24     	; 0x3e18 <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    3e00:	f7 01       	movw	r30, r14
    3e02:	80 81       	ld	r24, Z
    3e04:	22 e0       	ldi	r18, 0x02	; 2
    3e06:	30 e0       	ldi	r19, 0x00	; 0
    3e08:	e2 0e       	add	r14, r18
    3e0a:	f3 1e       	adc	r15, r19
    3e0c:	d1 cf       	rjmp	.-94     	; 0x3db0 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    3e0e:	00 e0       	ldi	r16, 0x00	; 0
    3e10:	10 e1       	ldi	r17, 0x10	; 16
    3e12:	40 e1       	ldi	r20, 0x10	; 16
    3e14:	a4 2e       	mov	r10, r20
    3e16:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    3e18:	32 e0       	ldi	r19, 0x02	; 2
    3e1a:	83 2e       	mov	r8, r19
    3e1c:	91 2c       	mov	r9, r1
    3e1e:	8e 0c       	add	r8, r14
    3e20:	9f 1c       	adc	r9, r15
    3e22:	f7 01       	movw	r30, r14
    3e24:	e0 80       	ld	r14, Z
    3e26:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    3e28:	84 36       	cpi	r24, 0x64	; 100
    3e2a:	b1 f4       	brne	.+44     	; 0x3e58 <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    3e2c:	f7 fe       	sbrs	r15, 7
    3e2e:	11 c0       	rjmp	.+34     	; 0x3e52 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    3e30:	f0 94       	com	r15
    3e32:	e1 94       	neg	r14
    3e34:	f1 08       	sbc	r15, r1
    3e36:	f3 94       	inc	r15
					rprintfChar('-');
    3e38:	8d e2       	ldi	r24, 0x2D	; 45
    3e3a:	0e 94 8f 1c 	call	0x391e	; 0x391e <rprintfChar>
    3e3e:	09 c0       	rjmp	.+18     	; 0x3e52 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    3e40:	c8 01       	movw	r24, r16
    3e42:	6a e0       	ldi	r22, 0x0A	; 10
    3e44:	70 e0       	ldi	r23, 0x00	; 0
    3e46:	0e 94 fd 23 	call	0x47fa	; 0x47fa <__udivmodhi4>
    3e4a:	8b 01       	movw	r16, r22
    3e4c:	62 30       	cpi	r22, 0x02	; 2
    3e4e:	71 05       	cpc	r23, r1
    3e50:	18 f0       	brcs	.+6      	; 0x3e58 <rprintf1RamRom+0xfc>
    3e52:	e0 16       	cp	r14, r16
    3e54:	f1 06       	cpc	r15, r17
    3e56:	a0 f3       	brcs	.-24     	; 0x3e40 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    3e58:	c7 01       	movw	r24, r14
    3e5a:	b8 01       	movw	r22, r16
    3e5c:	0e 94 fd 23 	call	0x47fa	; 0x47fa <__udivmodhi4>
    3e60:	86 2f       	mov	r24, r22
    3e62:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <rprintfu04>
				u_val %= div_val;
    3e66:	c7 01       	movw	r24, r14
    3e68:	b8 01       	movw	r22, r16
    3e6a:	0e 94 fd 23 	call	0x47fa	; 0x47fa <__udivmodhi4>
    3e6e:	7c 01       	movw	r14, r24
				div_val /= base;
    3e70:	c8 01       	movw	r24, r16
    3e72:	b5 01       	movw	r22, r10
    3e74:	0e 94 fd 23 	call	0x47fa	; 0x47fa <__udivmodhi4>
    3e78:	8b 01       	movw	r16, r22
			} while (div_val);
    3e7a:	61 15       	cp	r22, r1
    3e7c:	71 05       	cpc	r23, r1
    3e7e:	61 f7       	brne	.-40     	; 0x3e58 <rprintf1RamRom+0xfc>
    3e80:	74 01       	movw	r14, r8
    3e82:	98 cf       	rjmp	.-208    	; 0x3db4 <rprintf1RamRom+0x58>

00003e84 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    3e84:	20 91 b9 00 	lds	r18, 0x00B9
    3e88:	2e 7f       	andi	r18, 0xFE	; 254
    3e8a:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    3e8e:	20 91 b9 00 	lds	r18, 0x00B9
    3e92:	2d 7f       	andi	r18, 0xFD	; 253
    3e94:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    3e98:	9c 01       	movw	r18, r24
    3e9a:	40 e0       	ldi	r20, 0x00	; 0
    3e9c:	50 e0       	ldi	r21, 0x00	; 0
    3e9e:	60 e8       	ldi	r22, 0x80	; 128
    3ea0:	7e e3       	ldi	r23, 0x3E	; 62
    3ea2:	80 e0       	ldi	r24, 0x00	; 0
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	0e 94 46 24 	call	0x488c	; 0x488c <__divmodsi4>
	if(bitrate_div >= 16)
    3eaa:	20 31       	cpi	r18, 0x10	; 16
    3eac:	30 f0       	brcs	.+12     	; 0x3eba <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    3eae:	82 2f       	mov	r24, r18
    3eb0:	90 e0       	ldi	r25, 0x00	; 0
    3eb2:	40 97       	sbiw	r24, 0x10	; 16
    3eb4:	95 95       	asr	r25
    3eb6:	87 95       	ror	r24
    3eb8:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    3eba:	20 93 b8 00 	sts	0x00B8, r18
}
    3ebe:	08 95       	ret

00003ec0 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    3ec0:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    3ec2:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    3ec4:	10 92 c9 11 	sts	0x11C9, r1
    3ec8:	10 92 c8 11 	sts	0x11C8, r1
	i2cSlaveTransmit = 0;
    3ecc:	10 92 cb 11 	sts	0x11CB, r1
    3ed0:	10 92 ca 11 	sts	0x11CA, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    3ed4:	84 e6       	ldi	r24, 0x64	; 100
    3ed6:	90 e0       	ldi	r25, 0x00	; 0
    3ed8:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    3edc:	ec eb       	ldi	r30, 0xBC	; 188
    3ede:	f0 e0       	ldi	r31, 0x00	; 0
    3ee0:	80 81       	ld	r24, Z
    3ee2:	84 60       	ori	r24, 0x04	; 4
    3ee4:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    3ee6:	10 92 82 11 	sts	0x1182, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    3eea:	80 81       	ld	r24, Z
    3eec:	81 60       	ori	r24, 0x01	; 1
    3eee:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    3ef0:	80 81       	ld	r24, Z
    3ef2:	80 64       	ori	r24, 0x40	; 64
    3ef4:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    3ef6:	78 94       	sei
}
    3ef8:	08 95       	ret

00003efa <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    3efa:	90 e0       	ldi	r25, 0x00	; 0
    3efc:	61 11       	cpse	r22, r1
    3efe:	91 e0       	ldi	r25, 0x01	; 1
    3f00:	8e 7f       	andi	r24, 0xFE	; 254
    3f02:	98 2b       	or	r25, r24
    3f04:	90 93 ba 00 	sts	0x00BA, r25
}
    3f08:	08 95       	ret

00003f0a <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    3f0a:	90 93 c9 11 	sts	0x11C9, r25
    3f0e:	80 93 c8 11 	sts	0x11C8, r24
}
    3f12:	08 95       	ret

00003f14 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    3f14:	90 93 cb 11 	sts	0x11CB, r25
    3f18:	80 93 ca 11 	sts	0x11CA, r24
}
    3f1c:	08 95       	ret

00003f1e <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    3f1e:	ec eb       	ldi	r30, 0xBC	; 188
    3f20:	f0 e0       	ldi	r31, 0x00	; 0
    3f22:	80 81       	ld	r24, Z
    3f24:	8f 70       	andi	r24, 0x0F	; 15
    3f26:	80 6a       	ori	r24, 0xA0	; 160
    3f28:	80 83       	st	Z, r24
}
    3f2a:	08 95       	ret

00003f2c <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    3f2c:	ec eb       	ldi	r30, 0xBC	; 188
    3f2e:	f0 e0       	ldi	r31, 0x00	; 0
    3f30:	80 81       	ld	r24, Z
    3f32:	8f 70       	andi	r24, 0x0F	; 15
    3f34:	80 6d       	ori	r24, 0xD0	; 208
    3f36:	80 83       	st	Z, r24
}
    3f38:	08 95       	ret

00003f3a <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    3f3a:	80 91 bc 00 	lds	r24, 0x00BC
    3f3e:	87 ff       	sbrs	r24, 7
    3f40:	fc cf       	rjmp	.-8      	; 0x3f3a <i2cWaitForComplete>
}
    3f42:	08 95       	ret

00003f44 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    3f44:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    3f48:	ec eb       	ldi	r30, 0xBC	; 188
    3f4a:	f0 e0       	ldi	r31, 0x00	; 0
    3f4c:	80 81       	ld	r24, Z
    3f4e:	8f 70       	andi	r24, 0x0F	; 15
    3f50:	80 68       	ori	r24, 0x80	; 128
    3f52:	80 83       	st	Z, r24
}
    3f54:	08 95       	ret

00003f56 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    3f56:	88 23       	and	r24, r24
    3f58:	29 f0       	breq	.+10     	; 0x3f64 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    3f5a:	80 91 bc 00 	lds	r24, 0x00BC
    3f5e:	8f 70       	andi	r24, 0x0F	; 15
    3f60:	80 6c       	ori	r24, 0xC0	; 192
    3f62:	04 c0       	rjmp	.+8      	; 0x3f6c <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    3f64:	80 91 bc 00 	lds	r24, 0x00BC
    3f68:	8f 70       	andi	r24, 0x0F	; 15
    3f6a:	80 68       	ori	r24, 0x80	; 128
    3f6c:	80 93 bc 00 	sts	0x00BC, r24
    3f70:	08 95       	ret

00003f72 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    3f72:	80 91 bb 00 	lds	r24, 0x00BB
}
    3f76:	08 95       	ret

00003f78 <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    3f78:	80 91 b9 00 	lds	r24, 0x00B9
}
    3f7c:	08 95       	ret

00003f7e <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    3f7e:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    3f80:	80 91 82 11 	lds	r24, 0x1182
    3f84:	88 23       	and	r24, r24
    3f86:	e1 f7       	brne	.-8      	; 0x3f80 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    3f88:	82 e0       	ldi	r24, 0x02	; 2
    3f8a:	80 93 82 11 	sts	0x1182, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    3f8e:	9e 7f       	andi	r25, 0xFE	; 254
    3f90:	90 93 83 11 	sts	0x1183, r25
    3f94:	a4 e8       	ldi	r26, 0x84	; 132
    3f96:	b1 e1       	ldi	r27, 0x11	; 17
    3f98:	fa 01       	movw	r30, r20
    3f9a:	02 c0       	rjmp	.+4      	; 0x3fa0 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    3f9c:	81 91       	ld	r24, Z+
    3f9e:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    3fa0:	8e 2f       	mov	r24, r30
    3fa2:	84 1b       	sub	r24, r20
    3fa4:	86 17       	cp	r24, r22
    3fa6:	d0 f3       	brcs	.-12     	; 0x3f9c <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    3fa8:	10 92 a4 11 	sts	0x11A4, r1
	I2cSendDataLength = length;
    3fac:	60 93 a5 11 	sts	0x11A5, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    3fb0:	80 91 bc 00 	lds	r24, 0x00BC
    3fb4:	8f 70       	andi	r24, 0x0F	; 15
    3fb6:	80 6a       	ori	r24, 0xA0	; 160
    3fb8:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    3fbc:	08 95       	ret

00003fbe <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    3fbe:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    3fc0:	80 91 82 11 	lds	r24, 0x1182
    3fc4:	88 23       	and	r24, r24
    3fc6:	e1 f7       	brne	.-8      	; 0x3fc0 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    3fc8:	83 e0       	ldi	r24, 0x03	; 3
    3fca:	80 93 82 11 	sts	0x1182, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    3fce:	91 60       	ori	r25, 0x01	; 1
    3fd0:	90 93 83 11 	sts	0x1183, r25
	I2cReceiveDataIndex = 0;
    3fd4:	10 92 c6 11 	sts	0x11C6, r1
	I2cReceiveDataLength = length;
    3fd8:	60 93 c7 11 	sts	0x11C7, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    3fdc:	80 91 bc 00 	lds	r24, 0x00BC
    3fe0:	8f 70       	andi	r24, 0x0F	; 15
    3fe2:	80 6a       	ori	r24, 0xA0	; 160
    3fe4:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    3fe8:	80 91 82 11 	lds	r24, 0x1182
    3fec:	88 23       	and	r24, r24
    3fee:	e1 f7       	brne	.-8      	; 0x3fe8 <i2cMasterReceive+0x2a>
    3ff0:	a6 ea       	ldi	r26, 0xA6	; 166
    3ff2:	b1 e1       	ldi	r27, 0x11	; 17
    3ff4:	fa 01       	movw	r30, r20
    3ff6:	02 c0       	rjmp	.+4      	; 0x3ffc <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    3ff8:	8d 91       	ld	r24, X+
    3ffa:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    3ffc:	8e 2f       	mov	r24, r30
    3ffe:	84 1b       	sub	r24, r20
    4000:	86 17       	cp	r24, r22
    4002:	d0 f3       	brcs	.-12     	; 0x3ff8 <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    4004:	08 95       	ret

00004006 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    4006:	98 2f       	mov	r25, r24
    4008:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    400a:	80 91 bc 00 	lds	r24, 0x00BC
    400e:	8e 7f       	andi	r24, 0xFE	; 254
    4010:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    4014:	80 91 bc 00 	lds	r24, 0x00BC
    4018:	8f 70       	andi	r24, 0x0F	; 15
    401a:	80 6a       	ori	r24, 0xA0	; 160
    401c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4020:	80 91 bc 00 	lds	r24, 0x00BC
    4024:	87 ff       	sbrs	r24, 7
    4026:	fc cf       	rjmp	.-8      	; 0x4020 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    4028:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    402a:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    402e:	80 91 bc 00 	lds	r24, 0x00BC
    4032:	8f 70       	andi	r24, 0x0F	; 15
    4034:	80 68       	ori	r24, 0x80	; 128
    4036:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    403a:	80 91 bc 00 	lds	r24, 0x00BC
    403e:	87 ff       	sbrs	r24, 7
    4040:	fc cf       	rjmp	.-8      	; 0x403a <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    4042:	80 91 b9 00 	lds	r24, 0x00B9
    4046:	88 31       	cpi	r24, 0x18	; 24
    4048:	89 f0       	breq	.+34     	; 0x406c <i2cMasterSendNI+0x66>
    404a:	91 e0       	ldi	r25, 0x01	; 1
    404c:	12 c0       	rjmp	.+36     	; 0x4072 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    404e:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    4050:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4054:	80 91 bc 00 	lds	r24, 0x00BC
    4058:	8f 70       	andi	r24, 0x0F	; 15
    405a:	80 68       	ori	r24, 0x80	; 128
    405c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4060:	80 91 bc 00 	lds	r24, 0x00BC
    4064:	87 ff       	sbrs	r24, 7
    4066:	fc cf       	rjmp	.-8      	; 0x4060 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    4068:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    406a:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    406c:	66 23       	and	r22, r22
    406e:	79 f7       	brne	.-34     	; 0x404e <i2cMasterSendNI+0x48>
    4070:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    4072:	80 91 bc 00 	lds	r24, 0x00BC
    4076:	8f 70       	andi	r24, 0x0F	; 15
    4078:	80 6d       	ori	r24, 0xD0	; 208
    407a:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    407e:	80 91 bc 00 	lds	r24, 0x00BC
    4082:	84 ff       	sbrs	r24, 4
    4084:	fc cf       	rjmp	.-8      	; 0x407e <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    4086:	80 91 bc 00 	lds	r24, 0x00BC
    408a:	81 60       	ori	r24, 0x01	; 1
    408c:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    4090:	89 2f       	mov	r24, r25
    4092:	08 95       	ret

00004094 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    4094:	98 2f       	mov	r25, r24
    4096:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    4098:	80 91 bc 00 	lds	r24, 0x00BC
    409c:	8e 7f       	andi	r24, 0xFE	; 254
    409e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    40a2:	80 91 bc 00 	lds	r24, 0x00BC
    40a6:	8f 70       	andi	r24, 0x0F	; 15
    40a8:	80 6a       	ori	r24, 0xA0	; 160
    40aa:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    40ae:	80 91 bc 00 	lds	r24, 0x00BC
    40b2:	87 ff       	sbrs	r24, 7
    40b4:	fc cf       	rjmp	.-8      	; 0x40ae <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    40b6:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    40b8:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    40bc:	80 91 bc 00 	lds	r24, 0x00BC
    40c0:	8f 70       	andi	r24, 0x0F	; 15
    40c2:	80 68       	ori	r24, 0x80	; 128
    40c4:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    40c8:	80 91 bc 00 	lds	r24, 0x00BC
    40cc:	87 ff       	sbrs	r24, 7
    40ce:	fc cf       	rjmp	.-8      	; 0x40c8 <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    40d0:	80 91 b9 00 	lds	r24, 0x00B9
    40d4:	80 34       	cpi	r24, 0x40	; 64
    40d6:	81 f0       	breq	.+32     	; 0x40f8 <i2cMasterReceiveNI+0x64>
    40d8:	91 e0       	ldi	r25, 0x01	; 1
    40da:	1e c0       	rjmp	.+60     	; 0x4118 <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    40dc:	80 91 bc 00 	lds	r24, 0x00BC
    40e0:	8f 70       	andi	r24, 0x0F	; 15
    40e2:	80 6c       	ori	r24, 0xC0	; 192
    40e4:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    40e8:	80 91 bc 00 	lds	r24, 0x00BC
    40ec:	87 ff       	sbrs	r24, 7
    40ee:	fc cf       	rjmp	.-8      	; 0x40e8 <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    40f0:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    40f4:	81 93       	st	Z+, r24
			// decrement length
			length--;
    40f6:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    40f8:	62 30       	cpi	r22, 0x02	; 2
    40fa:	80 f7       	brcc	.-32     	; 0x40dc <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    40fc:	80 91 bc 00 	lds	r24, 0x00BC
    4100:	8f 70       	andi	r24, 0x0F	; 15
    4102:	80 68       	ori	r24, 0x80	; 128
    4104:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    4108:	80 91 bc 00 	lds	r24, 0x00BC
    410c:	87 ff       	sbrs	r24, 7
    410e:	fc cf       	rjmp	.-8      	; 0x4108 <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    4110:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    4114:	80 83       	st	Z, r24
    4116:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    4118:	80 91 bc 00 	lds	r24, 0x00BC
    411c:	8f 70       	andi	r24, 0x0F	; 15
    411e:	80 6d       	ori	r24, 0xD0	; 208
    4120:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    4124:	80 91 bc 00 	lds	r24, 0x00BC
    4128:	81 60       	ori	r24, 0x01	; 1
    412a:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    412e:	89 2f       	mov	r24, r25
    4130:	08 95       	ret

00004132 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    4132:	1f 92       	push	r1
    4134:	0f 92       	push	r0
    4136:	0f b6       	in	r0, 0x3f	; 63
    4138:	0f 92       	push	r0
    413a:	11 24       	eor	r1, r1
    413c:	2f 93       	push	r18
    413e:	3f 93       	push	r19
    4140:	4f 93       	push	r20
    4142:	5f 93       	push	r21
    4144:	6f 93       	push	r22
    4146:	7f 93       	push	r23
    4148:	8f 93       	push	r24
    414a:	9f 93       	push	r25
    414c:	af 93       	push	r26
    414e:	bf 93       	push	r27
    4150:	ef 93       	push	r30
    4152:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    4154:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    4158:	88 7f       	andi	r24, 0xF8	; 248
    415a:	80 36       	cpi	r24, 0x60	; 96
    415c:	09 f4       	brne	.+2      	; 0x4160 <__vector_39+0x2e>
    415e:	a0 c0       	rjmp	.+320    	; 0x42a0 <__vector_39+0x16e>
    4160:	81 36       	cpi	r24, 0x61	; 97
    4162:	70 f5       	brcc	.+92     	; 0x41c0 <__vector_39+0x8e>
    4164:	88 32       	cpi	r24, 0x28	; 40
    4166:	09 f4       	brne	.+2      	; 0x416a <__vector_39+0x38>
    4168:	5f c0       	rjmp	.+190    	; 0x4228 <__vector_39+0xf6>
    416a:	89 32       	cpi	r24, 0x29	; 41
    416c:	98 f4       	brcc	.+38     	; 0x4194 <__vector_39+0x62>
    416e:	80 31       	cpi	r24, 0x10	; 16
    4170:	09 f4       	brne	.+2      	; 0x4174 <__vector_39+0x42>
    4172:	57 c0       	rjmp	.+174    	; 0x4222 <__vector_39+0xf0>
    4174:	81 31       	cpi	r24, 0x11	; 17
    4176:	38 f4       	brcc	.+14     	; 0x4186 <__vector_39+0x54>
    4178:	88 23       	and	r24, r24
    417a:	09 f4       	brne	.+2      	; 0x417e <__vector_39+0x4c>
    417c:	ea c0       	rjmp	.+468    	; 0x4352 <__vector_39+0x220>
    417e:	88 30       	cpi	r24, 0x08	; 8
    4180:	09 f0       	breq	.+2      	; 0x4184 <__vector_39+0x52>
    4182:	ef c0       	rjmp	.+478    	; 0x4362 <__vector_39+0x230>
    4184:	4e c0       	rjmp	.+156    	; 0x4222 <__vector_39+0xf0>
    4186:	88 31       	cpi	r24, 0x18	; 24
    4188:	09 f4       	brne	.+2      	; 0x418c <__vector_39+0x5a>
    418a:	4e c0       	rjmp	.+156    	; 0x4228 <__vector_39+0xf6>
    418c:	80 32       	cpi	r24, 0x20	; 32
    418e:	09 f0       	breq	.+2      	; 0x4192 <__vector_39+0x60>
    4190:	e8 c0       	rjmp	.+464    	; 0x4362 <__vector_39+0x230>
    4192:	df c0       	rjmp	.+446    	; 0x4352 <__vector_39+0x220>
    4194:	80 34       	cpi	r24, 0x40	; 64
    4196:	09 f4       	brne	.+2      	; 0x419a <__vector_39+0x68>
    4198:	77 c0       	rjmp	.+238    	; 0x4288 <__vector_39+0x156>
    419a:	81 34       	cpi	r24, 0x41	; 65
    419c:	38 f4       	brcc	.+14     	; 0x41ac <__vector_39+0x7a>
    419e:	80 33       	cpi	r24, 0x30	; 48
    41a0:	09 f4       	brne	.+2      	; 0x41a4 <__vector_39+0x72>
    41a2:	d7 c0       	rjmp	.+430    	; 0x4352 <__vector_39+0x220>
    41a4:	88 33       	cpi	r24, 0x38	; 56
    41a6:	09 f0       	breq	.+2      	; 0x41aa <__vector_39+0x78>
    41a8:	dc c0       	rjmp	.+440    	; 0x4362 <__vector_39+0x230>
    41aa:	5d c0       	rjmp	.+186    	; 0x4266 <__vector_39+0x134>
    41ac:	80 35       	cpi	r24, 0x50	; 80
    41ae:	09 f4       	brne	.+2      	; 0x41b2 <__vector_39+0x80>
    41b0:	5f c0       	rjmp	.+190    	; 0x4270 <__vector_39+0x13e>
    41b2:	88 35       	cpi	r24, 0x58	; 88
    41b4:	09 f4       	brne	.+2      	; 0x41b8 <__vector_39+0x86>
    41b6:	4a c0       	rjmp	.+148    	; 0x424c <__vector_39+0x11a>
    41b8:	88 34       	cpi	r24, 0x48	; 72
    41ba:	09 f0       	breq	.+2      	; 0x41be <__vector_39+0x8c>
    41bc:	d2 c0       	rjmp	.+420    	; 0x4362 <__vector_39+0x230>
    41be:	c9 c0       	rjmp	.+402    	; 0x4352 <__vector_39+0x220>
    41c0:	88 39       	cpi	r24, 0x98	; 152
    41c2:	09 f4       	brne	.+2      	; 0x41c6 <__vector_39+0x94>
    41c4:	ba c0       	rjmp	.+372    	; 0x433a <__vector_39+0x208>
    41c6:	89 39       	cpi	r24, 0x99	; 153
    41c8:	b0 f4       	brcc	.+44     	; 0x41f6 <__vector_39+0xc4>
    41ca:	88 37       	cpi	r24, 0x78	; 120
    41cc:	09 f4       	brne	.+2      	; 0x41d0 <__vector_39+0x9e>
    41ce:	68 c0       	rjmp	.+208    	; 0x42a0 <__vector_39+0x16e>
    41d0:	89 37       	cpi	r24, 0x79	; 121
    41d2:	38 f4       	brcc	.+14     	; 0x41e2 <__vector_39+0xb0>
    41d4:	88 36       	cpi	r24, 0x68	; 104
    41d6:	09 f4       	brne	.+2      	; 0x41da <__vector_39+0xa8>
    41d8:	63 c0       	rjmp	.+198    	; 0x42a0 <__vector_39+0x16e>
    41da:	80 37       	cpi	r24, 0x70	; 112
    41dc:	09 f0       	breq	.+2      	; 0x41e0 <__vector_39+0xae>
    41de:	c1 c0       	rjmp	.+386    	; 0x4362 <__vector_39+0x230>
    41e0:	5f c0       	rjmp	.+190    	; 0x42a0 <__vector_39+0x16e>
    41e2:	88 38       	cpi	r24, 0x88	; 136
    41e4:	09 f4       	brne	.+2      	; 0x41e8 <__vector_39+0xb6>
    41e6:	a9 c0       	rjmp	.+338    	; 0x433a <__vector_39+0x208>
    41e8:	80 39       	cpi	r24, 0x90	; 144
    41ea:	09 f4       	brne	.+2      	; 0x41ee <__vector_39+0xbc>
    41ec:	5f c0       	rjmp	.+190    	; 0x42ac <__vector_39+0x17a>
    41ee:	80 38       	cpi	r24, 0x80	; 128
    41f0:	09 f0       	breq	.+2      	; 0x41f4 <__vector_39+0xc2>
    41f2:	b7 c0       	rjmp	.+366    	; 0x4362 <__vector_39+0x230>
    41f4:	5b c0       	rjmp	.+182    	; 0x42ac <__vector_39+0x17a>
    41f6:	80 3b       	cpi	r24, 0xB0	; 176
    41f8:	09 f4       	brne	.+2      	; 0x41fc <__vector_39+0xca>
    41fa:	79 c0       	rjmp	.+242    	; 0x42ee <__vector_39+0x1bc>
    41fc:	81 3b       	cpi	r24, 0xB1	; 177
    41fe:	38 f4       	brcc	.+14     	; 0x420e <__vector_39+0xdc>
    4200:	80 3a       	cpi	r24, 0xA0	; 160
    4202:	09 f4       	brne	.+2      	; 0x4206 <__vector_39+0xd4>
    4204:	62 c0       	rjmp	.+196    	; 0x42ca <__vector_39+0x198>
    4206:	88 3a       	cpi	r24, 0xA8	; 168
    4208:	09 f0       	breq	.+2      	; 0x420c <__vector_39+0xda>
    420a:	ab c0       	rjmp	.+342    	; 0x4362 <__vector_39+0x230>
    420c:	70 c0       	rjmp	.+224    	; 0x42ee <__vector_39+0x1bc>
    420e:	80 3c       	cpi	r24, 0xC0	; 192
    4210:	09 f4       	brne	.+2      	; 0x4214 <__vector_39+0xe2>
    4212:	9a c0       	rjmp	.+308    	; 0x4348 <__vector_39+0x216>
    4214:	88 3c       	cpi	r24, 0xC8	; 200
    4216:	09 f4       	brne	.+2      	; 0x421a <__vector_39+0xe8>
    4218:	97 c0       	rjmp	.+302    	; 0x4348 <__vector_39+0x216>
    421a:	88 3b       	cpi	r24, 0xB8	; 184
    421c:	09 f0       	breq	.+2      	; 0x4220 <__vector_39+0xee>
    421e:	a1 c0       	rjmp	.+322    	; 0x4362 <__vector_39+0x230>
    4220:	77 c0       	rjmp	.+238    	; 0x4310 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    4222:	80 91 83 11 	lds	r24, 0x1183
    4226:	0f c0       	rjmp	.+30     	; 0x4246 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    4228:	90 91 a4 11 	lds	r25, 0x11A4
    422c:	80 91 a5 11 	lds	r24, 0x11A5
    4230:	98 17       	cp	r25, r24
    4232:	08 f0       	brcs	.+2      	; 0x4236 <__vector_39+0x104>
    4234:	8e c0       	rjmp	.+284    	; 0x4352 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    4236:	e9 2f       	mov	r30, r25
    4238:	f0 e0       	ldi	r31, 0x00	; 0
    423a:	ec 57       	subi	r30, 0x7C	; 124
    423c:	fe 4e       	sbci	r31, 0xEE	; 238
    423e:	80 81       	ld	r24, Z
    4240:	9f 5f       	subi	r25, 0xFF	; 255
    4242:	90 93 a4 11 	sts	0x11A4, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    4246:	80 93 bb 00 	sts	0x00BB, r24
    424a:	77 c0       	rjmp	.+238    	; 0x433a <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    424c:	80 91 c6 11 	lds	r24, 0x11C6
    4250:	90 91 bb 00 	lds	r25, 0x00BB
    4254:	e8 2f       	mov	r30, r24
    4256:	f0 e0       	ldi	r31, 0x00	; 0
    4258:	ea 55       	subi	r30, 0x5A	; 90
    425a:	fe 4e       	sbci	r31, 0xEE	; 238
    425c:	90 83       	st	Z, r25
    425e:	8f 5f       	subi	r24, 0xFF	; 255
    4260:	80 93 c6 11 	sts	0x11C6, r24
    4264:	76 c0       	rjmp	.+236    	; 0x4352 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    4266:	80 91 bc 00 	lds	r24, 0x00BC
    426a:	8f 70       	andi	r24, 0x0F	; 15
    426c:	80 68       	ori	r24, 0x80	; 128
    426e:	75 c0       	rjmp	.+234    	; 0x435a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    4270:	80 91 c6 11 	lds	r24, 0x11C6
    4274:	90 91 bb 00 	lds	r25, 0x00BB
    4278:	e8 2f       	mov	r30, r24
    427a:	f0 e0       	ldi	r31, 0x00	; 0
    427c:	ea 55       	subi	r30, 0x5A	; 90
    427e:	fe 4e       	sbci	r31, 0xEE	; 238
    4280:	90 83       	st	Z, r25
    4282:	8f 5f       	subi	r24, 0xFF	; 255
    4284:	80 93 c6 11 	sts	0x11C6, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    4288:	20 91 c6 11 	lds	r18, 0x11C6
    428c:	30 e0       	ldi	r19, 0x00	; 0
    428e:	80 91 c7 11 	lds	r24, 0x11C7
    4292:	90 e0       	ldi	r25, 0x00	; 0
    4294:	01 97       	sbiw	r24, 0x01	; 1
    4296:	28 17       	cp	r18, r24
    4298:	39 07       	cpc	r19, r25
    429a:	0c f0       	brlt	.+2      	; 0x429e <__vector_39+0x16c>
    429c:	4e c0       	rjmp	.+156    	; 0x433a <__vector_39+0x208>
    429e:	48 c0       	rjmp	.+144    	; 0x4330 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    42a0:	85 e0       	ldi	r24, 0x05	; 5
    42a2:	80 93 82 11 	sts	0x1182, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    42a6:	10 92 c6 11 	sts	0x11C6, r1
    42aa:	42 c0       	rjmp	.+132    	; 0x4330 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    42ac:	80 91 c6 11 	lds	r24, 0x11C6
    42b0:	90 91 bb 00 	lds	r25, 0x00BB
    42b4:	e8 2f       	mov	r30, r24
    42b6:	f0 e0       	ldi	r31, 0x00	; 0
    42b8:	ea 55       	subi	r30, 0x5A	; 90
    42ba:	fe 4e       	sbci	r31, 0xEE	; 238
    42bc:	90 83       	st	Z, r25
    42be:	8f 5f       	subi	r24, 0xFF	; 255
    42c0:	80 93 c6 11 	sts	0x11C6, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    42c4:	80 32       	cpi	r24, 0x20	; 32
    42c6:	c8 f5       	brcc	.+114    	; 0x433a <__vector_39+0x208>
    42c8:	33 c0       	rjmp	.+102    	; 0x4330 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    42ca:	80 91 bc 00 	lds	r24, 0x00BC
    42ce:	8f 70       	andi	r24, 0x0F	; 15
    42d0:	80 6c       	ori	r24, 0xC0	; 192
    42d2:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    42d6:	e0 91 c8 11 	lds	r30, 0x11C8
    42da:	f0 91 c9 11 	lds	r31, 0x11C9
    42de:	30 97       	sbiw	r30, 0x00	; 0
    42e0:	f1 f1       	breq	.+124    	; 0x435e <__vector_39+0x22c>
    42e2:	80 91 c6 11 	lds	r24, 0x11C6
    42e6:	66 ea       	ldi	r22, 0xA6	; 166
    42e8:	71 e1       	ldi	r23, 0x11	; 17
    42ea:	09 95       	icall
    42ec:	38 c0       	rjmp	.+112    	; 0x435e <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    42ee:	84 e0       	ldi	r24, 0x04	; 4
    42f0:	80 93 82 11 	sts	0x1182, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    42f4:	e0 91 ca 11 	lds	r30, 0x11CA
    42f8:	f0 91 cb 11 	lds	r31, 0x11CB
    42fc:	30 97       	sbiw	r30, 0x00	; 0
    42fe:	31 f0       	breq	.+12     	; 0x430c <__vector_39+0x1da>
    4300:	80 e2       	ldi	r24, 0x20	; 32
    4302:	64 e8       	ldi	r22, 0x84	; 132
    4304:	71 e1       	ldi	r23, 0x11	; 17
    4306:	09 95       	icall
    4308:	80 93 a5 11 	sts	0x11A5, r24
		// reset data index
		I2cSendDataIndex = 0;
    430c:	10 92 a4 11 	sts	0x11A4, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    4310:	90 91 a4 11 	lds	r25, 0x11A4
    4314:	e9 2f       	mov	r30, r25
    4316:	f0 e0       	ldi	r31, 0x00	; 0
    4318:	ec 57       	subi	r30, 0x7C	; 124
    431a:	fe 4e       	sbci	r31, 0xEE	; 238
    431c:	80 81       	ld	r24, Z
    431e:	80 93 bb 00 	sts	0x00BB, r24
    4322:	9f 5f       	subi	r25, 0xFF	; 255
    4324:	90 93 a4 11 	sts	0x11A4, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    4328:	80 91 a5 11 	lds	r24, 0x11A5
    432c:	98 17       	cp	r25, r24
    432e:	28 f4       	brcc	.+10     	; 0x433a <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4330:	80 91 bc 00 	lds	r24, 0x00BC
    4334:	8f 70       	andi	r24, 0x0F	; 15
    4336:	80 6c       	ori	r24, 0xC0	; 192
    4338:	04 c0       	rjmp	.+8      	; 0x4342 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    433a:	80 91 bc 00 	lds	r24, 0x00BC
    433e:	8f 70       	andi	r24, 0x0F	; 15
    4340:	80 68       	ori	r24, 0x80	; 128
    4342:	80 93 bc 00 	sts	0x00BC, r24
    4346:	0d c0       	rjmp	.+26     	; 0x4362 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    4348:	80 91 bc 00 	lds	r24, 0x00BC
    434c:	8f 70       	andi	r24, 0x0F	; 15
    434e:	80 6c       	ori	r24, 0xC0	; 192
    4350:	04 c0       	rjmp	.+8      	; 0x435a <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    4352:	80 91 bc 00 	lds	r24, 0x00BC
    4356:	8f 70       	andi	r24, 0x0F	; 15
    4358:	80 6d       	ori	r24, 0xD0	; 208
    435a:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    435e:	10 92 82 11 	sts	0x1182, r1
		break;
	}
}
    4362:	ff 91       	pop	r31
    4364:	ef 91       	pop	r30
    4366:	bf 91       	pop	r27
    4368:	af 91       	pop	r26
    436a:	9f 91       	pop	r25
    436c:	8f 91       	pop	r24
    436e:	7f 91       	pop	r23
    4370:	6f 91       	pop	r22
    4372:	5f 91       	pop	r21
    4374:	4f 91       	pop	r20
    4376:	3f 91       	pop	r19
    4378:	2f 91       	pop	r18
    437a:	0f 90       	pop	r0
    437c:	0f be       	out	0x3f, r0	; 63
    437e:	0f 90       	pop	r0
    4380:	1f 90       	pop	r1
    4382:	18 95       	reti

00004384 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    4384:	80 91 82 11 	lds	r24, 0x1182
}
    4388:	08 95       	ret

0000438a <exit>:
    438a:	f8 94       	cli
    438c:	0c 94 61 24 	jmp	0x48c2	; 0x48c2 <_exit>

00004390 <memcpy>:
    4390:	fb 01       	movw	r30, r22
    4392:	dc 01       	movw	r26, r24
    4394:	02 c0       	rjmp	.+4      	; 0x439a <memcpy+0xa>
    4396:	01 90       	ld	r0, Z+
    4398:	0d 92       	st	X+, r0
    439a:	41 50       	subi	r20, 0x01	; 1
    439c:	50 40       	sbci	r21, 0x00	; 0
    439e:	d8 f7       	brcc	.-10     	; 0x4396 <memcpy+0x6>
    43a0:	08 95       	ret

000043a2 <memset>:
    43a2:	dc 01       	movw	r26, r24
    43a4:	01 c0       	rjmp	.+2      	; 0x43a8 <memset+0x6>
    43a6:	6d 93       	st	X+, r22
    43a8:	41 50       	subi	r20, 0x01	; 1
    43aa:	50 40       	sbci	r21, 0x00	; 0
    43ac:	e0 f7       	brcc	.-8      	; 0x43a6 <memset+0x4>
    43ae:	08 95       	ret

000043b0 <strncpy>:
    43b0:	fb 01       	movw	r30, r22
    43b2:	dc 01       	movw	r26, r24
    43b4:	41 50       	subi	r20, 0x01	; 1
    43b6:	50 40       	sbci	r21, 0x00	; 0
    43b8:	48 f0       	brcs	.+18     	; 0x43cc <strncpy+0x1c>
    43ba:	01 90       	ld	r0, Z+
    43bc:	0d 92       	st	X+, r0
    43be:	00 20       	and	r0, r0
    43c0:	c9 f7       	brne	.-14     	; 0x43b4 <strncpy+0x4>
    43c2:	01 c0       	rjmp	.+2      	; 0x43c6 <strncpy+0x16>
    43c4:	1d 92       	st	X+, r1
    43c6:	41 50       	subi	r20, 0x01	; 1
    43c8:	50 40       	sbci	r21, 0x00	; 0
    43ca:	e0 f7       	brcc	.-8      	; 0x43c4 <strncpy+0x14>
    43cc:	08 95       	ret

000043ce <__subsf3>:
    43ce:	50 58       	subi	r21, 0x80	; 128

000043d0 <__addsf3>:
    43d0:	bb 27       	eor	r27, r27
    43d2:	aa 27       	eor	r26, r26
    43d4:	0e d0       	rcall	.+28     	; 0x43f2 <__addsf3x>
    43d6:	70 c1       	rjmp	.+736    	; 0x46b8 <__fp_round>
    43d8:	61 d1       	rcall	.+706    	; 0x469c <__fp_pscA>
    43da:	30 f0       	brcs	.+12     	; 0x43e8 <__addsf3+0x18>
    43dc:	66 d1       	rcall	.+716    	; 0x46aa <__fp_pscB>
    43de:	20 f0       	brcs	.+8      	; 0x43e8 <__addsf3+0x18>
    43e0:	31 f4       	brne	.+12     	; 0x43ee <__addsf3+0x1e>
    43e2:	9f 3f       	cpi	r25, 0xFF	; 255
    43e4:	11 f4       	brne	.+4      	; 0x43ea <__addsf3+0x1a>
    43e6:	1e f4       	brtc	.+6      	; 0x43ee <__addsf3+0x1e>
    43e8:	56 c1       	rjmp	.+684    	; 0x4696 <__fp_nan>
    43ea:	0e f4       	brtc	.+2      	; 0x43ee <__addsf3+0x1e>
    43ec:	e0 95       	com	r30
    43ee:	e7 fb       	bst	r30, 7
    43f0:	4c c1       	rjmp	.+664    	; 0x468a <__fp_inf>

000043f2 <__addsf3x>:
    43f2:	e9 2f       	mov	r30, r25
    43f4:	72 d1       	rcall	.+740    	; 0x46da <__fp_split3>
    43f6:	80 f3       	brcs	.-32     	; 0x43d8 <__addsf3+0x8>
    43f8:	ba 17       	cp	r27, r26
    43fa:	62 07       	cpc	r22, r18
    43fc:	73 07       	cpc	r23, r19
    43fe:	84 07       	cpc	r24, r20
    4400:	95 07       	cpc	r25, r21
    4402:	18 f0       	brcs	.+6      	; 0x440a <__addsf3x+0x18>
    4404:	71 f4       	brne	.+28     	; 0x4422 <__addsf3x+0x30>
    4406:	9e f5       	brtc	.+102    	; 0x446e <__addsf3x+0x7c>
    4408:	8a c1       	rjmp	.+788    	; 0x471e <__fp_zero>
    440a:	0e f4       	brtc	.+2      	; 0x440e <__addsf3x+0x1c>
    440c:	e0 95       	com	r30
    440e:	0b 2e       	mov	r0, r27
    4410:	ba 2f       	mov	r27, r26
    4412:	a0 2d       	mov	r26, r0
    4414:	0b 01       	movw	r0, r22
    4416:	b9 01       	movw	r22, r18
    4418:	90 01       	movw	r18, r0
    441a:	0c 01       	movw	r0, r24
    441c:	ca 01       	movw	r24, r20
    441e:	a0 01       	movw	r20, r0
    4420:	11 24       	eor	r1, r1
    4422:	ff 27       	eor	r31, r31
    4424:	59 1b       	sub	r21, r25
    4426:	99 f0       	breq	.+38     	; 0x444e <__addsf3x+0x5c>
    4428:	59 3f       	cpi	r21, 0xF9	; 249
    442a:	50 f4       	brcc	.+20     	; 0x4440 <__addsf3x+0x4e>
    442c:	50 3e       	cpi	r21, 0xE0	; 224
    442e:	68 f1       	brcs	.+90     	; 0x448a <__addsf3x+0x98>
    4430:	1a 16       	cp	r1, r26
    4432:	f0 40       	sbci	r31, 0x00	; 0
    4434:	a2 2f       	mov	r26, r18
    4436:	23 2f       	mov	r18, r19
    4438:	34 2f       	mov	r19, r20
    443a:	44 27       	eor	r20, r20
    443c:	58 5f       	subi	r21, 0xF8	; 248
    443e:	f3 cf       	rjmp	.-26     	; 0x4426 <__addsf3x+0x34>
    4440:	46 95       	lsr	r20
    4442:	37 95       	ror	r19
    4444:	27 95       	ror	r18
    4446:	a7 95       	ror	r26
    4448:	f0 40       	sbci	r31, 0x00	; 0
    444a:	53 95       	inc	r21
    444c:	c9 f7       	brne	.-14     	; 0x4440 <__addsf3x+0x4e>
    444e:	7e f4       	brtc	.+30     	; 0x446e <__addsf3x+0x7c>
    4450:	1f 16       	cp	r1, r31
    4452:	ba 0b       	sbc	r27, r26
    4454:	62 0b       	sbc	r22, r18
    4456:	73 0b       	sbc	r23, r19
    4458:	84 0b       	sbc	r24, r20
    445a:	ba f0       	brmi	.+46     	; 0x448a <__addsf3x+0x98>
    445c:	91 50       	subi	r25, 0x01	; 1
    445e:	a1 f0       	breq	.+40     	; 0x4488 <__addsf3x+0x96>
    4460:	ff 0f       	add	r31, r31
    4462:	bb 1f       	adc	r27, r27
    4464:	66 1f       	adc	r22, r22
    4466:	77 1f       	adc	r23, r23
    4468:	88 1f       	adc	r24, r24
    446a:	c2 f7       	brpl	.-16     	; 0x445c <__addsf3x+0x6a>
    446c:	0e c0       	rjmp	.+28     	; 0x448a <__addsf3x+0x98>
    446e:	ba 0f       	add	r27, r26
    4470:	62 1f       	adc	r22, r18
    4472:	73 1f       	adc	r23, r19
    4474:	84 1f       	adc	r24, r20
    4476:	48 f4       	brcc	.+18     	; 0x448a <__addsf3x+0x98>
    4478:	87 95       	ror	r24
    447a:	77 95       	ror	r23
    447c:	67 95       	ror	r22
    447e:	b7 95       	ror	r27
    4480:	f7 95       	ror	r31
    4482:	9e 3f       	cpi	r25, 0xFE	; 254
    4484:	08 f0       	brcs	.+2      	; 0x4488 <__addsf3x+0x96>
    4486:	b3 cf       	rjmp	.-154    	; 0x43ee <__addsf3+0x1e>
    4488:	93 95       	inc	r25
    448a:	88 0f       	add	r24, r24
    448c:	08 f0       	brcs	.+2      	; 0x4490 <__addsf3x+0x9e>
    448e:	99 27       	eor	r25, r25
    4490:	ee 0f       	add	r30, r30
    4492:	97 95       	ror	r25
    4494:	87 95       	ror	r24
    4496:	08 95       	ret

00004498 <__cmpsf2>:
    4498:	d4 d0       	rcall	.+424    	; 0x4642 <__fp_cmp>
    449a:	08 f4       	brcc	.+2      	; 0x449e <__cmpsf2+0x6>
    449c:	81 e0       	ldi	r24, 0x01	; 1
    449e:	08 95       	ret

000044a0 <__divsf3>:
    44a0:	0c d0       	rcall	.+24     	; 0x44ba <__divsf3x>
    44a2:	0a c1       	rjmp	.+532    	; 0x46b8 <__fp_round>
    44a4:	02 d1       	rcall	.+516    	; 0x46aa <__fp_pscB>
    44a6:	40 f0       	brcs	.+16     	; 0x44b8 <__divsf3+0x18>
    44a8:	f9 d0       	rcall	.+498    	; 0x469c <__fp_pscA>
    44aa:	30 f0       	brcs	.+12     	; 0x44b8 <__divsf3+0x18>
    44ac:	21 f4       	brne	.+8      	; 0x44b6 <__divsf3+0x16>
    44ae:	5f 3f       	cpi	r21, 0xFF	; 255
    44b0:	19 f0       	breq	.+6      	; 0x44b8 <__divsf3+0x18>
    44b2:	eb c0       	rjmp	.+470    	; 0x468a <__fp_inf>
    44b4:	51 11       	cpse	r21, r1
    44b6:	34 c1       	rjmp	.+616    	; 0x4720 <__fp_szero>
    44b8:	ee c0       	rjmp	.+476    	; 0x4696 <__fp_nan>

000044ba <__divsf3x>:
    44ba:	0f d1       	rcall	.+542    	; 0x46da <__fp_split3>
    44bc:	98 f3       	brcs	.-26     	; 0x44a4 <__divsf3+0x4>

000044be <__divsf3_pse>:
    44be:	99 23       	and	r25, r25
    44c0:	c9 f3       	breq	.-14     	; 0x44b4 <__divsf3+0x14>
    44c2:	55 23       	and	r21, r21
    44c4:	b1 f3       	breq	.-20     	; 0x44b2 <__divsf3+0x12>
    44c6:	95 1b       	sub	r25, r21
    44c8:	55 0b       	sbc	r21, r21
    44ca:	bb 27       	eor	r27, r27
    44cc:	aa 27       	eor	r26, r26
    44ce:	62 17       	cp	r22, r18
    44d0:	73 07       	cpc	r23, r19
    44d2:	84 07       	cpc	r24, r20
    44d4:	38 f0       	brcs	.+14     	; 0x44e4 <__divsf3_pse+0x26>
    44d6:	9f 5f       	subi	r25, 0xFF	; 255
    44d8:	5f 4f       	sbci	r21, 0xFF	; 255
    44da:	22 0f       	add	r18, r18
    44dc:	33 1f       	adc	r19, r19
    44de:	44 1f       	adc	r20, r20
    44e0:	aa 1f       	adc	r26, r26
    44e2:	a9 f3       	breq	.-22     	; 0x44ce <__divsf3_pse+0x10>
    44e4:	33 d0       	rcall	.+102    	; 0x454c <__divsf3_pse+0x8e>
    44e6:	0e 2e       	mov	r0, r30
    44e8:	3a f0       	brmi	.+14     	; 0x44f8 <__divsf3_pse+0x3a>
    44ea:	e0 e8       	ldi	r30, 0x80	; 128
    44ec:	30 d0       	rcall	.+96     	; 0x454e <__divsf3_pse+0x90>
    44ee:	91 50       	subi	r25, 0x01	; 1
    44f0:	50 40       	sbci	r21, 0x00	; 0
    44f2:	e6 95       	lsr	r30
    44f4:	00 1c       	adc	r0, r0
    44f6:	ca f7       	brpl	.-14     	; 0x44ea <__divsf3_pse+0x2c>
    44f8:	29 d0       	rcall	.+82     	; 0x454c <__divsf3_pse+0x8e>
    44fa:	fe 2f       	mov	r31, r30
    44fc:	27 d0       	rcall	.+78     	; 0x454c <__divsf3_pse+0x8e>
    44fe:	66 0f       	add	r22, r22
    4500:	77 1f       	adc	r23, r23
    4502:	88 1f       	adc	r24, r24
    4504:	bb 1f       	adc	r27, r27
    4506:	26 17       	cp	r18, r22
    4508:	37 07       	cpc	r19, r23
    450a:	48 07       	cpc	r20, r24
    450c:	ab 07       	cpc	r26, r27
    450e:	b0 e8       	ldi	r27, 0x80	; 128
    4510:	09 f0       	breq	.+2      	; 0x4514 <__divsf3_pse+0x56>
    4512:	bb 0b       	sbc	r27, r27
    4514:	80 2d       	mov	r24, r0
    4516:	bf 01       	movw	r22, r30
    4518:	ff 27       	eor	r31, r31
    451a:	93 58       	subi	r25, 0x83	; 131
    451c:	5f 4f       	sbci	r21, 0xFF	; 255
    451e:	2a f0       	brmi	.+10     	; 0x452a <__divsf3_pse+0x6c>
    4520:	9e 3f       	cpi	r25, 0xFE	; 254
    4522:	51 05       	cpc	r21, r1
    4524:	68 f0       	brcs	.+26     	; 0x4540 <__divsf3_pse+0x82>
    4526:	b1 c0       	rjmp	.+354    	; 0x468a <__fp_inf>
    4528:	fb c0       	rjmp	.+502    	; 0x4720 <__fp_szero>
    452a:	5f 3f       	cpi	r21, 0xFF	; 255
    452c:	ec f3       	brlt	.-6      	; 0x4528 <__divsf3_pse+0x6a>
    452e:	98 3e       	cpi	r25, 0xE8	; 232
    4530:	dc f3       	brlt	.-10     	; 0x4528 <__divsf3_pse+0x6a>
    4532:	86 95       	lsr	r24
    4534:	77 95       	ror	r23
    4536:	67 95       	ror	r22
    4538:	b7 95       	ror	r27
    453a:	f7 95       	ror	r31
    453c:	9f 5f       	subi	r25, 0xFF	; 255
    453e:	c9 f7       	brne	.-14     	; 0x4532 <__divsf3_pse+0x74>
    4540:	88 0f       	add	r24, r24
    4542:	91 1d       	adc	r25, r1
    4544:	96 95       	lsr	r25
    4546:	87 95       	ror	r24
    4548:	97 f9       	bld	r25, 7
    454a:	08 95       	ret
    454c:	e1 e0       	ldi	r30, 0x01	; 1
    454e:	66 0f       	add	r22, r22
    4550:	77 1f       	adc	r23, r23
    4552:	88 1f       	adc	r24, r24
    4554:	bb 1f       	adc	r27, r27
    4556:	62 17       	cp	r22, r18
    4558:	73 07       	cpc	r23, r19
    455a:	84 07       	cpc	r24, r20
    455c:	ba 07       	cpc	r27, r26
    455e:	20 f0       	brcs	.+8      	; 0x4568 <__divsf3_pse+0xaa>
    4560:	62 1b       	sub	r22, r18
    4562:	73 0b       	sbc	r23, r19
    4564:	84 0b       	sbc	r24, r20
    4566:	ba 0b       	sbc	r27, r26
    4568:	ee 1f       	adc	r30, r30
    456a:	88 f7       	brcc	.-30     	; 0x454e <__divsf3_pse+0x90>
    456c:	e0 95       	com	r30
    456e:	08 95       	ret

00004570 <__fixunssfsi>:
    4570:	bc d0       	rcall	.+376    	; 0x46ea <__fp_splitA>
    4572:	88 f0       	brcs	.+34     	; 0x4596 <__fixunssfsi+0x26>
    4574:	9f 57       	subi	r25, 0x7F	; 127
    4576:	90 f0       	brcs	.+36     	; 0x459c <__fixunssfsi+0x2c>
    4578:	b9 2f       	mov	r27, r25
    457a:	99 27       	eor	r25, r25
    457c:	b7 51       	subi	r27, 0x17	; 23
    457e:	a0 f0       	brcs	.+40     	; 0x45a8 <__fixunssfsi+0x38>
    4580:	d1 f0       	breq	.+52     	; 0x45b6 <__fixunssfsi+0x46>
    4582:	66 0f       	add	r22, r22
    4584:	77 1f       	adc	r23, r23
    4586:	88 1f       	adc	r24, r24
    4588:	99 1f       	adc	r25, r25
    458a:	1a f0       	brmi	.+6      	; 0x4592 <__fixunssfsi+0x22>
    458c:	ba 95       	dec	r27
    458e:	c9 f7       	brne	.-14     	; 0x4582 <__fixunssfsi+0x12>
    4590:	12 c0       	rjmp	.+36     	; 0x45b6 <__fixunssfsi+0x46>
    4592:	b1 30       	cpi	r27, 0x01	; 1
    4594:	81 f0       	breq	.+32     	; 0x45b6 <__fixunssfsi+0x46>
    4596:	c3 d0       	rcall	.+390    	; 0x471e <__fp_zero>
    4598:	b1 e0       	ldi	r27, 0x01	; 1
    459a:	08 95       	ret
    459c:	c0 c0       	rjmp	.+384    	; 0x471e <__fp_zero>
    459e:	67 2f       	mov	r22, r23
    45a0:	78 2f       	mov	r23, r24
    45a2:	88 27       	eor	r24, r24
    45a4:	b8 5f       	subi	r27, 0xF8	; 248
    45a6:	39 f0       	breq	.+14     	; 0x45b6 <__fixunssfsi+0x46>
    45a8:	b9 3f       	cpi	r27, 0xF9	; 249
    45aa:	cc f3       	brlt	.-14     	; 0x459e <__fixunssfsi+0x2e>
    45ac:	86 95       	lsr	r24
    45ae:	77 95       	ror	r23
    45b0:	67 95       	ror	r22
    45b2:	b3 95       	inc	r27
    45b4:	d9 f7       	brne	.-10     	; 0x45ac <__fixunssfsi+0x3c>
    45b6:	3e f4       	brtc	.+14     	; 0x45c6 <__fixunssfsi+0x56>
    45b8:	90 95       	com	r25
    45ba:	80 95       	com	r24
    45bc:	70 95       	com	r23
    45be:	61 95       	neg	r22
    45c0:	7f 4f       	sbci	r23, 0xFF	; 255
    45c2:	8f 4f       	sbci	r24, 0xFF	; 255
    45c4:	9f 4f       	sbci	r25, 0xFF	; 255
    45c6:	08 95       	ret

000045c8 <__floatunsisf>:
    45c8:	e8 94       	clt
    45ca:	09 c0       	rjmp	.+18     	; 0x45de <__floatsisf+0x12>

000045cc <__floatsisf>:
    45cc:	97 fb       	bst	r25, 7
    45ce:	3e f4       	brtc	.+14     	; 0x45de <__floatsisf+0x12>
    45d0:	90 95       	com	r25
    45d2:	80 95       	com	r24
    45d4:	70 95       	com	r23
    45d6:	61 95       	neg	r22
    45d8:	7f 4f       	sbci	r23, 0xFF	; 255
    45da:	8f 4f       	sbci	r24, 0xFF	; 255
    45dc:	9f 4f       	sbci	r25, 0xFF	; 255
    45de:	99 23       	and	r25, r25
    45e0:	a9 f0       	breq	.+42     	; 0x460c <__floatsisf+0x40>
    45e2:	f9 2f       	mov	r31, r25
    45e4:	96 e9       	ldi	r25, 0x96	; 150
    45e6:	bb 27       	eor	r27, r27
    45e8:	93 95       	inc	r25
    45ea:	f6 95       	lsr	r31
    45ec:	87 95       	ror	r24
    45ee:	77 95       	ror	r23
    45f0:	67 95       	ror	r22
    45f2:	b7 95       	ror	r27
    45f4:	f1 11       	cpse	r31, r1
    45f6:	f8 cf       	rjmp	.-16     	; 0x45e8 <__floatsisf+0x1c>
    45f8:	fa f4       	brpl	.+62     	; 0x4638 <__floatsisf+0x6c>
    45fa:	bb 0f       	add	r27, r27
    45fc:	11 f4       	brne	.+4      	; 0x4602 <__floatsisf+0x36>
    45fe:	60 ff       	sbrs	r22, 0
    4600:	1b c0       	rjmp	.+54     	; 0x4638 <__floatsisf+0x6c>
    4602:	6f 5f       	subi	r22, 0xFF	; 255
    4604:	7f 4f       	sbci	r23, 0xFF	; 255
    4606:	8f 4f       	sbci	r24, 0xFF	; 255
    4608:	9f 4f       	sbci	r25, 0xFF	; 255
    460a:	16 c0       	rjmp	.+44     	; 0x4638 <__floatsisf+0x6c>
    460c:	88 23       	and	r24, r24
    460e:	11 f0       	breq	.+4      	; 0x4614 <__floatsisf+0x48>
    4610:	96 e9       	ldi	r25, 0x96	; 150
    4612:	11 c0       	rjmp	.+34     	; 0x4636 <__floatsisf+0x6a>
    4614:	77 23       	and	r23, r23
    4616:	21 f0       	breq	.+8      	; 0x4620 <__floatsisf+0x54>
    4618:	9e e8       	ldi	r25, 0x8E	; 142
    461a:	87 2f       	mov	r24, r23
    461c:	76 2f       	mov	r23, r22
    461e:	05 c0       	rjmp	.+10     	; 0x462a <__floatsisf+0x5e>
    4620:	66 23       	and	r22, r22
    4622:	71 f0       	breq	.+28     	; 0x4640 <__floatsisf+0x74>
    4624:	96 e8       	ldi	r25, 0x86	; 134
    4626:	86 2f       	mov	r24, r22
    4628:	70 e0       	ldi	r23, 0x00	; 0
    462a:	60 e0       	ldi	r22, 0x00	; 0
    462c:	2a f0       	brmi	.+10     	; 0x4638 <__floatsisf+0x6c>
    462e:	9a 95       	dec	r25
    4630:	66 0f       	add	r22, r22
    4632:	77 1f       	adc	r23, r23
    4634:	88 1f       	adc	r24, r24
    4636:	da f7       	brpl	.-10     	; 0x462e <__floatsisf+0x62>
    4638:	88 0f       	add	r24, r24
    463a:	96 95       	lsr	r25
    463c:	87 95       	ror	r24
    463e:	97 f9       	bld	r25, 7
    4640:	08 95       	ret

00004642 <__fp_cmp>:
    4642:	99 0f       	add	r25, r25
    4644:	00 08       	sbc	r0, r0
    4646:	55 0f       	add	r21, r21
    4648:	aa 0b       	sbc	r26, r26
    464a:	e0 e8       	ldi	r30, 0x80	; 128
    464c:	fe ef       	ldi	r31, 0xFE	; 254
    464e:	16 16       	cp	r1, r22
    4650:	17 06       	cpc	r1, r23
    4652:	e8 07       	cpc	r30, r24
    4654:	f9 07       	cpc	r31, r25
    4656:	c0 f0       	brcs	.+48     	; 0x4688 <__fp_cmp+0x46>
    4658:	12 16       	cp	r1, r18
    465a:	13 06       	cpc	r1, r19
    465c:	e4 07       	cpc	r30, r20
    465e:	f5 07       	cpc	r31, r21
    4660:	98 f0       	brcs	.+38     	; 0x4688 <__fp_cmp+0x46>
    4662:	62 1b       	sub	r22, r18
    4664:	73 0b       	sbc	r23, r19
    4666:	84 0b       	sbc	r24, r20
    4668:	95 0b       	sbc	r25, r21
    466a:	39 f4       	brne	.+14     	; 0x467a <__fp_cmp+0x38>
    466c:	0a 26       	eor	r0, r26
    466e:	61 f0       	breq	.+24     	; 0x4688 <__fp_cmp+0x46>
    4670:	23 2b       	or	r18, r19
    4672:	24 2b       	or	r18, r20
    4674:	25 2b       	or	r18, r21
    4676:	21 f4       	brne	.+8      	; 0x4680 <__fp_cmp+0x3e>
    4678:	08 95       	ret
    467a:	0a 26       	eor	r0, r26
    467c:	09 f4       	brne	.+2      	; 0x4680 <__fp_cmp+0x3e>
    467e:	a1 40       	sbci	r26, 0x01	; 1
    4680:	a6 95       	lsr	r26
    4682:	8f ef       	ldi	r24, 0xFF	; 255
    4684:	81 1d       	adc	r24, r1
    4686:	81 1d       	adc	r24, r1
    4688:	08 95       	ret

0000468a <__fp_inf>:
    468a:	97 f9       	bld	r25, 7
    468c:	9f 67       	ori	r25, 0x7F	; 127
    468e:	80 e8       	ldi	r24, 0x80	; 128
    4690:	70 e0       	ldi	r23, 0x00	; 0
    4692:	60 e0       	ldi	r22, 0x00	; 0
    4694:	08 95       	ret

00004696 <__fp_nan>:
    4696:	9f ef       	ldi	r25, 0xFF	; 255
    4698:	80 ec       	ldi	r24, 0xC0	; 192
    469a:	08 95       	ret

0000469c <__fp_pscA>:
    469c:	00 24       	eor	r0, r0
    469e:	0a 94       	dec	r0
    46a0:	16 16       	cp	r1, r22
    46a2:	17 06       	cpc	r1, r23
    46a4:	18 06       	cpc	r1, r24
    46a6:	09 06       	cpc	r0, r25
    46a8:	08 95       	ret

000046aa <__fp_pscB>:
    46aa:	00 24       	eor	r0, r0
    46ac:	0a 94       	dec	r0
    46ae:	12 16       	cp	r1, r18
    46b0:	13 06       	cpc	r1, r19
    46b2:	14 06       	cpc	r1, r20
    46b4:	05 06       	cpc	r0, r21
    46b6:	08 95       	ret

000046b8 <__fp_round>:
    46b8:	09 2e       	mov	r0, r25
    46ba:	03 94       	inc	r0
    46bc:	00 0c       	add	r0, r0
    46be:	11 f4       	brne	.+4      	; 0x46c4 <__fp_round+0xc>
    46c0:	88 23       	and	r24, r24
    46c2:	52 f0       	brmi	.+20     	; 0x46d8 <__fp_round+0x20>
    46c4:	bb 0f       	add	r27, r27
    46c6:	40 f4       	brcc	.+16     	; 0x46d8 <__fp_round+0x20>
    46c8:	bf 2b       	or	r27, r31
    46ca:	11 f4       	brne	.+4      	; 0x46d0 <__fp_round+0x18>
    46cc:	60 ff       	sbrs	r22, 0
    46ce:	04 c0       	rjmp	.+8      	; 0x46d8 <__fp_round+0x20>
    46d0:	6f 5f       	subi	r22, 0xFF	; 255
    46d2:	7f 4f       	sbci	r23, 0xFF	; 255
    46d4:	8f 4f       	sbci	r24, 0xFF	; 255
    46d6:	9f 4f       	sbci	r25, 0xFF	; 255
    46d8:	08 95       	ret

000046da <__fp_split3>:
    46da:	57 fd       	sbrc	r21, 7
    46dc:	90 58       	subi	r25, 0x80	; 128
    46de:	44 0f       	add	r20, r20
    46e0:	55 1f       	adc	r21, r21
    46e2:	59 f0       	breq	.+22     	; 0x46fa <__fp_splitA+0x10>
    46e4:	5f 3f       	cpi	r21, 0xFF	; 255
    46e6:	71 f0       	breq	.+28     	; 0x4704 <__fp_splitA+0x1a>
    46e8:	47 95       	ror	r20

000046ea <__fp_splitA>:
    46ea:	88 0f       	add	r24, r24
    46ec:	97 fb       	bst	r25, 7
    46ee:	99 1f       	adc	r25, r25
    46f0:	61 f0       	breq	.+24     	; 0x470a <__fp_splitA+0x20>
    46f2:	9f 3f       	cpi	r25, 0xFF	; 255
    46f4:	79 f0       	breq	.+30     	; 0x4714 <__fp_splitA+0x2a>
    46f6:	87 95       	ror	r24
    46f8:	08 95       	ret
    46fa:	12 16       	cp	r1, r18
    46fc:	13 06       	cpc	r1, r19
    46fe:	14 06       	cpc	r1, r20
    4700:	55 1f       	adc	r21, r21
    4702:	f2 cf       	rjmp	.-28     	; 0x46e8 <__fp_split3+0xe>
    4704:	46 95       	lsr	r20
    4706:	f1 df       	rcall	.-30     	; 0x46ea <__fp_splitA>
    4708:	08 c0       	rjmp	.+16     	; 0x471a <__fp_splitA+0x30>
    470a:	16 16       	cp	r1, r22
    470c:	17 06       	cpc	r1, r23
    470e:	18 06       	cpc	r1, r24
    4710:	99 1f       	adc	r25, r25
    4712:	f1 cf       	rjmp	.-30     	; 0x46f6 <__fp_splitA+0xc>
    4714:	86 95       	lsr	r24
    4716:	71 05       	cpc	r23, r1
    4718:	61 05       	cpc	r22, r1
    471a:	08 94       	sec
    471c:	08 95       	ret

0000471e <__fp_zero>:
    471e:	e8 94       	clt

00004720 <__fp_szero>:
    4720:	bb 27       	eor	r27, r27
    4722:	66 27       	eor	r22, r22
    4724:	77 27       	eor	r23, r23
    4726:	cb 01       	movw	r24, r22
    4728:	97 f9       	bld	r25, 7
    472a:	08 95       	ret

0000472c <__gesf2>:
    472c:	8a df       	rcall	.-236    	; 0x4642 <__fp_cmp>
    472e:	08 f4       	brcc	.+2      	; 0x4732 <__gesf2+0x6>
    4730:	8f ef       	ldi	r24, 0xFF	; 255
    4732:	08 95       	ret

00004734 <__mulsf3>:
    4734:	0b d0       	rcall	.+22     	; 0x474c <__mulsf3x>
    4736:	c0 cf       	rjmp	.-128    	; 0x46b8 <__fp_round>
    4738:	b1 df       	rcall	.-158    	; 0x469c <__fp_pscA>
    473a:	28 f0       	brcs	.+10     	; 0x4746 <__mulsf3+0x12>
    473c:	b6 df       	rcall	.-148    	; 0x46aa <__fp_pscB>
    473e:	18 f0       	brcs	.+6      	; 0x4746 <__mulsf3+0x12>
    4740:	95 23       	and	r25, r21
    4742:	09 f0       	breq	.+2      	; 0x4746 <__mulsf3+0x12>
    4744:	a2 cf       	rjmp	.-188    	; 0x468a <__fp_inf>
    4746:	a7 cf       	rjmp	.-178    	; 0x4696 <__fp_nan>
    4748:	11 24       	eor	r1, r1
    474a:	ea cf       	rjmp	.-44     	; 0x4720 <__fp_szero>

0000474c <__mulsf3x>:
    474c:	c6 df       	rcall	.-116    	; 0x46da <__fp_split3>
    474e:	a0 f3       	brcs	.-24     	; 0x4738 <__mulsf3+0x4>

00004750 <__mulsf3_pse>:
    4750:	95 9f       	mul	r25, r21
    4752:	d1 f3       	breq	.-12     	; 0x4748 <__mulsf3+0x14>
    4754:	95 0f       	add	r25, r21
    4756:	50 e0       	ldi	r21, 0x00	; 0
    4758:	55 1f       	adc	r21, r21
    475a:	62 9f       	mul	r22, r18
    475c:	f0 01       	movw	r30, r0
    475e:	72 9f       	mul	r23, r18
    4760:	bb 27       	eor	r27, r27
    4762:	f0 0d       	add	r31, r0
    4764:	b1 1d       	adc	r27, r1
    4766:	63 9f       	mul	r22, r19
    4768:	aa 27       	eor	r26, r26
    476a:	f0 0d       	add	r31, r0
    476c:	b1 1d       	adc	r27, r1
    476e:	aa 1f       	adc	r26, r26
    4770:	64 9f       	mul	r22, r20
    4772:	66 27       	eor	r22, r22
    4774:	b0 0d       	add	r27, r0
    4776:	a1 1d       	adc	r26, r1
    4778:	66 1f       	adc	r22, r22
    477a:	82 9f       	mul	r24, r18
    477c:	22 27       	eor	r18, r18
    477e:	b0 0d       	add	r27, r0
    4780:	a1 1d       	adc	r26, r1
    4782:	62 1f       	adc	r22, r18
    4784:	73 9f       	mul	r23, r19
    4786:	b0 0d       	add	r27, r0
    4788:	a1 1d       	adc	r26, r1
    478a:	62 1f       	adc	r22, r18
    478c:	83 9f       	mul	r24, r19
    478e:	a0 0d       	add	r26, r0
    4790:	61 1d       	adc	r22, r1
    4792:	22 1f       	adc	r18, r18
    4794:	74 9f       	mul	r23, r20
    4796:	33 27       	eor	r19, r19
    4798:	a0 0d       	add	r26, r0
    479a:	61 1d       	adc	r22, r1
    479c:	23 1f       	adc	r18, r19
    479e:	84 9f       	mul	r24, r20
    47a0:	60 0d       	add	r22, r0
    47a2:	21 1d       	adc	r18, r1
    47a4:	82 2f       	mov	r24, r18
    47a6:	76 2f       	mov	r23, r22
    47a8:	6a 2f       	mov	r22, r26
    47aa:	11 24       	eor	r1, r1
    47ac:	9f 57       	subi	r25, 0x7F	; 127
    47ae:	50 40       	sbci	r21, 0x00	; 0
    47b0:	8a f0       	brmi	.+34     	; 0x47d4 <__mulsf3_pse+0x84>
    47b2:	e1 f0       	breq	.+56     	; 0x47ec <__mulsf3_pse+0x9c>
    47b4:	88 23       	and	r24, r24
    47b6:	4a f0       	brmi	.+18     	; 0x47ca <__mulsf3_pse+0x7a>
    47b8:	ee 0f       	add	r30, r30
    47ba:	ff 1f       	adc	r31, r31
    47bc:	bb 1f       	adc	r27, r27
    47be:	66 1f       	adc	r22, r22
    47c0:	77 1f       	adc	r23, r23
    47c2:	88 1f       	adc	r24, r24
    47c4:	91 50       	subi	r25, 0x01	; 1
    47c6:	50 40       	sbci	r21, 0x00	; 0
    47c8:	a9 f7       	brne	.-22     	; 0x47b4 <__mulsf3_pse+0x64>
    47ca:	9e 3f       	cpi	r25, 0xFE	; 254
    47cc:	51 05       	cpc	r21, r1
    47ce:	70 f0       	brcs	.+28     	; 0x47ec <__mulsf3_pse+0x9c>
    47d0:	5c cf       	rjmp	.-328    	; 0x468a <__fp_inf>
    47d2:	a6 cf       	rjmp	.-180    	; 0x4720 <__fp_szero>
    47d4:	5f 3f       	cpi	r21, 0xFF	; 255
    47d6:	ec f3       	brlt	.-6      	; 0x47d2 <__mulsf3_pse+0x82>
    47d8:	98 3e       	cpi	r25, 0xE8	; 232
    47da:	dc f3       	brlt	.-10     	; 0x47d2 <__mulsf3_pse+0x82>
    47dc:	86 95       	lsr	r24
    47de:	77 95       	ror	r23
    47e0:	67 95       	ror	r22
    47e2:	b7 95       	ror	r27
    47e4:	f7 95       	ror	r31
    47e6:	e7 95       	ror	r30
    47e8:	9f 5f       	subi	r25, 0xFF	; 255
    47ea:	c1 f7       	brne	.-16     	; 0x47dc <__mulsf3_pse+0x8c>
    47ec:	fe 2b       	or	r31, r30
    47ee:	88 0f       	add	r24, r24
    47f0:	91 1d       	adc	r25, r1
    47f2:	96 95       	lsr	r25
    47f4:	87 95       	ror	r24
    47f6:	97 f9       	bld	r25, 7
    47f8:	08 95       	ret

000047fa <__udivmodhi4>:
    47fa:	aa 1b       	sub	r26, r26
    47fc:	bb 1b       	sub	r27, r27
    47fe:	51 e1       	ldi	r21, 0x11	; 17
    4800:	07 c0       	rjmp	.+14     	; 0x4810 <__udivmodhi4_ep>

00004802 <__udivmodhi4_loop>:
    4802:	aa 1f       	adc	r26, r26
    4804:	bb 1f       	adc	r27, r27
    4806:	a6 17       	cp	r26, r22
    4808:	b7 07       	cpc	r27, r23
    480a:	10 f0       	brcs	.+4      	; 0x4810 <__udivmodhi4_ep>
    480c:	a6 1b       	sub	r26, r22
    480e:	b7 0b       	sbc	r27, r23

00004810 <__udivmodhi4_ep>:
    4810:	88 1f       	adc	r24, r24
    4812:	99 1f       	adc	r25, r25
    4814:	5a 95       	dec	r21
    4816:	a9 f7       	brne	.-22     	; 0x4802 <__udivmodhi4_loop>
    4818:	80 95       	com	r24
    481a:	90 95       	com	r25
    481c:	bc 01       	movw	r22, r24
    481e:	cd 01       	movw	r24, r26
    4820:	08 95       	ret

00004822 <__divmodhi4>:
    4822:	97 fb       	bst	r25, 7
    4824:	09 2e       	mov	r0, r25
    4826:	07 26       	eor	r0, r23
    4828:	0a d0       	rcall	.+20     	; 0x483e <__divmodhi4_neg1>
    482a:	77 fd       	sbrc	r23, 7
    482c:	04 d0       	rcall	.+8      	; 0x4836 <__divmodhi4_neg2>
    482e:	e5 df       	rcall	.-54     	; 0x47fa <__udivmodhi4>
    4830:	06 d0       	rcall	.+12     	; 0x483e <__divmodhi4_neg1>
    4832:	00 20       	and	r0, r0
    4834:	1a f4       	brpl	.+6      	; 0x483c <__divmodhi4_exit>

00004836 <__divmodhi4_neg2>:
    4836:	70 95       	com	r23
    4838:	61 95       	neg	r22
    483a:	7f 4f       	sbci	r23, 0xFF	; 255

0000483c <__divmodhi4_exit>:
    483c:	08 95       	ret

0000483e <__divmodhi4_neg1>:
    483e:	f6 f7       	brtc	.-4      	; 0x483c <__divmodhi4_exit>
    4840:	90 95       	com	r25
    4842:	81 95       	neg	r24
    4844:	9f 4f       	sbci	r25, 0xFF	; 255
    4846:	08 95       	ret

00004848 <__udivmodsi4>:
    4848:	a1 e2       	ldi	r26, 0x21	; 33
    484a:	1a 2e       	mov	r1, r26
    484c:	aa 1b       	sub	r26, r26
    484e:	bb 1b       	sub	r27, r27
    4850:	fd 01       	movw	r30, r26
    4852:	0d c0       	rjmp	.+26     	; 0x486e <__udivmodsi4_ep>

00004854 <__udivmodsi4_loop>:
    4854:	aa 1f       	adc	r26, r26
    4856:	bb 1f       	adc	r27, r27
    4858:	ee 1f       	adc	r30, r30
    485a:	ff 1f       	adc	r31, r31
    485c:	a2 17       	cp	r26, r18
    485e:	b3 07       	cpc	r27, r19
    4860:	e4 07       	cpc	r30, r20
    4862:	f5 07       	cpc	r31, r21
    4864:	20 f0       	brcs	.+8      	; 0x486e <__udivmodsi4_ep>
    4866:	a2 1b       	sub	r26, r18
    4868:	b3 0b       	sbc	r27, r19
    486a:	e4 0b       	sbc	r30, r20
    486c:	f5 0b       	sbc	r31, r21

0000486e <__udivmodsi4_ep>:
    486e:	66 1f       	adc	r22, r22
    4870:	77 1f       	adc	r23, r23
    4872:	88 1f       	adc	r24, r24
    4874:	99 1f       	adc	r25, r25
    4876:	1a 94       	dec	r1
    4878:	69 f7       	brne	.-38     	; 0x4854 <__udivmodsi4_loop>
    487a:	60 95       	com	r22
    487c:	70 95       	com	r23
    487e:	80 95       	com	r24
    4880:	90 95       	com	r25
    4882:	9b 01       	movw	r18, r22
    4884:	ac 01       	movw	r20, r24
    4886:	bd 01       	movw	r22, r26
    4888:	cf 01       	movw	r24, r30
    488a:	08 95       	ret

0000488c <__divmodsi4>:
    488c:	97 fb       	bst	r25, 7
    488e:	09 2e       	mov	r0, r25
    4890:	05 26       	eor	r0, r21
    4892:	0e d0       	rcall	.+28     	; 0x48b0 <__divmodsi4_neg1>
    4894:	57 fd       	sbrc	r21, 7
    4896:	04 d0       	rcall	.+8      	; 0x48a0 <__divmodsi4_neg2>
    4898:	d7 df       	rcall	.-82     	; 0x4848 <__udivmodsi4>
    489a:	0a d0       	rcall	.+20     	; 0x48b0 <__divmodsi4_neg1>
    489c:	00 1c       	adc	r0, r0
    489e:	38 f4       	brcc	.+14     	; 0x48ae <__divmodsi4_exit>

000048a0 <__divmodsi4_neg2>:
    48a0:	50 95       	com	r21
    48a2:	40 95       	com	r20
    48a4:	30 95       	com	r19
    48a6:	21 95       	neg	r18
    48a8:	3f 4f       	sbci	r19, 0xFF	; 255
    48aa:	4f 4f       	sbci	r20, 0xFF	; 255
    48ac:	5f 4f       	sbci	r21, 0xFF	; 255

000048ae <__divmodsi4_exit>:
    48ae:	08 95       	ret

000048b0 <__divmodsi4_neg1>:
    48b0:	f6 f7       	brtc	.-4      	; 0x48ae <__divmodsi4_exit>
    48b2:	90 95       	com	r25
    48b4:	80 95       	com	r24
    48b6:	70 95       	com	r23
    48b8:	61 95       	neg	r22
    48ba:	7f 4f       	sbci	r23, 0xFF	; 255
    48bc:	8f 4f       	sbci	r24, 0xFF	; 255
    48be:	9f 4f       	sbci	r25, 0xFF	; 255
    48c0:	08 95       	ret

000048c2 <_exit>:
    48c2:	f8 94       	cli

000048c4 <__stop_program>:
    48c4:	ff cf       	rjmp	.-2      	; 0x48c4 <__stop_program>
