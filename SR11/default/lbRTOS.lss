
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009a  00800200  00006108  0000619c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006108  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fe9  0080029a  0080029a  00006236  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00006236  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001882  00000000  00000000  000063d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000059d7  00000000  00000000  00007c58  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016eb  00000000  00000000  0000d62f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000048be  00000000  00000000  0000ed1a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001230  00000000  00000000  000135d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000024d9  00000000  00000000  00014808  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002d3e  00000000  00000000  00016ce1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00019a1f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__ctors_end>
       4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
       8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
       c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      10:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      14:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      18:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      1c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      20:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      24:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      28:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      2c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      30:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      34:	0c 94 af 1e 	jmp	0x3d5e	; 0x3d5e <__vector_13>
      38:	0c 94 dc 1e 	jmp	0x3db8	; 0x3db8 <__vector_14>
      3c:	0c 94 ce 1c 	jmp	0x399c	; 0x399c <__vector_15>
      40:	0c 94 28 1e 	jmp	0x3c50	; 0x3c50 <__vector_16>
      44:	0c 94 fc 17 	jmp	0x2ff8	; 0x2ff8 <__vector_17>
      48:	0c 94 55 1e 	jmp	0x3caa	; 0x3caa <__vector_18>
      4c:	0c 94 82 1e 	jmp	0x3d04	; 0x3d04 <__vector_19>
      50:	0c 94 8e 1c 	jmp	0x391c	; 0x391c <__vector_20>
      54:	0c 94 ce 1d 	jmp	0x3b9c	; 0x3b9c <__vector_21>
      58:	0c 94 fb 1d 	jmp	0x3bf6	; 0x3bf6 <__vector_22>
      5c:	0c 94 3b 1c 	jmp	0x3876	; 0x3876 <__vector_23>
      60:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      64:	0c 94 a5 22 	jmp	0x454a	; 0x454a <__vector_25>
      68:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      6c:	0c 94 02 24 	jmp	0x4804	; 0x4804 <__vector_27>
      70:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      74:	0c 94 bc 26 	jmp	0x4d78	; 0x4d78 <__vector_29>
      78:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      7c:	0c 94 09 1f 	jmp	0x3e12	; 0x3e12 <__vector_31>
      80:	0c 94 36 1f 	jmp	0x3e6c	; 0x3e6c <__vector_32>
      84:	0c 94 63 1f 	jmp	0x3ec6	; 0x3ec6 <__vector_33>
      88:	0c 94 90 1f 	jmp	0x3f20	; 0x3f20 <__vector_34>
      8c:	0c 94 0e 1d 	jmp	0x3a1c	; 0x3a1c <__vector_35>
      90:	0c 94 80 22 	jmp	0x4500	; 0x4500 <__vector_36>
      94:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      98:	0c 94 dd 23 	jmp	0x47ba	; 0x47ba <__vector_38>
      9c:	0c 94 da 2a 	jmp	0x55b4	; 0x55b4 <__vector_39>
      a0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      a4:	0c 94 bd 1f 	jmp	0x3f7a	; 0x3f7a <__vector_41>
      a8:	0c 94 ea 1f 	jmp	0x3fd4	; 0x3fd4 <__vector_42>
      ac:	0c 94 17 20 	jmp	0x402e	; 0x402e <__vector_43>
      b0:	0c 94 44 20 	jmp	0x4088	; 0x4088 <__vector_44>
      b4:	0c 94 4e 1d 	jmp	0x3a9c	; 0x3a9c <__vector_45>
      b8:	0c 94 71 20 	jmp	0x40e2	; 0x40e2 <__vector_46>
      bc:	0c 94 9e 20 	jmp	0x413c	; 0x413c <__vector_47>
      c0:	0c 94 cb 20 	jmp	0x4196	; 0x4196 <__vector_48>
      c4:	0c 94 f8 20 	jmp	0x41f0	; 0x41f0 <__vector_49>
      c8:	0c 94 8e 1d 	jmp	0x3b1c	; 0x3b1c <__vector_50>
      cc:	0c 94 5b 22 	jmp	0x44b6	; 0x44b6 <__vector_51>
      d0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      d4:	0c 94 b8 23 	jmp	0x4770	; 0x4770 <__vector_53>
      d8:	0c 94 36 22 	jmp	0x446c	; 0x446c <__vector_54>
      dc:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
      e0:	0c 94 93 23 	jmp	0x4726	; 0x4726 <__vector_56>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <retConv_s16+0x92>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__c.3381>:
     166:	44 45 41 54 48 0a 00                                DEATH..

0000016d <__c.3171>:
     16d:	25 64 0a 00                                         %d..

00000171 <__c.3072>:
     171:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
     181:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

0000018c <__c.3067>:
     18c:	2e 00                                               ..

0000018e <__c.3065>:
     18e:	0d 0a 53 79 73 74 65 6d 20 57 61 72 6d 65 64 20     ..System Warmed 
     19e:	55 70 00                                            Up.

000001a1 <__c.3036>:
     1a1:	57 52 0a 00                                         WR..

000001a5 <__c.3005>:
     1a5:	57 52 0a 00                                         WR..

000001a9 <TimerPrescaleFactor>:
     1a9:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

000001b5 <Timer2PrescaleFactor>:
     1b5:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

000001c5 <__c.1991>:
     1c5:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

000001d6 <HexChars>:
     1d6:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

000001e8 <__ctors_end>:
     1e8:	11 24       	eor	r1, r1
     1ea:	1f be       	out	0x3f, r1	; 63
     1ec:	cf ef       	ldi	r28, 0xFF	; 255
     1ee:	d1 e2       	ldi	r29, 0x21	; 33
     1f0:	de bf       	out	0x3e, r29	; 62
     1f2:	cd bf       	out	0x3d, r28	; 61

000001f4 <__do_copy_data>:
     1f4:	12 e0       	ldi	r17, 0x02	; 2
     1f6:	a0 e0       	ldi	r26, 0x00	; 0
     1f8:	b2 e0       	ldi	r27, 0x02	; 2
     1fa:	e8 e0       	ldi	r30, 0x08	; 8
     1fc:	f1 e6       	ldi	r31, 0x61	; 97
     1fe:	02 c0       	rjmp	.+4      	; 0x204 <.do_copy_data_start>

00000200 <.do_copy_data_loop>:
     200:	05 90       	lpm	r0, Z+
     202:	0d 92       	st	X+, r0

00000204 <.do_copy_data_start>:
     204:	aa 39       	cpi	r26, 0x9A	; 154
     206:	b1 07       	cpc	r27, r17
     208:	d9 f7       	brne	.-10     	; 0x200 <.do_copy_data_loop>

0000020a <__do_clear_bss>:
     20a:	12 e1       	ldi	r17, 0x12	; 18
     20c:	aa e9       	ldi	r26, 0x9A	; 154
     20e:	b2 e0       	ldi	r27, 0x02	; 2
     210:	01 c0       	rjmp	.+2      	; 0x214 <.do_clear_bss_start>

00000212 <.do_clear_bss_loop>:
     212:	1d 92       	st	X+, r1

00000214 <.do_clear_bss_start>:
     214:	a3 38       	cpi	r26, 0x83	; 131
     216:	b1 07       	cpc	r27, r17
     218:	e1 f7       	brne	.-8      	; 0x212 <.do_clear_bss_loop>
     21a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <main>
     21e:	0c 94 06 2c 	jmp	0x580c	; 0x580c <exit>

00000222 <__bad_interrupt>:
     222:	0c 94 25 21 	jmp	0x424a	; 0x424a <__vector_default>

00000226 <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     226:	89 30       	cpi	r24, 0x09	; 9
     228:	49 f4       	brne	.+18     	; 0x23c <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     22a:	80 91 80 00 	lds	r24, 0x0080
     22e:	82 60       	ori	r24, 0x02	; 2
     230:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     234:	80 91 80 00 	lds	r24, 0x0080
     238:	8e 7f       	andi	r24, 0xFE	; 254
     23a:	0e c0       	rjmp	.+28     	; 0x258 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     23c:	8a 30       	cpi	r24, 0x0A	; 10
     23e:	21 f4       	brne	.+8      	; 0x248 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     240:	80 91 80 00 	lds	r24, 0x0080
     244:	82 60       	ori	r24, 0x02	; 2
     246:	03 c0       	rjmp	.+6      	; 0x24e <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     248:	80 91 80 00 	lds	r24, 0x0080
     24c:	8d 7f       	andi	r24, 0xFD	; 253
     24e:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     252:	80 91 80 00 	lds	r24, 0x0080
     256:	81 60       	ori	r24, 0x01	; 1
     258:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     25c:	10 92 8b 00 	sts	0x008B, r1
     260:	10 92 8a 00 	sts	0x008A, r1
}
     264:	08 95       	ret

00000266 <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     266:	89 30       	cpi	r24, 0x09	; 9
     268:	49 f4       	brne	.+18     	; 0x27c <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     26a:	80 91 b0 00 	lds	r24, 0x00B0
     26e:	82 60       	ori	r24, 0x02	; 2
     270:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     274:	80 91 b0 00 	lds	r24, 0x00B0
     278:	8e 7f       	andi	r24, 0xFE	; 254
     27a:	0e c0       	rjmp	.+28     	; 0x298 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     27c:	8a 30       	cpi	r24, 0x0A	; 10
     27e:	21 f4       	brne	.+8      	; 0x288 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     280:	80 91 b0 00 	lds	r24, 0x00B0
     284:	82 60       	ori	r24, 0x02	; 2
     286:	03 c0       	rjmp	.+6      	; 0x28e <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     288:	80 91 b0 00 	lds	r24, 0x00B0
     28c:	8d 7f       	andi	r24, 0xFD	; 253
     28e:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     292:	80 91 b0 00 	lds	r24, 0x00B0
     296:	81 60       	ori	r24, 0x01	; 1
     298:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     29c:	10 92 b4 00 	sts	0x00B4, r1
}
     2a0:	08 95       	ret

000002a2 <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2a2:	89 30       	cpi	r24, 0x09	; 9
     2a4:	49 f4       	brne	.+18     	; 0x2b8 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     2a6:	80 91 90 00 	lds	r24, 0x0090
     2aa:	82 60       	ori	r24, 0x02	; 2
     2ac:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     2b0:	80 91 90 00 	lds	r24, 0x0090
     2b4:	8e 7f       	andi	r24, 0xFE	; 254
     2b6:	0e c0       	rjmp	.+28     	; 0x2d4 <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     2b8:	8a 30       	cpi	r24, 0x0A	; 10
     2ba:	21 f4       	brne	.+8      	; 0x2c4 <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     2bc:	80 91 90 00 	lds	r24, 0x0090
     2c0:	82 60       	ori	r24, 0x02	; 2
     2c2:	03 c0       	rjmp	.+6      	; 0x2ca <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     2c4:	80 91 90 00 	lds	r24, 0x0090
     2c8:	8d 7f       	andi	r24, 0xFD	; 253
     2ca:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     2ce:	80 91 90 00 	lds	r24, 0x0090
     2d2:	81 60       	ori	r24, 0x01	; 1
     2d4:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     2d8:	10 92 99 00 	sts	0x0099, r1
     2dc:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2e0:	08 95       	ret

000002e2 <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     2e2:	89 30       	cpi	r24, 0x09	; 9
     2e4:	49 f4       	brne	.+18     	; 0x2f8 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     2e6:	80 91 91 00 	lds	r24, 0x0091
     2ea:	82 60       	ori	r24, 0x02	; 2
     2ec:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     2f0:	80 91 91 00 	lds	r24, 0x0091
     2f4:	8e 7f       	andi	r24, 0xFE	; 254
     2f6:	0e c0       	rjmp	.+28     	; 0x314 <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     2f8:	8a 30       	cpi	r24, 0x0A	; 10
     2fa:	21 f4       	brne	.+8      	; 0x304 <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     2fc:	80 91 91 00 	lds	r24, 0x0091
     300:	82 60       	ori	r24, 0x02	; 2
     302:	03 c0       	rjmp	.+6      	; 0x30a <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     304:	80 91 91 00 	lds	r24, 0x0091
     308:	8d 7f       	andi	r24, 0xFD	; 253
     30a:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     30e:	80 91 91 00 	lds	r24, 0x0091
     312:	81 60       	ori	r24, 0x01	; 1
     314:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     318:	10 92 9b 00 	sts	0x009B, r1
     31c:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     320:	08 95       	ret

00000322 <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     322:	89 30       	cpi	r24, 0x09	; 9
     324:	49 f4       	brne	.+18     	; 0x338 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     326:	80 91 92 00 	lds	r24, 0x0092
     32a:	82 60       	ori	r24, 0x02	; 2
     32c:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     330:	80 91 92 00 	lds	r24, 0x0092
     334:	8e 7f       	andi	r24, 0xFE	; 254
     336:	0e c0       	rjmp	.+28     	; 0x354 <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     338:	8a 30       	cpi	r24, 0x0A	; 10
     33a:	21 f4       	brne	.+8      	; 0x344 <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     33c:	80 91 92 00 	lds	r24, 0x0092
     340:	82 60       	ori	r24, 0x02	; 2
     342:	03 c0       	rjmp	.+6      	; 0x34a <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     344:	80 91 92 00 	lds	r24, 0x0092
     348:	8d 7f       	andi	r24, 0xFD	; 253
     34a:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     34e:	80 91 92 00 	lds	r24, 0x0092
     352:	81 60       	ori	r24, 0x01	; 1
     354:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     358:	10 92 9d 00 	sts	0x009D, r1
     35c:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     360:	08 95       	ret

00000362 <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     362:	89 30       	cpi	r24, 0x09	; 9
     364:	49 f4       	brne	.+18     	; 0x378 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     366:	80 91 a0 00 	lds	r24, 0x00A0
     36a:	82 60       	ori	r24, 0x02	; 2
     36c:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     370:	80 91 a0 00 	lds	r24, 0x00A0
     374:	8e 7f       	andi	r24, 0xFE	; 254
     376:	0e c0       	rjmp	.+28     	; 0x394 <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     378:	8a 30       	cpi	r24, 0x0A	; 10
     37a:	21 f4       	brne	.+8      	; 0x384 <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     37c:	80 91 a0 00 	lds	r24, 0x00A0
     380:	82 60       	ori	r24, 0x02	; 2
     382:	03 c0       	rjmp	.+6      	; 0x38a <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     384:	80 91 a0 00 	lds	r24, 0x00A0
     388:	8d 7f       	andi	r24, 0xFD	; 253
     38a:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     38e:	80 91 a0 00 	lds	r24, 0x00A0
     392:	81 60       	ori	r24, 0x01	; 1
     394:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     398:	10 92 a9 00 	sts	0x00A9, r1
     39c:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3a0:	08 95       	ret

000003a2 <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3a2:	89 30       	cpi	r24, 0x09	; 9
     3a4:	49 f4       	brne	.+18     	; 0x3b8 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     3a6:	80 91 a1 00 	lds	r24, 0x00A1
     3aa:	82 60       	ori	r24, 0x02	; 2
     3ac:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     3b0:	80 91 a1 00 	lds	r24, 0x00A1
     3b4:	8e 7f       	andi	r24, 0xFE	; 254
     3b6:	0e c0       	rjmp	.+28     	; 0x3d4 <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     3b8:	8a 30       	cpi	r24, 0x0A	; 10
     3ba:	21 f4       	brne	.+8      	; 0x3c4 <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     3bc:	80 91 a1 00 	lds	r24, 0x00A1
     3c0:	82 60       	ori	r24, 0x02	; 2
     3c2:	03 c0       	rjmp	.+6      	; 0x3ca <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     3c4:	80 91 a1 00 	lds	r24, 0x00A1
     3c8:	8d 7f       	andi	r24, 0xFD	; 253
     3ca:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     3ce:	80 91 a1 00 	lds	r24, 0x00A1
     3d2:	81 60       	ori	r24, 0x01	; 1
     3d4:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     3d8:	10 92 ab 00 	sts	0x00AB, r1
     3dc:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     3e0:	08 95       	ret

000003e2 <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     3e2:	89 30       	cpi	r24, 0x09	; 9
     3e4:	49 f4       	brne	.+18     	; 0x3f8 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     3e6:	80 91 a0 00 	lds	r24, 0x00A0
     3ea:	82 60       	ori	r24, 0x02	; 2
     3ec:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     3f0:	80 91 a0 00 	lds	r24, 0x00A0
     3f4:	8e 7f       	andi	r24, 0xFE	; 254
     3f6:	0e c0       	rjmp	.+28     	; 0x414 <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     3f8:	8a 30       	cpi	r24, 0x0A	; 10
     3fa:	21 f4       	brne	.+8      	; 0x404 <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     3fc:	80 91 a0 00 	lds	r24, 0x00A0
     400:	82 60       	ori	r24, 0x02	; 2
     402:	03 c0       	rjmp	.+6      	; 0x40a <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     404:	80 91 a0 00 	lds	r24, 0x00A0
     408:	8d 7f       	andi	r24, 0xFD	; 253
     40a:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     40e:	80 91 a0 00 	lds	r24, 0x00A0
     412:	81 60       	ori	r24, 0x01	; 1
     414:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     418:	10 92 ad 00 	sts	0x00AD, r1
     41c:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     420:	08 95       	ret

00000422 <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     422:	e0 e8       	ldi	r30, 0x80	; 128
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	20 81       	ld	r18, Z
     428:	2e 7f       	andi	r18, 0xFE	; 254
     42a:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     42c:	20 81       	ld	r18, Z
     42e:	22 60       	ori	r18, 0x02	; 2
     430:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     432:	e1 e8       	ldi	r30, 0x81	; 129
     434:	f0 e0       	ldi	r31, 0x00	; 0
     436:	20 81       	ld	r18, Z
     438:	28 60       	ori	r18, 0x08	; 8
     43a:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     43c:	20 81       	ld	r18, Z
     43e:	20 61       	ori	r18, 0x10	; 16
     440:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     442:	90 93 87 00 	sts	0x0087, r25
     446:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     44a:	10 92 89 00 	sts	0x0089, r1
     44e:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     452:	10 92 8b 00 	sts	0x008B, r1
     456:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     45a:	10 92 8d 00 	sts	0x008D, r1
     45e:	10 92 8c 00 	sts	0x008C, r1
}
     462:	08 95       	ret

00000464 <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     464:	e0 e9       	ldi	r30, 0x90	; 144
     466:	f0 e0       	ldi	r31, 0x00	; 0
     468:	20 81       	ld	r18, Z
     46a:	2e 7f       	andi	r18, 0xFE	; 254
     46c:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     46e:	20 81       	ld	r18, Z
     470:	22 60       	ori	r18, 0x02	; 2
     472:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     474:	e1 e9       	ldi	r30, 0x91	; 145
     476:	f0 e0       	ldi	r31, 0x00	; 0
     478:	20 81       	ld	r18, Z
     47a:	28 60       	ori	r18, 0x08	; 8
     47c:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     47e:	20 81       	ld	r18, Z
     480:	20 61       	ori	r18, 0x10	; 16
     482:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     484:	90 93 97 00 	sts	0x0097, r25
     488:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     48c:	10 92 99 00 	sts	0x0099, r1
     490:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     494:	10 92 9b 00 	sts	0x009B, r1
     498:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     49c:	10 92 9d 00 	sts	0x009D, r1
     4a0:	10 92 9c 00 	sts	0x009C, r1
}
     4a4:	08 95       	ret

000004a6 <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     4a6:	e0 ea       	ldi	r30, 0xA0	; 160
     4a8:	f0 e0       	ldi	r31, 0x00	; 0
     4aa:	20 81       	ld	r18, Z
     4ac:	2e 7f       	andi	r18, 0xFE	; 254
     4ae:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     4b0:	20 81       	ld	r18, Z
     4b2:	22 60       	ori	r18, 0x02	; 2
     4b4:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     4b6:	e1 ea       	ldi	r30, 0xA1	; 161
     4b8:	f0 e0       	ldi	r31, 0x00	; 0
     4ba:	20 81       	ld	r18, Z
     4bc:	28 60       	ori	r18, 0x08	; 8
     4be:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     4c0:	20 81       	ld	r18, Z
     4c2:	20 61       	ori	r18, 0x10	; 16
     4c4:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     4c6:	90 93 a7 00 	sts	0x00A7, r25
     4ca:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     4ce:	10 92 a9 00 	sts	0x00A9, r1
     4d2:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     4d6:	10 92 ab 00 	sts	0x00AB, r1
     4da:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     4de:	10 92 ad 00 	sts	0x00AD, r1
     4e2:	10 92 ac 00 	sts	0x00AC, r1
}
     4e6:	08 95       	ret

000004e8 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     4e8:	e0 e8       	ldi	r30, 0x80	; 128
     4ea:	f0 e0       	ldi	r31, 0x00	; 0
     4ec:	80 81       	ld	r24, Z
     4ee:	80 62       	ori	r24, 0x20	; 32
     4f0:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4f2:	80 81       	ld	r24, Z
     4f4:	8f 7e       	andi	r24, 0xEF	; 239
     4f6:	80 83       	st	Z, r24
}
     4f8:	08 95       	ret

000004fa <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     4fa:	e0 eb       	ldi	r30, 0xB0	; 176
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	80 81       	ld	r24, Z
     500:	80 62       	ori	r24, 0x20	; 32
     502:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     504:	80 81       	ld	r24, Z
     506:	8f 7e       	andi	r24, 0xEF	; 239
     508:	80 83       	st	Z, r24
}
     50a:	08 95       	ret

0000050c <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     50c:	e0 e9       	ldi	r30, 0x90	; 144
     50e:	f0 e0       	ldi	r31, 0x00	; 0
     510:	80 81       	ld	r24, Z
     512:	80 68       	ori	r24, 0x80	; 128
     514:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     516:	80 81       	ld	r24, Z
     518:	8f 7b       	andi	r24, 0xBF	; 191
     51a:	80 83       	st	Z, r24
}
     51c:	08 95       	ret

0000051e <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     51e:	e0 e9       	ldi	r30, 0x90	; 144
     520:	f0 e0       	ldi	r31, 0x00	; 0
     522:	80 81       	ld	r24, Z
     524:	80 62       	ori	r24, 0x20	; 32
     526:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     528:	80 81       	ld	r24, Z
     52a:	8f 7e       	andi	r24, 0xEF	; 239
     52c:	80 83       	st	Z, r24
}
     52e:	08 95       	ret

00000530 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     530:	e0 e9       	ldi	r30, 0x90	; 144
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	80 81       	ld	r24, Z
     536:	88 60       	ori	r24, 0x08	; 8
     538:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     53a:	80 81       	ld	r24, Z
     53c:	8b 7f       	andi	r24, 0xFB	; 251
     53e:	80 83       	st	Z, r24
}
     540:	08 95       	ret

00000542 <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     542:	e0 ea       	ldi	r30, 0xA0	; 160
     544:	f0 e0       	ldi	r31, 0x00	; 0
     546:	80 81       	ld	r24, Z
     548:	80 68       	ori	r24, 0x80	; 128
     54a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     54c:	80 81       	ld	r24, Z
     54e:	8f 7b       	andi	r24, 0xBF	; 191
     550:	80 83       	st	Z, r24
}
     552:	08 95       	ret

00000554 <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     554:	e0 ea       	ldi	r30, 0xA0	; 160
     556:	f0 e0       	ldi	r31, 0x00	; 0
     558:	80 81       	ld	r24, Z
     55a:	80 62       	ori	r24, 0x20	; 32
     55c:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     55e:	80 81       	ld	r24, Z
     560:	8f 7e       	andi	r24, 0xEF	; 239
     562:	80 83       	st	Z, r24
}
     564:	08 95       	ret

00000566 <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     566:	e0 ea       	ldi	r30, 0xA0	; 160
     568:	f0 e0       	ldi	r31, 0x00	; 0
     56a:	80 81       	ld	r24, Z
     56c:	88 60       	ori	r24, 0x08	; 8
     56e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     570:	80 81       	ld	r24, Z
     572:	8b 7f       	andi	r24, 0xFB	; 251
     574:	80 83       	st	Z, r24
}
     576:	08 95       	ret

00000578 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     578:	e0 e8       	ldi	r30, 0x80	; 128
     57a:	f0 e0       	ldi	r31, 0x00	; 0
     57c:	80 81       	ld	r24, Z
     57e:	8f 7d       	andi	r24, 0xDF	; 223
     580:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     582:	80 81       	ld	r24, Z
     584:	8f 7e       	andi	r24, 0xEF	; 239
     586:	80 83       	st	Z, r24
}
     588:	08 95       	ret

0000058a <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     58a:	e0 eb       	ldi	r30, 0xB0	; 176
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	80 81       	ld	r24, Z
     590:	8f 7d       	andi	r24, 0xDF	; 223
     592:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     594:	80 81       	ld	r24, Z
     596:	8f 7e       	andi	r24, 0xEF	; 239
     598:	80 83       	st	Z, r24
}
     59a:	08 95       	ret

0000059c <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     59c:	e0 e9       	ldi	r30, 0x90	; 144
     59e:	f0 e0       	ldi	r31, 0x00	; 0
     5a0:	80 81       	ld	r24, Z
     5a2:	8f 77       	andi	r24, 0x7F	; 127
     5a4:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     5a6:	80 81       	ld	r24, Z
     5a8:	8f 7b       	andi	r24, 0xBF	; 191
     5aa:	80 83       	st	Z, r24
}
     5ac:	08 95       	ret

000005ae <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     5ae:	e0 e9       	ldi	r30, 0x90	; 144
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	80 81       	ld	r24, Z
     5b4:	8f 7d       	andi	r24, 0xDF	; 223
     5b6:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     5b8:	80 81       	ld	r24, Z
     5ba:	8f 7e       	andi	r24, 0xEF	; 239
     5bc:	80 83       	st	Z, r24
}
     5be:	08 95       	ret

000005c0 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5c0:	e0 e9       	ldi	r30, 0x90	; 144
     5c2:	f0 e0       	ldi	r31, 0x00	; 0
     5c4:	80 81       	ld	r24, Z
     5c6:	87 7f       	andi	r24, 0xF7	; 247
     5c8:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5ca:	80 81       	ld	r24, Z
     5cc:	8b 7f       	andi	r24, 0xFB	; 251
     5ce:	80 83       	st	Z, r24
}
     5d0:	08 95       	ret

000005d2 <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5d2:	e0 ea       	ldi	r30, 0xA0	; 160
     5d4:	f0 e0       	ldi	r31, 0x00	; 0
     5d6:	80 81       	ld	r24, Z
     5d8:	8f 77       	andi	r24, 0x7F	; 127
     5da:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5dc:	80 81       	ld	r24, Z
     5de:	8f 7b       	andi	r24, 0xBF	; 191
     5e0:	80 83       	st	Z, r24
}
     5e2:	08 95       	ret

000005e4 <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f0 e0       	ldi	r31, 0x00	; 0
     5e8:	80 81       	ld	r24, Z
     5ea:	8f 7d       	andi	r24, 0xDF	; 223
     5ec:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5ee:	80 81       	ld	r24, Z
     5f0:	8f 7e       	andi	r24, 0xEF	; 239
     5f2:	80 83       	st	Z, r24
}
     5f4:	08 95       	ret

000005f6 <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5f6:	e0 ea       	ldi	r30, 0xA0	; 160
     5f8:	f0 e0       	ldi	r31, 0x00	; 0
     5fa:	80 81       	ld	r24, Z
     5fc:	87 7f       	andi	r24, 0xF7	; 247
     5fe:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     600:	80 81       	ld	r24, Z
     602:	8b 7f       	andi	r24, 0xFB	; 251
     604:	80 83       	st	Z, r24
}
     606:	08 95       	ret

00000608 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     608:	e0 e8       	ldi	r30, 0x80	; 128
     60a:	f0 e0       	ldi	r31, 0x00	; 0
     60c:	80 81       	ld	r24, Z
     60e:	8d 7f       	andi	r24, 0xFD	; 253
     610:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     612:	80 81       	ld	r24, Z
     614:	8e 7f       	andi	r24, 0xFE	; 254
     616:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     618:	80 81       	ld	r24, Z
     61a:	8f 7d       	andi	r24, 0xDF	; 223
     61c:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     61e:	80 81       	ld	r24, Z
     620:	8f 7e       	andi	r24, 0xEF	; 239
     622:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     624:	08 95       	ret

00000626 <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     626:	e0 eb       	ldi	r30, 0xB0	; 176
     628:	f0 e0       	ldi	r31, 0x00	; 0
     62a:	80 81       	ld	r24, Z
     62c:	8d 7f       	andi	r24, 0xFD	; 253
     62e:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     630:	80 81       	ld	r24, Z
     632:	8e 7f       	andi	r24, 0xFE	; 254
     634:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     636:	80 81       	ld	r24, Z
     638:	8f 7d       	andi	r24, 0xDF	; 223
     63a:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     63c:	80 81       	ld	r24, Z
     63e:	8f 7e       	andi	r24, 0xEF	; 239
     640:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     642:	08 95       	ret

00000644 <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     644:	e0 e9       	ldi	r30, 0x90	; 144
     646:	f0 e0       	ldi	r31, 0x00	; 0
     648:	80 81       	ld	r24, Z
     64a:	8d 7f       	andi	r24, 0xFD	; 253
     64c:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     64e:	80 81       	ld	r24, Z
     650:	8e 7f       	andi	r24, 0xFE	; 254
     652:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     654:	80 81       	ld	r24, Z
     656:	8f 77       	andi	r24, 0x7F	; 127
     658:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     65a:	80 81       	ld	r24, Z
     65c:	8f 7b       	andi	r24, 0xBF	; 191
     65e:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     660:	80 81       	ld	r24, Z
     662:	8f 7d       	andi	r24, 0xDF	; 223
     664:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     666:	80 81       	ld	r24, Z
     668:	8f 7e       	andi	r24, 0xEF	; 239
     66a:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     66c:	80 81       	ld	r24, Z
     66e:	87 7f       	andi	r24, 0xF7	; 247
     670:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     672:	80 81       	ld	r24, Z
     674:	8b 7f       	andi	r24, 0xFB	; 251
     676:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     678:	08 95       	ret

0000067a <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     67a:	e0 ea       	ldi	r30, 0xA0	; 160
     67c:	f0 e0       	ldi	r31, 0x00	; 0
     67e:	80 81       	ld	r24, Z
     680:	8d 7f       	andi	r24, 0xFD	; 253
     682:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     684:	80 81       	ld	r24, Z
     686:	8e 7f       	andi	r24, 0xFE	; 254
     688:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     68a:	80 81       	ld	r24, Z
     68c:	8f 77       	andi	r24, 0x7F	; 127
     68e:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     690:	80 81       	ld	r24, Z
     692:	8f 7b       	andi	r24, 0xBF	; 191
     694:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     696:	80 81       	ld	r24, Z
     698:	8f 7d       	andi	r24, 0xDF	; 223
     69a:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     69c:	80 81       	ld	r24, Z
     69e:	8f 7e       	andi	r24, 0xEF	; 239
     6a0:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     6a2:	80 81       	ld	r24, Z
     6a4:	87 7f       	andi	r24, 0xF7	; 247
     6a6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     6a8:	80 81       	ld	r24, Z
     6aa:	8b 7f       	andi	r24, 0xFB	; 251
     6ac:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     6ae:	08 95       	ret

000006b0 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     6b0:	90 93 8b 00 	sts	0x008B, r25
     6b4:	80 93 8a 00 	sts	0x008A, r24
     6b8:	08 95       	ret

000006ba <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     6ba:	80 93 b4 00 	sts	0x00B4, r24
     6be:	08 95       	ret

000006c0 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     6c0:	90 93 99 00 	sts	0x0099, r25
     6c4:	80 93 98 00 	sts	0x0098, r24
     6c8:	08 95       	ret

000006ca <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     6ca:	90 93 9b 00 	sts	0x009B, r25
     6ce:	80 93 9a 00 	sts	0x009A, r24
     6d2:	08 95       	ret

000006d4 <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     6d4:	90 93 9d 00 	sts	0x009D, r25
     6d8:	80 93 9c 00 	sts	0x009C, r24
     6dc:	08 95       	ret

000006de <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     6de:	90 93 a9 00 	sts	0x00A9, r25
     6e2:	80 93 a8 00 	sts	0x00A8, r24
     6e6:	08 95       	ret

000006e8 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     6e8:	90 93 ab 00 	sts	0x00AB, r25
     6ec:	80 93 aa 00 	sts	0x00AA, r24
     6f0:	08 95       	ret

000006f2 <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     6f2:	90 93 ad 00 	sts	0x00AD, r25
     6f6:	80 93 ac 00 	sts	0x00AC, r24
     6fa:	08 95       	ret

000006fc <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     6fc:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     6fe:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     700:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     704:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     708:	9f ef       	ldi	r25, 0xFF	; 255
     70a:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     70c:	80 e4       	ldi	r24, 0x40	; 64
     70e:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     710:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     712:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     714:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     716:	83 ef       	ldi	r24, 0xF3	; 243
     718:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     71a:	8e ef       	ldi	r24, 0xFE	; 254
     71c:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     71e:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     720:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     722:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     726:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     72a:	08 95       	ret

0000072c <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     72c:	08 95       	ret

0000072e <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     72e:	2e 9a       	sbi	0x05, 6	; 5
     730:	08 95       	ret

00000732 <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     732:	2e 98       	cbi	0x05, 6	; 5
     734:	08 95       	ret

00000736 <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     736:	22 b3       	in	r18, 0x12	; 18
     738:	30 e0       	ldi	r19, 0x00	; 0
     73a:	85 e0       	ldi	r24, 0x05	; 5
     73c:	36 95       	lsr	r19
     73e:	27 95       	ror	r18
     740:	8a 95       	dec	r24
     742:	e1 f7       	brne	.-8      	; 0x73c <button_pressed+0x6>
     744:	20 95       	com	r18
     746:	30 95       	com	r19
     748:	21 70       	andi	r18, 0x01	; 1
     74a:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     74c:	c9 01       	movw	r24, r18
     74e:	08 95       	ret

00000750 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     750:	97 fd       	sbrc	r25, 7
     752:	10 c0       	rjmp	.+32     	; 0x774 <cos_SoR+0x24>
		return angtable[degrees/5];
     754:	25 e0       	ldi	r18, 0x05	; 5
     756:	30 e0       	ldi	r19, 0x00	; 0
     758:	40 e0       	ldi	r20, 0x00	; 0
     75a:	50 e0       	ldi	r21, 0x00	; 0
     75c:	0e 94 67 30 	call	0x60ce	; 0x60ce <__divmodsi4>
     760:	da 01       	movw	r26, r20
     762:	c9 01       	movw	r24, r18
     764:	88 0f       	add	r24, r24
     766:	99 1f       	adc	r25, r25
     768:	80 50       	subi	r24, 0x00	; 0
     76a:	9e 4f       	sbci	r25, 0xFE	; 254
     76c:	fc 01       	movw	r30, r24
     76e:	20 81       	ld	r18, Z
     770:	31 81       	ldd	r19, Z+1	; 0x01
     772:	17 c0       	rjmp	.+46     	; 0x7a2 <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     774:	25 e0       	ldi	r18, 0x05	; 5
     776:	30 e0       	ldi	r19, 0x00	; 0
     778:	40 e0       	ldi	r20, 0x00	; 0
     77a:	50 e0       	ldi	r21, 0x00	; 0
     77c:	0e 94 67 30 	call	0x60ce	; 0x60ce <__divmodsi4>
     780:	da 01       	movw	r26, r20
     782:	c9 01       	movw	r24, r18
     784:	88 5b       	subi	r24, 0xB8	; 184
     786:	9f 4f       	sbci	r25, 0xFF	; 255
     788:	af 4f       	sbci	r26, 0xFF	; 255
     78a:	bf 4f       	sbci	r27, 0xFF	; 255
     78c:	88 0f       	add	r24, r24
     78e:	99 1f       	adc	r25, r25
     790:	80 50       	subi	r24, 0x00	; 0
     792:	9e 4f       	sbci	r25, 0xFE	; 254
     794:	fc 01       	movw	r30, r24
     796:	80 81       	ld	r24, Z
     798:	91 81       	ldd	r25, Z+1	; 0x01
     79a:	22 27       	eor	r18, r18
     79c:	33 27       	eor	r19, r19
     79e:	28 1b       	sub	r18, r24
     7a0:	39 0b       	sbc	r19, r25
	}
     7a2:	c9 01       	movw	r24, r18
     7a4:	08 95       	ret

000007a6 <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     7a6:	6a 55       	subi	r22, 0x5A	; 90
     7a8:	70 40       	sbci	r23, 0x00	; 0
     7aa:	80 40       	sbci	r24, 0x00	; 0
     7ac:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     7ae:	97 fd       	sbrc	r25, 7
     7b0:	10 c0       	rjmp	.+32     	; 0x7d2 <sin_SoR+0x2c>
		return angtable[degrees/5];
     7b2:	25 e0       	ldi	r18, 0x05	; 5
     7b4:	30 e0       	ldi	r19, 0x00	; 0
     7b6:	40 e0       	ldi	r20, 0x00	; 0
     7b8:	50 e0       	ldi	r21, 0x00	; 0
     7ba:	0e 94 67 30 	call	0x60ce	; 0x60ce <__divmodsi4>
     7be:	da 01       	movw	r26, r20
     7c0:	c9 01       	movw	r24, r18
     7c2:	88 0f       	add	r24, r24
     7c4:	99 1f       	adc	r25, r25
     7c6:	80 50       	subi	r24, 0x00	; 0
     7c8:	9e 4f       	sbci	r25, 0xFE	; 254
     7ca:	fc 01       	movw	r30, r24
     7cc:	20 81       	ld	r18, Z
     7ce:	31 81       	ldd	r19, Z+1	; 0x01
     7d0:	17 c0       	rjmp	.+46     	; 0x800 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     7d2:	25 e0       	ldi	r18, 0x05	; 5
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	0e 94 67 30 	call	0x60ce	; 0x60ce <__divmodsi4>
     7de:	da 01       	movw	r26, r20
     7e0:	c9 01       	movw	r24, r18
     7e2:	88 5b       	subi	r24, 0xB8	; 184
     7e4:	9f 4f       	sbci	r25, 0xFF	; 255
     7e6:	af 4f       	sbci	r26, 0xFF	; 255
     7e8:	bf 4f       	sbci	r27, 0xFF	; 255
     7ea:	88 0f       	add	r24, r24
     7ec:	99 1f       	adc	r25, r25
     7ee:	80 50       	subi	r24, 0x00	; 0
     7f0:	9e 4f       	sbci	r25, 0xFE	; 254
     7f2:	fc 01       	movw	r30, r24
     7f4:	80 81       	ld	r24, Z
     7f6:	91 81       	ldd	r25, Z+1	; 0x01
     7f8:	22 27       	eor	r18, r18
     7fa:	33 27       	eor	r19, r19
     7fc:	28 1b       	sub	r18, r24
     7fe:	39 0b       	sbc	r19, r25
	}
     800:	c9 01       	movw	r24, r18
     802:	08 95       	ret

00000804 <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     804:	cf 92       	push	r12
     806:	df 92       	push	r13
     808:	ef 92       	push	r14
     80a:	ff 92       	push	r15
     80c:	0f 93       	push	r16
     80e:	1f 93       	push	r17
     810:	6b 01       	movw	r12, r22
     812:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     814:	8a e5       	ldi	r24, 0x5A	; 90
     816:	c8 16       	cp	r12, r24
     818:	d1 04       	cpc	r13, r1
     81a:	e1 04       	cpc	r14, r1
     81c:	f1 04       	cpc	r15, r1
     81e:	a1 f1       	breq	.+104    	; 0x888 <tan_SoR+0x84>
     820:	86 ea       	ldi	r24, 0xA6	; 166
     822:	c8 16       	cp	r12, r24
     824:	8f ef       	ldi	r24, 0xFF	; 255
     826:	d8 06       	cpc	r13, r24
     828:	8f ef       	ldi	r24, 0xFF	; 255
     82a:	e8 06       	cpc	r14, r24
     82c:	8f ef       	ldi	r24, 0xFF	; 255
     82e:	f8 06       	cpc	r15, r24
     830:	59 f1       	breq	.+86     	; 0x888 <tan_SoR+0x84>
     832:	8e e0       	ldi	r24, 0x0E	; 14
     834:	c8 16       	cp	r12, r24
     836:	81 e0       	ldi	r24, 0x01	; 1
     838:	d8 06       	cpc	r13, r24
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	e8 06       	cpc	r14, r24
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	f8 06       	cpc	r15, r24
     842:	11 f1       	breq	.+68     	; 0x888 <tan_SoR+0x84>
     844:	82 ef       	ldi	r24, 0xF2	; 242
     846:	c8 16       	cp	r12, r24
     848:	8e ef       	ldi	r24, 0xFE	; 254
     84a:	d8 06       	cpc	r13, r24
     84c:	8f ef       	ldi	r24, 0xFF	; 255
     84e:	e8 06       	cpc	r14, r24
     850:	8f ef       	ldi	r24, 0xFF	; 255
     852:	f8 06       	cpc	r15, r24
     854:	c9 f0       	breq	.+50     	; 0x888 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     856:	c7 01       	movw	r24, r14
     858:	b6 01       	movw	r22, r12
     85a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <sin_SoR>
     85e:	8c 01       	movw	r16, r24
     860:	c7 01       	movw	r24, r14
     862:	b6 01       	movw	r22, r12
     864:	0e 94 a8 03 	call	0x750	; 0x750 <cos_SoR>
     868:	bc 01       	movw	r22, r24
     86a:	c8 01       	movw	r24, r16
     86c:	0e 94 32 30 	call	0x6064	; 0x6064 <__divmodhi4>
     870:	cb 01       	movw	r24, r22
     872:	9b 01       	movw	r18, r22
     874:	73 e0       	ldi	r23, 0x03	; 3
     876:	22 0f       	add	r18, r18
     878:	33 1f       	adc	r19, r19
     87a:	7a 95       	dec	r23
     87c:	e1 f7       	brne	.-8      	; 0x876 <tan_SoR+0x72>
     87e:	88 0f       	add	r24, r24
     880:	99 1f       	adc	r25, r25
     882:	28 0f       	add	r18, r24
     884:	39 1f       	adc	r19, r25
     886:	02 c0       	rjmp	.+4      	; 0x88c <tan_SoR+0x88>
     888:	20 e0       	ldi	r18, 0x00	; 0
     88a:	30 e0       	ldi	r19, 0x00	; 0
	}
     88c:	c9 01       	movw	r24, r18
     88e:	1f 91       	pop	r17
     890:	0f 91       	pop	r16
     892:	ff 90       	pop	r15
     894:	ef 90       	pop	r14
     896:	df 90       	pop	r13
     898:	cf 90       	pop	r12
     89a:	08 95       	ret

0000089c <prvPWMSetup>:
//-----------------------------**&&**


void prvPWMSetup(){

	PWM_Init_timer3_E4(10); // Left wheel
     89c:	8a e0       	ldi	r24, 0x0A	; 10
     89e:	0e 94 71 01 	call	0x2e2	; 0x2e2 <PWM_Init_timer3_E4>
	PWM_Init_timer3_E3(10); // Right wheel
     8a2:	8a e0       	ldi	r24, 0x0A	; 10
     8a4:	0e 94 51 01 	call	0x2a2	; 0x2a2 <PWM_Init_timer3_E3>
	PWM_Init_timer4_H3(10);	// Left sprayer
     8a8:	8a e0       	ldi	r24, 0x0A	; 10
     8aa:	0e 94 b1 01 	call	0x362	; 0x362 <PWM_Init_timer4_H3>
	PWM_Init_timer4_H4(10);	// Right sprayer
     8ae:	8a e0       	ldi	r24, 0x0A	; 10
     8b0:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <PWM_Init_timer4_H4>

}
     8b4:	08 95       	ret

000008b6 <char2hex>:

char char2hex(char c){
     8b6:	98 2f       	mov	r25, r24
	
	if((c > 47) && (c <58)){
     8b8:	80 53       	subi	r24, 0x30	; 48
     8ba:	8a 30       	cpi	r24, 0x0A	; 10
     8bc:	38 f0       	brcs	.+14     	; 0x8cc <char2hex+0x16>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8be:	81 51       	subi	r24, 0x11	; 17
     8c0:	86 30       	cpi	r24, 0x06	; 6
     8c2:	10 f0       	brcs	.+4      	; 0x8c8 <char2hex+0x12>
     8c4:	89 2f       	mov	r24, r25
     8c6:	08 95       	ret
		c -= 55;
     8c8:	89 2f       	mov	r24, r25
     8ca:	87 53       	subi	r24, 0x37	; 55
	}
	return c;
}
     8cc:	08 95       	ret

000008ce <retConv_s16>:

s16 retConv_s16(char* ch_head){
     8ce:	fc 01       	movw	r30, r24

	s16 int_val = 0x0000;
	char iv1 = *(ch_head);
     8d0:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     8d2:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     8d4:	42 81       	ldd	r20, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     8d6:	53 81       	ldd	r21, Z+3	; 0x03

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8d8:	89 2f       	mov	r24, r25
     8da:	80 53       	subi	r24, 0x30	; 48
     8dc:	8a 30       	cpi	r24, 0x0A	; 10
     8de:	10 f4       	brcc	.+4      	; 0x8e4 <retConv_s16+0x16>
     8e0:	98 2f       	mov	r25, r24
     8e2:	05 c0       	rjmp	.+10     	; 0x8ee <retConv_s16+0x20>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8e4:	89 2f       	mov	r24, r25
     8e6:	81 54       	subi	r24, 0x41	; 65
     8e8:	86 30       	cpi	r24, 0x06	; 6
     8ea:	08 f4       	brcc	.+2      	; 0x8ee <retConv_s16+0x20>
		c -= 55;
     8ec:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     8ee:	82 2f       	mov	r24, r18
     8f0:	80 53       	subi	r24, 0x30	; 48
     8f2:	8a 30       	cpi	r24, 0x0A	; 10
     8f4:	10 f4       	brcc	.+4      	; 0x8fa <retConv_s16+0x2c>
     8f6:	28 2f       	mov	r18, r24
     8f8:	05 c0       	rjmp	.+10     	; 0x904 <retConv_s16+0x36>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     8fa:	82 2f       	mov	r24, r18
     8fc:	81 54       	subi	r24, 0x41	; 65
     8fe:	86 30       	cpi	r24, 0x06	; 6
     900:	08 f4       	brcc	.+2      	; 0x904 <retConv_s16+0x36>
		c -= 55;
     902:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     904:	84 2f       	mov	r24, r20
     906:	80 53       	subi	r24, 0x30	; 48
     908:	8a 30       	cpi	r24, 0x0A	; 10
     90a:	10 f4       	brcc	.+4      	; 0x910 <retConv_s16+0x42>
     90c:	48 2f       	mov	r20, r24
     90e:	05 c0       	rjmp	.+10     	; 0x91a <retConv_s16+0x4c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     910:	84 2f       	mov	r24, r20
     912:	81 54       	subi	r24, 0x41	; 65
     914:	86 30       	cpi	r24, 0x06	; 6
     916:	08 f4       	brcc	.+2      	; 0x91a <retConv_s16+0x4c>
		c -= 55;
     918:	47 53       	subi	r20, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     91a:	85 2f       	mov	r24, r21
     91c:	80 53       	subi	r24, 0x30	; 48
     91e:	8a 30       	cpi	r24, 0x0A	; 10
     920:	10 f4       	brcc	.+4      	; 0x926 <retConv_s16+0x58>
     922:	58 2f       	mov	r21, r24
     924:	05 c0       	rjmp	.+10     	; 0x930 <retConv_s16+0x62>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     926:	85 2f       	mov	r24, r21
     928:	81 54       	subi	r24, 0x41	; 65
     92a:	86 30       	cpi	r24, 0x06	; 6
     92c:	08 f4       	brcc	.+2      	; 0x930 <retConv_s16+0x62>
		c -= 55;
     92e:	57 53       	subi	r21, 0x37	; 55
	iv2 = char2hex(iv2);
	iv3 = char2hex(iv3);
	iv4 = char2hex(iv4);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     930:	30 e0       	ldi	r19, 0x00	; 0
     932:	89 2f       	mov	r24, r25
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	a4 e0       	ldi	r26, 0x04	; 4
     938:	88 0f       	add	r24, r24
     93a:	99 1f       	adc	r25, r25
     93c:	aa 95       	dec	r26
     93e:	e1 f7       	brne	.-8      	; 0x938 <retConv_s16+0x6a>
     940:	28 2b       	or	r18, r24
     942:	39 2b       	or	r19, r25
	int_val = ((int_val<<4) | iv3);
     944:	f4 e0       	ldi	r31, 0x04	; 4
     946:	22 0f       	add	r18, r18
     948:	33 1f       	adc	r19, r19
     94a:	fa 95       	dec	r31
     94c:	e1 f7       	brne	.-8      	; 0x946 <retConv_s16+0x78>
     94e:	84 2f       	mov	r24, r20
     950:	90 e0       	ldi	r25, 0x00	; 0
     952:	82 2b       	or	r24, r18
     954:	93 2b       	or	r25, r19
	int_val = ((int_val<<4) | iv4);
     956:	e4 e0       	ldi	r30, 0x04	; 4
     958:	88 0f       	add	r24, r24
     95a:	99 1f       	adc	r25, r25
     95c:	ea 95       	dec	r30
     95e:	e1 f7       	brne	.-8      	; 0x958 <retConv_s16+0x8a>
     960:	25 2f       	mov	r18, r21
     962:	30 e0       	ldi	r19, 0x00	; 0
     964:	28 2b       	or	r18, r24
     966:	39 2b       	or	r19, r25
	return int_val;
}
     968:	c9 01       	movw	r24, r18
     96a:	08 95       	ret

0000096c <retConv_s32>:

s32 retConv_s32(char* ch_head){
     96c:	ff 92       	push	r15
     96e:	0f 93       	push	r16
     970:	1f 93       	push	r17
     972:	fc 01       	movw	r30, r24

	s32 int_val = 0x00000000;
	char iv1 = *(ch_head);
     974:	90 81       	ld	r25, Z
	char iv2 = *(ch_head + 1);
     976:	21 81       	ldd	r18, Z+1	; 0x01
	char iv3 = *(ch_head + 2);
     978:	62 81       	ldd	r22, Z+2	; 0x02
	char iv4 = *(ch_head + 3);
     97a:	73 81       	ldd	r23, Z+3	; 0x03
	char iv5 = *(ch_head + 4);
     97c:	14 81       	ldd	r17, Z+4	; 0x04
	char iv6 = *(ch_head + 5);
     97e:	05 81       	ldd	r16, Z+5	; 0x05
	char iv7 = *(ch_head + 6);
     980:	f6 80       	ldd	r15, Z+6	; 0x06
	char iv8 = *(ch_head + 7);
     982:	e7 81       	ldd	r30, Z+7	; 0x07

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     984:	89 2f       	mov	r24, r25
     986:	80 53       	subi	r24, 0x30	; 48
     988:	8a 30       	cpi	r24, 0x0A	; 10
     98a:	10 f4       	brcc	.+4      	; 0x990 <retConv_s32+0x24>
     98c:	98 2f       	mov	r25, r24
     98e:	05 c0       	rjmp	.+10     	; 0x99a <retConv_s32+0x2e>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     990:	89 2f       	mov	r24, r25
     992:	81 54       	subi	r24, 0x41	; 65
     994:	86 30       	cpi	r24, 0x06	; 6
     996:	08 f4       	brcc	.+2      	; 0x99a <retConv_s32+0x2e>
		c -= 55;
     998:	97 53       	subi	r25, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     99a:	82 2f       	mov	r24, r18
     99c:	80 53       	subi	r24, 0x30	; 48
     99e:	8a 30       	cpi	r24, 0x0A	; 10
     9a0:	10 f4       	brcc	.+4      	; 0x9a6 <retConv_s32+0x3a>
     9a2:	28 2f       	mov	r18, r24
     9a4:	05 c0       	rjmp	.+10     	; 0x9b0 <retConv_s32+0x44>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9a6:	82 2f       	mov	r24, r18
     9a8:	81 54       	subi	r24, 0x41	; 65
     9aa:	86 30       	cpi	r24, 0x06	; 6
     9ac:	08 f4       	brcc	.+2      	; 0x9b0 <retConv_s32+0x44>
		c -= 55;
     9ae:	27 53       	subi	r18, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9b0:	86 2f       	mov	r24, r22
     9b2:	80 53       	subi	r24, 0x30	; 48
     9b4:	8a 30       	cpi	r24, 0x0A	; 10
     9b6:	10 f4       	brcc	.+4      	; 0x9bc <retConv_s32+0x50>
     9b8:	68 2f       	mov	r22, r24
     9ba:	05 c0       	rjmp	.+10     	; 0x9c6 <retConv_s32+0x5a>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9bc:	86 2f       	mov	r24, r22
     9be:	81 54       	subi	r24, 0x41	; 65
     9c0:	86 30       	cpi	r24, 0x06	; 6
     9c2:	08 f4       	brcc	.+2      	; 0x9c6 <retConv_s32+0x5a>
		c -= 55;
     9c4:	67 53       	subi	r22, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9c6:	87 2f       	mov	r24, r23
     9c8:	80 53       	subi	r24, 0x30	; 48
     9ca:	8a 30       	cpi	r24, 0x0A	; 10
     9cc:	10 f4       	brcc	.+4      	; 0x9d2 <retConv_s32+0x66>
     9ce:	78 2f       	mov	r23, r24
     9d0:	05 c0       	rjmp	.+10     	; 0x9dc <retConv_s32+0x70>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9d2:	87 2f       	mov	r24, r23
     9d4:	81 54       	subi	r24, 0x41	; 65
     9d6:	86 30       	cpi	r24, 0x06	; 6
     9d8:	08 f4       	brcc	.+2      	; 0x9dc <retConv_s32+0x70>
		c -= 55;
     9da:	77 53       	subi	r23, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9dc:	81 2f       	mov	r24, r17
     9de:	80 53       	subi	r24, 0x30	; 48
     9e0:	8a 30       	cpi	r24, 0x0A	; 10
     9e2:	10 f4       	brcc	.+4      	; 0x9e8 <retConv_s32+0x7c>
     9e4:	18 2f       	mov	r17, r24
     9e6:	05 c0       	rjmp	.+10     	; 0x9f2 <retConv_s32+0x86>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9e8:	81 2f       	mov	r24, r17
     9ea:	81 54       	subi	r24, 0x41	; 65
     9ec:	86 30       	cpi	r24, 0x06	; 6
     9ee:	08 f4       	brcc	.+2      	; 0x9f2 <retConv_s32+0x86>
		c -= 55;
     9f0:	17 53       	subi	r17, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     9f2:	80 2f       	mov	r24, r16
     9f4:	80 53       	subi	r24, 0x30	; 48
     9f6:	8a 30       	cpi	r24, 0x0A	; 10
     9f8:	10 f4       	brcc	.+4      	; 0x9fe <retConv_s32+0x92>
     9fa:	08 2f       	mov	r16, r24
     9fc:	05 c0       	rjmp	.+10     	; 0xa08 <retConv_s32+0x9c>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     9fe:	80 2f       	mov	r24, r16
     a00:	81 54       	subi	r24, 0x41	; 65
     a02:	86 30       	cpi	r24, 0x06	; 6
     a04:	08 f4       	brcc	.+2      	; 0xa08 <retConv_s32+0x9c>
		c -= 55;
     a06:	07 53       	subi	r16, 0x37	; 55

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a08:	8f 2d       	mov	r24, r15
     a0a:	80 53       	subi	r24, 0x30	; 48
     a0c:	8a 30       	cpi	r24, 0x0A	; 10
     a0e:	10 f4       	brcc	.+4      	; 0xa14 <retConv_s32+0xa8>
     a10:	f8 2e       	mov	r15, r24
     a12:	06 c0       	rjmp	.+12     	; 0xa20 <retConv_s32+0xb4>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a14:	8f 2d       	mov	r24, r15
     a16:	81 54       	subi	r24, 0x41	; 65
     a18:	86 30       	cpi	r24, 0x06	; 6
     a1a:	10 f4       	brcc	.+4      	; 0xa20 <retConv_s32+0xb4>
		c -= 55;
     a1c:	89 ec       	ldi	r24, 0xC9	; 201
     a1e:	f8 0e       	add	r15, r24

}

char char2hex(char c){
	
	if((c > 47) && (c <58)){
     a20:	8e 2f       	mov	r24, r30
     a22:	80 53       	subi	r24, 0x30	; 48
     a24:	8a 30       	cpi	r24, 0x0A	; 10
     a26:	10 f4       	brcc	.+4      	; 0xa2c <retConv_s32+0xc0>
     a28:	e8 2f       	mov	r30, r24
     a2a:	05 c0       	rjmp	.+10     	; 0xa36 <retConv_s32+0xca>
		c -= 48;
	}
	else if((c > 64) && (c <71)){
     a2c:	8e 2f       	mov	r24, r30
     a2e:	81 54       	subi	r24, 0x41	; 65
     a30:	86 30       	cpi	r24, 0x06	; 6
     a32:	08 f4       	brcc	.+2      	; 0xa36 <retConv_s32+0xca>
		c -= 55;
     a34:	e7 53       	subi	r30, 0x37	; 55
	iv6 = char2hex(iv6);
	iv7 = char2hex(iv7);
	iv8 = char2hex(iv8);

	int_val = (int_val | iv1);
	int_val = ((int_val<<4) | iv2);
     a36:	30 e0       	ldi	r19, 0x00	; 0
     a38:	40 e0       	ldi	r20, 0x00	; 0
     a3a:	50 e0       	ldi	r21, 0x00	; 0
     a3c:	89 2f       	mov	r24, r25
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	a0 e0       	ldi	r26, 0x00	; 0
     a42:	b0 e0       	ldi	r27, 0x00	; 0
     a44:	f4 e0       	ldi	r31, 0x04	; 4
     a46:	88 0f       	add	r24, r24
     a48:	99 1f       	adc	r25, r25
     a4a:	aa 1f       	adc	r26, r26
     a4c:	bb 1f       	adc	r27, r27
     a4e:	fa 95       	dec	r31
     a50:	d1 f7       	brne	.-12     	; 0xa46 <retConv_s32+0xda>
     a52:	28 2b       	or	r18, r24
     a54:	39 2b       	or	r19, r25
     a56:	4a 2b       	or	r20, r26
     a58:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv3);
     a5a:	a4 e0       	ldi	r26, 0x04	; 4
     a5c:	22 0f       	add	r18, r18
     a5e:	33 1f       	adc	r19, r19
     a60:	44 1f       	adc	r20, r20
     a62:	55 1f       	adc	r21, r21
     a64:	aa 95       	dec	r26
     a66:	d1 f7       	brne	.-12     	; 0xa5c <retConv_s32+0xf0>
     a68:	86 2f       	mov	r24, r22
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	a0 e0       	ldi	r26, 0x00	; 0
     a6e:	b0 e0       	ldi	r27, 0x00	; 0
     a70:	82 2b       	or	r24, r18
     a72:	93 2b       	or	r25, r19
     a74:	a4 2b       	or	r26, r20
     a76:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv4);
     a78:	f4 e0       	ldi	r31, 0x04	; 4
     a7a:	88 0f       	add	r24, r24
     a7c:	99 1f       	adc	r25, r25
     a7e:	aa 1f       	adc	r26, r26
     a80:	bb 1f       	adc	r27, r27
     a82:	fa 95       	dec	r31
     a84:	d1 f7       	brne	.-12     	; 0xa7a <retConv_s32+0x10e>
     a86:	27 2f       	mov	r18, r23
     a88:	30 e0       	ldi	r19, 0x00	; 0
     a8a:	40 e0       	ldi	r20, 0x00	; 0
     a8c:	50 e0       	ldi	r21, 0x00	; 0
     a8e:	28 2b       	or	r18, r24
     a90:	39 2b       	or	r19, r25
     a92:	4a 2b       	or	r20, r26
     a94:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv5);
     a96:	64 e0       	ldi	r22, 0x04	; 4
     a98:	22 0f       	add	r18, r18
     a9a:	33 1f       	adc	r19, r19
     a9c:	44 1f       	adc	r20, r20
     a9e:	55 1f       	adc	r21, r21
     aa0:	6a 95       	dec	r22
     aa2:	d1 f7       	brne	.-12     	; 0xa98 <retConv_s32+0x12c>
     aa4:	81 2f       	mov	r24, r17
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	a0 e0       	ldi	r26, 0x00	; 0
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	82 2b       	or	r24, r18
     aae:	93 2b       	or	r25, r19
     ab0:	a4 2b       	or	r26, r20
     ab2:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv6);
     ab4:	24 e0       	ldi	r18, 0x04	; 4
     ab6:	88 0f       	add	r24, r24
     ab8:	99 1f       	adc	r25, r25
     aba:	aa 1f       	adc	r26, r26
     abc:	bb 1f       	adc	r27, r27
     abe:	2a 95       	dec	r18
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <retConv_s32+0x14a>
     ac2:	20 2f       	mov	r18, r16
     ac4:	30 e0       	ldi	r19, 0x00	; 0
     ac6:	40 e0       	ldi	r20, 0x00	; 0
     ac8:	50 e0       	ldi	r21, 0x00	; 0
     aca:	28 2b       	or	r18, r24
     acc:	39 2b       	or	r19, r25
     ace:	4a 2b       	or	r20, r26
     ad0:	5b 2b       	or	r21, r27
	int_val = ((int_val<<4) | iv7);
     ad2:	04 e0       	ldi	r16, 0x04	; 4
     ad4:	22 0f       	add	r18, r18
     ad6:	33 1f       	adc	r19, r19
     ad8:	44 1f       	adc	r20, r20
     ada:	55 1f       	adc	r21, r21
     adc:	0a 95       	dec	r16
     ade:	d1 f7       	brne	.-12     	; 0xad4 <retConv_s32+0x168>
     ae0:	8f 2d       	mov	r24, r15
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	a0 e0       	ldi	r26, 0x00	; 0
     ae6:	b0 e0       	ldi	r27, 0x00	; 0
     ae8:	82 2b       	or	r24, r18
     aea:	93 2b       	or	r25, r19
     aec:	a4 2b       	or	r26, r20
     aee:	b5 2b       	or	r27, r21
	int_val = ((int_val<<4) | iv8);
     af0:	14 e0       	ldi	r17, 0x04	; 4
     af2:	88 0f       	add	r24, r24
     af4:	99 1f       	adc	r25, r25
     af6:	aa 1f       	adc	r26, r26
     af8:	bb 1f       	adc	r27, r27
     afa:	1a 95       	dec	r17
     afc:	d1 f7       	brne	.-12     	; 0xaf2 <retConv_s32+0x186>
     afe:	2e 2f       	mov	r18, r30
     b00:	30 e0       	ldi	r19, 0x00	; 0
     b02:	40 e0       	ldi	r20, 0x00	; 0
     b04:	50 e0       	ldi	r21, 0x00	; 0
     b06:	28 2b       	or	r18, r24
     b08:	39 2b       	or	r19, r25
     b0a:	4a 2b       	or	r20, r26
     b0c:	5b 2b       	or	r21, r27
	return int_val;
}
     b0e:	b9 01       	movw	r22, r18
     b10:	ca 01       	movw	r24, r20
     b12:	1f 91       	pop	r17
     b14:	0f 91       	pop	r16
     b16:	ff 90       	pop	r15
     b18:	08 95       	ret

00000b1a <wheel_L>:
	{
	return 739.38*pow(value,-.8105);
	}
//***FROM THE SoR LIBRARIES

void wheel_L(signed int cmd_vel){
     b1a:	9c 01       	movw	r18, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b1c:	85 32       	cpi	r24, 0x25	; 37
     b1e:	91 05       	cpc	r25, r1
     b20:	1c f0       	brlt	.+6      	; 0xb28 <wheel_L+0xe>
     b22:	24 e2       	ldi	r18, 0x24	; 36
     b24:	30 e0       	ldi	r19, 0x00	; 0
     b26:	06 c0       	rjmp	.+12     	; 0xb34 <wheel_L+0x1a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b28:	8f ef       	ldi	r24, 0xFF	; 255
     b2a:	2c 3d       	cpi	r18, 0xDC	; 220
     b2c:	38 07       	cpc	r19, r24
     b2e:	14 f4       	brge	.+4      	; 0xb34 <wheel_L+0x1a>
     b30:	2c ed       	ldi	r18, 0xDC	; 220
     b32:	3f ef       	ldi	r19, 0xFF	; 255
		rprintf("*** PWM: ");
		rprintfFloat(10, s_out);
		rprintf(" | %d ", (int)s_out); 
		rprintf(" ***LLL\n");
		*/
		taskENTER_CRITICAL();
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	f8 94       	cli
     b38:	0f 92       	push	r0
		PWM_timer3_Set_E4((int)s_out);
     b3a:	b9 01       	movw	r22, r18
     b3c:	88 27       	eor	r24, r24
     b3e:	77 fd       	sbrc	r23, 7
     b40:	80 95       	com	r24
     b42:	98 2f       	mov	r25, r24
     b44:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
     b48:	28 e4       	ldi	r18, 0x48	; 72
     b4a:	30 e5       	ldi	r19, 0x50	; 80
     b4c:	4c ef       	ldi	r20, 0xFC	; 252
     b4e:	5e eb       	ldi	r21, 0xBE	; 190
     b50:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     b54:	2f e1       	ldi	r18, 0x1F	; 31
     b56:	35 e4       	ldi	r19, 0x45	; 69
     b58:	49 e3       	ldi	r20, 0x39	; 57
     b5a:	53 e4       	ldi	r21, 0x43	; 67
     b5c:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
     b60:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     b64:	70 93 9b 00 	sts	0x009B, r23
     b68:	60 93 9a 00 	sts	0x009A, r22
		taskEXIT_CRITICAL();
     b6c:	0f 90       	pop	r0
     b6e:	0f be       	out	0x3f, r0	; 63


}
     b70:	08 95       	ret

00000b72 <wheel_R>:

void wheel_R(signed int cmd_vel){
     b72:	9c 01       	movw	r18, r24
		if(cmd_vel > 36){cmd_vel = 36;}
     b74:	85 32       	cpi	r24, 0x25	; 37
     b76:	91 05       	cpc	r25, r1
     b78:	1c f0       	brlt	.+6      	; 0xb80 <wheel_R+0xe>
     b7a:	24 e2       	ldi	r18, 0x24	; 36
     b7c:	30 e0       	ldi	r19, 0x00	; 0
     b7e:	06 c0       	rjmp	.+12     	; 0xb8c <wheel_R+0x1a>
		if(cmd_vel < -36){cmd_vel = -36;}
     b80:	8f ef       	ldi	r24, 0xFF	; 255
     b82:	2c 3d       	cpi	r18, 0xDC	; 220
     b84:	38 07       	cpc	r19, r24
     b86:	14 f4       	brge	.+4      	; 0xb8c <wheel_R+0x1a>
     b88:	2c ed       	ldi	r18, 0xDC	; 220
     b8a:	3f ef       	ldi	r19, 0xFF	; 255
		rprintf("*** PWM: ");
		rprintfFloat(10, s_out);
		rprintf(" | %d ", (int)s_out); 
		rprintf(" ***RRR\n");
		*/
		taskENTER_CRITICAL();
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	0f 92       	push	r0
		PWM_timer3_Set_E3((int)s_out);
     b92:	b9 01       	movw	r22, r18
     b94:	88 27       	eor	r24, r24
     b96:	77 fd       	sbrc	r23, 7
     b98:	80 95       	com	r24
     b9a:	98 2f       	mov	r25, r24
     b9c:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
     ba0:	21 e1       	ldi	r18, 0x11	; 17
     ba2:	37 ec       	ldi	r19, 0xC7	; 199
     ba4:	4a e0       	ldi	r20, 0x0A	; 10
     ba6:	5f eb       	ldi	r21, 0xBF	; 191
     ba8:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     bac:	26 ef       	ldi	r18, 0xF6	; 246
     bae:	38 e6       	ldi	r19, 0x68	; 104
     bb0:	4c e3       	ldi	r20, 0x3C	; 60
     bb2:	53 e4       	ldi	r21, 0x43	; 67
     bb4:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
     bb8:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     bbc:	70 93 99 00 	sts	0x0099, r23
     bc0:	60 93 98 00 	sts	0x0098, r22
		taskEXIT_CRITICAL();
     bc4:	0f 90       	pop	r0
     bc6:	0f be       	out	0x3f, r0	; 63


}
     bc8:	08 95       	ret

00000bca <num2char>:


}
*/

char num2char(char c){
     bca:	98 2f       	mov	r25, r24
	
	if(c <10){
     bcc:	8a 30       	cpi	r24, 0x0A	; 10
     bce:	10 f4       	brcc	.+4      	; 0xbd4 <num2char+0xa>
		c += 48;
     bd0:	90 5d       	subi	r25, 0xD0	; 208
     bd2:	04 c0       	rjmp	.+8      	; 0xbdc <num2char+0x12>
	}
	else if((c >= 10) && (c <= 16)){
     bd4:	8a 50       	subi	r24, 0x0A	; 10
     bd6:	87 30       	cpi	r24, 0x07	; 7
     bd8:	08 f4       	brcc	.+2      	; 0xbdc <num2char+0x12>
		c += 55;
     bda:	99 5c       	subi	r25, 0xC9	; 201
	}
	return c;
}
     bdc:	89 2f       	mov	r24, r25
     bde:	08 95       	ret

00000be0 <fwdSer_L>:
		
			//taskYIELD();
	//	}
		
}
void fwdSer_L(unsigned char c){
     be0:	98 2f       	mov	r25, r24
	static char v_flag;
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars
		//rprintf("%c",c);
		if(c != 0xff){
     be2:	8f 3f       	cpi	r24, 0xFF	; 255
     be4:	09 f4       	brne	.+2      	; 0xbe8 <fwdSer_L+0x8>
     be6:	79 c0       	rjmp	.+242    	; 0xcda <fwdSer_L+0xfa>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     be8:	8a 30       	cpi	r24, 0x0A	; 10
     bea:	21 f4       	brne	.+8      	; 0xbf4 <fwdSer_L+0x14>
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	80 93 da 02 	sts	0x02DA, r24
     bf2:	33 c0       	rjmp	.+102    	; 0xc5a <fwdSer_L+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     bf4:	80 91 da 02 	lds	r24, 0x02DA
     bf8:	88 23       	and	r24, r24
     bfa:	91 f0       	breq	.+36     	; 0xc20 <fwdSer_L+0x40>
     bfc:	96 35       	cpi	r25, 0x56	; 86
     bfe:	31 f4       	brne	.+12     	; 0xc0c <fwdSer_L+0x2c>
				v_flag = SET;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	80 93 d7 02 	sts	0x02D7, r24
				v_iter = 0;
     c06:	10 92 d9 02 	sts	0x02D9, r1
     c0a:	07 c0       	rjmp	.+14     	; 0xc1a <fwdSer_L+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     c0c:	94 34       	cpi	r25, 0x44	; 68
     c0e:	41 f4       	brne	.+16     	; 0xc20 <fwdSer_L+0x40>
				d_flag = SET;
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	80 93 d6 02 	sts	0x02D6, r24
				d_iter = 0;
     c16:	10 92 d8 02 	sts	0x02D8, r1
				lf_flag = UNSET;
     c1a:	10 92 da 02 	sts	0x02DA, r1
     c1e:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     c20:	80 91 d7 02 	lds	r24, 0x02D7
     c24:	88 23       	and	r24, r24
     c26:	59 f0       	breq	.+22     	; 0xc3e <fwdSer_L+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     c28:	80 91 d9 02 	lds	r24, 0x02D9
     c2c:	e8 2f       	mov	r30, r24
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	ee 52       	subi	r30, 0x2E	; 46
     c32:	fd 4f       	sbci	r31, 0xFD	; 253
     c34:	90 83       	st	Z, r25
     c36:	8f 5f       	subi	r24, 0xFF	; 255
     c38:	80 93 d9 02 	sts	0x02D9, r24
     c3c:	0e c0       	rjmp	.+28     	; 0xc5a <fwdSer_L+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     c3e:	80 91 d6 02 	lds	r24, 0x02D6
     c42:	88 23       	and	r24, r24
     c44:	51 f0       	breq	.+20     	; 0xc5a <fwdSer_L+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     c46:	80 91 d8 02 	lds	r24, 0x02D8
     c4a:	e8 2f       	mov	r30, r24
     c4c:	f0 e0       	ldi	r31, 0x00	; 0
     c4e:	e6 53       	subi	r30, 0x36	; 54
     c50:	fd 4f       	sbci	r31, 0xFD	; 253
     c52:	90 83       	st	Z, r25
     c54:	8f 5f       	subi	r24, 0xFF	; 255
     c56:	80 93 d8 02 	sts	0x02D8, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     c5a:	80 91 d9 02 	lds	r24, 0x02D9
     c5e:	84 30       	cpi	r24, 0x04	; 4
     c60:	e9 f4       	brne	.+58     	; 0xc9c <fwdSer_L+0xbc>
				LEFTVel_current = CM_TICK * retConv_s16(&vel_rough);
     c62:	82 ed       	ldi	r24, 0xD2	; 210
     c64:	92 e0       	ldi	r25, 0x02	; 2
     c66:	0e 94 67 04 	call	0x8ce	; 0x8ce <retConv_s16>
     c6a:	aa 27       	eor	r26, r26
     c6c:	97 fd       	sbrc	r25, 7
     c6e:	a0 95       	com	r26
     c70:	ba 2f       	mov	r27, r26
     c72:	bc 01       	movw	r22, r24
     c74:	cd 01       	movw	r24, r26
     c76:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
     c7a:	20 e0       	ldi	r18, 0x00	; 0
     c7c:	30 e0       	ldi	r19, 0x00	; 0
     c7e:	40 e8       	ldi	r20, 0x80	; 128
     c80:	5e e3       	ldi	r21, 0x3E	; 62
     c82:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     c86:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
     c8a:	70 93 a5 02 	sts	0x02A5, r23
     c8e:	60 93 a4 02 	sts	0x02A4, r22
				v_flag = UNSET;
     c92:	10 92 d7 02 	sts	0x02D7, r1
				v_iter = 0;
     c96:	10 92 d9 02 	sts	0x02D9, r1
     c9a:	08 95       	ret
			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     c9c:	80 91 d8 02 	lds	r24, 0x02D8
     ca0:	88 30       	cpi	r24, 0x08	; 8
     ca2:	51 f5       	brne	.+84     	; 0xcf8 <fwdSer_L+0x118>
				LEFTDis_current = CM_TICK * retConv_s32(&dis_rough);
     ca4:	8a ec       	ldi	r24, 0xCA	; 202
     ca6:	92 e0       	ldi	r25, 0x02	; 2
     ca8:	0e 94 b6 04 	call	0x96c	; 0x96c <retConv_s32>
     cac:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
     cb0:	20 e0       	ldi	r18, 0x00	; 0
     cb2:	30 e0       	ldi	r19, 0x00	; 0
     cb4:	40 e8       	ldi	r20, 0x80	; 128
     cb6:	5e e3       	ldi	r21, 0x3E	; 62
     cb8:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     cbc:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
     cc0:	60 93 a6 02 	sts	0x02A6, r22
     cc4:	70 93 a7 02 	sts	0x02A7, r23
     cc8:	80 93 a8 02 	sts	0x02A8, r24
     ccc:	90 93 a9 02 	sts	0x02A9, r25
			//	rprintf("dL: %d\n",dLEFTDis);
				d_flag = UNSET;
     cd0:	10 92 d6 02 	sts	0x02D6, r1
				d_iter = 0;
     cd4:	10 92 d8 02 	sts	0x02D8, r1
     cd8:	08 95       	ret
			//	rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     cda:	00 d0       	rcall	.+0      	; 0xcdc <fwdSer_L+0xfc>
     cdc:	0f 92       	push	r0
     cde:	81 e0       	ldi	r24, 0x01	; 1
     ce0:	ed b7       	in	r30, 0x3d	; 61
     ce2:	fe b7       	in	r31, 0x3e	; 62
     ce4:	81 83       	std	Z+1, r24	; 0x01
     ce6:	81 ea       	ldi	r24, 0xA1	; 161
     ce8:	91 e0       	ldi	r25, 0x01	; 1
     cea:	93 83       	std	Z+3, r25	; 0x03
     cec:	82 83       	std	Z+2, r24	; 0x02
     cee:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>
     cf2:	0f 90       	pop	r0
     cf4:	0f 90       	pop	r0
     cf6:	0f 90       	pop	r0
     cf8:	08 95       	ret

00000cfa <fwdSer_R>:
	int_val = ((int_val<<4) | iv8);
	return int_val;
}


void fwdSer_R(unsigned char c){
     cfa:	98 2f       	mov	r25, r24
	static char v_flag;
	static char d_flag;
	static char vel_rough[4];  //store ascii chars
	static char dis_rough[8];  //store ascii chars
		//rprintf("%c",c);
		if(c != 0xff){
     cfc:	8f 3f       	cpi	r24, 0xFF	; 255
     cfe:	09 f4       	brne	.+2      	; 0xd02 <fwdSer_R+0x8>
     d00:	79 c0       	rjmp	.+242    	; 0xdf4 <fwdSer_R+0xfa>
		//if the data isn't whitespace (0xff), post it
		//	rprintf("%c",c);

			if(c == 0x0A){lf_flag = SET;} //line feed detected, the character will be a 'D' or a 'V'
     d02:	8a 30       	cpi	r24, 0x0A	; 10
     d04:	21 f4       	brne	.+8      	; 0xd0e <fwdSer_R+0x14>
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	80 93 eb 02 	sts	0x02EB, r24
     d0c:	33 c0       	rjmp	.+102    	; 0xd74 <fwdSer_R+0x7a>
	
			else if((lf_flag) && (c == 'V')){ //set velocity flag
     d0e:	80 91 eb 02 	lds	r24, 0x02EB
     d12:	88 23       	and	r24, r24
     d14:	91 f0       	breq	.+36     	; 0xd3a <fwdSer_R+0x40>
     d16:	96 35       	cpi	r25, 0x56	; 86
     d18:	31 f4       	brne	.+12     	; 0xd26 <fwdSer_R+0x2c>
				v_flag = SET;
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	80 93 e8 02 	sts	0x02E8, r24
				v_iter = 0;
     d20:	10 92 ea 02 	sts	0x02EA, r1
     d24:	07 c0       	rjmp	.+14     	; 0xd34 <fwdSer_R+0x3a>
				lf_flag = UNSET;
				return;
			} 
			else if((lf_flag) && (c == 'D')){ //set distance flag
     d26:	94 34       	cpi	r25, 0x44	; 68
     d28:	41 f4       	brne	.+16     	; 0xd3a <fwdSer_R+0x40>
				d_flag = SET;
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	80 93 e7 02 	sts	0x02E7, r24
				d_iter = 0;
     d30:	10 92 e9 02 	sts	0x02E9, r1
				lf_flag = UNSET;
     d34:	10 92 eb 02 	sts	0x02EB, r1
     d38:	08 95       	ret
			//	rprintf("%c",c);
				return;
			}
			else if(v_flag){
     d3a:	80 91 e8 02 	lds	r24, 0x02E8
     d3e:	88 23       	and	r24, r24
     d40:	59 f0       	breq	.+22     	; 0xd58 <fwdSer_R+0x5e>
				vel_rough[v_iter++] = c;	//store then increment	
     d42:	80 91 ea 02 	lds	r24, 0x02EA
     d46:	e8 2f       	mov	r30, r24
     d48:	f0 e0       	ldi	r31, 0x00	; 0
     d4a:	ed 51       	subi	r30, 0x1D	; 29
     d4c:	fd 4f       	sbci	r31, 0xFD	; 253
     d4e:	90 83       	st	Z, r25
     d50:	8f 5f       	subi	r24, 0xFF	; 255
     d52:	80 93 ea 02 	sts	0x02EA, r24
     d56:	0e c0       	rjmp	.+28     	; 0xd74 <fwdSer_R+0x7a>
				//rprintf("%c",c);
			}	
			else if(d_flag){
     d58:	80 91 e7 02 	lds	r24, 0x02E7
     d5c:	88 23       	and	r24, r24
     d5e:	51 f0       	breq	.+20     	; 0xd74 <fwdSer_R+0x7a>
				dis_rough[d_iter++] = c;	//store then increment	
     d60:	80 91 e9 02 	lds	r24, 0x02E9
     d64:	e8 2f       	mov	r30, r24
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	e5 52       	subi	r30, 0x25	; 37
     d6a:	fd 4f       	sbci	r31, 0xFD	; 253
     d6c:	90 83       	st	Z, r25
     d6e:	8f 5f       	subi	r24, 0xFF	; 255
     d70:	80 93 e9 02 	sts	0x02E9, r24
			//	rprintf("%c",c);
			}

			if(v_iter == 4){
     d74:	80 91 ea 02 	lds	r24, 0x02EA
     d78:	84 30       	cpi	r24, 0x04	; 4
     d7a:	e9 f4       	brne	.+58     	; 0xdb6 <fwdSer_R+0xbc>
				RIGHTVel_current = CM_TICK * retConv_s16(&vel_rough);
     d7c:	83 ee       	ldi	r24, 0xE3	; 227
     d7e:	92 e0       	ldi	r25, 0x02	; 2
     d80:	0e 94 67 04 	call	0x8ce	; 0x8ce <retConv_s16>
     d84:	aa 27       	eor	r26, r26
     d86:	97 fd       	sbrc	r25, 7
     d88:	a0 95       	com	r26
     d8a:	ba 2f       	mov	r27, r26
     d8c:	bc 01       	movw	r22, r24
     d8e:	cd 01       	movw	r24, r26
     d90:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
     d94:	20 e0       	ldi	r18, 0x00	; 0
     d96:	30 e0       	ldi	r19, 0x00	; 0
     d98:	40 e8       	ldi	r20, 0x80	; 128
     d9a:	5e e3       	ldi	r21, 0x3E	; 62
     d9c:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     da0:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
     da4:	70 93 b1 02 	sts	0x02B1, r23
     da8:	60 93 b0 02 	sts	0x02B0, r22
				v_flag = UNSET;
     dac:	10 92 e8 02 	sts	0x02E8, r1
				v_iter = 0;
     db0:	10 92 ea 02 	sts	0x02EA, r1
     db4:	08 95       	ret
			//	rprintf("RRR VVV: ");
			//	rprintfu16(RIGHTVel_current);
			//	rprintf("\n");
			}
			else if(d_iter == 8){
     db6:	80 91 e9 02 	lds	r24, 0x02E9
     dba:	88 30       	cpi	r24, 0x08	; 8
     dbc:	51 f5       	brne	.+84     	; 0xe12 <fwdSer_R+0x118>
				RIGHTDis_current = CM_TICK * retConv_s32(&dis_rough);
     dbe:	8b ed       	ldi	r24, 0xDB	; 219
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	0e 94 b6 04 	call	0x96c	; 0x96c <retConv_s32>
     dc6:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
     dca:	20 e0       	ldi	r18, 0x00	; 0
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	40 e8       	ldi	r20, 0x80	; 128
     dd0:	5e e3       	ldi	r21, 0x3E	; 62
     dd2:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     dd6:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
     dda:	60 93 b2 02 	sts	0x02B2, r22
     dde:	70 93 b3 02 	sts	0x02B3, r23
     de2:	80 93 b4 02 	sts	0x02B4, r24
     de6:	90 93 b5 02 	sts	0x02B5, r25
				//rprintf("dR: %d\n",dRIGHTDis);
				d_flag = UNSET;
     dea:	10 92 e7 02 	sts	0x02E7, r1
				d_iter = 0;
     dee:	10 92 e9 02 	sts	0x02E9, r1
     df2:	08 95       	ret
				//rprintf("\n");
			}
		
		}

		else{rprintf("WR\n");}
     df4:	00 d0       	rcall	.+0      	; 0xdf6 <fwdSer_R+0xfc>
     df6:	0f 92       	push	r0
     df8:	81 e0       	ldi	r24, 0x01	; 1
     dfa:	ed b7       	in	r30, 0x3d	; 61
     dfc:	fe b7       	in	r31, 0x3e	; 62
     dfe:	81 83       	std	Z+1, r24	; 0x01
     e00:	85 ea       	ldi	r24, 0xA5	; 165
     e02:	91 e0       	ldi	r25, 0x01	; 1
     e04:	93 83       	std	Z+3, r25	; 0x03
     e06:	82 83       	std	Z+2, r24	; 0x02
     e08:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>
     e0c:	0f 90       	pop	r0
     e0e:	0f 90       	pop	r0
     e10:	0f 90       	pop	r0
     e12:	08 95       	ret

00000e14 <LDSrcv>:
}

void LDSrcv(unsigned char c){
	const portTickType xTicksToWait = 10 / portTICK_RATE_MS;
	//xQueueSendToBackFromISR(xQueueLDS, &c, xTicksToWait);
	uart1SendByte(c);
     e14:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
}
     e18:	08 95       	ret

00000e1a <vQuickSend>:
		
	}

}

void vQuickSend(){
     e1a:	ef 92       	push	r14
     e1c:	ff 92       	push	r15
     e1e:	1f 93       	push	r17
     e20:	df 93       	push	r29
     e22:	cf 93       	push	r28
     e24:	0f 92       	push	r0
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10 / portTICK_RATE_MS;
	uint8_t rcv_value;
	for(;;){
		if(uxQueueMessagesWaiting(xQueueLDS) >= 22){
			xQueueReceive(xQueueLDS, &rcv_value, xTicksToWait);
     e2a:	7e 01       	movw	r14, r28
     e2c:	08 94       	sec
     e2e:	e1 1c       	adc	r14, r1
     e30:	f1 1c       	adc	r15, r1

void vQuickSend(){
	const portTickType xTicksToWait = 10 / portTICK_RATE_MS;
	uint8_t rcv_value;
	for(;;){
		if(uxQueueMessagesWaiting(xQueueLDS) >= 22){
     e32:	80 91 10 12 	lds	r24, 0x1210
     e36:	90 91 11 12 	lds	r25, 0x1211
     e3a:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <uxQueueMessagesWaiting>
     e3e:	86 31       	cpi	r24, 0x16	; 22
     e40:	90 f1       	brcs	.+100    	; 0xea6 <vQuickSend+0x8c>
			xQueueReceive(xQueueLDS, &rcv_value, xTicksToWait);
     e42:	80 91 10 12 	lds	r24, 0x1210
     e46:	90 91 11 12 	lds	r25, 0x1211
     e4a:	b7 01       	movw	r22, r14
     e4c:	4a e0       	ldi	r20, 0x0A	; 10
     e4e:	50 e0       	ldi	r21, 0x00	; 0
     e50:	20 e0       	ldi	r18, 0x00	; 0
     e52:	0e 94 bf 10 	call	0x217e	; 0x217e <xQueueGenericReceive>
			if(rcv_value == 0xFA){
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	8a 3f       	cpi	r24, 0xFA	; 250
     e5a:	29 f5       	brne	.+74     	; 0xea6 <vQuickSend+0x8c>
				xQueueReceive(xQueueLDS, &rcv_value, xTicksToWait);
     e5c:	80 91 10 12 	lds	r24, 0x1210
     e60:	90 91 11 12 	lds	r25, 0x1211
     e64:	b7 01       	movw	r22, r14
     e66:	4a e0       	ldi	r20, 0x0A	; 10
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	20 e0       	ldi	r18, 0x00	; 0
     e6c:	0e 94 bf 10 	call	0x217e	; 0x217e <xQueueGenericReceive>
				if((rcv_value >= 0xA0)&&(rcv_value <= 0xF9)){
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	80 5a       	subi	r24, 0xA0	; 160
     e74:	8a 35       	cpi	r24, 0x5A	; 90
     e76:	b8 f4       	brcc	.+46     	; 0xea6 <vQuickSend+0x8c>
					uart1SendByte(0xFA);
     e78:	8a ef       	ldi	r24, 0xFA	; 250
     e7a:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
					uart1SendByte(rcv_value);
     e7e:	89 81       	ldd	r24, Y+1	; 0x01
     e80:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
     e84:	10 e0       	ldi	r17, 0x00	; 0
					for(uint8_t ndx = 0; ndx < 21; ndx++){
						xQueueReceive(xQueueLDS, &rcv_value, xTicksToWait);
     e86:	80 91 10 12 	lds	r24, 0x1210
     e8a:	90 91 11 12 	lds	r25, 0x1211
     e8e:	b7 01       	movw	r22, r14
     e90:	4a e0       	ldi	r20, 0x0A	; 10
     e92:	50 e0       	ldi	r21, 0x00	; 0
     e94:	20 e0       	ldi	r18, 0x00	; 0
     e96:	0e 94 bf 10 	call	0x217e	; 0x217e <xQueueGenericReceive>
						uart1SendByte(rcv_value);
     e9a:	89 81       	ldd	r24, Y+1	; 0x01
     e9c:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
			if(rcv_value == 0xFA){
				xQueueReceive(xQueueLDS, &rcv_value, xTicksToWait);
				if((rcv_value >= 0xA0)&&(rcv_value <= 0xF9)){
					uart1SendByte(0xFA);
					uart1SendByte(rcv_value);
					for(uint8_t ndx = 0; ndx < 21; ndx++){
     ea0:	1f 5f       	subi	r17, 0xFF	; 255
     ea2:	15 31       	cpi	r17, 0x15	; 21
     ea4:	81 f7       	brne	.-32     	; 0xe86 <vQuickSend+0x6c>
						uart1SendByte(rcv_value);
					}
				}
			}
		}
		vTaskDelay( 10/portTICK_RATE_MS);
     ea6:	8a e0       	ldi	r24, 0x0A	; 10
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	0e 94 a7 14 	call	0x294e	; 0x294e <vTaskDelay>
     eae:	c1 cf       	rjmp	.-126    	; 0xe32 <vQuickSend+0x18>

00000eb0 <vQuickReadEnc>:
		p45_range = 0;
	}

}

void vQuickReadEnc(){
     eb0:	0f 93       	push	r16
     eb2:	1f 93       	push	r17
	uint16_t right_enc;	//pin 10
	uint16_t left_enc; 	//pin 11

	for(;;){

		right_enc = a2dConvert10bit(10);
     eb4:	8a e0       	ldi	r24, 0x0A	; 10
     eb6:	0e 94 8c 26 	call	0x4d18	; 0x4d18 <a2dConvert10bit>
     eba:	18 2f       	mov	r17, r24
		left_enc = a2dConvert10bit(11);
     ebc:	8b e0       	ldi	r24, 0x0B	; 11
     ebe:	0e 94 8c 26 	call	0x4d18	; 0x4d18 <a2dConvert10bit>
     ec2:	08 2f       	mov	r16, r24
		taskENTER_CRITICAL();
     ec4:	0f b6       	in	r0, 0x3f	; 63
     ec6:	f8 94       	cli
     ec8:	0f 92       	push	r0
		uart1SendByte('R');
     eca:	82 e5       	ldi	r24, 0x52	; 82
     ecc:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
		uart1SendByte(right_enc);
     ed0:	81 2f       	mov	r24, r17
     ed2:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
		uart1SendByte('L');
     ed6:	8c e4       	ldi	r24, 0x4C	; 76
     ed8:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
		uart1SendByte(left_enc);
     edc:	80 2f       	mov	r24, r16
     ede:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
		uart1SendByte('/n');
     ee2:	8e e6       	ldi	r24, 0x6E	; 110
     ee4:	0e 94 da 21 	call	0x43b4	; 0x43b4 <uart1SendByte>
		taskEXIT_CRITICAL();
     ee8:	0f 90       	pop	r0
     eea:	0f be       	out	0x3f, r0	; 63
		vTaskDelay( 250/portTICK_RATE_MS);
     eec:	8a ef       	ldi	r24, 0xFA	; 250
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	0e 94 a7 14 	call	0x294e	; 0x294e <vTaskDelay>
     ef4:	df cf       	rjmp	.-66     	; 0xeb4 <vQuickReadEnc+0x4>

00000ef6 <vScript>:
		
	}

}

void vScript(){
     ef6:	ef 92       	push	r14
     ef8:	ff 92       	push	r15
     efa:	0f 93       	push	r16
     efc:	1f 93       	push	r17
     efe:	df 93       	push	r29
     f00:	cf 93       	push	r28
     f02:	00 d0       	rcall	.+0      	; 0xf04 <vScript+0xe>
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     f08:	8e 01       	movw	r16, r28
     f0a:	0f 5f       	subi	r16, 0xFF	; 255
     f0c:	1f 4f       	sbci	r17, 0xFF	; 255
		cmd_angle = 90;
     f0e:	aa e5       	ldi	r26, 0x5A	; 90
     f10:	ea 2e       	mov	r14, r26
     f12:	f1 2c       	mov	r15, r1
void vScript(){
	const portTickType xTicksToWait = 10000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;

	for(;;){
		cmd_angle = 0;
     f14:	10 92 c1 02 	sts	0x02C1, r1
     f18:	10 92 c0 02 	sts	0x02C0, r1
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     f1c:	c8 01       	movw	r24, r16
     f1e:	60 e1       	ldi	r22, 0x10	; 16
     f20:	77 e2       	ldi	r23, 0x27	; 39
     f22:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
		cmd_angle = 90;
     f26:	f0 92 c1 02 	sts	0x02C1, r15
     f2a:	e0 92 c0 02 	sts	0x02C0, r14
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     f2e:	c8 01       	movw	r24, r16
     f30:	60 e1       	ldi	r22, 0x10	; 16
     f32:	77 e2       	ldi	r23, 0x27	; 39
     f34:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
     f38:	ed cf       	rjmp	.-38     	; 0xf14 <vScript+0x1e>

00000f3a <vRampVel>:
	uart3SendByte(r2);
	uart3SendByte(r1);
	uart3SendByte('\n'); //line feed
}

void vRampVel(){
     f3a:	8f 92       	push	r8
     f3c:	9f 92       	push	r9
     f3e:	af 92       	push	r10
     f40:	bf 92       	push	r11
     f42:	cf 92       	push	r12
     f44:	df 92       	push	r13
     f46:	ef 92       	push	r14
     f48:	ff 92       	push	r15
     f4a:	0f 93       	push	r16
     f4c:	1f 93       	push	r17
     f4e:	df 93       	push	r29
     f50:	cf 93       	push	r28
     f52:	00 d0       	rcall	.+0      	; 0xf54 <vRampVel+0x1a>
     f54:	cd b7       	in	r28, 0x3d	; 61
     f56:	de b7       	in	r29, 0x3e	; 62
	const portTickType xTicksToWait = 1000 / portTICK_RATE_MS;
	portTickType xLastWakeTime;
	v_command = 0;
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	a0 e0       	ldi	r26, 0x00	; 0
     f5e:	b0 e0       	ldi	r27, 0x00	; 0
     f60:	80 93 9a 02 	sts	0x029A, r24
     f64:	90 93 9b 02 	sts	0x029B, r25
     f68:	a0 93 9c 02 	sts	0x029C, r26
     f6c:	b0 93 9d 02 	sts	0x029D, r27
	inst_cmd_vel = 25;
     f70:	80 e0       	ldi	r24, 0x00	; 0
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	a8 ec       	ldi	r26, 0xC8	; 200
     f76:	b1 e4       	ldi	r27, 0x41	; 65
     f78:	80 93 9e 02 	sts	0x029E, r24
     f7c:	90 93 9f 02 	sts	0x029F, r25
     f80:	a0 93 a0 02 	sts	0x02A0, r26
     f84:	b0 93 a1 02 	sts	0x02A1, r27
	vTaskDelayUntil(&xLastWakeTime, 10000 / portTICK_RATE_MS);	//leave velocity at zero briefly
     f88:	8e 01       	movw	r16, r28
     f8a:	0f 5f       	subi	r16, 0xFF	; 255
     f8c:	1f 4f       	sbci	r17, 0xFF	; 255
     f8e:	c8 01       	movw	r24, r16
     f90:	60 e1       	ldi	r22, 0x10	; 16
     f92:	77 e2       	ldi	r23, 0x27	; 39
     f94:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>

	for(;;){
		
		vTaskDelayUntil(&xLastWakeTime, xTicksToWait);
     f98:	48 01       	movw	r8, r16
     f9a:	c4 01       	movw	r24, r8
     f9c:	68 ee       	ldi	r22, 0xE8	; 232
     f9e:	73 e0       	ldi	r23, 0x03	; 3
     fa0:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
		//if(v_command != inst_cmd_vel){v_command++;}
		v_command += (1/(inst_cmd_vel - v_command))*(inst_cmd_vel);
     fa4:	e0 90 9e 02 	lds	r14, 0x029E
     fa8:	f0 90 9f 02 	lds	r15, 0x029F
     fac:	00 91 a0 02 	lds	r16, 0x02A0
     fb0:	10 91 a1 02 	lds	r17, 0x02A1
     fb4:	a0 90 9a 02 	lds	r10, 0x029A
     fb8:	b0 90 9b 02 	lds	r11, 0x029B
     fbc:	c0 90 9c 02 	lds	r12, 0x029C
     fc0:	d0 90 9d 02 	lds	r13, 0x029D
     fc4:	c8 01       	movw	r24, r16
     fc6:	b7 01       	movw	r22, r14
     fc8:	a6 01       	movw	r20, r12
     fca:	95 01       	movw	r18, r10
     fcc:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
     fd0:	9b 01       	movw	r18, r22
     fd2:	ac 01       	movw	r20, r24
     fd4:	60 e0       	ldi	r22, 0x00	; 0
     fd6:	70 e0       	ldi	r23, 0x00	; 0
     fd8:	80 e8       	ldi	r24, 0x80	; 128
     fda:	9f e3       	ldi	r25, 0x3F	; 63
     fdc:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
     fe0:	a8 01       	movw	r20, r16
     fe2:	97 01       	movw	r18, r14
     fe4:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
     fe8:	9b 01       	movw	r18, r22
     fea:	ac 01       	movw	r20, r24
     fec:	c6 01       	movw	r24, r12
     fee:	b5 01       	movw	r22, r10
     ff0:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
     ff4:	60 93 9a 02 	sts	0x029A, r22
     ff8:	70 93 9b 02 	sts	0x029B, r23
     ffc:	80 93 9c 02 	sts	0x029C, r24
    1000:	90 93 9d 02 	sts	0x029D, r25

		if(v_command > 25){v_command = 25;}
    1004:	20 e0       	ldi	r18, 0x00	; 0
    1006:	30 e0       	ldi	r19, 0x00	; 0
    1008:	48 ec       	ldi	r20, 0xC8	; 200
    100a:	51 e4       	ldi	r21, 0x41	; 65
    100c:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    1010:	18 16       	cp	r1, r24
    1012:	64 f4       	brge	.+24     	; 0x102c <vRampVel+0xf2>
    1014:	80 e0       	ldi	r24, 0x00	; 0
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	a8 ec       	ldi	r26, 0xC8	; 200
    101a:	b1 e4       	ldi	r27, 0x41	; 65
    101c:	80 93 9a 02 	sts	0x029A, r24
    1020:	90 93 9b 02 	sts	0x029B, r25
    1024:	a0 93 9c 02 	sts	0x029C, r26
    1028:	b0 93 9d 02 	sts	0x029D, r27
		if(v_command <  0){v_command =  0;}
    102c:	60 91 9a 02 	lds	r22, 0x029A
    1030:	70 91 9b 02 	lds	r23, 0x029B
    1034:	80 91 9c 02 	lds	r24, 0x029C
    1038:	90 91 9d 02 	lds	r25, 0x029D
    103c:	20 e0       	ldi	r18, 0x00	; 0
    103e:	30 e0       	ldi	r19, 0x00	; 0
    1040:	40 e0       	ldi	r20, 0x00	; 0
    1042:	50 e0       	ldi	r21, 0x00	; 0
    1044:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1048:	88 23       	and	r24, r24
    104a:	0c f0       	brlt	.+2      	; 0x104e <vRampVel+0x114>
    104c:	a6 cf       	rjmp	.-180    	; 0xf9a <vRampVel+0x60>
    104e:	80 e0       	ldi	r24, 0x00	; 0
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	a0 e0       	ldi	r26, 0x00	; 0
    1054:	b0 e0       	ldi	r27, 0x00	; 0
    1056:	80 93 9a 02 	sts	0x029A, r24
    105a:	90 93 9b 02 	sts	0x029B, r25
    105e:	a0 93 9c 02 	sts	0x029C, r26
    1062:	b0 93 9d 02 	sts	0x029D, r27
    1066:	99 cf       	rjmp	.-206    	; 0xf9a <vRampVel+0x60>

00001068 <vLight1On>:
		PORT_OFF(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		
	}
}
void vLight1On(void *pvParameters){
    1068:	0f 93       	push	r16
    106a:	1f 93       	push	r17
    106c:	df 93       	push	r29
    106e:	cf 93       	push	r28
    1070:	00 d0       	rcall	.+0      	; 0x1072 <vLight1On+0xa>
    1072:	cd b7       	in	r28, 0x3d	; 61
    1074:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		LED_on();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1076:	8e 01       	movw	r16, r28
    1078:	0f 5f       	subi	r16, 0xFF	; 255
    107a:	1f 4f       	sbci	r17, 0xFF	; 255
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    107c:	2e 98       	cbi	0x05, 6	; 5
    107e:	c8 01       	movw	r24, r16
    1080:	62 e3       	ldi	r22, 0x32	; 50
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1088:	2e 9a       	sbi	0x05, 6	; 5
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
    108a:	c8 01       	movw	r24, r16
    108c:	62 e3       	ldi	r22, 0x32	; 50
    108e:	70 e0       	ldi	r23, 0x00	; 0
    1090:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
    1094:	f3 cf       	rjmp	.-26     	; 0x107c <vLight1On+0x14>

00001096 <vLight0On>:
	}
}



void vLight0On(void *pvParameters){
    1096:	0f 93       	push	r16
    1098:	1f 93       	push	r17
    109a:	df 93       	push	r29
    109c:	cf 93       	push	r28
    109e:	00 d0       	rcall	.+0      	; 0x10a0 <vLight0On+0xa>
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10a4:	8e 01       	movw	r16, r28
    10a6:	0f 5f       	subi	r16, 0xFF	; 255
    10a8:	1f 4f       	sbci	r17, 0xFF	; 255


void vLight0On(void *pvParameters){
	portTickType xLastWakeTime;
	for(;;){
		PORT_ON(PORTA, 0);
    10aa:	10 9a       	sbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10ac:	c8 01       	movw	r24, r16
    10ae:	62 e3       	ldi	r22, 0x32	; 50
    10b0:	70 e0       	ldi	r23, 0x00	; 0
    10b2:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
		//taskYIELD();	
		PORT_OFF(PORTA, 0);
    10b6:	10 98       	cbi	0x02, 0	; 2
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10b8:	c8 01       	movw	r24, r16
    10ba:	62 e3       	ldi	r22, 0x32	; 50
    10bc:	70 e0       	ldi	r23, 0x00	; 0
    10be:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
    10c2:	f3 cf       	rjmp	.-26     	; 0x10aa <vLight0On+0x14>

000010c4 <vPID_R>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
	}

}

void vPID_R(void* pvParameters){
    10c4:	6f 92       	push	r6
    10c6:	7f 92       	push	r7
    10c8:	8f 92       	push	r8
    10ca:	9f 92       	push	r9
    10cc:	af 92       	push	r10
    10ce:	bf 92       	push	r11
    10d0:	cf 92       	push	r12
    10d2:	df 92       	push	r13
    10d4:	ef 92       	push	r14
    10d6:	ff 92       	push	r15
    10d8:	0f 93       	push	r16
    10da:	1f 93       	push	r17
    10dc:	df 93       	push	r29
    10de:	cf 93       	push	r28
    10e0:	00 d0       	rcall	.+0      	; 0x10e2 <vPID_R+0x1e>
    10e2:	cd b7       	in	r28, 0x3d	; 61
    10e4:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
    10e6:	80 91 90 00 	lds	r24, 0x0090
    10ea:	80 68       	ori	r24, 0x80	; 128
    10ec:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3A0);
    10f0:	80 91 90 00 	lds	r24, 0x0090
    10f4:	8f 7b       	andi	r24, 0xBF	; 191
    10f6:	80 93 90 00 	sts	0x0090, r24
    10fa:	88 24       	eor	r8, r8
    10fc:	99 24       	eor	r9, r9
	//		if(adj == 'p'){ KD+= 0.01;}
	//		else if(adj == 'l'){ KD -= 0.01;}
			


		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    10fe:	3e 01       	movw	r6, r28
    1100:	08 94       	sec
    1102:	61 1c       	adc	r6, r1
    1104:	71 1c       	adc	r7, r1
	wheel_R_on();

	char adj;
	for(;;){
			
			signed int v_out = v_command - v_offset;
    1106:	e0 90 9a 02 	lds	r14, 0x029A
    110a:	f0 90 9b 02 	lds	r15, 0x029B
    110e:	00 91 9c 02 	lds	r16, 0x029C
    1112:	10 91 9d 02 	lds	r17, 0x029D
    1116:	60 91 a2 02 	lds	r22, 0x02A2
    111a:	70 91 a3 02 	lds	r23, 0x02A3
    111e:	88 27       	eor	r24, r24
    1120:	77 fd       	sbrc	r23, 7
    1122:	80 95       	com	r24
    1124:	98 2f       	mov	r25, r24
    1126:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    112a:	9b 01       	movw	r18, r22
    112c:	ac 01       	movw	r20, r24
    112e:	c8 01       	movw	r24, r16
    1130:	b7 01       	movw	r22, r14
    1132:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1136:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    113a:	5b 01       	movw	r10, r22
    113c:	6c 01       	movw	r12, r24
			error = v_command - (-RIGHTVel_current);
    113e:	60 91 b0 02 	lds	r22, 0x02B0
    1142:	70 91 b1 02 	lds	r23, 0x02B1
    1146:	70 95       	com	r23
    1148:	61 95       	neg	r22
    114a:	7f 4f       	sbci	r23, 0xFF	; 255
    114c:	88 27       	eor	r24, r24
    114e:	77 fd       	sbrc	r23, 7
    1150:	80 95       	com	r24
    1152:	98 2f       	mov	r25, r24
    1154:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1158:	9b 01       	movw	r18, r22
    115a:	ac 01       	movw	r20, r24
    115c:	c8 01       	movw	r24, r16
    115e:	b7 01       	movw	r22, r14
    1160:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1164:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    1168:	6b 01       	movw	r12, r22
	//		d_error = (error - pre_error)/dt;
	//		wD = 1 - (d_error)/(d_error + cD);
	//		d_error *= wD; 
			v_out += (signed int)((KP * error) + (KI * acc_error));
    116a:	b6 01       	movw	r22, r12
    116c:	88 27       	eor	r24, r24
    116e:	77 fd       	sbrc	r23, 7
    1170:	80 95       	com	r24
    1172:	98 2f       	mov	r25, r24
    1174:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1178:	20 e0       	ldi	r18, 0x00	; 0
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	40 e8       	ldi	r20, 0x80	; 128
    117e:	5e e3       	ldi	r21, 0x3E	; 62
    1180:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1184:	7b 01       	movw	r14, r22
    1186:	8c 01       	movw	r16, r24
    1188:	b4 01       	movw	r22, r8
    118a:	88 27       	eor	r24, r24
    118c:	77 fd       	sbrc	r23, 7
    118e:	80 95       	com	r24
    1190:	98 2f       	mov	r25, r24
    1192:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1196:	20 e0       	ldi	r18, 0x00	; 0
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	40 e0       	ldi	r20, 0x00	; 0
    119c:	5e e3       	ldi	r21, 0x3E	; 62
    119e:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    11a2:	9b 01       	movw	r18, r22
    11a4:	ac 01       	movw	r20, r24
    11a6:	c8 01       	movw	r24, r16
    11a8:	b7 01       	movw	r22, r14
    11aa:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    11ae:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    11b2:	6a 0d       	add	r22, r10
    11b4:	7b 1d       	adc	r23, r11
	//		pre_error = error;
			if(v_out > 36){v_out = 36;}
    11b6:	65 32       	cpi	r22, 0x25	; 37
    11b8:	71 05       	cpc	r23, r1
    11ba:	1c f0       	brlt	.+6      	; 0x11c2 <vPID_R+0xfe>
    11bc:	64 e2       	ldi	r22, 0x24	; 36
    11be:	70 e0       	ldi	r23, 0x00	; 0
    11c0:	06 c0       	rjmp	.+12     	; 0x11ce <vPID_R+0x10a>
			if(v_out < -36){v_out = -36;}
    11c2:	8f ef       	ldi	r24, 0xFF	; 255
    11c4:	6c 3d       	cpi	r22, 0xDC	; 220
    11c6:	78 07       	cpc	r23, r24
    11c8:	14 f4       	brge	.+4      	; 0x11ce <vPID_R+0x10a>
    11ca:	6c ed       	ldi	r22, 0xDC	; 220
    11cc:	7f ef       	ldi	r23, 0xFF	; 255
			taskENTER_CRITICAL();
    11ce:	0f b6       	in	r0, 0x3f	; 63
    11d0:	f8 94       	cli
    11d2:	0f 92       	push	r0
			wheel_R(-v_out);
    11d4:	88 27       	eor	r24, r24
    11d6:	99 27       	eor	r25, r25
    11d8:	86 1b       	sub	r24, r22
    11da:	97 0b       	sbc	r25, r23
    11dc:	0e 94 b9 05 	call	0xb72	; 0xb72 <wheel_R>
			
		
		//rprintfNum(10, 5, 0, ' ', s_out);
//		rprintf("RRR: %d , %d\n",v_out,RIGHTVel_current);
	//	rprintf("%d\n", -RIGHTVel_current);
			taskEXIT_CRITICAL();
    11e0:	0f 90       	pop	r0
    11e2:	0f be       	out	0x3f, r0	; 63

			acc_error += error;
    11e4:	8c 0c       	add	r8, r12
    11e6:	9d 1c       	adc	r9, r13
	//		if(adj == 'p'){ KD+= 0.01;}
	//		else if(adj == 'l'){ KD -= 0.01;}
			


		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    11e8:	c3 01       	movw	r24, r6
    11ea:	62 e3       	ldi	r22, 0x32	; 50
    11ec:	70 e0       	ldi	r23, 0x00	; 0
    11ee:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
    11f2:	89 cf       	rjmp	.-238    	; 0x1106 <vPID_R+0x42>

000011f4 <vPID_L>:
		taskEXIT_CRITICAL();


}

void vPID_L(void* pvParameters){
    11f4:	4f 92       	push	r4
    11f6:	5f 92       	push	r5
    11f8:	6f 92       	push	r6
    11fa:	7f 92       	push	r7
    11fc:	8f 92       	push	r8
    11fe:	9f 92       	push	r9
    1200:	af 92       	push	r10
    1202:	bf 92       	push	r11
    1204:	cf 92       	push	r12
    1206:	df 92       	push	r13
    1208:	ef 92       	push	r14
    120a:	ff 92       	push	r15
    120c:	0f 93       	push	r16
    120e:	1f 93       	push	r17
    1210:	df 93       	push	r29
    1212:	cf 93       	push	r28
    1214:	00 d0       	rcall	.+0      	; 0x1216 <vPID_L+0x22>
    1216:	cd b7       	in	r28, 0x3d	; 61
    1218:	de b7       	in	r29, 0x3e	; 62
}
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
    121a:	80 91 90 00 	lds	r24, 0x0090
    121e:	80 62       	ori	r24, 0x20	; 32
    1220:	80 93 90 00 	sts	0x0090, r24
	cbi(TCCR3A,COM3B0);
    1224:	80 91 90 00 	lds	r24, 0x0090
    1228:	8f 7e       	andi	r24, 0xEF	; 239
    122a:	80 93 90 00 	sts	0x0090, r24
    122e:	66 24       	eor	r6, r6
    1230:	77 24       	eor	r7, r7

		
			//rprintfNum(10, 5, 0, ' ', s_out);
//			rprintf("LLL: %d , %d\n",v_out,LEFTVel_current);
			taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    1232:	2e 01       	movw	r4, r28
    1234:	08 94       	sec
    1236:	41 1c       	adc	r4, r1
    1238:	51 1c       	adc	r5, r1
	

	wheel_L_on();

	for(;;){
			signed int v_out = v_command + v_offset;
    123a:	60 91 a2 02 	lds	r22, 0x02A2
    123e:	70 91 a3 02 	lds	r23, 0x02A3
    1242:	88 27       	eor	r24, r24
    1244:	77 fd       	sbrc	r23, 7
    1246:	80 95       	com	r24
    1248:	98 2f       	mov	r25, r24
    124a:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    124e:	20 91 9a 02 	lds	r18, 0x029A
    1252:	30 91 9b 02 	lds	r19, 0x029B
    1256:	40 91 9c 02 	lds	r20, 0x029C
    125a:	50 91 9d 02 	lds	r21, 0x029D
    125e:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    1262:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    1266:	7b 01       	movw	r14, r22
    1268:	8c 01       	movw	r16, r24
			error = v_out - LEFTVel_current;
    126a:	80 91 a4 02 	lds	r24, 0x02A4
    126e:	90 91 a5 02 	lds	r25, 0x02A5
    1272:	47 01       	movw	r8, r14
    1274:	88 1a       	sub	r8, r24
    1276:	99 0a       	sbc	r9, r25
	//		d_error = (error - pre_error);
			
			v_out += (signed int)((KP * error) + (KI * acc_error));
    1278:	b4 01       	movw	r22, r8
    127a:	88 27       	eor	r24, r24
    127c:	77 fd       	sbrc	r23, 7
    127e:	80 95       	com	r24
    1280:	98 2f       	mov	r25, r24
    1282:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1286:	20 e0       	ldi	r18, 0x00	; 0
    1288:	30 e0       	ldi	r19, 0x00	; 0
    128a:	40 e8       	ldi	r20, 0x80	; 128
    128c:	5e e3       	ldi	r21, 0x3E	; 62
    128e:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1292:	5b 01       	movw	r10, r22
    1294:	6c 01       	movw	r12, r24
    1296:	b3 01       	movw	r22, r6
    1298:	88 27       	eor	r24, r24
    129a:	77 fd       	sbrc	r23, 7
    129c:	80 95       	com	r24
    129e:	98 2f       	mov	r25, r24
    12a0:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    12a4:	20 e0       	ldi	r18, 0x00	; 0
    12a6:	30 e0       	ldi	r19, 0x00	; 0
    12a8:	40 e0       	ldi	r20, 0x00	; 0
    12aa:	5e e3       	ldi	r21, 0x3E	; 62
    12ac:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    12b0:	9b 01       	movw	r18, r22
    12b2:	ac 01       	movw	r20, r24
    12b4:	c6 01       	movw	r24, r12
    12b6:	b5 01       	movw	r22, r10
    12b8:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    12bc:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    12c0:	cb 01       	movw	r24, r22
    12c2:	8e 0d       	add	r24, r14
    12c4:	9f 1d       	adc	r25, r15
	//		pre_error = error;
			acc_error += error;
    12c6:	68 0c       	add	r6, r8
    12c8:	79 1c       	adc	r7, r9

			if(v_out > 36){v_out = 36;}
    12ca:	85 32       	cpi	r24, 0x25	; 37
    12cc:	91 05       	cpc	r25, r1
    12ce:	1c f0       	brlt	.+6      	; 0x12d6 <vPID_L+0xe2>
    12d0:	84 e2       	ldi	r24, 0x24	; 36
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	06 c0       	rjmp	.+12     	; 0x12e2 <vPID_L+0xee>
			if(v_out < -36){v_out = -36;}
    12d6:	2f ef       	ldi	r18, 0xFF	; 255
    12d8:	8c 3d       	cpi	r24, 0xDC	; 220
    12da:	92 07       	cpc	r25, r18
    12dc:	14 f4       	brge	.+4      	; 0x12e2 <vPID_L+0xee>
    12de:	8c ed       	ldi	r24, 0xDC	; 220
    12e0:	9f ef       	ldi	r25, 0xFF	; 255
			taskENTER_CRITICAL();
    12e2:	0f b6       	in	r0, 0x3f	; 63
    12e4:	f8 94       	cli
    12e6:	0f 92       	push	r0
			wheel_L(v_out);
    12e8:	0e 94 8d 05 	call	0xb1a	; 0xb1a <wheel_L>

		
			//rprintfNum(10, 5, 0, ' ', s_out);
//			rprintf("LLL: %d , %d\n",v_out,LEFTVel_current);
			taskEXIT_CRITICAL();
    12ec:	0f 90       	pop	r0
    12ee:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
    12f0:	c2 01       	movw	r24, r4
    12f2:	62 e3       	ldi	r22, 0x32	; 50
    12f4:	70 e0       	ldi	r23, 0x00	; 0
    12f6:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
    12fa:	9f cf       	rjmp	.-194    	; 0x123a <vPID_L+0x46>

000012fc <vEnc_UpdatePose>:
		
	
	}
}

void vEnc_UpdatePose(){
    12fc:	df 92       	push	r13
    12fe:	ef 92       	push	r14
    1300:	ff 92       	push	r15
    1302:	0f 93       	push	r16
    1304:	1f 93       	push	r17

	for(;;){
		
		//The below formula yields the encoder calculated angular velocity of the robot
		//as it rotates about some ICC(Instantaneous Center of Curvature)
		reset_timer0();
    1306:	0e 94 23 1b 	call	0x3646	; 0x3646 <reset_timer0>
		enc_ang_vel = ((-RIGHTVel_current) - LEFTVel_current) / ROBOT_DIAMETER;
    130a:	60 91 b0 02 	lds	r22, 0x02B0
    130e:	70 91 b1 02 	lds	r23, 0x02B1
    1312:	70 95       	com	r23
    1314:	61 95       	neg	r22
    1316:	7f 4f       	sbci	r23, 0xFF	; 255
    1318:	20 91 a4 02 	lds	r18, 0x02A4
    131c:	30 91 a5 02 	lds	r19, 0x02A5
    1320:	62 1b       	sub	r22, r18
    1322:	73 0b       	sbc	r23, r19
    1324:	88 27       	eor	r24, r24
    1326:	77 fd       	sbrc	r23, 7
    1328:	80 95       	com	r24
    132a:	98 2f       	mov	r25, r24
    132c:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1330:	26 e6       	ldi	r18, 0x66	; 102
    1332:	36 e6       	ldi	r19, 0x66	; 102
    1334:	46 e8       	ldi	r20, 0x86	; 134
    1336:	51 e4       	ldi	r21, 0x41	; 65
    1338:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    133c:	7b 01       	movw	r14, r22
    133e:	8c 01       	movw	r16, r24
		elapsed_time = ((get_timer0_overflow()*255 + TCNT0) * 0.256) / 1000;
    1340:	0e 94 c4 1a 	call	0x3588	; 0x3588 <get_timer0_overflow>
    1344:	d6 b4       	in	r13, 0x26	; 38
		//dRL = dRIGHTDis - dLEFTDis;
		//dis_enc_heading += sin((dRL)/ ROBOT_DIAMETER);
		//dRIGHTDis = dLEFTDis = 0;
		enc_heading += enc_ang_vel * elapsed_time;
    1346:	2f ef       	ldi	r18, 0xFF	; 255
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	40 e0       	ldi	r20, 0x00	; 0
    134c:	50 e0       	ldi	r21, 0x00	; 0
    134e:	0e 94 ff 2f 	call	0x5ffe	; 0x5ffe <__mulsi3>
    1352:	6d 0d       	add	r22, r13
    1354:	71 1d       	adc	r23, r1
    1356:	81 1d       	adc	r24, r1
    1358:	91 1d       	adc	r25, r1
    135a:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <__floatunsisf>
    135e:	2f e6       	ldi	r18, 0x6F	; 111
    1360:	32 e1       	ldi	r19, 0x12	; 18
    1362:	43 e8       	ldi	r20, 0x83	; 131
    1364:	5e e3       	ldi	r21, 0x3E	; 62
    1366:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    136a:	20 e0       	ldi	r18, 0x00	; 0
    136c:	30 e0       	ldi	r19, 0x00	; 0
    136e:	4a e7       	ldi	r20, 0x7A	; 122
    1370:	54 e4       	ldi	r21, 0x44	; 68
    1372:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1376:	9b 01       	movw	r18, r22
    1378:	ac 01       	movw	r20, r24
    137a:	c8 01       	movw	r24, r16
    137c:	b7 01       	movw	r22, r14
    137e:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1382:	9b 01       	movw	r18, r22
    1384:	ac 01       	movw	r20, r24
    1386:	60 91 bc 02 	lds	r22, 0x02BC
    138a:	70 91 bd 02 	lds	r23, 0x02BD
    138e:	80 91 be 02 	lds	r24, 0x02BE
    1392:	90 91 bf 02 	lds	r25, 0x02BF
    1396:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    139a:	60 93 bc 02 	sts	0x02BC, r22
    139e:	70 93 bd 02 	sts	0x02BD, r23
    13a2:	80 93 be 02 	sts	0x02BE, r24
    13a6:	90 93 bf 02 	sts	0x02BF, r25
    13aa:	ad cf       	rjmp	.-166    	; 0x1306 <vEnc_UpdatePose+0xa>

000013ac <send_frame>:
	}
	return c;
}


void send_frame(char flag, int16_t data){
    13ac:	ff 92       	push	r15
    13ae:	0f 93       	push	r16
    13b0:	1f 93       	push	r17
    13b2:	cf 93       	push	r28
    13b4:	df 93       	push	r29
    13b6:	eb 01       	movw	r28, r22
	uint8_t r1 = 0;
	uint8_t r2 = 0;
	uint8_t r3 = 0;
	uint8_t r4 = 0;

	uart3SendByte(flag);
    13b8:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <uart3SendByte>

	r1 = num2char(0x0F & (uint8_t)data);
    13bc:	8f e0       	ldi	r24, 0x0F	; 15
    13be:	f8 2e       	mov	r15, r24
    13c0:	fc 22       	and	r15, r28
}
*/

char num2char(char c){
	
	if(c <10){
    13c2:	89 e0       	ldi	r24, 0x09	; 9
    13c4:	8f 15       	cp	r24, r15
    13c6:	18 f0       	brcs	.+6      	; 0x13ce <send_frame+0x22>
		c += 48;
    13c8:	90 e3       	ldi	r25, 0x30	; 48
    13ca:	f9 0e       	add	r15, r25
    13cc:	06 c0       	rjmp	.+12     	; 0x13da <send_frame+0x2e>
	}
	else if((c >= 10) && (c <= 16)){
    13ce:	8f 2d       	mov	r24, r15
    13d0:	8a 50       	subi	r24, 0x0A	; 10
    13d2:	87 30       	cpi	r24, 0x07	; 7
    13d4:	10 f4       	brcc	.+4      	; 0x13da <send_frame+0x2e>
		c += 55;
    13d6:	87 e3       	ldi	r24, 0x37	; 55
    13d8:	f8 0e       	add	r15, r24
	uint8_t r4 = 0;

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
    13da:	ce 01       	movw	r24, r28
    13dc:	04 e0       	ldi	r16, 0x04	; 4
    13de:	95 95       	asr	r25
    13e0:	87 95       	ror	r24
    13e2:	0a 95       	dec	r16
    13e4:	e1 f7       	brne	.-8      	; 0x13de <send_frame+0x32>
    13e6:	08 2f       	mov	r16, r24
    13e8:	0f 70       	andi	r16, 0x0F	; 15
}
*/

char num2char(char c){
	
	if(c <10){
    13ea:	0a 30       	cpi	r16, 0x0A	; 10
    13ec:	10 f4       	brcc	.+4      	; 0x13f2 <send_frame+0x46>
		c += 48;
    13ee:	00 5d       	subi	r16, 0xD0	; 208
    13f0:	05 c0       	rjmp	.+10     	; 0x13fc <send_frame+0x50>
	}
	else if((c >= 10) && (c <= 16)){
    13f2:	80 2f       	mov	r24, r16
    13f4:	8a 50       	subi	r24, 0x0A	; 10
    13f6:	87 30       	cpi	r24, 0x07	; 7
    13f8:	08 f4       	brcc	.+2      	; 0x13fc <send_frame+0x50>
		c += 55;
    13fa:	09 5c       	subi	r16, 0xC9	; 201

	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
    13fc:	8d 2f       	mov	r24, r29
    13fe:	99 27       	eor	r25, r25
    1400:	87 fd       	sbrc	r24, 7
    1402:	9a 95       	dec	r25
    1404:	18 2f       	mov	r17, r24
    1406:	1f 70       	andi	r17, 0x0F	; 15
}
*/

char num2char(char c){
	
	if(c <10){
    1408:	1a 30       	cpi	r17, 0x0A	; 10
    140a:	10 f4       	brcc	.+4      	; 0x1410 <send_frame+0x64>
		c += 48;
    140c:	10 5d       	subi	r17, 0xD0	; 208
    140e:	05 c0       	rjmp	.+10     	; 0x141a <send_frame+0x6e>
	}
	else if((c >= 10) && (c <= 16)){
    1410:	81 2f       	mov	r24, r17
    1412:	8a 50       	subi	r24, 0x0A	; 10
    1414:	87 30       	cpi	r24, 0x07	; 7
    1416:	08 f4       	brcc	.+2      	; 0x141a <send_frame+0x6e>
		c += 55;
    1418:	19 5c       	subi	r17, 0xC9	; 201
	uart3SendByte(flag);

	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );
    141a:	c0 e1       	ldi	r28, 0x10	; 16
    141c:	dc 02       	muls	r29, r28
    141e:	c1 2d       	mov	r28, r1
    1420:	dd 0b       	sbc	r29, r29
    1422:	11 24       	eor	r1, r1
    1424:	ce 01       	movw	r24, r28
    1426:	8f 70       	andi	r24, 0x0F	; 15
    1428:	68 2f       	mov	r22, r24
}
*/

char num2char(char c){
	
	if(c <10){
    142a:	8a 30       	cpi	r24, 0x0A	; 10
    142c:	10 f4       	brcc	.+4      	; 0x1432 <send_frame+0x86>
		c += 48;
    142e:	60 5d       	subi	r22, 0xD0	; 208
    1430:	04 c0       	rjmp	.+8      	; 0x143a <send_frame+0x8e>
	}
	else if((c >= 10) && (c <= 16)){
    1432:	8a 50       	subi	r24, 0x0A	; 10
    1434:	87 30       	cpi	r24, 0x07	; 7
    1436:	08 f4       	brcc	.+2      	; 0x143a <send_frame+0x8e>
		c += 55;
    1438:	69 5c       	subi	r22, 0xC9	; 201
	r1 = num2char(0x0F & (uint8_t)data);
	r2 = num2char(0x0F & ((uint8_t)(data >> 4)) );
	r3 = num2char(0x0F & ((uint8_t)(data >> 8)) );
	r4 = num2char(0x0F & ((uint8_t)(data >> 12)) );

	uart3SendByte(r4);
    143a:	86 2f       	mov	r24, r22
    143c:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <uart3SendByte>
	uart3SendByte(r3);
    1440:	81 2f       	mov	r24, r17
    1442:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <uart3SendByte>
	uart3SendByte(r2);
    1446:	80 2f       	mov	r24, r16
    1448:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <uart3SendByte>
	uart3SendByte(r1);
    144c:	8f 2d       	mov	r24, r15
    144e:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <uart3SendByte>
	uart3SendByte('\n'); //line feed
    1452:	8a e0       	ldi	r24, 0x0A	; 10
    1454:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <uart3SendByte>
}
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	08 95       	ret

00001464 <vUpdatePose>:


	}
}

void vUpdatePose(){
    1464:	af 92       	push	r10
    1466:	bf 92       	push	r11
    1468:	cf 92       	push	r12
    146a:	df 92       	push	r13
    146c:	ef 92       	push	r14
    146e:	ff 92       	push	r15
    1470:	0f 93       	push	r16
    1472:	1f 93       	push	r17
	s16 dDis;
	float CMD_K = 0.5;
	float COR_K = 1;

	for(;;){
		robot.heading = (180 * enc_heading) / M_PI; 
    1474:	60 91 bc 02 	lds	r22, 0x02BC
    1478:	70 91 bd 02 	lds	r23, 0x02BD
    147c:	80 91 be 02 	lds	r24, 0x02BE
    1480:	90 91 bf 02 	lds	r25, 0x02BF
    1484:	20 e0       	ldi	r18, 0x00	; 0
    1486:	30 e0       	ldi	r19, 0x00	; 0
    1488:	44 e3       	ldi	r20, 0x34	; 52
    148a:	53 e4       	ldi	r21, 0x43	; 67
    148c:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1490:	2b ed       	ldi	r18, 0xDB	; 219
    1492:	3f e0       	ldi	r19, 0x0F	; 15
    1494:	49 e4       	ldi	r20, 0x49	; 73
    1496:	50 e4       	ldi	r21, 0x40	; 64
    1498:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    149c:	5b 01       	movw	r10, r22
    149e:	6c 01       	movw	r12, r24
    14a0:	60 93 02 12 	sts	0x1202, r22
    14a4:	70 93 03 12 	sts	0x1203, r23
    14a8:	80 93 04 12 	sts	0x1204, r24
    14ac:	90 93 05 12 	sts	0x1205, r25
		v_offset = (0.5 * robot.heading) + CMD_K*cmd_angle + COR_K*correction_angle;
    14b0:	20 e0       	ldi	r18, 0x00	; 0
    14b2:	30 e0       	ldi	r19, 0x00	; 0
    14b4:	40 e0       	ldi	r20, 0x00	; 0
    14b6:	5f e3       	ldi	r21, 0x3F	; 63
    14b8:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    14bc:	7b 01       	movw	r14, r22
    14be:	8c 01       	movw	r16, r24
    14c0:	60 91 c0 02 	lds	r22, 0x02C0
    14c4:	70 91 c1 02 	lds	r23, 0x02C1
    14c8:	88 27       	eor	r24, r24
    14ca:	77 fd       	sbrc	r23, 7
    14cc:	80 95       	com	r24
    14ce:	98 2f       	mov	r25, r24
    14d0:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    14d4:	20 e0       	ldi	r18, 0x00	; 0
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	40 e0       	ldi	r20, 0x00	; 0
    14da:	5f e3       	ldi	r21, 0x3F	; 63
    14dc:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    14e0:	9b 01       	movw	r18, r22
    14e2:	ac 01       	movw	r20, r24
    14e4:	c8 01       	movw	r24, r16
    14e6:	b7 01       	movw	r22, r14
    14e8:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    14ec:	20 91 c6 02 	lds	r18, 0x02C6
    14f0:	30 91 c7 02 	lds	r19, 0x02C7
    14f4:	40 91 c8 02 	lds	r20, 0x02C8
    14f8:	50 91 c9 02 	lds	r21, 0x02C9
    14fc:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    1500:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    1504:	70 93 a3 02 	sts	0x02A3, r23
    1508:	60 93 a2 02 	sts	0x02A2, r22
		robot.vel = (LEFTVel_current + (-RIGHTVel_current)) / 2;
    150c:	80 91 a4 02 	lds	r24, 0x02A4
    1510:	90 91 a5 02 	lds	r25, 0x02A5
    1514:	20 91 b0 02 	lds	r18, 0x02B0
    1518:	30 91 b1 02 	lds	r19, 0x02B1
    151c:	82 1b       	sub	r24, r18
    151e:	93 0b       	sbc	r25, r19
    1520:	62 e0       	ldi	r22, 0x02	; 2
    1522:	70 e0       	ldi	r23, 0x00	; 0
    1524:	0e 94 32 30 	call	0x6064	; 0x6064 <__divmodhi4>
    1528:	88 27       	eor	r24, r24
    152a:	77 fd       	sbrc	r23, 7
    152c:	80 95       	com	r24
    152e:	98 2f       	mov	r25, r24
    1530:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1534:	60 93 06 12 	sts	0x1206, r22
    1538:	70 93 07 12 	sts	0x1207, r23
    153c:	80 93 08 12 	sts	0x1208, r24
    1540:	90 93 09 12 	sts	0x1209, r25
		
		dRIGHTDis = (-RIGHTDis_current) - (-RIGHTDis_prev); 
    1544:	80 91 b2 02 	lds	r24, 0x02B2
    1548:	90 91 b3 02 	lds	r25, 0x02B3
    154c:	a0 91 b4 02 	lds	r26, 0x02B4
    1550:	b0 91 b5 02 	lds	r27, 0x02B5
    1554:	e0 90 b6 02 	lds	r14, 0x02B6
    1558:	f0 90 b7 02 	lds	r15, 0x02B7
    155c:	e8 1a       	sub	r14, r24
    155e:	f9 0a       	sbc	r15, r25
		RIGHTDis_prev = RIGHTDis_current;
    1560:	80 93 b6 02 	sts	0x02B6, r24
    1564:	90 93 b7 02 	sts	0x02B7, r25
    1568:	a0 93 b8 02 	sts	0x02B8, r26
    156c:	b0 93 b9 02 	sts	0x02B9, r27
		dLEFTDis = LEFTDis_current - LEFTDis_prev;
    1570:	80 91 a6 02 	lds	r24, 0x02A6
    1574:	90 91 a7 02 	lds	r25, 0x02A7
    1578:	a0 91 a8 02 	lds	r26, 0x02A8
    157c:	b0 91 a9 02 	lds	r27, 0x02A9
    1580:	20 91 aa 02 	lds	r18, 0x02AA
    1584:	30 91 ab 02 	lds	r19, 0x02AB
    1588:	8c 01       	movw	r16, r24
    158a:	02 1b       	sub	r16, r18
    158c:	13 0b       	sbc	r17, r19
		LEFTDis_prev = LEFTDis_current;
    158e:	80 93 aa 02 	sts	0x02AA, r24
    1592:	90 93 ab 02 	sts	0x02AB, r25
    1596:	a0 93 ac 02 	sts	0x02AC, r26
    159a:	b0 93 ad 02 	sts	0x02AD, r27
		
		dDis = (10*(dRIGHTDis + dLEFTDis))/2;	//Send shifted value to avoid decimals
		dRIGHTDis = dLEFTDis = 0;
    159e:	10 92 af 02 	sts	0x02AF, r1
    15a2:	10 92 ae 02 	sts	0x02AE, r1
    15a6:	10 92 bb 02 	sts	0x02BB, r1
    15aa:	10 92 ba 02 	sts	0x02BA, r1
		
		send_frame('H', robot.heading);
    15ae:	c6 01       	movw	r24, r12
    15b0:	b5 01       	movw	r22, r10
    15b2:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    15b6:	9b 01       	movw	r18, r22
    15b8:	ac 01       	movw	r20, r24
    15ba:	88 e4       	ldi	r24, 0x48	; 72
    15bc:	b9 01       	movw	r22, r18
    15be:	0e 94 d6 09 	call	0x13ac	; 0x13ac <send_frame>
		send_frame('V', robot.vel);
    15c2:	60 91 06 12 	lds	r22, 0x1206
    15c6:	70 91 07 12 	lds	r23, 0x1207
    15ca:	80 91 08 12 	lds	r24, 0x1208
    15ce:	90 91 09 12 	lds	r25, 0x1209
    15d2:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
    15d6:	9b 01       	movw	r18, r22
    15d8:	ac 01       	movw	r20, r24
    15da:	86 e5       	ldi	r24, 0x56	; 86
    15dc:	b9 01       	movw	r22, r18
    15de:	0e 94 d6 09 	call	0x13ac	; 0x13ac <send_frame>
		send_frame('S', dDis);
    15e2:	0e 0d       	add	r16, r14
    15e4:	1f 1d       	adc	r17, r15
    15e6:	b8 01       	movw	r22, r16
    15e8:	66 0f       	add	r22, r22
    15ea:	77 1f       	adc	r23, r23
    15ec:	66 0f       	add	r22, r22
    15ee:	77 1f       	adc	r23, r23
    15f0:	60 0f       	add	r22, r16
    15f2:	71 1f       	adc	r23, r17
    15f4:	83 e5       	ldi	r24, 0x53	; 83
    15f6:	0e 94 d6 09 	call	0x13ac	; 0x13ac <send_frame>
    15fa:	3c cf       	rjmp	.-392    	; 0x1474 <vUpdatePose+0x10>

000015fc <vServoOsc>:
	}

}


void vServoOsc(){
    15fc:	cf 92       	push	r12
    15fe:	df 92       	push	r13
    1600:	ef 92       	push	r14
    1602:	ff 92       	push	r15
    1604:	0f 93       	push	r16
    1606:	1f 93       	push	r17
    1608:	df 93       	push	r29
    160a:	cf 93       	push	r28
    160c:	00 d0       	rcall	.+0      	; 0x160e <vServoOsc+0x12>
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
	sbi(TCCR4A,COM4A1);
	cbi(TCCR4A,COM4A0);
}
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
    1612:	80 91 a0 00 	lds	r24, 0x00A0
    1616:	80 62       	ori	r24, 0x20	; 32
    1618:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4B0);
    161c:	80 91 a0 00 	lds	r24, 0x00A0
    1620:	8f 7e       	andi	r24, 0xEF	; 239
    1622:	80 93 a0 00 	sts	0x00A0, r24
	sbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
    1626:	80 91 a0 00 	lds	r24, 0x00A0
    162a:	80 68       	ori	r24, 0x80	; 128
    162c:	80 93 a0 00 	sts	0x00A0, r24
	cbi(TCCR4A,COM4A0);
    1630:	80 91 a0 00 	lds	r24, 0x00A0
    1634:	8f 7b       	andi	r24, 0xBF	; 191
    1636:	80 93 a0 00 	sts	0x00A0, r24
    163a:	0a e7       	ldi	r16, 0x7A	; 122
    163c:	10 e0       	ldi	r17, 0x00	; 0
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    163e:	2c ec       	ldi	r18, 0xCC	; 204
    1640:	c2 2e       	mov	r12, r18
    1642:	d1 2c       	mov	r13, r1
		taskENTER_CRITICAL();
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1644:	7e 01       	movw	r14, r28
    1646:	08 94       	sec
    1648:	e1 1c       	adc	r14, r1
    164a:	f1 1c       	adc	r15, r1
	spray_R_on();
	spray_L_on();
	uint16_t h3duty = 122;

	for(;;){
		if(h3duty > 1023){ h3duty = 0;}
    164c:	84 e0       	ldi	r24, 0x04	; 4
    164e:	00 30       	cpi	r16, 0x00	; 0
    1650:	18 07       	cpc	r17, r24
    1652:	10 f0       	brcs	.+4      	; 0x1658 <vServoOsc+0x5c>
    1654:	00 e0       	ldi	r16, 0x00	; 0
    1656:	10 e0       	ldi	r17, 0x00	; 0
		taskENTER_CRITICAL();
    1658:	0f b6       	in	r0, 0x3f	; 63
    165a:	f8 94       	cli
    165c:	0f 92       	push	r0
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
    165e:	10 93 a9 00 	sts	0x00A9, r17
    1662:	00 93 a8 00 	sts	0x00A8, r16
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
    1666:	d0 92 ab 00 	sts	0x00AB, r13
    166a:	c0 92 aa 00 	sts	0x00AA, r12
	//	PWM_timer3_Set_E3(i);	//right
		PWM_timer4_Set_H3(h3duty);	//left sprayer //originally 204
		PWM_timer4_Set_H4(204);	//right sprayer
		taskEXIT_CRITICAL();
    166e:	0f 90       	pop	r0
    1670:	0f be       	out	0x3f, r0	; 63
		vTaskDelayUntil(&xLastWakeTime, (spray_time / portTICK_RATE_MS));
    1672:	60 91 92 02 	lds	r22, 0x0292
    1676:	70 91 93 02 	lds	r23, 0x0293
    167a:	c7 01       	movw	r24, r14
    167c:	0e 94 e5 14 	call	0x29ca	; 0x29ca <vTaskDelayUntil>
		adj = uart1GetByte();
    1680:	0e 94 9c 24 	call	0x4938	; 0x4938 <uart1GetByte>
		if(adj == 'p'){ h3duty++;;}
    1684:	80 37       	cpi	r24, 0x70	; 112
    1686:	19 f4       	brne	.+6      	; 0x168e <vServoOsc+0x92>
    1688:	0f 5f       	subi	r16, 0xFF	; 255
    168a:	1f 4f       	sbci	r17, 0xFF	; 255
    168c:	04 c0       	rjmp	.+8      	; 0x1696 <vServoOsc+0x9a>
		else if(adj == 'l'){ h3duty--;}
    168e:	8c 36       	cpi	r24, 0x6C	; 108
    1690:	11 f4       	brne	.+4      	; 0x1696 <vServoOsc+0x9a>
    1692:	01 50       	subi	r16, 0x01	; 1
    1694:	10 40       	sbci	r17, 0x00	; 0
		//rprintf("%d", h3duty);
		//rprintf(",");
		//rprintfNum(10, 5, 1, ' ', LEFTVel_current);
		//rprintf("\n");
	
		h3duty++;
    1696:	0f 5f       	subi	r16, 0xFF	; 255
    1698:	1f 4f       	sbci	r17, 0xFF	; 255
    169a:	d8 cf       	rjmp	.-80     	; 0x164c <vServoOsc+0x50>

0000169c <vServoTm>:
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));
		LED_off();
		vTaskDelayUntil(&xLastWakeTime, (50 / portTICK_RATE_MS));	}
}

void vServoTm(){
    169c:	1f 93       	push	r17
    169e:	cf 93       	push	r28
    16a0:	df 93       	push	r29
	char adj;
	for(;;){
		adj = uart1GetByte();
		if(adj == 'p'){ spray_time++;}
		else if(adj == 'l'){ spray_time--;}
		rprintf("%d\n", spray_time);
    16a2:	11 e0       	ldi	r17, 0x01	; 1
    16a4:	cd e6       	ldi	r28, 0x6D	; 109
    16a6:	d1 e0       	ldi	r29, 0x01	; 1
}

void vServoTm(){
	char adj;
	for(;;){
		adj = uart1GetByte();
    16a8:	0e 94 9c 24 	call	0x4938	; 0x4938 <uart1GetByte>
		if(adj == 'p'){ spray_time++;}
    16ac:	80 37       	cpi	r24, 0x70	; 112
    16ae:	31 f4       	brne	.+12     	; 0x16bc <vServoTm+0x20>
    16b0:	80 91 92 02 	lds	r24, 0x0292
    16b4:	90 91 93 02 	lds	r25, 0x0293
    16b8:	01 96       	adiw	r24, 0x01	; 1
    16ba:	07 c0       	rjmp	.+14     	; 0x16ca <vServoTm+0x2e>
		else if(adj == 'l'){ spray_time--;}
    16bc:	8c 36       	cpi	r24, 0x6C	; 108
    16be:	49 f4       	brne	.+18     	; 0x16d2 <vServoTm+0x36>
    16c0:	80 91 92 02 	lds	r24, 0x0292
    16c4:	90 91 93 02 	lds	r25, 0x0293
    16c8:	01 97       	sbiw	r24, 0x01	; 1
    16ca:	90 93 93 02 	sts	0x0293, r25
    16ce:	80 93 92 02 	sts	0x0292, r24
		rprintf("%d\n", spray_time);
    16d2:	00 d0       	rcall	.+0      	; 0x16d4 <vServoTm+0x38>
    16d4:	00 d0       	rcall	.+0      	; 0x16d6 <vServoTm+0x3a>
    16d6:	0f 92       	push	r0
    16d8:	ed b7       	in	r30, 0x3d	; 61
    16da:	fe b7       	in	r31, 0x3e	; 62
    16dc:	31 96       	adiw	r30, 0x01	; 1
    16de:	ad b7       	in	r26, 0x3d	; 61
    16e0:	be b7       	in	r27, 0x3e	; 62
    16e2:	11 96       	adiw	r26, 0x01	; 1
    16e4:	1c 93       	st	X, r17
    16e6:	d2 83       	std	Z+2, r29	; 0x02
    16e8:	c1 83       	std	Z+1, r28	; 0x01
    16ea:	80 91 92 02 	lds	r24, 0x0292
    16ee:	90 91 93 02 	lds	r25, 0x0293
    16f2:	94 83       	std	Z+4, r25	; 0x04
    16f4:	83 83       	std	Z+3, r24	; 0x03
    16f6:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>
    16fa:	0f 90       	pop	r0
    16fc:	0f 90       	pop	r0
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	0f 90       	pop	r0
    1704:	d1 cf       	rjmp	.-94     	; 0x16a8 <vServoTm+0xc>

00001706 <sharp_IR_interpret_GP2Y0A21YK>:
	}

//Sharp GP2Y0A21YK IR Range Sensor - 4 cm to 30 cm
int sharp_IR_interpret_GP2Y0A21YK(int value)
	{
	return 739.38*pow(value,-.8105);
    1706:	aa 27       	eor	r26, r26
    1708:	97 fd       	sbrc	r25, 7
    170a:	a0 95       	com	r26
    170c:	ba 2f       	mov	r27, r26
    170e:	bc 01       	movw	r22, r24
    1710:	cd 01       	movw	r24, r26
    1712:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    1716:	2e ee       	ldi	r18, 0xEE	; 238
    1718:	3c e7       	ldi	r19, 0x7C	; 124
    171a:	4f e4       	ldi	r20, 0x4F	; 79
    171c:	5f eb       	ldi	r21, 0xBF	; 191
    171e:	0e 94 43 2e 	call	0x5c86	; 0x5c86 <pow>
    1722:	9b 01       	movw	r18, r22
    1724:	ac 01       	movw	r20, r24
    1726:	ca 01       	movw	r24, r20
    1728:	b9 01       	movw	r22, r18
    172a:	22 e5       	ldi	r18, 0x52	; 82
    172c:	38 ed       	ldi	r19, 0xD8	; 216
    172e:	48 e3       	ldi	r20, 0x38	; 56
    1730:	54 e4       	ldi	r21, 0x44	; 68
    1732:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1736:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
	}
    173a:	cb 01       	movw	r24, r22
    173c:	08 95       	ret

0000173e <sharp_IR_interpret_GP2D12>:

//***FROM THE SoR LIBRARIES
//Sharp GP2D12 IR Range Sensor -  claims 10cm to 80cm (I got 8cm to 150cm)
int sharp_IR_interpret_GP2D12(int value)
	{
	return 1384.4*pow(value,-.9988);
    173e:	aa 27       	eor	r26, r26
    1740:	97 fd       	sbrc	r25, 7
    1742:	a0 95       	com	r26
    1744:	ba 2f       	mov	r27, r26
    1746:	bc 01       	movw	r22, r24
    1748:	cd 01       	movw	r24, r26
    174a:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    174e:	2b e5       	ldi	r18, 0x5B	; 91
    1750:	31 eb       	ldi	r19, 0xB1	; 177
    1752:	4f e7       	ldi	r20, 0x7F	; 127
    1754:	5f eb       	ldi	r21, 0xBF	; 191
    1756:	0e 94 43 2e 	call	0x5c86	; 0x5c86 <pow>
    175a:	9b 01       	movw	r18, r22
    175c:	ac 01       	movw	r20, r24
    175e:	ca 01       	movw	r24, r20
    1760:	b9 01       	movw	r22, r18
    1762:	2d ec       	ldi	r18, 0xCD	; 205
    1764:	3c e0       	ldi	r19, 0x0C	; 12
    1766:	4d ea       	ldi	r20, 0xAD	; 173
    1768:	54 e4       	ldi	r21, 0x44	; 68
    176a:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    176e:	0e 94 f9 2c 	call	0x59f2	; 0x59f2 <__fixsfsi>
	}
    1772:	cb 01       	movw	r24, r22
    1774:	08 95       	ret

00001776 <vReadIR>:
		
	
	}
}

void vReadIR(){
    1776:	2f 92       	push	r2
    1778:	3f 92       	push	r3
    177a:	4f 92       	push	r4
    177c:	5f 92       	push	r5
    177e:	6f 92       	push	r6
    1780:	7f 92       	push	r7
    1782:	8f 92       	push	r8
    1784:	9f 92       	push	r9
    1786:	af 92       	push	r10
    1788:	bf 92       	push	r11
    178a:	cf 92       	push	r12
    178c:	df 92       	push	r13
    178e:	ef 92       	push	r14
    1790:	ff 92       	push	r15
    1792:	0f 93       	push	r16
    1794:	1f 93       	push	r17
    1796:	df 93       	push	r29
    1798:	cf 93       	push	r28
    179a:	cd b7       	in	r28, 0x3d	; 61
    179c:	de b7       	in	r29, 0x3e	; 62
    179e:	2d 97       	sbiw	r28, 0x0d	; 13
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	f8 94       	cli
    17a4:	de bf       	out	0x3e, r29	; 62
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	cd bf       	out	0x3d, r28	; 61
    17aa:	19 82       	std	Y+1, r1	; 0x01
    17ac:	0f 2e       	mov	r0, r31
    17ae:	f0 e0       	ldi	r31, 0x00	; 0
    17b0:	ef 2e       	mov	r14, r31
    17b2:	f0 e0       	ldi	r31, 0x00	; 0
    17b4:	ff 2e       	mov	r15, r31
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	0f 2f       	mov	r16, r31
    17ba:	f0 e0       	ldi	r31, 0x00	; 0
    17bc:	1f 2f       	mov	r17, r31
    17be:	f0 2d       	mov	r31, r0
    17c0:	57 01       	movw	r10, r14
    17c2:	68 01       	movw	r12, r16
    17c4:	ea 86       	std	Y+10, r14	; 0x0a
    17c6:	fb 86       	std	Y+11, r15	; 0x0b
    17c8:	0c 87       	std	Y+12, r16	; 0x0c
    17ca:	1d 87       	std	Y+13, r17	; 0x0d
    17cc:	37 01       	movw	r6, r14
    17ce:	48 01       	movw	r8, r16
    17d0:	17 01       	movw	r2, r14
    17d2:	28 01       	movw	r4, r16
    17d4:	93 c0       	rjmp	.+294    	; 0x18fc <vReadIR+0x186>
	float cor_coeff;
	float vel_coeff;

	for(;;){
		for(uint8_t itr = 0; itr < NUM_IR_READS; itr++){
			n90_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(2)))/NUM_IR_READS;
    17d6:	82 e0       	ldi	r24, 0x02	; 2
    17d8:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <a2dConvert8bit>
    17dc:	90 e0       	ldi	r25, 0x00	; 0
    17de:	0e 94 83 0b 	call	0x1706	; 0x1706 <sharp_IR_interpret_GP2Y0A21YK>
    17e2:	aa 27       	eor	r26, r26
    17e4:	97 fd       	sbrc	r25, 7
    17e6:	a0 95       	com	r26
    17e8:	ba 2f       	mov	r27, r26
    17ea:	bc 01       	movw	r22, r24
    17ec:	cd 01       	movw	r24, r26
    17ee:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    17f2:	20 e0       	ldi	r18, 0x00	; 0
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	40 e2       	ldi	r20, 0x20	; 32
    17f8:	51 e4       	ldi	r21, 0x41	; 65
    17fa:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    17fe:	9b 01       	movw	r18, r22
    1800:	ac 01       	movw	r20, r24
    1802:	c8 01       	movw	r24, r16
    1804:	b7 01       	movw	r22, r14
    1806:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    180a:	7b 01       	movw	r14, r22
    180c:	8c 01       	movw	r16, r24
			zero_range += ((float)sharp_IR_interpret_GP2D12(a2dConvert8bit(3)))/NUM_IR_READS;
    180e:	83 e0       	ldi	r24, 0x03	; 3
    1810:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <a2dConvert8bit>
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	0e 94 9f 0b 	call	0x173e	; 0x173e <sharp_IR_interpret_GP2D12>
    181a:	aa 27       	eor	r26, r26
    181c:	97 fd       	sbrc	r25, 7
    181e:	a0 95       	com	r26
    1820:	ba 2f       	mov	r27, r26
    1822:	bc 01       	movw	r22, r24
    1824:	cd 01       	movw	r24, r26
    1826:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    182a:	20 e0       	ldi	r18, 0x00	; 0
    182c:	30 e0       	ldi	r19, 0x00	; 0
    182e:	40 e2       	ldi	r20, 0x20	; 32
    1830:	51 e4       	ldi	r21, 0x41	; 65
    1832:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1836:	9b 01       	movw	r18, r22
    1838:	ac 01       	movw	r20, r24
    183a:	6a 85       	ldd	r22, Y+10	; 0x0a
    183c:	7b 85       	ldd	r23, Y+11	; 0x0b
    183e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1840:	9d 85       	ldd	r25, Y+13	; 0x0d
    1842:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    1846:	6a 87       	std	Y+10, r22	; 0x0a
    1848:	7b 87       	std	Y+11, r23	; 0x0b
    184a:	8c 87       	std	Y+12, r24	; 0x0c
    184c:	9d 87       	std	Y+13, r25	; 0x0d
			p90_range  += ((float)sharp_IR_interpret_GP2D12(a2dConvert8bit(4)))/NUM_IR_READS;
    184e:	84 e0       	ldi	r24, 0x04	; 4
    1850:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <a2dConvert8bit>
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	0e 94 9f 0b 	call	0x173e	; 0x173e <sharp_IR_interpret_GP2D12>
    185a:	aa 27       	eor	r26, r26
    185c:	97 fd       	sbrc	r25, 7
    185e:	a0 95       	com	r26
    1860:	ba 2f       	mov	r27, r26
    1862:	bc 01       	movw	r22, r24
    1864:	cd 01       	movw	r24, r26
    1866:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    186a:	20 e0       	ldi	r18, 0x00	; 0
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	40 e2       	ldi	r20, 0x20	; 32
    1870:	51 e4       	ldi	r21, 0x41	; 65
    1872:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1876:	9b 01       	movw	r18, r22
    1878:	ac 01       	movw	r20, r24
    187a:	c6 01       	movw	r24, r12
    187c:	b5 01       	movw	r22, r10
    187e:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    1882:	5b 01       	movw	r10, r22
    1884:	6c 01       	movw	r12, r24
			p45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(5)))/NUM_IR_READS;
    1886:	85 e0       	ldi	r24, 0x05	; 5
    1888:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <a2dConvert8bit>
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	0e 94 83 0b 	call	0x1706	; 0x1706 <sharp_IR_interpret_GP2Y0A21YK>
    1892:	aa 27       	eor	r26, r26
    1894:	97 fd       	sbrc	r25, 7
    1896:	a0 95       	com	r26
    1898:	ba 2f       	mov	r27, r26
    189a:	bc 01       	movw	r22, r24
    189c:	cd 01       	movw	r24, r26
    189e:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    18a2:	20 e0       	ldi	r18, 0x00	; 0
    18a4:	30 e0       	ldi	r19, 0x00	; 0
    18a6:	40 e2       	ldi	r20, 0x20	; 32
    18a8:	51 e4       	ldi	r21, 0x41	; 65
    18aa:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    18ae:	9b 01       	movw	r18, r22
    18b0:	ac 01       	movw	r20, r24
    18b2:	c2 01       	movw	r24, r4
    18b4:	b1 01       	movw	r22, r2
    18b6:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    18ba:	1b 01       	movw	r2, r22
    18bc:	2c 01       	movw	r4, r24
			n45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(6)))/NUM_IR_READS;
    18be:	86 e0       	ldi	r24, 0x06	; 6
    18c0:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <a2dConvert8bit>
    18c4:	90 e0       	ldi	r25, 0x00	; 0
    18c6:	0e 94 83 0b 	call	0x1706	; 0x1706 <sharp_IR_interpret_GP2Y0A21YK>
    18ca:	aa 27       	eor	r26, r26
    18cc:	97 fd       	sbrc	r25, 7
    18ce:	a0 95       	com	r26
    18d0:	ba 2f       	mov	r27, r26
    18d2:	bc 01       	movw	r22, r24
    18d4:	cd 01       	movw	r24, r26
    18d6:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    18da:	20 e0       	ldi	r18, 0x00	; 0
    18dc:	30 e0       	ldi	r19, 0x00	; 0
    18de:	40 e2       	ldi	r20, 0x20	; 32
    18e0:	51 e4       	ldi	r21, 0x41	; 65
    18e2:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    18e6:	9b 01       	movw	r18, r22
    18e8:	ac 01       	movw	r20, r24
    18ea:	c4 01       	movw	r24, r8
    18ec:	b3 01       	movw	r22, r6
    18ee:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    18f2:	3b 01       	movw	r6, r22
    18f4:	4c 01       	movw	r8, r24

	float cor_coeff;
	float vel_coeff;

	for(;;){
		for(uint8_t itr = 0; itr < NUM_IR_READS; itr++){
    18f6:	89 81       	ldd	r24, Y+1	; 0x01
    18f8:	8f 5f       	subi	r24, 0xFF	; 255
    18fa:	89 83       	std	Y+1, r24	; 0x01
    18fc:	99 81       	ldd	r25, Y+1	; 0x01
    18fe:	9a 30       	cpi	r25, 0x0A	; 10
    1900:	08 f4       	brcc	.+2      	; 0x1904 <vReadIR+0x18e>
    1902:	69 cf       	rjmp	.-302    	; 0x17d6 <vReadIR+0x60>
			p45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(5)))/NUM_IR_READS;
			n45_range  += ((float)sharp_IR_interpret_GP2Y0A21YK(a2dConvert8bit(6)))/NUM_IR_READS;
		}
//		rprintf("IR[-90]: %d\tIR[-45]: %d\tIR[0]: %d\tin_vel: %d\tvel_cmd: %d\t",(uint8_t)n90_range, (uint8_t)n45_range, (uint8_t)zero_range, (int32_t)inst_cmd_vel, (int32_t)v_command);

		denom_n90 = ((n90_range)-IR_TO_EDGE)*((n90_range)-IR_TO_EDGE);
    1904:	c8 01       	movw	r24, r16
    1906:	b7 01       	movw	r22, r14
    1908:	20 e0       	ldi	r18, 0x00	; 0
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	40 e2       	ldi	r20, 0x20	; 32
    190e:	51 e4       	ldi	r21, 0x41	; 65
    1910:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1914:	9b 01       	movw	r18, r22
    1916:	ac 01       	movw	r20, r24
    1918:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    191c:	7b 01       	movw	r14, r22
    191e:	8c 01       	movw	r16, r24
		denom_p90 = ((p90_range)-IR_TO_EDGE)*((p90_range)-IR_TO_EDGE);
    1920:	c6 01       	movw	r24, r12
    1922:	b5 01       	movw	r22, r10
    1924:	20 e0       	ldi	r18, 0x00	; 0
    1926:	30 e0       	ldi	r19, 0x00	; 0
    1928:	40 e2       	ldi	r20, 0x20	; 32
    192a:	51 e4       	ldi	r21, 0x41	; 65
    192c:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1930:	9b 01       	movw	r18, r22
    1932:	ac 01       	movw	r20, r24
    1934:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1938:	5b 01       	movw	r10, r22
    193a:	6c 01       	movw	r12, r24
		denom_n45 = ((n45_range)-IR_TO_EDGE)*((n45_range)-IR_TO_EDGE);
    193c:	c4 01       	movw	r24, r8
    193e:	b3 01       	movw	r22, r6
    1940:	20 e0       	ldi	r18, 0x00	; 0
    1942:	30 e0       	ldi	r19, 0x00	; 0
    1944:	40 e2       	ldi	r20, 0x20	; 32
    1946:	51 e4       	ldi	r21, 0x41	; 65
    1948:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    194c:	9b 01       	movw	r18, r22
    194e:	ac 01       	movw	r20, r24
    1950:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1954:	3b 01       	movw	r6, r22
    1956:	4c 01       	movw	r8, r24
		denom_p45 = ((p45_range)-IR_TO_EDGE)*((p45_range)-IR_TO_EDGE);
    1958:	c2 01       	movw	r24, r4
    195a:	b1 01       	movw	r22, r2
    195c:	20 e0       	ldi	r18, 0x00	; 0
    195e:	30 e0       	ldi	r19, 0x00	; 0
    1960:	40 e2       	ldi	r20, 0x20	; 32
    1962:	51 e4       	ldi	r21, 0x41	; 65
    1964:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1968:	9b 01       	movw	r18, r22
    196a:	ac 01       	movw	r20, r24
    196c:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1970:	6e 83       	std	Y+6, r22	; 0x06
    1972:	7f 83       	std	Y+7, r23	; 0x07
    1974:	88 87       	std	Y+8, r24	; 0x08
    1976:	99 87       	std	Y+9, r25	; 0x09
		
		if(denom_n90 != 0){
    1978:	c8 01       	movw	r24, r16
    197a:	b7 01       	movw	r22, r14
    197c:	20 e0       	ldi	r18, 0x00	; 0
    197e:	30 e0       	ldi	r19, 0x00	; 0
    1980:	40 e0       	ldi	r20, 0x00	; 0
    1982:	50 e0       	ldi	r21, 0x00	; 0
    1984:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1988:	88 23       	and	r24, r24
    198a:	a1 f0       	breq	.+40     	; 0x19b4 <vReadIR+0x23e>
			cor_ang_n90 =  1000.0/denom_n90;
    198c:	60 e0       	ldi	r22, 0x00	; 0
    198e:	70 e0       	ldi	r23, 0x00	; 0
    1990:	8a e7       	ldi	r24, 0x7A	; 122
    1992:	94 e4       	ldi	r25, 0x44	; 68
    1994:	a8 01       	movw	r20, r16
    1996:	97 01       	movw	r18, r14
    1998:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    199c:	6a 83       	std	Y+2, r22	; 0x02
    199e:	7b 83       	std	Y+3, r23	; 0x03
    19a0:	8c 83       	std	Y+4, r24	; 0x04
    19a2:	9d 83       	std	Y+5, r25	; 0x05
			if(cor_ang_n90 > 90){cor_ang_n90 = 90;}
    19a4:	20 e0       	ldi	r18, 0x00	; 0
    19a6:	30 e0       	ldi	r19, 0x00	; 0
    19a8:	44 eb       	ldi	r20, 0xB4	; 180
    19aa:	52 e4       	ldi	r21, 0x42	; 66
    19ac:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    19b0:	18 16       	cp	r1, r24
    19b2:	2c f4       	brge	.+10     	; 0x19be <vReadIR+0x248>
    19b4:	80 e0       	ldi	r24, 0x00	; 0
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	a4 eb       	ldi	r26, 0xB4	; 180
    19ba:	b2 e4       	ldi	r27, 0x42	; 66
    19bc:	10 c0       	rjmp	.+32     	; 0x19de <vReadIR+0x268>
			if(cor_ang_n90 < -90){cor_ang_n90 = -90;}
    19be:	6a 81       	ldd	r22, Y+2	; 0x02
    19c0:	7b 81       	ldd	r23, Y+3	; 0x03
    19c2:	8c 81       	ldd	r24, Y+4	; 0x04
    19c4:	9d 81       	ldd	r25, Y+5	; 0x05
    19c6:	20 e0       	ldi	r18, 0x00	; 0
    19c8:	30 e0       	ldi	r19, 0x00	; 0
    19ca:	44 eb       	ldi	r20, 0xB4	; 180
    19cc:	52 ec       	ldi	r21, 0xC2	; 194
    19ce:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    19d2:	88 23       	and	r24, r24
    19d4:	44 f4       	brge	.+16     	; 0x19e6 <vReadIR+0x270>
    19d6:	80 e0       	ldi	r24, 0x00	; 0
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	a4 eb       	ldi	r26, 0xB4	; 180
    19dc:	b2 ec       	ldi	r27, 0xC2	; 194
    19de:	8a 83       	std	Y+2, r24	; 0x02
    19e0:	9b 83       	std	Y+3, r25	; 0x03
    19e2:	ac 83       	std	Y+4, r26	; 0x04
    19e4:	bd 83       	std	Y+5, r27	; 0x05
		}
		else{cor_ang_n90 = 90;}

		if(denom_p90 != 0){
    19e6:	c6 01       	movw	r24, r12
    19e8:	b5 01       	movw	r22, r10
    19ea:	20 e0       	ldi	r18, 0x00	; 0
    19ec:	30 e0       	ldi	r19, 0x00	; 0
    19ee:	40 e0       	ldi	r20, 0x00	; 0
    19f0:	50 e0       	ldi	r21, 0x00	; 0
    19f2:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    19f6:	88 23       	and	r24, r24
    19f8:	91 f0       	breq	.+36     	; 0x1a1e <vReadIR+0x2a8>
			cor_ang_p90 =  1000.0/denom_p90;
    19fa:	60 e0       	ldi	r22, 0x00	; 0
    19fc:	70 e0       	ldi	r23, 0x00	; 0
    19fe:	8a e7       	ldi	r24, 0x7A	; 122
    1a00:	94 e4       	ldi	r25, 0x44	; 68
    1a02:	a6 01       	movw	r20, r12
    1a04:	95 01       	movw	r18, r10
    1a06:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1a0a:	7b 01       	movw	r14, r22
    1a0c:	8c 01       	movw	r16, r24
			if(cor_ang_p90 > 90){cor_ang_p90 = 90;}
    1a0e:	20 e0       	ldi	r18, 0x00	; 0
    1a10:	30 e0       	ldi	r19, 0x00	; 0
    1a12:	44 eb       	ldi	r20, 0xB4	; 180
    1a14:	52 e4       	ldi	r21, 0x42	; 66
    1a16:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    1a1a:	18 16       	cp	r1, r24
    1a1c:	5c f4       	brge	.+22     	; 0x1a34 <vReadIR+0x2be>
    1a1e:	0f 2e       	mov	r0, r31
    1a20:	f0 e0       	ldi	r31, 0x00	; 0
    1a22:	ef 2e       	mov	r14, r31
    1a24:	f0 e0       	ldi	r31, 0x00	; 0
    1a26:	ff 2e       	mov	r15, r31
    1a28:	f4 eb       	ldi	r31, 0xB4	; 180
    1a2a:	0f 2f       	mov	r16, r31
    1a2c:	f2 e4       	ldi	r31, 0x42	; 66
    1a2e:	1f 2f       	mov	r17, r31
    1a30:	f0 2d       	mov	r31, r0
    1a32:	14 c0       	rjmp	.+40     	; 0x1a5c <vReadIR+0x2e6>
			if(cor_ang_p90 < -90){cor_ang_p90 = -90;}
    1a34:	c8 01       	movw	r24, r16
    1a36:	b7 01       	movw	r22, r14
    1a38:	20 e0       	ldi	r18, 0x00	; 0
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	44 eb       	ldi	r20, 0xB4	; 180
    1a3e:	52 ec       	ldi	r21, 0xC2	; 194
    1a40:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1a44:	88 23       	and	r24, r24
    1a46:	54 f4       	brge	.+20     	; 0x1a5c <vReadIR+0x2e6>
    1a48:	0f 2e       	mov	r0, r31
    1a4a:	f0 e0       	ldi	r31, 0x00	; 0
    1a4c:	ef 2e       	mov	r14, r31
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	ff 2e       	mov	r15, r31
    1a52:	f4 eb       	ldi	r31, 0xB4	; 180
    1a54:	0f 2f       	mov	r16, r31
    1a56:	f2 ec       	ldi	r31, 0xC2	; 194
    1a58:	1f 2f       	mov	r17, r31
    1a5a:	f0 2d       	mov	r31, r0
		}
		else{cor_ang_p90 = 90;}

		if(denom_n45 != 0){
    1a5c:	c4 01       	movw	r24, r8
    1a5e:	b3 01       	movw	r22, r6
    1a60:	20 e0       	ldi	r18, 0x00	; 0
    1a62:	30 e0       	ldi	r19, 0x00	; 0
    1a64:	40 e0       	ldi	r20, 0x00	; 0
    1a66:	50 e0       	ldi	r21, 0x00	; 0
    1a68:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1a6c:	88 23       	and	r24, r24
    1a6e:	91 f0       	breq	.+36     	; 0x1a94 <vReadIR+0x31e>
			cor_ang_n45 =  1000.0/denom_n45;
    1a70:	60 e0       	ldi	r22, 0x00	; 0
    1a72:	70 e0       	ldi	r23, 0x00	; 0
    1a74:	8a e7       	ldi	r24, 0x7A	; 122
    1a76:	94 e4       	ldi	r25, 0x44	; 68
    1a78:	a4 01       	movw	r20, r8
    1a7a:	93 01       	movw	r18, r6
    1a7c:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1a80:	1b 01       	movw	r2, r22
    1a82:	2c 01       	movw	r4, r24
			if(cor_ang_n45 > 90){cor_ang_n45 = 90;}
    1a84:	20 e0       	ldi	r18, 0x00	; 0
    1a86:	30 e0       	ldi	r19, 0x00	; 0
    1a88:	44 eb       	ldi	r20, 0xB4	; 180
    1a8a:	52 e4       	ldi	r21, 0x42	; 66
    1a8c:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    1a90:	18 16       	cp	r1, r24
    1a92:	5c f4       	brge	.+22     	; 0x1aaa <vReadIR+0x334>
    1a94:	0f 2e       	mov	r0, r31
    1a96:	f0 e0       	ldi	r31, 0x00	; 0
    1a98:	2f 2e       	mov	r2, r31
    1a9a:	f0 e0       	ldi	r31, 0x00	; 0
    1a9c:	3f 2e       	mov	r3, r31
    1a9e:	f4 eb       	ldi	r31, 0xB4	; 180
    1aa0:	4f 2e       	mov	r4, r31
    1aa2:	f2 e4       	ldi	r31, 0x42	; 66
    1aa4:	5f 2e       	mov	r5, r31
    1aa6:	f0 2d       	mov	r31, r0
    1aa8:	14 c0       	rjmp	.+40     	; 0x1ad2 <vReadIR+0x35c>
			if(cor_ang_n45 < -90){cor_ang_n45 = -90;}
    1aaa:	c2 01       	movw	r24, r4
    1aac:	b1 01       	movw	r22, r2
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
    1ab2:	44 eb       	ldi	r20, 0xB4	; 180
    1ab4:	52 ec       	ldi	r21, 0xC2	; 194
    1ab6:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1aba:	88 23       	and	r24, r24
    1abc:	54 f4       	brge	.+20     	; 0x1ad2 <vReadIR+0x35c>
    1abe:	0f 2e       	mov	r0, r31
    1ac0:	f0 e0       	ldi	r31, 0x00	; 0
    1ac2:	2f 2e       	mov	r2, r31
    1ac4:	f0 e0       	ldi	r31, 0x00	; 0
    1ac6:	3f 2e       	mov	r3, r31
    1ac8:	f4 eb       	ldi	r31, 0xB4	; 180
    1aca:	4f 2e       	mov	r4, r31
    1acc:	f2 ec       	ldi	r31, 0xC2	; 194
    1ace:	5f 2e       	mov	r5, r31
    1ad0:	f0 2d       	mov	r31, r0
		}
		else{cor_ang_n45 = 90;}

		if(denom_p45 != 0){
    1ad2:	6e 81       	ldd	r22, Y+6	; 0x06
    1ad4:	7f 81       	ldd	r23, Y+7	; 0x07
    1ad6:	88 85       	ldd	r24, Y+8	; 0x08
    1ad8:	99 85       	ldd	r25, Y+9	; 0x09
    1ada:	20 e0       	ldi	r18, 0x00	; 0
    1adc:	30 e0       	ldi	r19, 0x00	; 0
    1ade:	40 e0       	ldi	r20, 0x00	; 0
    1ae0:	50 e0       	ldi	r21, 0x00	; 0
    1ae2:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1ae6:	88 23       	and	r24, r24
    1ae8:	a1 f0       	breq	.+40     	; 0x1b12 <vReadIR+0x39c>
			cor_ang_p45 =  1000.0/denom_p45;
    1aea:	60 e0       	ldi	r22, 0x00	; 0
    1aec:	70 e0       	ldi	r23, 0x00	; 0
    1aee:	8a e7       	ldi	r24, 0x7A	; 122
    1af0:	94 e4       	ldi	r25, 0x44	; 68
    1af2:	2e 81       	ldd	r18, Y+6	; 0x06
    1af4:	3f 81       	ldd	r19, Y+7	; 0x07
    1af6:	48 85       	ldd	r20, Y+8	; 0x08
    1af8:	59 85       	ldd	r21, Y+9	; 0x09
    1afa:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1afe:	5b 01       	movw	r10, r22
    1b00:	6c 01       	movw	r12, r24
			if(cor_ang_p45 > 90){cor_ang_p45 = 90;}
    1b02:	20 e0       	ldi	r18, 0x00	; 0
    1b04:	30 e0       	ldi	r19, 0x00	; 0
    1b06:	44 eb       	ldi	r20, 0xB4	; 180
    1b08:	52 e4       	ldi	r21, 0x42	; 66
    1b0a:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    1b0e:	18 16       	cp	r1, r24
    1b10:	5c f4       	brge	.+22     	; 0x1b28 <vReadIR+0x3b2>
    1b12:	0f 2e       	mov	r0, r31
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	af 2e       	mov	r10, r31
    1b18:	f0 e0       	ldi	r31, 0x00	; 0
    1b1a:	bf 2e       	mov	r11, r31
    1b1c:	f4 eb       	ldi	r31, 0xB4	; 180
    1b1e:	cf 2e       	mov	r12, r31
    1b20:	f2 e4       	ldi	r31, 0x42	; 66
    1b22:	df 2e       	mov	r13, r31
    1b24:	f0 2d       	mov	r31, r0
    1b26:	14 c0       	rjmp	.+40     	; 0x1b50 <vReadIR+0x3da>
			if(cor_ang_p45 < -90){cor_ang_p45 = -90;}
    1b28:	c6 01       	movw	r24, r12
    1b2a:	b5 01       	movw	r22, r10
    1b2c:	20 e0       	ldi	r18, 0x00	; 0
    1b2e:	30 e0       	ldi	r19, 0x00	; 0
    1b30:	44 eb       	ldi	r20, 0xB4	; 180
    1b32:	52 ec       	ldi	r21, 0xC2	; 194
    1b34:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1b38:	88 23       	and	r24, r24
    1b3a:	54 f4       	brge	.+20     	; 0x1b50 <vReadIR+0x3da>
    1b3c:	0f 2e       	mov	r0, r31
    1b3e:	f0 e0       	ldi	r31, 0x00	; 0
    1b40:	af 2e       	mov	r10, r31
    1b42:	f0 e0       	ldi	r31, 0x00	; 0
    1b44:	bf 2e       	mov	r11, r31
    1b46:	f4 eb       	ldi	r31, 0xB4	; 180
    1b48:	cf 2e       	mov	r12, r31
    1b4a:	f2 ec       	ldi	r31, 0xC2	; 194
    1b4c:	df 2e       	mov	r13, r31
    1b4e:	f0 2d       	mov	r31, r0
		}
		else{cor_ang_p45 = 90;}

		cor_coeff = 40/(zero_range - IR_TO_EDGE);
    1b50:	6a 85       	ldd	r22, Y+10	; 0x0a
    1b52:	7b 85       	ldd	r23, Y+11	; 0x0b
    1b54:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b56:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b58:	20 e0       	ldi	r18, 0x00	; 0
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	40 e2       	ldi	r20, 0x20	; 32
    1b5e:	51 e4       	ldi	r21, 0x41	; 65
    1b60:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1b64:	9b 01       	movw	r18, r22
    1b66:	ac 01       	movw	r20, r24
    1b68:	60 e0       	ldi	r22, 0x00	; 0
    1b6a:	70 e0       	ldi	r23, 0x00	; 0
    1b6c:	80 e2       	ldi	r24, 0x20	; 32
    1b6e:	92 e4       	ldi	r25, 0x42	; 66
    1b70:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1b74:	3b 01       	movw	r6, r22
    1b76:	4c 01       	movw	r8, r24
		vel_coeff = sqrt((zero_range)/40);
    1b78:	6a 85       	ldd	r22, Y+10	; 0x0a
    1b7a:	7b 85       	ldd	r23, Y+11	; 0x0b
    1b7c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b7e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	40 e2       	ldi	r20, 0x20	; 32
    1b86:	52 e4       	ldi	r21, 0x42	; 66
    1b88:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    1b8c:	0e 94 93 2e 	call	0x5d26	; 0x5d26 <sqrt>
//		rprintf("VEL_COEFF: %d\t",(int16_t)vel_coeff);
		inst_cmd_vel = (vel_coeff * inst_cmd_vel) + 1;
    1b90:	20 91 9e 02 	lds	r18, 0x029E
    1b94:	30 91 9f 02 	lds	r19, 0x029F
    1b98:	40 91 a0 02 	lds	r20, 0x02A0
    1b9c:	50 91 a1 02 	lds	r21, 0x02A1
    1ba0:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1ba4:	20 e0       	ldi	r18, 0x00	; 0
    1ba6:	30 e0       	ldi	r19, 0x00	; 0
    1ba8:	40 e8       	ldi	r20, 0x80	; 128
    1baa:	5f e3       	ldi	r21, 0x3F	; 63
    1bac:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    1bb0:	60 93 9e 02 	sts	0x029E, r22
    1bb4:	70 93 9f 02 	sts	0x029F, r23
    1bb8:	80 93 a0 02 	sts	0x02A0, r24
    1bbc:	90 93 a1 02 	sts	0x02A1, r25
		if(cor_coeff < 1){cor_coeff = 1;}
    1bc0:	c4 01       	movw	r24, r8
    1bc2:	b3 01       	movw	r22, r6
    1bc4:	20 e0       	ldi	r18, 0x00	; 0
    1bc6:	30 e0       	ldi	r19, 0x00	; 0
    1bc8:	40 e8       	ldi	r20, 0x80	; 128
    1bca:	5f e3       	ldi	r21, 0x3F	; 63
    1bcc:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1bd0:	88 23       	and	r24, r24
    1bd2:	54 f4       	brge	.+20     	; 0x1be8 <vReadIR+0x472>
    1bd4:	0f 2e       	mov	r0, r31
    1bd6:	f0 e0       	ldi	r31, 0x00	; 0
    1bd8:	6f 2e       	mov	r6, r31
    1bda:	f0 e0       	ldi	r31, 0x00	; 0
    1bdc:	7f 2e       	mov	r7, r31
    1bde:	f0 e8       	ldi	r31, 0x80	; 128
    1be0:	8f 2e       	mov	r8, r31
    1be2:	ff e3       	ldi	r31, 0x3F	; 63
    1be4:	9f 2e       	mov	r9, r31
    1be6:	f0 2d       	mov	r31, r0

		//rprintf("caIR[-90]: %d\tcaIR[-45]: %d\tcaIR[90]: %d\tcaIR[45]: %d\t",(uint8_t)cor_ang_n90, (uint8_t)cor_ang_n45, (uint8_t)cor_ang_p90, (uint8_t)cor_ang_p45);

		correction_angle = (cor_coeff)*((cor_ang_p90 - cor_ang_n90) + (cor_ang_p45 - cor_ang_n45));
    1be8:	c8 01       	movw	r24, r16
    1bea:	b7 01       	movw	r22, r14
    1bec:	2a 81       	ldd	r18, Y+2	; 0x02
    1bee:	3b 81       	ldd	r19, Y+3	; 0x03
    1bf0:	4c 81       	ldd	r20, Y+4	; 0x04
    1bf2:	5d 81       	ldd	r21, Y+5	; 0x05
    1bf4:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1bf8:	7b 01       	movw	r14, r22
    1bfa:	8c 01       	movw	r16, r24
    1bfc:	c6 01       	movw	r24, r12
    1bfe:	b5 01       	movw	r22, r10
    1c00:	a2 01       	movw	r20, r4
    1c02:	91 01       	movw	r18, r2
    1c04:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    1c08:	9b 01       	movw	r18, r22
    1c0a:	ac 01       	movw	r20, r24
    1c0c:	c8 01       	movw	r24, r16
    1c0e:	b7 01       	movw	r22, r14
    1c10:	0e 94 29 2c 	call	0x5852	; 0x5852 <__addsf3>
    1c14:	9b 01       	movw	r18, r22
    1c16:	ac 01       	movw	r20, r24
    1c18:	c4 01       	movw	r24, r8
    1c1a:	b3 01       	movw	r22, r6
    1c1c:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    1c20:	60 93 c6 02 	sts	0x02C6, r22
    1c24:	70 93 c7 02 	sts	0x02C7, r23
    1c28:	80 93 c8 02 	sts	0x02C8, r24
    1c2c:	90 93 c9 02 	sts	0x02C9, r25
		if(correction_angle > 90){correction_angle = 90;}
    1c30:	20 e0       	ldi	r18, 0x00	; 0
    1c32:	30 e0       	ldi	r19, 0x00	; 0
    1c34:	44 eb       	ldi	r20, 0xB4	; 180
    1c36:	52 e4       	ldi	r21, 0x42	; 66
    1c38:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    1c3c:	18 16       	cp	r1, r24
    1c3e:	64 f4       	brge	.+24     	; 0x1c58 <vReadIR+0x4e2>
    1c40:	80 e0       	ldi	r24, 0x00	; 0
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	a4 eb       	ldi	r26, 0xB4	; 180
    1c46:	b2 e4       	ldi	r27, 0x42	; 66
    1c48:	80 93 c6 02 	sts	0x02C6, r24
    1c4c:	90 93 c7 02 	sts	0x02C7, r25
    1c50:	a0 93 c8 02 	sts	0x02C8, r26
    1c54:	b0 93 c9 02 	sts	0x02C9, r27
		if(correction_angle < -90){correction_angle = -90;}
    1c58:	60 91 c6 02 	lds	r22, 0x02C6
    1c5c:	70 91 c7 02 	lds	r23, 0x02C7
    1c60:	80 91 c8 02 	lds	r24, 0x02C8
    1c64:	90 91 c9 02 	lds	r25, 0x02C9
    1c68:	20 e0       	ldi	r18, 0x00	; 0
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	44 eb       	ldi	r20, 0xB4	; 180
    1c6e:	52 ec       	ldi	r21, 0xC2	; 194
    1c70:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    1c74:	87 ff       	sbrs	r24, 7
    1c76:	0c c0       	rjmp	.+24     	; 0x1c90 <vReadIR+0x51a>
    1c78:	80 e0       	ldi	r24, 0x00	; 0
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	a4 eb       	ldi	r26, 0xB4	; 180
    1c7e:	b2 ec       	ldi	r27, 0xC2	; 194
    1c80:	80 93 c6 02 	sts	0x02C6, r24
    1c84:	90 93 c7 02 	sts	0x02C7, r25
    1c88:	a0 93 c8 02 	sts	0x02C8, r26
    1c8c:	b0 93 c9 02 	sts	0x02C9, r27
    1c90:	19 82       	std	Y+1, r1	; 0x01
    1c92:	0f 2e       	mov	r0, r31
    1c94:	f0 e0       	ldi	r31, 0x00	; 0
    1c96:	ef 2e       	mov	r14, r31
    1c98:	f0 e0       	ldi	r31, 0x00	; 0
    1c9a:	ff 2e       	mov	r15, r31
    1c9c:	f0 e0       	ldi	r31, 0x00	; 0
    1c9e:	0f 2f       	mov	r16, r31
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	1f 2f       	mov	r17, r31
    1ca4:	f0 2d       	mov	r31, r0
    1ca6:	57 01       	movw	r10, r14
    1ca8:	68 01       	movw	r12, r16
    1caa:	ea 86       	std	Y+10, r14	; 0x0a
    1cac:	fb 86       	std	Y+11, r15	; 0x0b
    1cae:	0c 87       	std	Y+12, r16	; 0x0c
    1cb0:	1d 87       	std	Y+13, r17	; 0x0d
    1cb2:	37 01       	movw	r6, r14
    1cb4:	48 01       	movw	r8, r16
    1cb6:	17 01       	movw	r2, r14
    1cb8:	28 01       	movw	r4, r16
    1cba:	8d cd       	rjmp	.-1254   	; 0x17d6 <vReadIR+0x60>

00001cbc <prvSetupHardware>:
	i2cSendByte((u08)robot.heading);
	rprintf("%d\n",(u08)robot.heading);
}
*/

void prvSetupHardware(){
    1cbc:	0f 93       	push	r16
    1cbe:	1f 93       	push	r17
    1cc0:	cf 93       	push	r28
    1cc2:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
    1cc4:	0e 94 87 25 	call	0x4b0e	; 0x4b0e <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
    1cc8:	80 e0       	ldi	r24, 0x00	; 0
    1cca:	40 e0       	ldi	r20, 0x00	; 0
    1ccc:	56 e9       	ldi	r21, 0x96	; 150
    1cce:	60 e0       	ldi	r22, 0x00	; 0
    1cd0:	70 e0       	ldi	r23, 0x00	; 0
    1cd2:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
    1cd6:	81 e0       	ldi	r24, 0x01	; 1
    1cd8:	40 e0       	ldi	r20, 0x00	; 0
    1cda:	52 ec       	ldi	r21, 0xC2	; 194
    1cdc:	61 e0       	ldi	r22, 0x01	; 1
    1cde:	70 e0       	ldi	r23, 0x00	; 0
    1ce0:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
    1ce4:	82 e0       	ldi	r24, 0x02	; 2
    1ce6:	40 e0       	ldi	r20, 0x00	; 0
    1ce8:	56 e9       	ldi	r21, 0x96	; 150
    1cea:	60 e0       	ldi	r22, 0x00	; 0
    1cec:	70 e0       	ldi	r23, 0x00	; 0
    1cee:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
    uartSetBaudRate(3, 115200); // set UARTJ speed, for Blackfin
    1cf2:	83 e0       	ldi	r24, 0x03	; 3
    1cf4:	40 e0       	ldi	r20, 0x00	; 0
    1cf6:	52 ec       	ldi	r21, 0xC2	; 194
    1cf8:	61 e0       	ldi	r22, 0x01	; 1
    1cfa:	70 e0       	ldi	r23, 0x00	; 0
    1cfc:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
    1d00:	8a ed       	ldi	r24, 0xDA	; 218
    1d02:	91 e2       	ldi	r25, 0x21	; 33
    1d04:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
    1d08:	0e 94 7e 03 	call	0x6fc	; 0x6fc <configure_ports>
	*/

	
	//UART ISR *** UART ISR ***
	
	uartSetRxHandler(2, &fwdSer_L);
    1d0c:	82 e0       	ldi	r24, 0x02	; 2
    1d0e:	60 ef       	ldi	r22, 0xF0	; 240
    1d10:	75 e0       	ldi	r23, 0x05	; 5
    1d12:	0e 94 56 21 	call	0x42ac	; 0x42ac <uartSetRxHandler>
	uartSetRxHandler(0, &fwdSer_R);
    1d16:	80 e0       	ldi	r24, 0x00	; 0
    1d18:	6d e7       	ldi	r22, 0x7D	; 125
    1d1a:	76 e0       	ldi	r23, 0x06	; 6
    1d1c:	0e 94 56 21 	call	0x42ac	; 0x42ac <uartSetRxHandler>
	uartSetRxHandler(3, &LDSrcv);
    1d20:	83 e0       	ldi	r24, 0x03	; 3
    1d22:	6a e0       	ldi	r22, 0x0A	; 10
    1d24:	77 e0       	ldi	r23, 0x07	; 7
    1d26:	0e 94 56 21 	call	0x42ac	; 0x42ac <uartSetRxHandler>
void LED_on(void)
	{PORT_OFF(PORTB,6);}
    1d2a:	2e 98       	cbi	0x05, 6	; 5

	//UART ISR *** UART ISR ***

	LED_on();

	rprintf("\r\nSystem Warmed Up");
    1d2c:	00 d0       	rcall	.+0      	; 0x1d2e <prvSetupHardware+0x72>
    1d2e:	0f 92       	push	r0
    1d30:	81 e0       	ldi	r24, 0x01	; 1
    1d32:	ed b7       	in	r30, 0x3d	; 61
    1d34:	fe b7       	in	r31, 0x3e	; 62
    1d36:	81 83       	std	Z+1, r24	; 0x01
    1d38:	8e e8       	ldi	r24, 0x8E	; 142
    1d3a:	91 e0       	ldi	r25, 0x01	; 1
    1d3c:	93 83       	std	Z+3, r25	; 0x03
    1d3e:	82 83       	std	Z+2, r24	; 0x02
    1d40:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
    1d44:	0f 90       	pop	r0
    1d46:	0f 90       	pop	r0
    1d48:	0f 90       	pop	r0
    1d4a:	85 e0       	ldi	r24, 0x05	; 5
    1d4c:	0e 94 6d 1b 	call	0x36da	; 0x36da <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	init_timer2(TIMER2_CLK_64);
    1d50:	84 e0       	ldi	r24, 0x04	; 4
    1d52:	0e 94 8d 1b 	call	0x371a	; 0x371a <init_timer2>
 	init_timer3(TIMER_CLK_64);
    1d56:	83 e0       	ldi	r24, 0x03	; 3
    1d58:	0e 94 9d 1b 	call	0x373a	; 0x373a <init_timer3>
 	init_timer4(TIMER_CLK_64);
    1d5c:	83 e0       	ldi	r24, 0x03	; 3
    1d5e:	0e 94 af 1b 	call	0x375e	; 0x375e <init_timer4>
 	init_timer5(TIMER_CLK_64);
    1d62:	83 e0       	ldi	r24, 0x03	; 3
    1d64:	0e 94 c1 1b 	call	0x3782	; 0x3782 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
    1d68:	0e 94 40 26 	call	0x4c80	; 0x4c80 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
    1d6c:	85 e0       	ldi	r24, 0x05	; 5
    1d6e:	0e 94 65 26 	call	0x4cca	; 0x4cca <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	0e 94 6c 26 	call	0x4cd8	; 0x4cd8 <a2dSetReference>
    1d78:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1d7a:	01 e0       	ldi	r16, 0x01	; 1
    1d7c:	cc e8       	ldi	r28, 0x8C	; 140
    1d7e:	d1 e0       	ldi	r29, 0x01	; 1
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
    1d80:	81 2f       	mov	r24, r17
    1d82:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
    1d86:	00 d0       	rcall	.+0      	; 0x1d88 <prvSetupHardware+0xcc>
    1d88:	0f 92       	push	r0
    1d8a:	ed b7       	in	r30, 0x3d	; 61
    1d8c:	fe b7       	in	r31, 0x3e	; 62
    1d8e:	01 83       	std	Z+1, r16	; 0x01
    1d90:	d3 83       	std	Z+3, r29	; 0x03
    1d92:	c2 83       	std	Z+2, r28	; 0x02
    1d94:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>
    1d98:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
    1d9a:	0f 90       	pop	r0
    1d9c:	0f 90       	pop	r0
    1d9e:	0f 90       	pop	r0
    1da0:	10 31       	cpi	r17, 0x10	; 16
    1da2:	71 f7       	brne	.-36     	; 0x1d80 <prvSetupHardware+0xc4>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
    1da4:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
    1da6:	00 d0       	rcall	.+0      	; 0x1da8 <prvSetupHardware+0xec>
    1da8:	0f 92       	push	r0
    1daa:	ed b7       	in	r30, 0x3d	; 61
    1dac:	fe b7       	in	r31, 0x3e	; 62
    1dae:	01 83       	std	Z+1, r16	; 0x01
    1db0:	81 e7       	ldi	r24, 0x71	; 113
    1db2:	91 e0       	ldi	r25, 0x01	; 1
    1db4:	93 83       	std	Z+3, r25	; 0x03
    1db6:	82 83       	std	Z+2, r24	; 0x02
    1db8:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
    1dbc:	0f 90       	pop	r0
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	0e 94 23 1b 	call	0x3646	; 0x3646 <reset_timer0>
	reset_timer1();
    1dc6:	0e 94 2d 1b 	call	0x365a	; 0x365a <reset_timer1>
	reset_timer2();
    1dca:	0e 94 3a 1b 	call	0x3674	; 0x3674 <reset_timer2>
	reset_timer3();
    1dce:	0e 94 45 1b 	call	0x368a	; 0x368a <reset_timer3>
	reset_timer4();
    1dd2:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <reset_timer4>
	reset_timer5();
    1dd6:	0e 94 5f 1b 	call	0x36be	; 0x36be <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
    1dda:	0e 94 4e 04 	call	0x89c	; 0x89c <prvPWMSetup>

}
    1dde:	df 91       	pop	r29
    1de0:	cf 91       	pop	r28
    1de2:	1f 91       	pop	r17
    1de4:	0f 91       	pop	r16
    1de6:	08 95       	ret

00001de8 <main>:
		vTaskDelay( 10/portTICK_RATE_MS);
	}
}

int main(void)
{
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
	xQueueLDS = xQueueCreate(1000, 1);
    1dee:	88 ee       	ldi	r24, 0xE8	; 232
    1df0:	61 e0       	ldi	r22, 0x01	; 1
    1df2:	0e 94 2f 12 	call	0x245e	; 0x245e <xQueueCreate>
    1df6:	90 93 11 12 	sts	0x1211, r25
    1dfa:	80 93 10 12 	sts	0x1210, r24
	
	prvSetupHardware();
    1dfe:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <prvSetupHardware>
//	xTaskCreate(vPID_R, "vPID_R", 500, NULL, 2, NULL);
//	xTaskCreate(vScript, "vScript", 100, NULL, 2, NULL);
//	xTaskCreate(vReadIR, "vReadIR", 200, NULL, 1, NULL);
//	xTaskCreate(vQuickReadEnc, "QuickEnc", 100, NULL, 1, NULL);
//	xTaskCreate(vQuickSend, "QuickSend", 100, NULL, 2, NULL);
	vTaskStartScheduler();
    1e02:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <vTaskStartScheduler>
	for(;;){rprintf("DEATH\n");}
    1e06:	11 e0       	ldi	r17, 0x01	; 1
    1e08:	c6 e6       	ldi	r28, 0x66	; 102
    1e0a:	d1 e0       	ldi	r29, 0x01	; 1
    1e0c:	00 d0       	rcall	.+0      	; 0x1e0e <main+0x26>
    1e0e:	0f 92       	push	r0
    1e10:	ed b7       	in	r30, 0x3d	; 61
    1e12:	fe b7       	in	r31, 0x3e	; 62
    1e14:	11 83       	std	Z+1, r17	; 0x01
    1e16:	d3 83       	std	Z+3, r29	; 0x03
    1e18:	c2 83       	std	Z+2, r28	; 0x02
    1e1a:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>
    1e1e:	0f 90       	pop	r0
    1e20:	0f 90       	pop	r0
    1e22:	0f 90       	pop	r0
    1e24:	f3 cf       	rjmp	.-26     	; 0x1e0c <main+0x24>

00001e26 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1e26:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1e28:	9c 01       	movw	r18, r24
    1e2a:	2d 5f       	subi	r18, 0xFD	; 253
    1e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2e:	32 83       	std	Z+2, r19	; 0x02
    1e30:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1e32:	8f ef       	ldi	r24, 0xFF	; 255
    1e34:	9f ef       	ldi	r25, 0xFF	; 255
    1e36:	94 83       	std	Z+4, r25	; 0x04
    1e38:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1e3a:	36 83       	std	Z+6, r19	; 0x06
    1e3c:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1e3e:	30 87       	std	Z+8, r19	; 0x08
    1e40:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
    1e42:	10 82       	st	Z, r1
}
    1e44:	08 95       	ret

00001e46 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1e46:	fc 01       	movw	r30, r24
    1e48:	11 86       	std	Z+9, r1	; 0x09
    1e4a:	10 86       	std	Z+8, r1	; 0x08
}
    1e4c:	08 95       	ret

00001e4e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1e4e:	cf 93       	push	r28
    1e50:	df 93       	push	r29
    1e52:	ac 01       	movw	r20, r24
    1e54:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1e56:	ec 01       	movw	r28, r24
    1e58:	29 81       	ldd	r18, Y+1	; 0x01
    1e5a:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1e5c:	f9 01       	movw	r30, r18
    1e5e:	82 81       	ldd	r24, Z+2	; 0x02
    1e60:	93 81       	ldd	r25, Z+3	; 0x03
    1e62:	13 96       	adiw	r26, 0x03	; 3
    1e64:	9c 93       	st	X, r25
    1e66:	8e 93       	st	-X, r24
    1e68:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1e6a:	89 81       	ldd	r24, Y+1	; 0x01
    1e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e6e:	15 96       	adiw	r26, 0x05	; 5
    1e70:	9c 93       	st	X, r25
    1e72:	8e 93       	st	-X, r24
    1e74:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1e76:	02 80       	ldd	r0, Z+2	; 0x02
    1e78:	f3 81       	ldd	r31, Z+3	; 0x03
    1e7a:	e0 2d       	mov	r30, r0
    1e7c:	75 83       	std	Z+5, r23	; 0x05
    1e7e:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1e80:	e9 01       	movw	r28, r18
    1e82:	7b 83       	std	Y+3, r23	; 0x03
    1e84:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1e86:	fa 01       	movw	r30, r20
    1e88:	72 83       	std	Z+2, r23	; 0x02
    1e8a:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e8c:	19 96       	adiw	r26, 0x09	; 9
    1e8e:	5c 93       	st	X, r21
    1e90:	4e 93       	st	-X, r20
    1e92:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1e94:	80 81       	ld	r24, Z
    1e96:	8f 5f       	subi	r24, 0xFF	; 255
    1e98:	80 83       	st	Z, r24
}
    1e9a:	df 91       	pop	r29
    1e9c:	cf 91       	pop	r28
    1e9e:	08 95       	ret

00001ea0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1ea0:	cf 93       	push	r28
    1ea2:	df 93       	push	r29
    1ea4:	9c 01       	movw	r18, r24
    1ea6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1ea8:	48 81       	ld	r20, Y
    1eaa:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1eac:	8f ef       	ldi	r24, 0xFF	; 255
    1eae:	4f 3f       	cpi	r20, 0xFF	; 255
    1eb0:	58 07       	cpc	r21, r24
    1eb2:	21 f4       	brne	.+8      	; 0x1ebc <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1eb4:	f9 01       	movw	r30, r18
    1eb6:	a7 81       	ldd	r26, Z+7	; 0x07
    1eb8:	b0 85       	ldd	r27, Z+8	; 0x08
    1eba:	10 c0       	rjmp	.+32     	; 0x1edc <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1ebc:	d9 01       	movw	r26, r18
    1ebe:	13 96       	adiw	r26, 0x03	; 3
    1ec0:	04 c0       	rjmp	.+8      	; 0x1eca <vListInsert+0x2a>
    1ec2:	12 96       	adiw	r26, 0x02	; 2
    1ec4:	0d 90       	ld	r0, X+
    1ec6:	bc 91       	ld	r27, X
    1ec8:	a0 2d       	mov	r26, r0
    1eca:	12 96       	adiw	r26, 0x02	; 2
    1ecc:	ed 91       	ld	r30, X+
    1ece:	fc 91       	ld	r31, X
    1ed0:	13 97       	sbiw	r26, 0x03	; 3
    1ed2:	80 81       	ld	r24, Z
    1ed4:	91 81       	ldd	r25, Z+1	; 0x01
    1ed6:	48 17       	cp	r20, r24
    1ed8:	59 07       	cpc	r21, r25
    1eda:	98 f7       	brcc	.-26     	; 0x1ec2 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1edc:	12 96       	adiw	r26, 0x02	; 2
    1ede:	ed 91       	ld	r30, X+
    1ee0:	fc 91       	ld	r31, X
    1ee2:	13 97       	sbiw	r26, 0x03	; 3
    1ee4:	fb 83       	std	Y+3, r31	; 0x03
    1ee6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1ee8:	d5 83       	std	Z+5, r29	; 0x05
    1eea:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1eec:	bd 83       	std	Y+5, r27	; 0x05
    1eee:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1ef0:	13 96       	adiw	r26, 0x03	; 3
    1ef2:	dc 93       	st	X, r29
    1ef4:	ce 93       	st	-X, r28
    1ef6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ef8:	39 87       	std	Y+9, r19	; 0x09
    1efa:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1efc:	f9 01       	movw	r30, r18
    1efe:	80 81       	ld	r24, Z
    1f00:	8f 5f       	subi	r24, 0xFF	; 255
    1f02:	80 83       	st	Z, r24
}
    1f04:	df 91       	pop	r29
    1f06:	cf 91       	pop	r28
    1f08:	08 95       	ret

00001f0a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1f0a:	cf 93       	push	r28
    1f0c:	df 93       	push	r29
    1f0e:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1f10:	12 96       	adiw	r26, 0x02	; 2
    1f12:	ed 91       	ld	r30, X+
    1f14:	fc 91       	ld	r31, X
    1f16:	13 97       	sbiw	r26, 0x03	; 3
    1f18:	14 96       	adiw	r26, 0x04	; 4
    1f1a:	8d 91       	ld	r24, X+
    1f1c:	9c 91       	ld	r25, X
    1f1e:	15 97       	sbiw	r26, 0x05	; 5
    1f20:	95 83       	std	Z+5, r25	; 0x05
    1f22:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f24:	14 96       	adiw	r26, 0x04	; 4
    1f26:	cd 91       	ld	r28, X+
    1f28:	dc 91       	ld	r29, X
    1f2a:	15 97       	sbiw	r26, 0x05	; 5
    1f2c:	fb 83       	std	Y+3, r31	; 0x03
    1f2e:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1f30:	18 96       	adiw	r26, 0x08	; 8
    1f32:	ed 91       	ld	r30, X+
    1f34:	fc 91       	ld	r31, X
    1f36:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1f38:	81 81       	ldd	r24, Z+1	; 0x01
    1f3a:	92 81       	ldd	r25, Z+2	; 0x02
    1f3c:	8a 17       	cp	r24, r26
    1f3e:	9b 07       	cpc	r25, r27
    1f40:	11 f4       	brne	.+4      	; 0x1f46 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1f42:	d2 83       	std	Z+2, r29	; 0x02
    1f44:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1f46:	19 96       	adiw	r26, 0x09	; 9
    1f48:	1c 92       	st	X, r1
    1f4a:	1e 92       	st	-X, r1
    1f4c:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1f4e:	80 81       	ld	r24, Z
    1f50:	81 50       	subi	r24, 0x01	; 1
    1f52:	80 83       	st	Z, r24
}
    1f54:	df 91       	pop	r29
    1f56:	cf 91       	pop	r28
    1f58:	08 95       	ret

00001f5a <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1f5a:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1f5c:	0f b6       	in	r0, 0x3f	; 63
    1f5e:	f8 94       	cli
    1f60:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1f62:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1f64:	0f 90       	pop	r0
    1f66:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1f68:	08 95       	ret

00001f6a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1f6a:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1f6c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1f6e:	08 95       	ret

00001f70 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1f70:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1f72:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	88 23       	and	r24, r24
    1f78:	09 f4       	brne	.+2      	; 0x1f7c <xQueueIsQueueEmptyFromISR+0xc>
    1f7a:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
    1f7c:	89 2f       	mov	r24, r25
    1f7e:	08 95       	ret

00001f80 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1f80:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1f82:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f84:	20 e0       	ldi	r18, 0x00	; 0
    1f86:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f88:	98 17       	cp	r25, r24
    1f8a:	09 f4       	brne	.+2      	; 0x1f8e <xQueueIsQueueFullFromISR+0xe>
    1f8c:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
    1f8e:	82 2f       	mov	r24, r18
    1f90:	08 95       	ret

00001f92 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1f92:	0f 93       	push	r16
    1f94:	1f 93       	push	r17
    1f96:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1f98:	fc 01       	movw	r30, r24
    1f9a:	80 81       	ld	r24, Z
    1f9c:	91 81       	ldd	r25, Z+1	; 0x01
    1f9e:	0e 94 22 1a 	call	0x3444	; 0x3444 <vPortFree>
	vPortFree( pxQueue );
    1fa2:	c8 01       	movw	r24, r16
    1fa4:	0e 94 22 1a 	call	0x3444	; 0x3444 <vPortFree>
}
    1fa8:	1f 91       	pop	r17
    1faa:	0f 91       	pop	r16
    1fac:	08 95       	ret

00001fae <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1fae:	0f 93       	push	r16
    1fb0:	1f 93       	push	r17
    1fb2:	cf 93       	push	r28
    1fb4:	df 93       	push	r29
    1fb6:	ec 01       	movw	r28, r24
    1fb8:	fb 01       	movw	r30, r22
    1fba:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1fbc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fbe:	88 23       	and	r24, r24
    1fc0:	81 f1       	breq	.+96     	; 0x2022 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1fc2:	48 81       	ld	r20, Y
    1fc4:	59 81       	ldd	r21, Y+1	; 0x01
    1fc6:	41 15       	cp	r20, r1
    1fc8:	51 05       	cpc	r21, r1
    1fca:	a9 f0       	breq	.+42     	; 0x1ff6 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1fcc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1fce:	2e 81       	ldd	r18, Y+6	; 0x06
    1fd0:	3f 81       	ldd	r19, Y+7	; 0x07
    1fd2:	28 0f       	add	r18, r24
    1fd4:	31 1d       	adc	r19, r1
    1fd6:	3f 83       	std	Y+7, r19	; 0x07
    1fd8:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1fda:	8a 81       	ldd	r24, Y+2	; 0x02
    1fdc:	9b 81       	ldd	r25, Y+3	; 0x03
    1fde:	28 17       	cp	r18, r24
    1fe0:	39 07       	cpc	r19, r25
    1fe2:	10 f0       	brcs	.+4      	; 0x1fe8 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1fe4:	5f 83       	std	Y+7, r21	; 0x07
    1fe6:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1fe8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1fea:	6e 81       	ldd	r22, Y+6	; 0x06
    1fec:	7f 81       	ldd	r23, Y+7	; 0x07
    1fee:	cf 01       	movw	r24, r30
    1ff0:	50 e0       	ldi	r21, 0x00	; 0
    1ff2:	0e 94 09 2c 	call	0x5812	; 0x5812 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    1ff6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ff8:	81 50       	subi	r24, 0x01	; 1
    1ffa:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1ffc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1ffe:	8f 3f       	cpi	r24, 0xFF	; 255
    2000:	69 f4       	brne	.+26     	; 0x201c <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    2002:	88 85       	ldd	r24, Y+8	; 0x08
    2004:	88 23       	and	r24, r24
    2006:	61 f0       	breq	.+24     	; 0x2020 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2008:	ce 01       	movw	r24, r28
    200a:	08 96       	adiw	r24, 0x08	; 8
    200c:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    2010:	88 23       	and	r24, r24
    2012:	31 f0       	breq	.+12     	; 0x2020 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	f8 01       	movw	r30, r16
    2018:	80 83       	st	Z, r24
    201a:	03 c0       	rjmp	.+6      	; 0x2022 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    201c:	8f 5f       	subi	r24, 0xFF	; 255
    201e:	8d 8f       	std	Y+29, r24	; 0x1d
    2020:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2022:	df 91       	pop	r29
    2024:	cf 91       	pop	r28
    2026:	1f 91       	pop	r17
    2028:	0f 91       	pop	r16
    202a:	08 95       	ret

0000202c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    202c:	cf 93       	push	r28
    202e:	df 93       	push	r29
    2030:	ec 01       	movw	r28, r24
    2032:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2034:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2036:	44 23       	and	r20, r20
    2038:	a1 f1       	breq	.+104    	; 0x20a2 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    203a:	88 23       	and	r24, r24
    203c:	b1 f4       	brne	.+44     	; 0x206a <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    203e:	8c 81       	ldd	r24, Y+4	; 0x04
    2040:	9d 81       	ldd	r25, Y+5	; 0x05
    2042:	50 e0       	ldi	r21, 0x00	; 0
    2044:	0e 94 09 2c 	call	0x5812	; 0x5812 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2048:	8c 8d       	ldd	r24, Y+28	; 0x1c
    204a:	2c 81       	ldd	r18, Y+4	; 0x04
    204c:	3d 81       	ldd	r19, Y+5	; 0x05
    204e:	28 0f       	add	r18, r24
    2050:	31 1d       	adc	r19, r1
    2052:	3d 83       	std	Y+5, r19	; 0x05
    2054:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2056:	8a 81       	ldd	r24, Y+2	; 0x02
    2058:	9b 81       	ldd	r25, Y+3	; 0x03
    205a:	28 17       	cp	r18, r24
    205c:	39 07       	cpc	r19, r25
    205e:	08 f1       	brcs	.+66     	; 0x20a2 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2060:	88 81       	ld	r24, Y
    2062:	99 81       	ldd	r25, Y+1	; 0x01
    2064:	9d 83       	std	Y+5, r25	; 0x05
    2066:	8c 83       	std	Y+4, r24	; 0x04
    2068:	1c c0       	rjmp	.+56     	; 0x20a2 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    206a:	8e 81       	ldd	r24, Y+6	; 0x06
    206c:	9f 81       	ldd	r25, Y+7	; 0x07
    206e:	50 e0       	ldi	r21, 0x00	; 0
    2070:	0e 94 09 2c 	call	0x5812	; 0x5812 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2074:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2076:	90 e0       	ldi	r25, 0x00	; 0
    2078:	44 27       	eor	r20, r20
    207a:	55 27       	eor	r21, r21
    207c:	48 1b       	sub	r20, r24
    207e:	59 0b       	sbc	r21, r25
    2080:	8e 81       	ldd	r24, Y+6	; 0x06
    2082:	9f 81       	ldd	r25, Y+7	; 0x07
    2084:	84 0f       	add	r24, r20
    2086:	95 1f       	adc	r25, r21
    2088:	9f 83       	std	Y+7, r25	; 0x07
    208a:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    208c:	28 81       	ld	r18, Y
    208e:	39 81       	ldd	r19, Y+1	; 0x01
    2090:	82 17       	cp	r24, r18
    2092:	93 07       	cpc	r25, r19
    2094:	30 f4       	brcc	.+12     	; 0x20a2 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2096:	8a 81       	ldd	r24, Y+2	; 0x02
    2098:	9b 81       	ldd	r25, Y+3	; 0x03
    209a:	84 0f       	add	r24, r20
    209c:	95 1f       	adc	r25, r21
    209e:	9f 83       	std	Y+7, r25	; 0x07
    20a0:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    20a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20a4:	8f 5f       	subi	r24, 0xFF	; 255
    20a6:	8a 8f       	std	Y+26, r24	; 0x1a
}
    20a8:	df 91       	pop	r29
    20aa:	cf 91       	pop	r28
    20ac:	08 95       	ret

000020ae <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    20ae:	0f 93       	push	r16
    20b0:	1f 93       	push	r17
    20b2:	cf 93       	push	r28
    20b4:	df 93       	push	r29
    20b6:	ec 01       	movw	r28, r24
    20b8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    20bc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20be:	98 17       	cp	r25, r24
    20c0:	10 f0       	brcs	.+4      	; 0x20c6 <xQueueGenericSendFromISR+0x18>
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	17 c0       	rjmp	.+46     	; 0x20f4 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20c6:	ce 01       	movw	r24, r28
    20c8:	42 2f       	mov	r20, r18
    20ca:	0e 94 16 10 	call	0x202c	; 0x202c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    20ce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    20d0:	8f 3f       	cpi	r24, 0xFF	; 255
    20d2:	69 f4       	brne	.+26     	; 0x20ee <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    20d4:	89 89       	ldd	r24, Y+17	; 0x11
    20d6:	88 23       	and	r24, r24
    20d8:	61 f0       	breq	.+24     	; 0x20f2 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20da:	ce 01       	movw	r24, r28
    20dc:	41 96       	adiw	r24, 0x11	; 17
    20de:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    20e2:	88 23       	and	r24, r24
    20e4:	31 f0       	breq	.+12     	; 0x20f2 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	f8 01       	movw	r30, r16
    20ea:	80 83       	st	Z, r24
    20ec:	03 c0       	rjmp	.+6      	; 0x20f4 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    20ee:	8f 5f       	subi	r24, 0xFF	; 255
    20f0:	8e 8f       	std	Y+30, r24	; 0x1e
    20f2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20f4:	df 91       	pop	r29
    20f6:	cf 91       	pop	r28
    20f8:	1f 91       	pop	r17
    20fa:	0f 91       	pop	r16
    20fc:	08 95       	ret

000020fe <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    20fe:	0f 93       	push	r16
    2100:	1f 93       	push	r17
    2102:	cf 93       	push	r28
    2104:	df 93       	push	r29
    2106:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2108:	0f b6       	in	r0, 0x3f	; 63
    210a:	f8 94       	cli
    210c:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    210e:	8c 01       	movw	r16, r24
    2110:	0f 5e       	subi	r16, 0xEF	; 239
    2112:	1f 4f       	sbci	r17, 0xFF	; 255
    2114:	0d c0       	rjmp	.+26     	; 0x2130 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2116:	89 89       	ldd	r24, Y+17	; 0x11
    2118:	88 23       	and	r24, r24
    211a:	69 f0       	breq	.+26     	; 0x2136 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    211c:	c8 01       	movw	r24, r16
    211e:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    2122:	88 23       	and	r24, r24
    2124:	11 f0       	breq	.+4      	; 0x212a <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    2126:	0e 94 33 13 	call	0x2666	; 0x2666 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    212a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    212c:	81 50       	subi	r24, 0x01	; 1
    212e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2130:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2132:	18 16       	cp	r1, r24
    2134:	84 f3       	brlt	.-32     	; 0x2116 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2136:	8f ef       	ldi	r24, 0xFF	; 255
    2138:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    213a:	0f 90       	pop	r0
    213c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    213e:	0f b6       	in	r0, 0x3f	; 63
    2140:	f8 94       	cli
    2142:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2144:	8e 01       	movw	r16, r28
    2146:	08 5f       	subi	r16, 0xF8	; 248
    2148:	1f 4f       	sbci	r17, 0xFF	; 255
    214a:	0d c0       	rjmp	.+26     	; 0x2166 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    214c:	88 85       	ldd	r24, Y+8	; 0x08
    214e:	88 23       	and	r24, r24
    2150:	69 f0       	breq	.+26     	; 0x216c <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2152:	c8 01       	movw	r24, r16
    2154:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    2158:	88 23       	and	r24, r24
    215a:	11 f0       	breq	.+4      	; 0x2160 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    215c:	0e 94 33 13 	call	0x2666	; 0x2666 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2160:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2162:	81 50       	subi	r24, 0x01	; 1
    2164:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2166:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2168:	18 16       	cp	r1, r24
    216a:	84 f3       	brlt	.-32     	; 0x214c <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    216c:	8f ef       	ldi	r24, 0xFF	; 255
    216e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2170:	0f 90       	pop	r0
    2172:	0f be       	out	0x3f, r0	; 63
}
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	1f 91       	pop	r17
    217a:	0f 91       	pop	r16
    217c:	08 95       	ret

0000217e <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    217e:	7f 92       	push	r7
    2180:	8f 92       	push	r8
    2182:	9f 92       	push	r9
    2184:	af 92       	push	r10
    2186:	bf 92       	push	r11
    2188:	cf 92       	push	r12
    218a:	df 92       	push	r13
    218c:	ef 92       	push	r14
    218e:	ff 92       	push	r15
    2190:	0f 93       	push	r16
    2192:	1f 93       	push	r17
    2194:	df 93       	push	r29
    2196:	cf 93       	push	r28
    2198:	00 d0       	rcall	.+0      	; 0x219a <xQueueGenericReceive+0x1c>
    219a:	00 d0       	rcall	.+0      	; 0x219c <xQueueGenericReceive+0x1e>
    219c:	0f 92       	push	r0
    219e:	cd b7       	in	r28, 0x3d	; 61
    21a0:	de b7       	in	r29, 0x3e	; 62
    21a2:	8c 01       	movw	r16, r24
    21a4:	96 2e       	mov	r9, r22
    21a6:	87 2e       	mov	r8, r23
    21a8:	5d 83       	std	Y+5, r21	; 0x05
    21aa:	4c 83       	std	Y+4, r20	; 0x04
    21ac:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    21ae:	91 e1       	ldi	r25, 0x11	; 17
    21b0:	c9 2e       	mov	r12, r25
    21b2:	d1 2c       	mov	r13, r1
    21b4:	c0 0e       	add	r12, r16
    21b6:	d1 1e       	adc	r13, r17
    21b8:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    21ba:	7e 01       	movw	r14, r28
    21bc:	08 94       	sec
    21be:	e1 1c       	adc	r14, r1
    21c0:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    21c2:	84 e0       	ldi	r24, 0x04	; 4
    21c4:	a8 2e       	mov	r10, r24
    21c6:	b1 2c       	mov	r11, r1
    21c8:	ac 0e       	add	r10, r28
    21ca:	bd 1e       	adc	r11, r29
    21cc:	01 c0       	rjmp	.+2      	; 0x21d0 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    21ce:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    21d0:	0f b6       	in	r0, 0x3f	; 63
    21d2:	f8 94       	cli
    21d4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    21d6:	f8 01       	movw	r30, r16
    21d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    21da:	88 23       	and	r24, r24
    21dc:	09 f4       	brne	.+2      	; 0x21e0 <xQueueGenericReceive+0x62>
    21de:	3e c0       	rjmp	.+124    	; 0x225c <__stack+0x5d>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    21e0:	e6 80       	ldd	r14, Z+6	; 0x06
    21e2:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    21e4:	40 81       	ld	r20, Z
    21e6:	51 81       	ldd	r21, Z+1	; 0x01
    21e8:	41 15       	cp	r20, r1
    21ea:	51 05       	cpc	r21, r1
    21ec:	b1 f0       	breq	.+44     	; 0x221a <__stack+0x1b>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    21ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    21f0:	97 01       	movw	r18, r14
    21f2:	28 0f       	add	r18, r24
    21f4:	31 1d       	adc	r19, r1
    21f6:	37 83       	std	Z+7, r19	; 0x07
    21f8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    21fa:	82 81       	ldd	r24, Z+2	; 0x02
    21fc:	93 81       	ldd	r25, Z+3	; 0x03
    21fe:	28 17       	cp	r18, r24
    2200:	39 07       	cpc	r19, r25
    2202:	10 f0       	brcs	.+4      	; 0x2208 <__stack+0x9>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2204:	57 83       	std	Z+7, r21	; 0x07
    2206:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2208:	f8 01       	movw	r30, r16
    220a:	44 8d       	ldd	r20, Z+28	; 0x1c
    220c:	66 81       	ldd	r22, Z+6	; 0x06
    220e:	77 81       	ldd	r23, Z+7	; 0x07
    2210:	89 2d       	mov	r24, r9
    2212:	98 2d       	mov	r25, r8
    2214:	50 e0       	ldi	r21, 0x00	; 0
    2216:	0e 94 09 2c 	call	0x5812	; 0x5812 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    221a:	77 20       	and	r7, r7
    221c:	71 f4       	brne	.+28     	; 0x223a <__stack+0x3b>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    221e:	f8 01       	movw	r30, r16
    2220:	82 8d       	ldd	r24, Z+26	; 0x1a
    2222:	81 50       	subi	r24, 0x01	; 1
    2224:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2226:	80 85       	ldd	r24, Z+8	; 0x08
    2228:	88 23       	and	r24, r24
    222a:	a1 f0       	breq	.+40     	; 0x2254 <__stack+0x55>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    222c:	c8 01       	movw	r24, r16
    222e:	08 96       	adiw	r24, 0x08	; 8
    2230:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    2234:	81 30       	cpi	r24, 0x01	; 1
    2236:	71 f4       	brne	.+28     	; 0x2254 <__stack+0x55>
    2238:	0b c0       	rjmp	.+22     	; 0x2250 <__stack+0x51>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    223a:	f8 01       	movw	r30, r16
    223c:	f7 82       	std	Z+7, r15	; 0x07
    223e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    2240:	81 89       	ldd	r24, Z+17	; 0x11
    2242:	88 23       	and	r24, r24
    2244:	39 f0       	breq	.+14     	; 0x2254 <__stack+0x55>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2246:	c6 01       	movw	r24, r12
    2248:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    224c:	88 23       	and	r24, r24
    224e:	11 f0       	breq	.+4      	; 0x2254 <__stack+0x55>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2250:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2254:	0f 90       	pop	r0
    2256:	0f be       	out	0x3f, r0	; 63
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	4a c0       	rjmp	.+148    	; 0x22f0 <__stack+0xf1>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    225c:	8c 81       	ldd	r24, Y+4	; 0x04
    225e:	9d 81       	ldd	r25, Y+5	; 0x05
    2260:	89 2b       	or	r24, r25
    2262:	19 f4       	brne	.+6      	; 0x226a <__stack+0x6b>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2264:	0f 90       	pop	r0
    2266:	0f be       	out	0x3f, r0	; 63
    2268:	42 c0       	rjmp	.+132    	; 0x22ee <__stack+0xef>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    226a:	22 23       	and	r18, r18
    226c:	19 f4       	brne	.+6      	; 0x2274 <__stack+0x75>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    226e:	c7 01       	movw	r24, r14
    2270:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    2274:	0f 90       	pop	r0
    2276:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2278:	0e 94 92 12 	call	0x2524	; 0x2524 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    227c:	0f b6       	in	r0, 0x3f	; 63
    227e:	f8 94       	cli
    2280:	0f 92       	push	r0
    2282:	f8 01       	movw	r30, r16
    2284:	85 8d       	ldd	r24, Z+29	; 0x1d
    2286:	8f 3f       	cpi	r24, 0xFF	; 255
    2288:	09 f4       	brne	.+2      	; 0x228c <__stack+0x8d>
    228a:	15 8e       	std	Z+29, r1	; 0x1d
    228c:	f8 01       	movw	r30, r16
    228e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2290:	8f 3f       	cpi	r24, 0xFF	; 255
    2292:	09 f4       	brne	.+2      	; 0x2296 <__stack+0x97>
    2294:	16 8e       	std	Z+30, r1	; 0x1e
    2296:	0f 90       	pop	r0
    2298:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    229a:	c7 01       	movw	r24, r14
    229c:	b5 01       	movw	r22, r10
    229e:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <xTaskCheckForTimeOut>
    22a2:	88 23       	and	r24, r24
    22a4:	f9 f4       	brne	.+62     	; 0x22e4 <__stack+0xe5>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    22a6:	0f b6       	in	r0, 0x3f	; 63
    22a8:	f8 94       	cli
    22aa:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    22ac:	f8 01       	movw	r30, r16
    22ae:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    22b0:	0f 90       	pop	r0
    22b2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    22b4:	88 23       	and	r24, r24
    22b6:	81 f4       	brne	.+32     	; 0x22d8 <__stack+0xd9>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22b8:	6c 81       	ldd	r22, Y+4	; 0x04
    22ba:	7d 81       	ldd	r23, Y+5	; 0x05
    22bc:	c6 01       	movw	r24, r12
    22be:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    22c2:	c8 01       	movw	r24, r16
    22c4:	0e 94 7f 10 	call	0x20fe	; 0x20fe <prvUnlockQueue>
				if( !xTaskResumeAll() )
    22c8:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    22cc:	88 23       	and	r24, r24
    22ce:	09 f0       	breq	.+2      	; 0x22d2 <__stack+0xd3>
    22d0:	7e cf       	rjmp	.-260    	; 0x21ce <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    22d2:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
    22d6:	7b cf       	rjmp	.-266    	; 0x21ce <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    22d8:	c8 01       	movw	r24, r16
    22da:	0e 94 7f 10 	call	0x20fe	; 0x20fe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    22de:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    22e2:	75 cf       	rjmp	.-278    	; 0x21ce <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    22e4:	c8 01       	movw	r24, r16
    22e6:	0e 94 7f 10 	call	0x20fe	; 0x20fe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    22ea:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    22ee:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    22f0:	0f 90       	pop	r0
    22f2:	0f 90       	pop	r0
    22f4:	0f 90       	pop	r0
    22f6:	0f 90       	pop	r0
    22f8:	0f 90       	pop	r0
    22fa:	cf 91       	pop	r28
    22fc:	df 91       	pop	r29
    22fe:	1f 91       	pop	r17
    2300:	0f 91       	pop	r16
    2302:	ff 90       	pop	r15
    2304:	ef 90       	pop	r14
    2306:	df 90       	pop	r13
    2308:	cf 90       	pop	r12
    230a:	bf 90       	pop	r11
    230c:	af 90       	pop	r10
    230e:	9f 90       	pop	r9
    2310:	8f 90       	pop	r8
    2312:	7f 90       	pop	r7
    2314:	08 95       	ret

00002316 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2316:	7f 92       	push	r7
    2318:	8f 92       	push	r8
    231a:	9f 92       	push	r9
    231c:	af 92       	push	r10
    231e:	bf 92       	push	r11
    2320:	cf 92       	push	r12
    2322:	df 92       	push	r13
    2324:	ef 92       	push	r14
    2326:	ff 92       	push	r15
    2328:	0f 93       	push	r16
    232a:	1f 93       	push	r17
    232c:	df 93       	push	r29
    232e:	cf 93       	push	r28
    2330:	00 d0       	rcall	.+0      	; 0x2332 <xQueueGenericSend+0x1c>
    2332:	00 d0       	rcall	.+0      	; 0x2334 <xQueueGenericSend+0x1e>
    2334:	0f 92       	push	r0
    2336:	cd b7       	in	r28, 0x3d	; 61
    2338:	de b7       	in	r29, 0x3e	; 62
    233a:	8c 01       	movw	r16, r24
    233c:	6b 01       	movw	r12, r22
    233e:	5d 83       	std	Y+5, r21	; 0x05
    2340:	4c 83       	std	Y+4, r20	; 0x04
    2342:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2344:	48 e0       	ldi	r20, 0x08	; 8
    2346:	e4 2e       	mov	r14, r20
    2348:	f1 2c       	mov	r15, r1
    234a:	e8 0e       	add	r14, r24
    234c:	f9 1e       	adc	r15, r25
    234e:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2350:	5e 01       	movw	r10, r28
    2352:	08 94       	sec
    2354:	a1 1c       	adc	r10, r1
    2356:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2358:	34 e0       	ldi	r19, 0x04	; 4
    235a:	83 2e       	mov	r8, r19
    235c:	91 2c       	mov	r9, r1
    235e:	8c 0e       	add	r8, r28
    2360:	9d 1e       	adc	r9, r29
    2362:	01 c0       	rjmp	.+2      	; 0x2366 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2364:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2366:	0f b6       	in	r0, 0x3f	; 63
    2368:	f8 94       	cli
    236a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    236c:	f8 01       	movw	r30, r16
    236e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2370:	83 8d       	ldd	r24, Z+27	; 0x1b
    2372:	98 17       	cp	r25, r24
    2374:	a8 f4       	brcc	.+42     	; 0x23a0 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2376:	c8 01       	movw	r24, r16
    2378:	b6 01       	movw	r22, r12
    237a:	47 2d       	mov	r20, r7
    237c:	0e 94 16 10 	call	0x202c	; 0x202c <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2380:	f8 01       	movw	r30, r16
    2382:	81 89       	ldd	r24, Z+17	; 0x11
    2384:	88 23       	and	r24, r24
    2386:	41 f0       	breq	.+16     	; 0x2398 <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2388:	c8 01       	movw	r24, r16
    238a:	41 96       	adiw	r24, 0x11	; 17
    238c:	0e 94 37 13 	call	0x266e	; 0x266e <xTaskRemoveFromEventList>
    2390:	81 30       	cpi	r24, 0x01	; 1
    2392:	11 f4       	brne	.+4      	; 0x2398 <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2394:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2398:	0f 90       	pop	r0
    239a:	0f be       	out	0x3f, r0	; 63
    239c:	81 e0       	ldi	r24, 0x01	; 1
    239e:	4c c0       	rjmp	.+152    	; 0x2438 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    23a0:	8c 81       	ldd	r24, Y+4	; 0x04
    23a2:	9d 81       	ldd	r25, Y+5	; 0x05
    23a4:	89 2b       	or	r24, r25
    23a6:	19 f4       	brne	.+6      	; 0x23ae <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23a8:	0f 90       	pop	r0
    23aa:	0f be       	out	0x3f, r0	; 63
    23ac:	44 c0       	rjmp	.+136    	; 0x2436 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    23ae:	22 23       	and	r18, r18
    23b0:	19 f4       	brne	.+6      	; 0x23b8 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23b2:	c5 01       	movw	r24, r10
    23b4:	0e 94 ee 12 	call	0x25dc	; 0x25dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    23b8:	0f 90       	pop	r0
    23ba:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23bc:	0e 94 92 12 	call	0x2524	; 0x2524 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23c0:	0f b6       	in	r0, 0x3f	; 63
    23c2:	f8 94       	cli
    23c4:	0f 92       	push	r0
    23c6:	f8 01       	movw	r30, r16
    23c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    23ca:	8f 3f       	cpi	r24, 0xFF	; 255
    23cc:	09 f4       	brne	.+2      	; 0x23d0 <xQueueGenericSend+0xba>
    23ce:	15 8e       	std	Z+29, r1	; 0x1d
    23d0:	f8 01       	movw	r30, r16
    23d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    23d4:	8f 3f       	cpi	r24, 0xFF	; 255
    23d6:	09 f4       	brne	.+2      	; 0x23da <xQueueGenericSend+0xc4>
    23d8:	16 8e       	std	Z+30, r1	; 0x1e
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23de:	c5 01       	movw	r24, r10
    23e0:	b4 01       	movw	r22, r8
    23e2:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <xTaskCheckForTimeOut>
    23e6:	88 23       	and	r24, r24
    23e8:	09 f5       	brne	.+66     	; 0x242c <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23ea:	0f b6       	in	r0, 0x3f	; 63
    23ec:	f8 94       	cli
    23ee:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    23f0:	f8 01       	movw	r30, r16
    23f2:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    23f4:	0f 90       	pop	r0
    23f6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    23f8:	f8 01       	movw	r30, r16
    23fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    23fc:	98 17       	cp	r25, r24
    23fe:	81 f4       	brne	.+32     	; 0x2420 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2400:	6c 81       	ldd	r22, Y+4	; 0x04
    2402:	7d 81       	ldd	r23, Y+5	; 0x05
    2404:	c7 01       	movw	r24, r14
    2406:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    240a:	c8 01       	movw	r24, r16
    240c:	0e 94 7f 10 	call	0x20fe	; 0x20fe <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    2410:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    2414:	88 23       	and	r24, r24
    2416:	09 f0       	breq	.+2      	; 0x241a <xQueueGenericSend+0x104>
    2418:	a5 cf       	rjmp	.-182    	; 0x2364 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    241a:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
    241e:	a2 cf       	rjmp	.-188    	; 0x2364 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2420:	c8 01       	movw	r24, r16
    2422:	0e 94 7f 10 	call	0x20fe	; 0x20fe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2426:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    242a:	9c cf       	rjmp	.-200    	; 0x2364 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    242c:	c8 01       	movw	r24, r16
    242e:	0e 94 7f 10 	call	0x20fe	; 0x20fe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2432:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    2436:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    2438:	0f 90       	pop	r0
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	0f 90       	pop	r0
    2440:	0f 90       	pop	r0
    2442:	cf 91       	pop	r28
    2444:	df 91       	pop	r29
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	ff 90       	pop	r15
    244c:	ef 90       	pop	r14
    244e:	df 90       	pop	r13
    2450:	cf 90       	pop	r12
    2452:	bf 90       	pop	r11
    2454:	af 90       	pop	r10
    2456:	9f 90       	pop	r9
    2458:	8f 90       	pop	r8
    245a:	7f 90       	pop	r7
    245c:	08 95       	ret

0000245e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    245e:	8f 92       	push	r8
    2460:	9f 92       	push	r9
    2462:	af 92       	push	r10
    2464:	bf 92       	push	r11
    2466:	cf 92       	push	r12
    2468:	df 92       	push	r13
    246a:	ef 92       	push	r14
    246c:	ff 92       	push	r15
    246e:	0f 93       	push	r16
    2470:	1f 93       	push	r17
    2472:	cf 93       	push	r28
    2474:	df 93       	push	r29
    2476:	98 2e       	mov	r9, r24
    2478:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    247a:	88 23       	and	r24, r24
    247c:	09 f4       	brne	.+2      	; 0x2480 <xQueueCreate+0x22>
    247e:	42 c0       	rjmp	.+132    	; 0x2504 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2480:	8f e1       	ldi	r24, 0x1F	; 31
    2482:	90 e0       	ldi	r25, 0x00	; 0
    2484:	0e 94 32 1a 	call	0x3464	; 0x3464 <pvPortMalloc>
    2488:	8c 01       	movw	r16, r24
    248a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    248c:	00 97       	sbiw	r24, 0x00	; 0
    248e:	e1 f1       	breq	.+120    	; 0x2508 <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2490:	c9 2c       	mov	r12, r9
    2492:	dd 24       	eor	r13, r13
    2494:	a8 2c       	mov	r10, r8
    2496:	bb 24       	eor	r11, r11
    2498:	ac 9c       	mul	r10, r12
    249a:	70 01       	movw	r14, r0
    249c:	ad 9c       	mul	r10, r13
    249e:	f0 0c       	add	r15, r0
    24a0:	bc 9c       	mul	r11, r12
    24a2:	f0 0c       	add	r15, r0
    24a4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    24a6:	c7 01       	movw	r24, r14
    24a8:	01 96       	adiw	r24, 0x01	; 1
    24aa:	0e 94 32 1a 	call	0x3464	; 0x3464 <pvPortMalloc>
    24ae:	9c 01       	movw	r18, r24
    24b0:	99 83       	std	Y+1, r25	; 0x01
    24b2:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    24b4:	00 97       	sbiw	r24, 0x00	; 0
    24b6:	19 f1       	breq	.+70     	; 0x24fe <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    24b8:	e8 0e       	add	r14, r24
    24ba:	f9 1e       	adc	r15, r25
    24bc:	fb 82       	std	Y+3, r15	; 0x03
    24be:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    24c0:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    24c2:	9d 83       	std	Y+5, r25	; 0x05
    24c4:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    24c6:	08 94       	sec
    24c8:	c1 08       	sbc	r12, r1
    24ca:	d1 08       	sbc	r13, r1
    24cc:	ca 9c       	mul	r12, r10
    24ce:	c0 01       	movw	r24, r0
    24d0:	cb 9c       	mul	r12, r11
    24d2:	90 0d       	add	r25, r0
    24d4:	da 9c       	mul	r13, r10
    24d6:	90 0d       	add	r25, r0
    24d8:	11 24       	eor	r1, r1
    24da:	28 0f       	add	r18, r24
    24dc:	39 1f       	adc	r19, r25
    24de:	3f 83       	std	Y+7, r19	; 0x07
    24e0:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    24e2:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    24e4:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    24e6:	8f ef       	ldi	r24, 0xFF	; 255
    24e8:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    24ea:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    24ec:	c8 01       	movw	r24, r16
    24ee:	08 96       	adiw	r24, 0x08	; 8
    24f0:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    24f4:	c8 01       	movw	r24, r16
    24f6:	41 96       	adiw	r24, 0x11	; 17
    24f8:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
    24fc:	05 c0       	rjmp	.+10     	; 0x2508 <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    24fe:	c8 01       	movw	r24, r16
    2500:	0e 94 22 1a 	call	0x3444	; 0x3444 <vPortFree>
    2504:	c0 e0       	ldi	r28, 0x00	; 0
    2506:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    2508:	ce 01       	movw	r24, r28
    250a:	df 91       	pop	r29
    250c:	cf 91       	pop	r28
    250e:	1f 91       	pop	r17
    2510:	0f 91       	pop	r16
    2512:	ff 90       	pop	r15
    2514:	ef 90       	pop	r14
    2516:	df 90       	pop	r13
    2518:	cf 90       	pop	r12
    251a:	bf 90       	pop	r11
    251c:	af 90       	pop	r10
    251e:	9f 90       	pop	r9
    2520:	8f 90       	pop	r8
    2522:	08 95       	ret

00002524 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2524:	80 91 f2 02 	lds	r24, 0x02F2
    2528:	8f 5f       	subi	r24, 0xFF	; 255
    252a:	80 93 f2 02 	sts	0x02F2, r24
}
    252e:	08 95       	ret

00002530 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    2530:	0f b6       	in	r0, 0x3f	; 63
    2532:	f8 94       	cli
    2534:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2536:	20 91 f0 02 	lds	r18, 0x02F0
    253a:	30 91 f1 02 	lds	r19, 0x02F1
	}
	portEXIT_CRITICAL();
    253e:	0f 90       	pop	r0
    2540:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2542:	c9 01       	movw	r24, r18
    2544:	08 95       	ret

00002546 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    2546:	20 91 f0 02 	lds	r18, 0x02F0
    254a:	30 91 f1 02 	lds	r19, 0x02F1
}
    254e:	c9 01       	movw	r24, r18
    2550:	08 95       	ret

00002552 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2552:	80 91 f5 02 	lds	r24, 0x02F5
}
    2556:	08 95       	ret

00002558 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2558:	80 91 f2 02 	lds	r24, 0x02F2
    255c:	88 23       	and	r24, r24
    255e:	51 f0       	breq	.+20     	; 0x2574 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	80 93 ee 02 	sts	0x02EE, r24
    2566:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    2568:	80 91 f3 02 	lds	r24, 0x02F3
    256c:	81 50       	subi	r24, 0x01	; 1
    256e:	80 93 f3 02 	sts	0x02F3, r24
    2572:	01 c0       	rjmp	.+2      	; 0x2576 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2574:	99 e0       	ldi	r25, 0x09	; 9
    2576:	e0 91 f3 02 	lds	r30, 0x02F3
    257a:	e9 9f       	mul	r30, r25
    257c:	f0 01       	movw	r30, r0
    257e:	11 24       	eor	r1, r1
    2580:	e6 50       	subi	r30, 0x06	; 6
    2582:	fd 4f       	sbci	r31, 0xFD	; 253
    2584:	80 81       	ld	r24, Z
    2586:	88 23       	and	r24, r24
    2588:	79 f3       	breq	.-34     	; 0x2568 <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    258a:	90 91 f3 02 	lds	r25, 0x02F3
    258e:	89 e0       	ldi	r24, 0x09	; 9
    2590:	98 9f       	mul	r25, r24
    2592:	d0 01       	movw	r26, r0
    2594:	11 24       	eor	r1, r1
    2596:	a6 50       	subi	r26, 0x06	; 6
    2598:	bd 4f       	sbci	r27, 0xFD	; 253
    259a:	11 96       	adiw	r26, 0x01	; 1
    259c:	ed 91       	ld	r30, X+
    259e:	fc 91       	ld	r31, X
    25a0:	12 97       	sbiw	r26, 0x02	; 2
    25a2:	02 80       	ldd	r0, Z+2	; 0x02
    25a4:	f3 81       	ldd	r31, Z+3	; 0x03
    25a6:	e0 2d       	mov	r30, r0
    25a8:	12 96       	adiw	r26, 0x02	; 2
    25aa:	fc 93       	st	X, r31
    25ac:	ee 93       	st	-X, r30
    25ae:	11 97       	sbiw	r26, 0x01	; 1
    25b0:	cd 01       	movw	r24, r26
    25b2:	03 96       	adiw	r24, 0x03	; 3
    25b4:	e8 17       	cp	r30, r24
    25b6:	f9 07       	cpc	r31, r25
    25b8:	31 f4       	brne	.+12     	; 0x25c6 <vTaskSwitchContext+0x6e>
    25ba:	82 81       	ldd	r24, Z+2	; 0x02
    25bc:	93 81       	ldd	r25, Z+3	; 0x03
    25be:	12 96       	adiw	r26, 0x02	; 2
    25c0:	9c 93       	st	X, r25
    25c2:	8e 93       	st	-X, r24
    25c4:	11 97       	sbiw	r26, 0x01	; 1
    25c6:	11 96       	adiw	r26, 0x01	; 1
    25c8:	ed 91       	ld	r30, X+
    25ca:	fc 91       	ld	r31, X
    25cc:	12 97       	sbiw	r26, 0x02	; 2
    25ce:	86 81       	ldd	r24, Z+6	; 0x06
    25d0:	97 81       	ldd	r25, Z+7	; 0x07
    25d2:	90 93 ed 02 	sts	0x02ED, r25
    25d6:	80 93 ec 02 	sts	0x02EC, r24
    25da:	08 95       	ret

000025dc <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    25dc:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    25de:	80 91 ef 02 	lds	r24, 0x02EF
    25e2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    25e4:	80 91 f0 02 	lds	r24, 0x02F0
    25e8:	90 91 f1 02 	lds	r25, 0x02F1
    25ec:	92 83       	std	Z+2, r25	; 0x02
    25ee:	81 83       	std	Z+1, r24	; 0x01
}
    25f0:	08 95       	ret

000025f2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    25f2:	fc 01       	movw	r30, r24
    25f4:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    25f6:	0f b6       	in	r0, 0x3f	; 63
    25f8:	f8 94       	cli
    25fa:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    25fc:	90 91 ef 02 	lds	r25, 0x02EF
    2600:	80 81       	ld	r24, Z
    2602:	98 17       	cp	r25, r24
    2604:	49 f0       	breq	.+18     	; 0x2618 <xTaskCheckForTimeOut+0x26>
    2606:	20 91 f0 02 	lds	r18, 0x02F0
    260a:	30 91 f1 02 	lds	r19, 0x02F1
    260e:	81 81       	ldd	r24, Z+1	; 0x01
    2610:	92 81       	ldd	r25, Z+2	; 0x02
    2612:	28 17       	cp	r18, r24
    2614:	39 07       	cpc	r19, r25
    2616:	18 f5       	brcc	.+70     	; 0x265e <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2618:	80 91 f0 02 	lds	r24, 0x02F0
    261c:	90 91 f1 02 	lds	r25, 0x02F1
    2620:	21 81       	ldd	r18, Z+1	; 0x01
    2622:	32 81       	ldd	r19, Z+2	; 0x02
    2624:	4d 91       	ld	r20, X+
    2626:	5c 91       	ld	r21, X
    2628:	11 97       	sbiw	r26, 0x01	; 1
    262a:	82 1b       	sub	r24, r18
    262c:	93 0b       	sbc	r25, r19
    262e:	84 17       	cp	r24, r20
    2630:	95 07       	cpc	r25, r21
    2632:	a8 f4       	brcc	.+42     	; 0x265e <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2634:	80 91 f0 02 	lds	r24, 0x02F0
    2638:	90 91 f1 02 	lds	r25, 0x02F1
    263c:	28 1b       	sub	r18, r24
    263e:	39 0b       	sbc	r19, r25
    2640:	24 0f       	add	r18, r20
    2642:	35 1f       	adc	r19, r21
    2644:	2d 93       	st	X+, r18
    2646:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2648:	80 91 ef 02 	lds	r24, 0x02EF
    264c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    264e:	80 91 f0 02 	lds	r24, 0x02F0
    2652:	90 91 f1 02 	lds	r25, 0x02F1
    2656:	92 83       	std	Z+2, r25	; 0x02
    2658:	81 83       	std	Z+1, r24	; 0x01
    265a:	80 e0       	ldi	r24, 0x00	; 0
    265c:	01 c0       	rjmp	.+2      	; 0x2660 <xTaskCheckForTimeOut+0x6e>
    265e:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    2660:	0f 90       	pop	r0
    2662:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2664:	08 95       	ret

00002666 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	80 93 ee 02 	sts	0x02EE, r24
}
    266c:	08 95       	ret

0000266e <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    266e:	0f 93       	push	r16
    2670:	1f 93       	push	r17
    2672:	cf 93       	push	r28
    2674:	df 93       	push	r29
    2676:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2678:	80 81       	ld	r24, Z
    267a:	88 23       	and	r24, r24
    267c:	19 f4       	brne	.+6      	; 0x2684 <xTaskRemoveFromEventList+0x16>
    267e:	c0 e0       	ldi	r28, 0x00	; 0
    2680:	d0 e0       	ldi	r29, 0x00	; 0
    2682:	05 c0       	rjmp	.+10     	; 0x268e <xTaskRemoveFromEventList+0x20>
    2684:	05 80       	ldd	r0, Z+5	; 0x05
    2686:	f6 81       	ldd	r31, Z+6	; 0x06
    2688:	e0 2d       	mov	r30, r0
    268a:	c6 81       	ldd	r28, Z+6	; 0x06
    268c:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    268e:	8e 01       	movw	r16, r28
    2690:	04 5f       	subi	r16, 0xF4	; 244
    2692:	1f 4f       	sbci	r17, 0xFF	; 255
    2694:	c8 01       	movw	r24, r16
    2696:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    269a:	80 91 f2 02 	lds	r24, 0x02F2
    269e:	88 23       	and	r24, r24
    26a0:	a1 f4       	brne	.+40     	; 0x26ca <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    26a2:	8e 01       	movw	r16, r28
    26a4:	0e 5f       	subi	r16, 0xFE	; 254
    26a6:	1f 4f       	sbci	r17, 0xFF	; 255
    26a8:	c8 01       	movw	r24, r16
    26aa:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    26ae:	9e 89       	ldd	r25, Y+22	; 0x16
    26b0:	80 91 f3 02 	lds	r24, 0x02F3
    26b4:	89 17       	cp	r24, r25
    26b6:	10 f4       	brcc	.+4      	; 0x26bc <xTaskRemoveFromEventList+0x4e>
    26b8:	90 93 f3 02 	sts	0x02F3, r25
    26bc:	89 e0       	ldi	r24, 0x09	; 9
    26be:	98 9f       	mul	r25, r24
    26c0:	c0 01       	movw	r24, r0
    26c2:	11 24       	eor	r1, r1
    26c4:	86 50       	subi	r24, 0x06	; 6
    26c6:	9d 4f       	sbci	r25, 0xFD	; 253
    26c8:	02 c0       	rjmp	.+4      	; 0x26ce <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    26ca:	84 e3       	ldi	r24, 0x34	; 52
    26cc:	93 e0       	ldi	r25, 0x03	; 3
    26ce:	b8 01       	movw	r22, r16
    26d0:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    26d4:	e0 91 ec 02 	lds	r30, 0x02EC
    26d8:	f0 91 ed 02 	lds	r31, 0x02ED
    26dc:	20 e0       	ldi	r18, 0x00	; 0
    26de:	9e 89       	ldd	r25, Y+22	; 0x16
    26e0:	86 89       	ldd	r24, Z+22	; 0x16
    26e2:	98 17       	cp	r25, r24
    26e4:	08 f0       	brcs	.+2      	; 0x26e8 <xTaskRemoveFromEventList+0x7a>
    26e6:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    26e8:	82 2f       	mov	r24, r18
    26ea:	df 91       	pop	r29
    26ec:	cf 91       	pop	r28
    26ee:	1f 91       	pop	r17
    26f0:	0f 91       	pop	r16
    26f2:	08 95       	ret

000026f4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    26f4:	ff 92       	push	r15
    26f6:	0f 93       	push	r16
    26f8:	1f 93       	push	r17
    26fa:	cf 93       	push	r28
    26fc:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    26fe:	80 91 f2 02 	lds	r24, 0x02F2
    2702:	88 23       	and	r24, r24
    2704:	09 f0       	breq	.+2      	; 0x2708 <vTaskIncrementTick+0x14>
    2706:	61 c0       	rjmp	.+194    	; 0x27ca <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    2708:	80 91 f0 02 	lds	r24, 0x02F0
    270c:	90 91 f1 02 	lds	r25, 0x02F1
    2710:	01 96       	adiw	r24, 0x01	; 1
    2712:	90 93 f1 02 	sts	0x02F1, r25
    2716:	80 93 f0 02 	sts	0x02F0, r24
		if( xTickCount == ( portTickType ) 0 )
    271a:	80 91 f0 02 	lds	r24, 0x02F0
    271e:	90 91 f1 02 	lds	r25, 0x02F1
    2722:	89 2b       	or	r24, r25
    2724:	e9 f5       	brne	.+122    	; 0x27a0 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    2726:	80 91 30 03 	lds	r24, 0x0330
    272a:	90 91 31 03 	lds	r25, 0x0331
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    272e:	20 91 32 03 	lds	r18, 0x0332
    2732:	30 91 33 03 	lds	r19, 0x0333
    2736:	30 93 31 03 	sts	0x0331, r19
    273a:	20 93 30 03 	sts	0x0330, r18
			pxOverflowDelayedTaskList = pxTemp;
    273e:	90 93 33 03 	sts	0x0333, r25
    2742:	80 93 32 03 	sts	0x0332, r24
			xNumOfOverflows++;
    2746:	80 91 ef 02 	lds	r24, 0x02EF
    274a:	8f 5f       	subi	r24, 0xFF	; 255
    274c:	80 93 ef 02 	sts	0x02EF, r24
    2750:	27 c0       	rjmp	.+78     	; 0x27a0 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2752:	20 91 f0 02 	lds	r18, 0x02F0
    2756:	30 91 f1 02 	lds	r19, 0x02F1
    275a:	8a 81       	ldd	r24, Y+2	; 0x02
    275c:	9b 81       	ldd	r25, Y+3	; 0x03
    275e:	28 17       	cp	r18, r24
    2760:	39 07       	cpc	r19, r25
    2762:	c0 f1       	brcs	.+112    	; 0x27d4 <vTaskIncrementTick+0xe0>
    2764:	8e 01       	movw	r16, r28
    2766:	0e 5f       	subi	r16, 0xFE	; 254
    2768:	1f 4f       	sbci	r17, 0xFF	; 255
    276a:	c8 01       	movw	r24, r16
    276c:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
    2770:	8c 89       	ldd	r24, Y+20	; 0x14
    2772:	9d 89       	ldd	r25, Y+21	; 0x15
    2774:	89 2b       	or	r24, r25
    2776:	21 f0       	breq	.+8      	; 0x2780 <vTaskIncrementTick+0x8c>
    2778:	ce 01       	movw	r24, r28
    277a:	0c 96       	adiw	r24, 0x0c	; 12
    277c:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
    2780:	9e 89       	ldd	r25, Y+22	; 0x16
    2782:	80 91 f3 02 	lds	r24, 0x02F3
    2786:	89 17       	cp	r24, r25
    2788:	10 f4       	brcc	.+4      	; 0x278e <vTaskIncrementTick+0x9a>
    278a:	90 93 f3 02 	sts	0x02F3, r25
    278e:	9f 9d       	mul	r25, r15
    2790:	c0 01       	movw	r24, r0
    2792:	11 24       	eor	r1, r1
    2794:	86 50       	subi	r24, 0x06	; 6
    2796:	9d 4f       	sbci	r25, 0xFD	; 253
    2798:	b8 01       	movw	r22, r16
    279a:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>
    279e:	02 c0       	rjmp	.+4      	; 0x27a4 <vTaskIncrementTick+0xb0>
    27a0:	89 e0       	ldi	r24, 0x09	; 9
    27a2:	f8 2e       	mov	r15, r24
    27a4:	e0 91 30 03 	lds	r30, 0x0330
    27a8:	f0 91 31 03 	lds	r31, 0x0331
    27ac:	80 81       	ld	r24, Z
    27ae:	88 23       	and	r24, r24
    27b0:	89 f0       	breq	.+34     	; 0x27d4 <vTaskIncrementTick+0xe0>
    27b2:	e0 91 30 03 	lds	r30, 0x0330
    27b6:	f0 91 31 03 	lds	r31, 0x0331
    27ba:	05 80       	ldd	r0, Z+5	; 0x05
    27bc:	f6 81       	ldd	r31, Z+6	; 0x06
    27be:	e0 2d       	mov	r30, r0
    27c0:	c6 81       	ldd	r28, Z+6	; 0x06
    27c2:	d7 81       	ldd	r29, Z+7	; 0x07
    27c4:	20 97       	sbiw	r28, 0x00	; 0
    27c6:	29 f6       	brne	.-118    	; 0x2752 <vTaskIncrementTick+0x5e>
    27c8:	05 c0       	rjmp	.+10     	; 0x27d4 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    27ca:	80 91 f4 02 	lds	r24, 0x02F4
    27ce:	8f 5f       	subi	r24, 0xFF	; 255
    27d0:	80 93 f4 02 	sts	0x02F4, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    27d4:	df 91       	pop	r29
    27d6:	cf 91       	pop	r28
    27d8:	1f 91       	pop	r17
    27da:	0f 91       	pop	r16
    27dc:	ff 90       	pop	r15
    27de:	08 95       	ret

000027e0 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    27e0:	0f 93       	push	r16
    27e2:	1f 93       	push	r17
    27e4:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    27e6:	60 91 ec 02 	lds	r22, 0x02EC
    27ea:	70 91 ed 02 	lds	r23, 0x02ED
    27ee:	64 5f       	subi	r22, 0xF4	; 244
    27f0:	7f 4f       	sbci	r23, 0xFF	; 255
    27f2:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27f6:	80 91 ec 02 	lds	r24, 0x02EC
    27fa:	90 91 ed 02 	lds	r25, 0x02ED
    27fe:	02 96       	adiw	r24, 0x02	; 2
    2800:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2804:	80 91 f0 02 	lds	r24, 0x02F0
    2808:	90 91 f1 02 	lds	r25, 0x02F1
    280c:	80 0f       	add	r24, r16
    280e:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2810:	e0 91 ec 02 	lds	r30, 0x02EC
    2814:	f0 91 ed 02 	lds	r31, 0x02ED
    2818:	93 83       	std	Z+3, r25	; 0x03
    281a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    281c:	20 91 f0 02 	lds	r18, 0x02F0
    2820:	30 91 f1 02 	lds	r19, 0x02F1
    2824:	82 17       	cp	r24, r18
    2826:	93 07       	cpc	r25, r19
    2828:	28 f4       	brcc	.+10     	; 0x2834 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    282a:	80 91 32 03 	lds	r24, 0x0332
    282e:	90 91 33 03 	lds	r25, 0x0333
    2832:	04 c0       	rjmp	.+8      	; 0x283c <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2834:	80 91 30 03 	lds	r24, 0x0330
    2838:	90 91 31 03 	lds	r25, 0x0331
    283c:	60 91 ec 02 	lds	r22, 0x02EC
    2840:	70 91 ed 02 	lds	r23, 0x02ED
    2844:	6e 5f       	subi	r22, 0xFE	; 254
    2846:	7f 4f       	sbci	r23, 0xFF	; 255
    2848:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vListInsert>
			}
	}
	#endif
}
    284c:	1f 91       	pop	r17
    284e:	0f 91       	pop	r16
    2850:	08 95       	ret

00002852 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2852:	cf 92       	push	r12
    2854:	df 92       	push	r13
    2856:	ff 92       	push	r15
    2858:	0f 93       	push	r16
    285a:	1f 93       	push	r17
    285c:	df 93       	push	r29
    285e:	cf 93       	push	r28
    2860:	0f 92       	push	r0
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    2866:	0f b6       	in	r0, 0x3f	; 63
    2868:	f8 94       	cli
    286a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    286c:	80 91 f2 02 	lds	r24, 0x02F2
    2870:	81 50       	subi	r24, 0x01	; 1
    2872:	80 93 f2 02 	sts	0x02F2, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2876:	80 91 f2 02 	lds	r24, 0x02F2
    287a:	88 23       	and	r24, r24
    287c:	09 f0       	breq	.+2      	; 0x2880 <xTaskResumeAll+0x2e>
    287e:	5b c0       	rjmp	.+182    	; 0x2936 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    2880:	80 91 f5 02 	lds	r24, 0x02F5
    2884:	88 23       	and	r24, r24
    2886:	09 f4       	brne	.+2      	; 0x288a <xTaskResumeAll+0x38>
    2888:	56 c0       	rjmp	.+172    	; 0x2936 <xTaskResumeAll+0xe4>
    288a:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    288c:	99 e0       	ldi	r25, 0x09	; 9
    288e:	f9 2e       	mov	r15, r25
    2890:	27 c0       	rjmp	.+78     	; 0x28e0 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2892:	c6 01       	movw	r24, r12
    2894:	0c 96       	adiw	r24, 0x0c	; 12
    2896:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    289a:	86 01       	movw	r16, r12
    289c:	0e 5f       	subi	r16, 0xFE	; 254
    289e:	1f 4f       	sbci	r17, 0xFF	; 255
    28a0:	c8 01       	movw	r24, r16
    28a2:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    28a6:	d6 01       	movw	r26, r12
    28a8:	56 96       	adiw	r26, 0x16	; 22
    28aa:	9c 91       	ld	r25, X
    28ac:	80 91 f3 02 	lds	r24, 0x02F3
    28b0:	89 17       	cp	r24, r25
    28b2:	10 f4       	brcc	.+4      	; 0x28b8 <xTaskResumeAll+0x66>
    28b4:	90 93 f3 02 	sts	0x02F3, r25
    28b8:	9f 9d       	mul	r25, r15
    28ba:	c0 01       	movw	r24, r0
    28bc:	11 24       	eor	r1, r1
    28be:	86 50       	subi	r24, 0x06	; 6
    28c0:	9d 4f       	sbci	r25, 0xFD	; 253
    28c2:	b8 01       	movw	r22, r16
    28c4:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    28c8:	e0 91 ec 02 	lds	r30, 0x02EC
    28cc:	f0 91 ed 02 	lds	r31, 0x02ED
    28d0:	d6 01       	movw	r26, r12
    28d2:	56 96       	adiw	r26, 0x16	; 22
    28d4:	9c 91       	ld	r25, X
    28d6:	86 89       	ldd	r24, Z+22	; 0x16
    28d8:	98 17       	cp	r25, r24
    28da:	10 f0       	brcs	.+4      	; 0x28e0 <xTaskResumeAll+0x8e>
    28dc:	b1 e0       	ldi	r27, 0x01	; 1
    28de:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    28e0:	80 91 34 03 	lds	r24, 0x0334
    28e4:	88 23       	and	r24, r24
    28e6:	49 f0       	breq	.+18     	; 0x28fa <xTaskResumeAll+0xa8>
    28e8:	e0 91 39 03 	lds	r30, 0x0339
    28ec:	f0 91 3a 03 	lds	r31, 0x033A
    28f0:	c6 80       	ldd	r12, Z+6	; 0x06
    28f2:	d7 80       	ldd	r13, Z+7	; 0x07
    28f4:	c1 14       	cp	r12, r1
    28f6:	d1 04       	cpc	r13, r1
    28f8:	61 f6       	brne	.-104    	; 0x2892 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    28fa:	80 91 f4 02 	lds	r24, 0x02F4
    28fe:	88 23       	and	r24, r24
    2900:	41 f4       	brne	.+16     	; 0x2912 <xTaskResumeAll+0xc0>
    2902:	0c c0       	rjmp	.+24     	; 0x291c <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    2904:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <vTaskIncrementTick>
						--uxMissedTicks;
    2908:	80 91 f4 02 	lds	r24, 0x02F4
    290c:	81 50       	subi	r24, 0x01	; 1
    290e:	80 93 f4 02 	sts	0x02F4, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2912:	80 91 f4 02 	lds	r24, 0x02F4
    2916:	88 23       	and	r24, r24
    2918:	a9 f7       	brne	.-22     	; 0x2904 <xTaskResumeAll+0xb2>
    291a:	07 c0       	rjmp	.+14     	; 0x292a <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    291c:	e9 81       	ldd	r30, Y+1	; 0x01
    291e:	e1 30       	cpi	r30, 0x01	; 1
    2920:	21 f0       	breq	.+8      	; 0x292a <xTaskResumeAll+0xd8>
    2922:	80 91 ee 02 	lds	r24, 0x02EE
    2926:	81 30       	cpi	r24, 0x01	; 1
    2928:	31 f4       	brne	.+12     	; 0x2936 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    292a:	10 92 ee 02 	sts	0x02EE, r1
					portYIELD_WITHIN_API();
    292e:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
    2932:	81 e0       	ldi	r24, 0x01	; 1
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <xTaskResumeAll+0xe6>
    2936:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    2938:	0f 90       	pop	r0
    293a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    293c:	0f 90       	pop	r0
    293e:	cf 91       	pop	r28
    2940:	df 91       	pop	r29
    2942:	1f 91       	pop	r17
    2944:	0f 91       	pop	r16
    2946:	ff 90       	pop	r15
    2948:	df 90       	pop	r13
    294a:	cf 90       	pop	r12
    294c:	08 95       	ret

0000294e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    2954:	00 97       	sbiw	r24, 0x00	; 0
    2956:	a1 f1       	breq	.+104    	; 0x29c0 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2958:	80 91 f2 02 	lds	r24, 0x02F2
    295c:	8f 5f       	subi	r24, 0xFF	; 255
    295e:	80 93 f2 02 	sts	0x02F2, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2962:	00 91 f0 02 	lds	r16, 0x02F0
    2966:	10 91 f1 02 	lds	r17, 0x02F1
    296a:	02 0f       	add	r16, r18
    296c:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    296e:	80 91 ec 02 	lds	r24, 0x02EC
    2972:	90 91 ed 02 	lds	r25, 0x02ED
    2976:	02 96       	adiw	r24, 0x02	; 2
    2978:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    297c:	e0 91 ec 02 	lds	r30, 0x02EC
    2980:	f0 91 ed 02 	lds	r31, 0x02ED
    2984:	13 83       	std	Z+3, r17	; 0x03
    2986:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    2988:	80 91 f0 02 	lds	r24, 0x02F0
    298c:	90 91 f1 02 	lds	r25, 0x02F1
    2990:	08 17       	cp	r16, r24
    2992:	19 07       	cpc	r17, r25
    2994:	28 f4       	brcc	.+10     	; 0x29a0 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2996:	80 91 32 03 	lds	r24, 0x0332
    299a:	90 91 33 03 	lds	r25, 0x0333
    299e:	04 c0       	rjmp	.+8      	; 0x29a8 <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    29a0:	80 91 30 03 	lds	r24, 0x0330
    29a4:	90 91 31 03 	lds	r25, 0x0331
    29a8:	60 91 ec 02 	lds	r22, 0x02EC
    29ac:	70 91 ed 02 	lds	r23, 0x02ED
    29b0:	6e 5f       	subi	r22, 0xFE	; 254
    29b2:	7f 4f       	sbci	r23, 0xFF	; 255
    29b4:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    29b8:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    29bc:	88 23       	and	r24, r24
    29be:	11 f4       	brne	.+4      	; 0x29c4 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    29c0:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
		}
	}
    29c4:	1f 91       	pop	r17
    29c6:	0f 91       	pop	r16
    29c8:	08 95       	ret

000029ca <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    29ca:	cf 93       	push	r28
    29cc:	df 93       	push	r29
    29ce:	fc 01       	movw	r30, r24
    29d0:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    29d2:	80 91 f2 02 	lds	r24, 0x02F2
    29d6:	8f 5f       	subi	r24, 0xFF	; 255
    29d8:	80 93 f2 02 	sts	0x02F2, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    29dc:	20 81       	ld	r18, Z
    29de:	31 81       	ldd	r19, Z+1	; 0x01
    29e0:	c2 0f       	add	r28, r18
    29e2:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    29e4:	80 91 f0 02 	lds	r24, 0x02F0
    29e8:	90 91 f1 02 	lds	r25, 0x02F1
    29ec:	82 17       	cp	r24, r18
    29ee:	93 07       	cpc	r25, r19
    29f0:	28 f4       	brcc	.+10     	; 0x29fc <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    29f2:	c2 17       	cp	r28, r18
    29f4:	d3 07       	cpc	r29, r19
    29f6:	28 f0       	brcs	.+10     	; 0x2a02 <vTaskDelayUntil+0x38>
    29f8:	20 e0       	ldi	r18, 0x00	; 0
    29fa:	0c c0       	rjmp	.+24     	; 0x2a14 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    29fc:	c2 17       	cp	r28, r18
    29fe:	d3 07       	cpc	r29, r19
    2a00:	40 f0       	brcs	.+16     	; 0x2a12 <vTaskDelayUntil+0x48>
    2a02:	80 91 f0 02 	lds	r24, 0x02F0
    2a06:	90 91 f1 02 	lds	r25, 0x02F1
    2a0a:	20 e0       	ldi	r18, 0x00	; 0
    2a0c:	8c 17       	cp	r24, r28
    2a0e:	9d 07       	cpc	r25, r29
    2a10:	08 f4       	brcc	.+2      	; 0x2a14 <vTaskDelayUntil+0x4a>
    2a12:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2a14:	d1 83       	std	Z+1, r29	; 0x01
    2a16:	c0 83       	st	Z, r28

			if( xShouldDelay )
    2a18:	22 23       	and	r18, r18
    2a1a:	29 f1       	breq	.+74     	; 0x2a66 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a1c:	80 91 ec 02 	lds	r24, 0x02EC
    2a20:	90 91 ed 02 	lds	r25, 0x02ED
    2a24:	02 96       	adiw	r24, 0x02	; 2
    2a26:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2a2a:	e0 91 ec 02 	lds	r30, 0x02EC
    2a2e:	f0 91 ed 02 	lds	r31, 0x02ED
    2a32:	d3 83       	std	Z+3, r29	; 0x03
    2a34:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    2a36:	80 91 f0 02 	lds	r24, 0x02F0
    2a3a:	90 91 f1 02 	lds	r25, 0x02F1
    2a3e:	c8 17       	cp	r28, r24
    2a40:	d9 07       	cpc	r29, r25
    2a42:	28 f4       	brcc	.+10     	; 0x2a4e <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a44:	80 91 32 03 	lds	r24, 0x0332
    2a48:	90 91 33 03 	lds	r25, 0x0333
    2a4c:	04 c0       	rjmp	.+8      	; 0x2a56 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a4e:	80 91 30 03 	lds	r24, 0x0330
    2a52:	90 91 31 03 	lds	r25, 0x0331
    2a56:	60 91 ec 02 	lds	r22, 0x02EC
    2a5a:	70 91 ed 02 	lds	r23, 0x02ED
    2a5e:	6e 5f       	subi	r22, 0xFE	; 254
    2a60:	7f 4f       	sbci	r23, 0xFF	; 255
    2a62:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2a66:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    2a6a:	88 23       	and	r24, r24
    2a6c:	11 f4       	brne	.+4      	; 0x2a72 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    2a6e:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
		}
	}
    2a72:	df 91       	pop	r29
    2a74:	cf 91       	pop	r28
    2a76:	08 95       	ret

00002a78 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2a78:	ef 92       	push	r14
    2a7a:	ff 92       	push	r15
    2a7c:	0f 93       	push	r16
    2a7e:	1f 93       	push	r17
    2a80:	cf 93       	push	r28
    2a82:	df 93       	push	r29
    2a84:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    2a86:	0f b6       	in	r0, 0x3f	; 63
    2a88:	f8 94       	cli
    2a8a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2a8c:	80 91 ec 02 	lds	r24, 0x02EC
    2a90:	90 91 ed 02 	lds	r25, 0x02ED
    2a94:	08 17       	cp	r16, r24
    2a96:	19 07       	cpc	r17, r25
    2a98:	19 f4       	brne	.+6      	; 0x2aa0 <vTaskDelete+0x28>
    2a9a:	00 e0       	ldi	r16, 0x00	; 0
    2a9c:	10 e0       	ldi	r17, 0x00	; 0
    2a9e:	03 c0       	rjmp	.+6      	; 0x2aa6 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2aa0:	01 15       	cp	r16, r1
    2aa2:	11 05       	cpc	r17, r1
    2aa4:	29 f4       	brne	.+10     	; 0x2ab0 <vTaskDelete+0x38>
    2aa6:	c0 91 ec 02 	lds	r28, 0x02EC
    2aaa:	d0 91 ed 02 	lds	r29, 0x02ED
    2aae:	01 c0       	rjmp	.+2      	; 0x2ab2 <vTaskDelete+0x3a>
    2ab0:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2ab2:	22 e0       	ldi	r18, 0x02	; 2
    2ab4:	e2 2e       	mov	r14, r18
    2ab6:	f1 2c       	mov	r15, r1
    2ab8:	ec 0e       	add	r14, r28
    2aba:	fd 1e       	adc	r15, r29
    2abc:	c7 01       	movw	r24, r14
    2abe:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2ac2:	8c 89       	ldd	r24, Y+20	; 0x14
    2ac4:	9d 89       	ldd	r25, Y+21	; 0x15
    2ac6:	89 2b       	or	r24, r25
    2ac8:	21 f0       	breq	.+8      	; 0x2ad2 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2aca:	ce 01       	movw	r24, r28
    2acc:	0c 96       	adiw	r24, 0x0c	; 12
    2ace:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2ad2:	8d e3       	ldi	r24, 0x3D	; 61
    2ad4:	93 e0       	ldi	r25, 0x03	; 3
    2ad6:	b7 01       	movw	r22, r14
    2ad8:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2adc:	80 91 f7 02 	lds	r24, 0x02F7
    2ae0:	8f 5f       	subi	r24, 0xFF	; 255
    2ae2:	80 93 f7 02 	sts	0x02F7, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2ae6:	80 91 f8 02 	lds	r24, 0x02F8
    2aea:	8f 5f       	subi	r24, 0xFF	; 255
    2aec:	80 93 f8 02 	sts	0x02F8, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    2af0:	0f 90       	pop	r0
    2af2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2af4:	80 91 f6 02 	lds	r24, 0x02F6
    2af8:	88 23       	and	r24, r24
    2afa:	21 f0       	breq	.+8      	; 0x2b04 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2afc:	01 2b       	or	r16, r17
    2afe:	11 f4       	brne	.+4      	; 0x2b04 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    2b00:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
			}
		}
	}
    2b04:	df 91       	pop	r29
    2b06:	cf 91       	pop	r28
    2b08:	1f 91       	pop	r17
    2b0a:	0f 91       	pop	r16
    2b0c:	ff 90       	pop	r15
    2b0e:	ef 90       	pop	r14
    2b10:	08 95       	ret

00002b12 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2b12:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2b14:	10 92 f6 02 	sts	0x02F6, r1
	vPortEndScheduler();
    2b18:	0e 94 a0 17 	call	0x2f40	; 0x2f40 <vPortEndScheduler>
}
    2b1c:	08 95       	ret

00002b1e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2b1e:	1f 93       	push	r17
    2b20:	cf 93       	push	r28
    2b22:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    2b24:	80 91 f7 02 	lds	r24, 0x02F7
    2b28:	88 23       	and	r24, r24
    2b2a:	91 f1       	breq	.+100    	; 0x2b90 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2b2c:	80 91 f2 02 	lds	r24, 0x02F2
    2b30:	8f 5f       	subi	r24, 0xFF	; 255
    2b32:	80 93 f2 02 	sts	0x02F2, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2b36:	10 91 3d 03 	lds	r17, 0x033D
			xTaskResumeAll();
    2b3a:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>

			if( !xListIsEmpty )
    2b3e:	11 23       	and	r17, r17
    2b40:	39 f1       	breq	.+78     	; 0x2b90 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    2b42:	0f b6       	in	r0, 0x3f	; 63
    2b44:	f8 94       	cli
    2b46:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2b48:	80 91 3d 03 	lds	r24, 0x033D
    2b4c:	88 23       	and	r24, r24
    2b4e:	19 f4       	brne	.+6      	; 0x2b56 <prvIdleTask+0x38>
    2b50:	c0 e0       	ldi	r28, 0x00	; 0
    2b52:	d0 e0       	ldi	r29, 0x00	; 0
    2b54:	06 c0       	rjmp	.+12     	; 0x2b62 <prvIdleTask+0x44>
    2b56:	e0 91 42 03 	lds	r30, 0x0342
    2b5a:	f0 91 43 03 	lds	r31, 0x0343
    2b5e:	c6 81       	ldd	r28, Z+6	; 0x06
    2b60:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    2b62:	ce 01       	movw	r24, r28
    2b64:	02 96       	adiw	r24, 0x02	; 2
    2b66:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
					--uxCurrentNumberOfTasks;
    2b6a:	80 91 f5 02 	lds	r24, 0x02F5
    2b6e:	81 50       	subi	r24, 0x01	; 1
    2b70:	80 93 f5 02 	sts	0x02F5, r24
					--uxTasksDeleted;
    2b74:	80 91 f7 02 	lds	r24, 0x02F7
    2b78:	81 50       	subi	r24, 0x01	; 1
    2b7a:	80 93 f7 02 	sts	0x02F7, r24
				}
				portEXIT_CRITICAL();
    2b7e:	0f 90       	pop	r0
    2b80:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2b82:	8f 89       	ldd	r24, Y+23	; 0x17
    2b84:	98 8d       	ldd	r25, Y+24	; 0x18
    2b86:	0e 94 22 1a 	call	0x3444	; 0x3444 <vPortFree>
		vPortFree( pxTCB );
    2b8a:	ce 01       	movw	r24, r28
    2b8c:	0e 94 22 1a 	call	0x3444	; 0x3444 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2b90:	80 91 fa 02 	lds	r24, 0x02FA
    2b94:	82 30       	cpi	r24, 0x02	; 2
    2b96:	30 f2       	brcs	.-116    	; 0x2b24 <prvIdleTask+0x6>
			{
				taskYIELD();
    2b98:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
    2b9c:	c3 cf       	rjmp	.-122    	; 0x2b24 <prvIdleTask+0x6>

00002b9e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2b9e:	2f 92       	push	r2
    2ba0:	3f 92       	push	r3
    2ba2:	5f 92       	push	r5
    2ba4:	6f 92       	push	r6
    2ba6:	7f 92       	push	r7
    2ba8:	8f 92       	push	r8
    2baa:	9f 92       	push	r9
    2bac:	af 92       	push	r10
    2bae:	bf 92       	push	r11
    2bb0:	cf 92       	push	r12
    2bb2:	df 92       	push	r13
    2bb4:	ef 92       	push	r14
    2bb6:	ff 92       	push	r15
    2bb8:	0f 93       	push	r16
    2bba:	1f 93       	push	r17
    2bbc:	df 93       	push	r29
    2bbe:	cf 93       	push	r28
    2bc0:	00 d0       	rcall	.+0      	; 0x2bc2 <xTaskGenericCreate+0x24>
    2bc2:	00 d0       	rcall	.+0      	; 0x2bc4 <xTaskGenericCreate+0x26>
    2bc4:	cd b7       	in	r28, 0x3d	; 61
    2bc6:	de b7       	in	r29, 0x3e	; 62
    2bc8:	9a 83       	std	Y+2, r25	; 0x02
    2bca:	89 83       	std	Y+1, r24	; 0x01
    2bcc:	4b 01       	movw	r8, r22
    2bce:	5a 01       	movw	r10, r20
    2bd0:	19 01       	movw	r2, r18
    2bd2:	50 2e       	mov	r5, r16
    2bd4:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2bd6:	81 e2       	ldi	r24, 0x21	; 33
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	0e 94 32 1a 	call	0x3464	; 0x3464 <pvPortMalloc>
    2bde:	8b 83       	std	Y+3, r24	; 0x03
    2be0:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    2be2:	8b 81       	ldd	r24, Y+3	; 0x03
    2be4:	9c 81       	ldd	r25, Y+4	; 0x04
    2be6:	89 2b       	or	r24, r25
    2be8:	89 f0       	breq	.+34     	; 0x2c0c <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2bea:	c1 14       	cp	r12, r1
    2bec:	d1 04       	cpc	r13, r1
    2bee:	21 f4       	brne	.+8      	; 0x2bf8 <xTaskGenericCreate+0x5a>
    2bf0:	c5 01       	movw	r24, r10
    2bf2:	0e 94 32 1a 	call	0x3464	; 0x3464 <pvPortMalloc>
    2bf6:	6c 01       	movw	r12, r24
    2bf8:	eb 81       	ldd	r30, Y+3	; 0x03
    2bfa:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfc:	d0 8e       	std	Z+24, r13	; 0x18
    2bfe:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2c00:	c1 14       	cp	r12, r1
    2c02:	d1 04       	cpc	r13, r1
    2c04:	29 f4       	brne	.+10     	; 0x2c10 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2c06:	cf 01       	movw	r24, r30
    2c08:	0e 94 22 1a 	call	0x3444	; 0x3444 <vPortFree>
    2c0c:	8f ef       	ldi	r24, 0xFF	; 255
    2c0e:	d5 c0       	rjmp	.+426    	; 0x2dba <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2c10:	c6 01       	movw	r24, r12
    2c12:	65 ea       	ldi	r22, 0xA5	; 165
    2c14:	70 e0       	ldi	r23, 0x00	; 0
    2c16:	a5 01       	movw	r20, r10
    2c18:	0e 94 12 2c 	call	0x5824	; 0x5824 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    2c1c:	08 94       	sec
    2c1e:	a1 08       	sbc	r10, r1
    2c20:	b1 08       	sbc	r11, r1
    2c22:	eb 81       	ldd	r30, Y+3	; 0x03
    2c24:	fc 81       	ldd	r31, Y+4	; 0x04
    2c26:	e7 88       	ldd	r14, Z+23	; 0x17
    2c28:	f0 8c       	ldd	r15, Z+24	; 0x18
    2c2a:	ea 0c       	add	r14, r10
    2c2c:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2c2e:	cf 01       	movw	r24, r30
    2c30:	49 96       	adiw	r24, 0x19	; 25
    2c32:	b4 01       	movw	r22, r8
    2c34:	48 e0       	ldi	r20, 0x08	; 8
    2c36:	50 e0       	ldi	r21, 0x00	; 0
    2c38:	0e 94 19 2c 	call	0x5832	; 0x5832 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    2c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c40:	10 a2       	std	Z+32, r1	; 0x20
    2c42:	05 2d       	mov	r16, r5
    2c44:	f3 e0       	ldi	r31, 0x03	; 3
    2c46:	f5 15       	cp	r31, r5
    2c48:	08 f4       	brcc	.+2      	; 0x2c4c <xTaskGenericCreate+0xae>
    2c4a:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    2c4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c50:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2c52:	42 e0       	ldi	r20, 0x02	; 2
    2c54:	c4 2e       	mov	r12, r20
    2c56:	d1 2c       	mov	r13, r1
    2c58:	ce 0e       	add	r12, r30
    2c5a:	df 1e       	adc	r13, r31
    2c5c:	c6 01       	movw	r24, r12
    2c5e:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	0c 96       	adiw	r24, 0x0c	; 12
    2c68:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c70:	fc 01       	movw	r30, r24
    2c72:	91 87       	std	Z+9, r25	; 0x09
    2c74:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2c76:	84 e0       	ldi	r24, 0x04	; 4
    2c78:	90 e0       	ldi	r25, 0x00	; 0
    2c7a:	80 1b       	sub	r24, r16
    2c7c:	91 09       	sbc	r25, r1
    2c7e:	95 87       	std	Z+13, r25	; 0x0d
    2c80:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2c82:	f3 8b       	std	Z+19, r31	; 0x13
    2c84:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2c86:	c7 01       	movw	r24, r14
    2c88:	69 81       	ldd	r22, Y+1	; 0x01
    2c8a:	7a 81       	ldd	r23, Y+2	; 0x02
    2c8c:	a1 01       	movw	r20, r2
    2c8e:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <pxPortInitialiseStack>
    2c92:	eb 81       	ldd	r30, Y+3	; 0x03
    2c94:	fc 81       	ldd	r31, Y+4	; 0x04
    2c96:	91 83       	std	Z+1, r25	; 0x01
    2c98:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    2c9a:	61 14       	cp	r6, r1
    2c9c:	71 04       	cpc	r7, r1
    2c9e:	21 f0       	breq	.+8      	; 0x2ca8 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2ca0:	cf 01       	movw	r24, r30
    2ca2:	f3 01       	movw	r30, r6
    2ca4:	91 83       	std	Z+1, r25	; 0x01
    2ca6:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    2ca8:	0f b6       	in	r0, 0x3f	; 63
    2caa:	f8 94       	cli
    2cac:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2cae:	80 91 f5 02 	lds	r24, 0x02F5
    2cb2:	8f 5f       	subi	r24, 0xFF	; 255
    2cb4:	80 93 f5 02 	sts	0x02F5, r24
			if( pxCurrentTCB == NULL )
    2cb8:	80 91 ec 02 	lds	r24, 0x02EC
    2cbc:	90 91 ed 02 	lds	r25, 0x02ED
    2cc0:	89 2b       	or	r24, r25
    2cc2:	b9 f5       	brne	.+110    	; 0x2d32 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2cc4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc8:	f0 93 ed 02 	sts	0x02ED, r31
    2ccc:	e0 93 ec 02 	sts	0x02EC, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2cd0:	80 91 f5 02 	lds	r24, 0x02F5
    2cd4:	81 30       	cpi	r24, 0x01	; 1
    2cd6:	f1 f5       	brne	.+124    	; 0x2d54 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2cd8:	8a ef       	ldi	r24, 0xFA	; 250
    2cda:	92 e0       	ldi	r25, 0x02	; 2
    2cdc:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
    2ce0:	83 e0       	ldi	r24, 0x03	; 3
    2ce2:	93 e0       	ldi	r25, 0x03	; 3
    2ce4:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
    2ce8:	8c e0       	ldi	r24, 0x0C	; 12
    2cea:	93 e0       	ldi	r25, 0x03	; 3
    2cec:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
    2cf0:	85 e1       	ldi	r24, 0x15	; 21
    2cf2:	93 e0       	ldi	r25, 0x03	; 3
    2cf4:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2cf8:	3e e1       	ldi	r19, 0x1E	; 30
    2cfa:	e3 2e       	mov	r14, r19
    2cfc:	33 e0       	ldi	r19, 0x03	; 3
    2cfe:	f3 2e       	mov	r15, r19
    2d00:	c7 01       	movw	r24, r14
    2d02:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2d06:	07 e2       	ldi	r16, 0x27	; 39
    2d08:	13 e0       	ldi	r17, 0x03	; 3
    2d0a:	c8 01       	movw	r24, r16
    2d0c:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2d10:	84 e3       	ldi	r24, 0x34	; 52
    2d12:	93 e0       	ldi	r25, 0x03	; 3
    2d14:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2d18:	8d e3       	ldi	r24, 0x3D	; 61
    2d1a:	93 e0       	ldi	r25, 0x03	; 3
    2d1c:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2d20:	f0 92 31 03 	sts	0x0331, r15
    2d24:	e0 92 30 03 	sts	0x0330, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2d28:	10 93 33 03 	sts	0x0333, r17
    2d2c:	00 93 32 03 	sts	0x0332, r16
    2d30:	11 c0       	rjmp	.+34     	; 0x2d54 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2d32:	80 91 f6 02 	lds	r24, 0x02F6
    2d36:	88 23       	and	r24, r24
    2d38:	69 f4       	brne	.+26     	; 0x2d54 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2d3a:	e0 91 ec 02 	lds	r30, 0x02EC
    2d3e:	f0 91 ed 02 	lds	r31, 0x02ED
    2d42:	86 89       	ldd	r24, Z+22	; 0x16
    2d44:	58 16       	cp	r5, r24
    2d46:	30 f0       	brcs	.+12     	; 0x2d54 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    2d48:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d4c:	90 93 ed 02 	sts	0x02ED, r25
    2d50:	80 93 ec 02 	sts	0x02EC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2d54:	eb 81       	ldd	r30, Y+3	; 0x03
    2d56:	fc 81       	ldd	r31, Y+4	; 0x04
    2d58:	96 89       	ldd	r25, Z+22	; 0x16
    2d5a:	80 91 f9 02 	lds	r24, 0x02F9
    2d5e:	89 17       	cp	r24, r25
    2d60:	10 f4       	brcc	.+4      	; 0x2d66 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2d62:	90 93 f9 02 	sts	0x02F9, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2d66:	80 91 f8 02 	lds	r24, 0x02F8
    2d6a:	8f 5f       	subi	r24, 0xFF	; 255
    2d6c:	80 93 f8 02 	sts	0x02F8, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2d70:	eb 81       	ldd	r30, Y+3	; 0x03
    2d72:	fc 81       	ldd	r31, Y+4	; 0x04
    2d74:	96 89       	ldd	r25, Z+22	; 0x16
    2d76:	80 91 f3 02 	lds	r24, 0x02F3
    2d7a:	89 17       	cp	r24, r25
    2d7c:	10 f4       	brcc	.+4      	; 0x2d82 <xTaskGenericCreate+0x1e4>
    2d7e:	90 93 f3 02 	sts	0x02F3, r25
    2d82:	eb 81       	ldd	r30, Y+3	; 0x03
    2d84:	fc 81       	ldd	r31, Y+4	; 0x04
    2d86:	86 89       	ldd	r24, Z+22	; 0x16
    2d88:	29 e0       	ldi	r18, 0x09	; 9
    2d8a:	82 9f       	mul	r24, r18
    2d8c:	c0 01       	movw	r24, r0
    2d8e:	11 24       	eor	r1, r1
    2d90:	86 50       	subi	r24, 0x06	; 6
    2d92:	9d 4f       	sbci	r25, 0xFD	; 253
    2d94:	b6 01       	movw	r22, r12
    2d96:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    2d9a:	0f 90       	pop	r0
    2d9c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2d9e:	80 91 f6 02 	lds	r24, 0x02F6
    2da2:	88 23       	and	r24, r24
    2da4:	49 f0       	breq	.+18     	; 0x2db8 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2da6:	e0 91 ec 02 	lds	r30, 0x02EC
    2daa:	f0 91 ed 02 	lds	r31, 0x02ED
    2dae:	86 89       	ldd	r24, Z+22	; 0x16
    2db0:	85 15       	cp	r24, r5
    2db2:	10 f4       	brcc	.+4      	; 0x2db8 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    2db4:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vPortYield>
    2db8:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2dba:	0f 90       	pop	r0
    2dbc:	0f 90       	pop	r0
    2dbe:	0f 90       	pop	r0
    2dc0:	0f 90       	pop	r0
    2dc2:	cf 91       	pop	r28
    2dc4:	df 91       	pop	r29
    2dc6:	1f 91       	pop	r17
    2dc8:	0f 91       	pop	r16
    2dca:	ff 90       	pop	r15
    2dcc:	ef 90       	pop	r14
    2dce:	df 90       	pop	r13
    2dd0:	cf 90       	pop	r12
    2dd2:	bf 90       	pop	r11
    2dd4:	af 90       	pop	r10
    2dd6:	9f 90       	pop	r9
    2dd8:	8f 90       	pop	r8
    2dda:	7f 90       	pop	r7
    2ddc:	6f 90       	pop	r6
    2dde:	5f 90       	pop	r5
    2de0:	3f 90       	pop	r3
    2de2:	2f 90       	pop	r2
    2de4:	08 95       	ret

00002de6 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2de6:	af 92       	push	r10
    2de8:	bf 92       	push	r11
    2dea:	cf 92       	push	r12
    2dec:	df 92       	push	r13
    2dee:	ef 92       	push	r14
    2df0:	ff 92       	push	r15
    2df2:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    2df4:	8f e8       	ldi	r24, 0x8F	; 143
    2df6:	95 e1       	ldi	r25, 0x15	; 21
    2df8:	64 e9       	ldi	r22, 0x94	; 148
    2dfa:	72 e0       	ldi	r23, 0x02	; 2
    2dfc:	45 e5       	ldi	r20, 0x55	; 85
    2dfe:	50 e0       	ldi	r21, 0x00	; 0
    2e00:	20 e0       	ldi	r18, 0x00	; 0
    2e02:	30 e0       	ldi	r19, 0x00	; 0
    2e04:	00 e0       	ldi	r16, 0x00	; 0
    2e06:	ee 24       	eor	r14, r14
    2e08:	ff 24       	eor	r15, r15
    2e0a:	cc 24       	eor	r12, r12
    2e0c:	dd 24       	eor	r13, r13
    2e0e:	aa 24       	eor	r10, r10
    2e10:	bb 24       	eor	r11, r11
    2e12:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <xTaskGenericCreate>

	if( xReturn == pdPASS )
    2e16:	81 30       	cpi	r24, 0x01	; 1
    2e18:	49 f4       	brne	.+18     	; 0x2e2c <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2e1a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2e1c:	80 93 f6 02 	sts	0x02F6, r24
		xTickCount = ( portTickType ) 0;
    2e20:	10 92 f1 02 	sts	0x02F1, r1
    2e24:	10 92 f0 02 	sts	0x02F0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    2e28:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    2e2c:	0f 91       	pop	r16
    2e2e:	ff 90       	pop	r15
    2e30:	ef 90       	pop	r14
    2e32:	df 90       	pop	r13
    2e34:	cf 90       	pop	r12
    2e36:	bf 90       	pop	r11
    2e38:	af 90       	pop	r10
    2e3a:	08 95       	ret

00002e3c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2e3c:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2e3e:	91 e1       	ldi	r25, 0x11	; 17
    2e40:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2e42:	22 e2       	ldi	r18, 0x22	; 34
    2e44:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2e46:	83 e3       	ldi	r24, 0x33	; 51
    2e48:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2e4a:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2e4c:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2e4e:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2e50:	80 e8       	ldi	r24, 0x80	; 128
    2e52:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2e54:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2e56:	82 e0       	ldi	r24, 0x02	; 2
    2e58:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2e5a:	83 e0       	ldi	r24, 0x03	; 3
    2e5c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2e5e:	84 e0       	ldi	r24, 0x04	; 4
    2e60:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2e62:	85 e0       	ldi	r24, 0x05	; 5
    2e64:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2e66:	86 e0       	ldi	r24, 0x06	; 6
    2e68:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2e6a:	87 e0       	ldi	r24, 0x07	; 7
    2e6c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2e6e:	88 e0       	ldi	r24, 0x08	; 8
    2e70:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2e72:	89 e0       	ldi	r24, 0x09	; 9
    2e74:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2e76:	80 e1       	ldi	r24, 0x10	; 16
    2e78:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2e7a:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2e7c:	82 e1       	ldi	r24, 0x12	; 18
    2e7e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2e80:	83 e1       	ldi	r24, 0x13	; 19
    2e82:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2e84:	84 e1       	ldi	r24, 0x14	; 20
    2e86:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2e88:	85 e1       	ldi	r24, 0x15	; 21
    2e8a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2e8c:	86 e1       	ldi	r24, 0x16	; 22
    2e8e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2e90:	87 e1       	ldi	r24, 0x17	; 23
    2e92:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2e94:	88 e1       	ldi	r24, 0x18	; 24
    2e96:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2e98:	89 e1       	ldi	r24, 0x19	; 25
    2e9a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2e9c:	80 e2       	ldi	r24, 0x20	; 32
    2e9e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2ea0:	81 e2       	ldi	r24, 0x21	; 33
    2ea2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2ea4:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2ea6:	83 e2       	ldi	r24, 0x23	; 35
    2ea8:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2eaa:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2eac:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2eae:	86 e2       	ldi	r24, 0x26	; 38
    2eb0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2eb2:	87 e2       	ldi	r24, 0x27	; 39
    2eb4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2eb6:	88 e2       	ldi	r24, 0x28	; 40
    2eb8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2eba:	89 e2       	ldi	r24, 0x29	; 41
    2ebc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2ebe:	80 e3       	ldi	r24, 0x30	; 48
    2ec0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2ec2:	81 e3       	ldi	r24, 0x31	; 49
    2ec4:	82 93       	st	-Z, r24
    2ec6:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2ec8:	cf 01       	movw	r24, r30
    2eca:	08 95       	ret

00002ecc <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    2ecc:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2ed0:	89 ef       	ldi	r24, 0xF9	; 249
    2ed2:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2ed6:	8b e0       	ldi	r24, 0x0B	; 11
    2ed8:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2edc:	ef e6       	ldi	r30, 0x6F	; 111
    2ede:	f0 e0       	ldi	r31, 0x00	; 0
    2ee0:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2ee2:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2ee4:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2ee6:	a0 91 ec 02 	lds	r26, 0x02EC
    2eea:	b0 91 ed 02 	lds	r27, 0x02ED
    2eee:	cd 91       	ld	r28, X+
    2ef0:	cd bf       	out	0x3d, r28	; 61
    2ef2:	dd 91       	ld	r29, X+
    2ef4:	de bf       	out	0x3e, r29	; 62
    2ef6:	ff 91       	pop	r31
    2ef8:	ef 91       	pop	r30
    2efa:	df 91       	pop	r29
    2efc:	cf 91       	pop	r28
    2efe:	bf 91       	pop	r27
    2f00:	af 91       	pop	r26
    2f02:	9f 91       	pop	r25
    2f04:	8f 91       	pop	r24
    2f06:	7f 91       	pop	r23
    2f08:	6f 91       	pop	r22
    2f0a:	5f 91       	pop	r21
    2f0c:	4f 91       	pop	r20
    2f0e:	3f 91       	pop	r19
    2f10:	2f 91       	pop	r18
    2f12:	1f 91       	pop	r17
    2f14:	0f 91       	pop	r16
    2f16:	ff 90       	pop	r15
    2f18:	ef 90       	pop	r14
    2f1a:	df 90       	pop	r13
    2f1c:	cf 90       	pop	r12
    2f1e:	bf 90       	pop	r11
    2f20:	af 90       	pop	r10
    2f22:	9f 90       	pop	r9
    2f24:	8f 90       	pop	r8
    2f26:	7f 90       	pop	r7
    2f28:	6f 90       	pop	r6
    2f2a:	5f 90       	pop	r5
    2f2c:	4f 90       	pop	r4
    2f2e:	3f 90       	pop	r3
    2f30:	2f 90       	pop	r2
    2f32:	1f 90       	pop	r1
    2f34:	0f 90       	pop	r0
    2f36:	0f be       	out	0x3f, r0	; 63
    2f38:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2f3a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2f3c:	81 e0       	ldi	r24, 0x01	; 1
    2f3e:	08 95       	ret

00002f40 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2f40:	08 95       	ret

00002f42 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2f42:	0f 92       	push	r0
    2f44:	0f b6       	in	r0, 0x3f	; 63
    2f46:	f8 94       	cli
    2f48:	0f 92       	push	r0
    2f4a:	1f 92       	push	r1
    2f4c:	11 24       	eor	r1, r1
    2f4e:	2f 92       	push	r2
    2f50:	3f 92       	push	r3
    2f52:	4f 92       	push	r4
    2f54:	5f 92       	push	r5
    2f56:	6f 92       	push	r6
    2f58:	7f 92       	push	r7
    2f5a:	8f 92       	push	r8
    2f5c:	9f 92       	push	r9
    2f5e:	af 92       	push	r10
    2f60:	bf 92       	push	r11
    2f62:	cf 92       	push	r12
    2f64:	df 92       	push	r13
    2f66:	ef 92       	push	r14
    2f68:	ff 92       	push	r15
    2f6a:	0f 93       	push	r16
    2f6c:	1f 93       	push	r17
    2f6e:	2f 93       	push	r18
    2f70:	3f 93       	push	r19
    2f72:	4f 93       	push	r20
    2f74:	5f 93       	push	r21
    2f76:	6f 93       	push	r22
    2f78:	7f 93       	push	r23
    2f7a:	8f 93       	push	r24
    2f7c:	9f 93       	push	r25
    2f7e:	af 93       	push	r26
    2f80:	bf 93       	push	r27
    2f82:	cf 93       	push	r28
    2f84:	df 93       	push	r29
    2f86:	ef 93       	push	r30
    2f88:	ff 93       	push	r31
    2f8a:	a0 91 ec 02 	lds	r26, 0x02EC
    2f8e:	b0 91 ed 02 	lds	r27, 0x02ED
    2f92:	0d b6       	in	r0, 0x3d	; 61
    2f94:	0d 92       	st	X+, r0
    2f96:	0e b6       	in	r0, 0x3e	; 62
    2f98:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2f9a:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <vTaskIncrementTick>
	vTaskSwitchContext();
    2f9e:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2fa2:	a0 91 ec 02 	lds	r26, 0x02EC
    2fa6:	b0 91 ed 02 	lds	r27, 0x02ED
    2faa:	cd 91       	ld	r28, X+
    2fac:	cd bf       	out	0x3d, r28	; 61
    2fae:	dd 91       	ld	r29, X+
    2fb0:	de bf       	out	0x3e, r29	; 62
    2fb2:	ff 91       	pop	r31
    2fb4:	ef 91       	pop	r30
    2fb6:	df 91       	pop	r29
    2fb8:	cf 91       	pop	r28
    2fba:	bf 91       	pop	r27
    2fbc:	af 91       	pop	r26
    2fbe:	9f 91       	pop	r25
    2fc0:	8f 91       	pop	r24
    2fc2:	7f 91       	pop	r23
    2fc4:	6f 91       	pop	r22
    2fc6:	5f 91       	pop	r21
    2fc8:	4f 91       	pop	r20
    2fca:	3f 91       	pop	r19
    2fcc:	2f 91       	pop	r18
    2fce:	1f 91       	pop	r17
    2fd0:	0f 91       	pop	r16
    2fd2:	ff 90       	pop	r15
    2fd4:	ef 90       	pop	r14
    2fd6:	df 90       	pop	r13
    2fd8:	cf 90       	pop	r12
    2fda:	bf 90       	pop	r11
    2fdc:	af 90       	pop	r10
    2fde:	9f 90       	pop	r9
    2fe0:	8f 90       	pop	r8
    2fe2:	7f 90       	pop	r7
    2fe4:	6f 90       	pop	r6
    2fe6:	5f 90       	pop	r5
    2fe8:	4f 90       	pop	r4
    2fea:	3f 90       	pop	r3
    2fec:	2f 90       	pop	r2
    2fee:	1f 90       	pop	r1
    2ff0:	0f 90       	pop	r0
    2ff2:	0f be       	out	0x3f, r0	; 63
    2ff4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ff6:	08 95       	ret

00002ff8 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2ff8:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2ffc:	18 95       	reti

00002ffe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2ffe:	0f 92       	push	r0
    3000:	0f b6       	in	r0, 0x3f	; 63
    3002:	f8 94       	cli
    3004:	0f 92       	push	r0
    3006:	1f 92       	push	r1
    3008:	11 24       	eor	r1, r1
    300a:	2f 92       	push	r2
    300c:	3f 92       	push	r3
    300e:	4f 92       	push	r4
    3010:	5f 92       	push	r5
    3012:	6f 92       	push	r6
    3014:	7f 92       	push	r7
    3016:	8f 92       	push	r8
    3018:	9f 92       	push	r9
    301a:	af 92       	push	r10
    301c:	bf 92       	push	r11
    301e:	cf 92       	push	r12
    3020:	df 92       	push	r13
    3022:	ef 92       	push	r14
    3024:	ff 92       	push	r15
    3026:	0f 93       	push	r16
    3028:	1f 93       	push	r17
    302a:	2f 93       	push	r18
    302c:	3f 93       	push	r19
    302e:	4f 93       	push	r20
    3030:	5f 93       	push	r21
    3032:	6f 93       	push	r22
    3034:	7f 93       	push	r23
    3036:	8f 93       	push	r24
    3038:	9f 93       	push	r25
    303a:	af 93       	push	r26
    303c:	bf 93       	push	r27
    303e:	cf 93       	push	r28
    3040:	df 93       	push	r29
    3042:	ef 93       	push	r30
    3044:	ff 93       	push	r31
    3046:	a0 91 ec 02 	lds	r26, 0x02EC
    304a:	b0 91 ed 02 	lds	r27, 0x02ED
    304e:	0d b6       	in	r0, 0x3d	; 61
    3050:	0d 92       	st	X+, r0
    3052:	0e b6       	in	r0, 0x3e	; 62
    3054:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3056:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    305a:	a0 91 ec 02 	lds	r26, 0x02EC
    305e:	b0 91 ed 02 	lds	r27, 0x02ED
    3062:	cd 91       	ld	r28, X+
    3064:	cd bf       	out	0x3d, r28	; 61
    3066:	dd 91       	ld	r29, X+
    3068:	de bf       	out	0x3e, r29	; 62
    306a:	ff 91       	pop	r31
    306c:	ef 91       	pop	r30
    306e:	df 91       	pop	r29
    3070:	cf 91       	pop	r28
    3072:	bf 91       	pop	r27
    3074:	af 91       	pop	r26
    3076:	9f 91       	pop	r25
    3078:	8f 91       	pop	r24
    307a:	7f 91       	pop	r23
    307c:	6f 91       	pop	r22
    307e:	5f 91       	pop	r21
    3080:	4f 91       	pop	r20
    3082:	3f 91       	pop	r19
    3084:	2f 91       	pop	r18
    3086:	1f 91       	pop	r17
    3088:	0f 91       	pop	r16
    308a:	ff 90       	pop	r15
    308c:	ef 90       	pop	r14
    308e:	df 90       	pop	r13
    3090:	cf 90       	pop	r12
    3092:	bf 90       	pop	r11
    3094:	af 90       	pop	r10
    3096:	9f 90       	pop	r9
    3098:	8f 90       	pop	r8
    309a:	7f 90       	pop	r7
    309c:	6f 90       	pop	r6
    309e:	5f 90       	pop	r5
    30a0:	4f 90       	pop	r4
    30a2:	3f 90       	pop	r3
    30a4:	2f 90       	pop	r2
    30a6:	1f 90       	pop	r1
    30a8:	0f 90       	pop	r0
    30aa:	0f be       	out	0x3f, r0	; 63
    30ac:	0f 90       	pop	r0

	asm volatile ( "ret" );
    30ae:	08 95       	ret

000030b0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    30b0:	0f 93       	push	r16
    30b2:	1f 93       	push	r17
    30b4:	cf 93       	push	r28
    30b6:	df 93       	push	r29
    30b8:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    30ba:	80 81       	ld	r24, Z
    30bc:	88 23       	and	r24, r24
    30be:	19 f4       	brne	.+6      	; 0x30c6 <xCoRoutineRemoveFromEventList+0x16>
    30c0:	c0 e0       	ldi	r28, 0x00	; 0
    30c2:	d0 e0       	ldi	r29, 0x00	; 0
    30c4:	05 c0       	rjmp	.+10     	; 0x30d0 <xCoRoutineRemoveFromEventList+0x20>
    30c6:	05 80       	ldd	r0, Z+5	; 0x05
    30c8:	f6 81       	ldd	r31, Z+6	; 0x06
    30ca:	e0 2d       	mov	r30, r0
    30cc:	c6 81       	ldd	r28, Z+6	; 0x06
    30ce:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    30d0:	8e 01       	movw	r16, r28
    30d2:	04 5f       	subi	r16, 0xF4	; 244
    30d4:	1f 4f       	sbci	r17, 0xFF	; 255
    30d6:	c8 01       	movw	r24, r16
    30d8:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    30dc:	87 e7       	ldi	r24, 0x77	; 119
    30de:	93 e0       	ldi	r25, 0x03	; 3
    30e0:	b8 01       	movw	r22, r16
    30e2:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>
    30e6:	20 e0       	ldi	r18, 0x00	; 0
    30e8:	e0 91 46 03 	lds	r30, 0x0346
    30ec:	f0 91 47 03 	lds	r31, 0x0347
    30f0:	9e 89       	ldd	r25, Y+22	; 0x16
    30f2:	86 89       	ldd	r24, Z+22	; 0x16
    30f4:	98 17       	cp	r25, r24
    30f6:	08 f0       	brcs	.+2      	; 0x30fa <xCoRoutineRemoveFromEventList+0x4a>
    30f8:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    30fa:	82 2f       	mov	r24, r18
    30fc:	df 91       	pop	r29
    30fe:	cf 91       	pop	r28
    3100:	1f 91       	pop	r17
    3102:	0f 91       	pop	r16
    3104:	08 95       	ret

00003106 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    3106:	ff 92       	push	r15
    3108:	0f 93       	push	r16
    310a:	1f 93       	push	r17
    310c:	cf 93       	push	r28
    310e:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    3110:	99 e0       	ldi	r25, 0x09	; 9
    3112:	f9 2e       	mov	r15, r25
    3114:	28 c0       	rjmp	.+80     	; 0x3166 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    3116:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    3118:	80 91 77 03 	lds	r24, 0x0377
    311c:	88 23       	and	r24, r24
    311e:	19 f4       	brne	.+6      	; 0x3126 <vCoRoutineSchedule+0x20>
    3120:	c0 e0       	ldi	r28, 0x00	; 0
    3122:	d0 e0       	ldi	r29, 0x00	; 0
    3124:	06 c0       	rjmp	.+12     	; 0x3132 <vCoRoutineSchedule+0x2c>
    3126:	e0 91 7c 03 	lds	r30, 0x037C
    312a:	f0 91 7d 03 	lds	r31, 0x037D
    312e:	c6 81       	ldd	r28, Z+6	; 0x06
    3130:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3132:	ce 01       	movw	r24, r28
    3134:	0c 96       	adiw	r24, 0x0c	; 12
    3136:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
		}
		portENABLE_INTERRUPTS();
    313a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    313c:	8e 01       	movw	r16, r28
    313e:	0e 5f       	subi	r16, 0xFE	; 254
    3140:	1f 4f       	sbci	r17, 0xFF	; 255
    3142:	c8 01       	movw	r24, r16
    3144:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    3148:	9e 89       	ldd	r25, Y+22	; 0x16
    314a:	80 91 48 03 	lds	r24, 0x0348
    314e:	89 17       	cp	r24, r25
    3150:	10 f4       	brcc	.+4      	; 0x3156 <vCoRoutineSchedule+0x50>
    3152:	90 93 48 03 	sts	0x0348, r25
    3156:	9f 9d       	mul	r25, r15
    3158:	c0 01       	movw	r24, r0
    315a:	11 24       	eor	r1, r1
    315c:	81 5b       	subi	r24, 0xB1	; 177
    315e:	9c 4f       	sbci	r25, 0xFC	; 252
    3160:	b8 01       	movw	r22, r16
    3162:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    3166:	80 91 77 03 	lds	r24, 0x0377
    316a:	88 23       	and	r24, r24
    316c:	a1 f6       	brne	.-88     	; 0x3116 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    316e:	0e 94 98 12 	call	0x2530	; 0x2530 <xTaskGetTickCount>
    3172:	20 91 49 03 	lds	r18, 0x0349
    3176:	30 91 4a 03 	lds	r19, 0x034A
    317a:	82 1b       	sub	r24, r18
    317c:	93 0b       	sbc	r25, r19
    317e:	90 93 4c 03 	sts	0x034C, r25
    3182:	80 93 4b 03 	sts	0x034B, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    3186:	89 e0       	ldi	r24, 0x09	; 9
    3188:	f8 2e       	mov	r15, r24
    318a:	54 c0       	rjmp	.+168    	; 0x3234 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    318c:	01 96       	adiw	r24, 0x01	; 1
    318e:	90 93 4e 03 	sts	0x034E, r25
    3192:	80 93 4d 03 	sts	0x034D, r24
		xPassedTicks--;
    3196:	21 50       	subi	r18, 0x01	; 1
    3198:	30 40       	sbci	r19, 0x00	; 0
    319a:	30 93 4c 03 	sts	0x034C, r19
    319e:	20 93 4b 03 	sts	0x034B, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    31a2:	89 2b       	or	r24, r25
    31a4:	c9 f5       	brne	.+114    	; 0x3218 <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    31a6:	20 91 73 03 	lds	r18, 0x0373
    31aa:	30 91 74 03 	lds	r19, 0x0374
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    31ae:	80 91 75 03 	lds	r24, 0x0375
    31b2:	90 91 76 03 	lds	r25, 0x0376
    31b6:	90 93 74 03 	sts	0x0374, r25
    31ba:	80 93 73 03 	sts	0x0373, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    31be:	30 93 76 03 	sts	0x0376, r19
    31c2:	20 93 75 03 	sts	0x0375, r18
    31c6:	28 c0       	rjmp	.+80     	; 0x3218 <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    31c8:	20 91 4d 03 	lds	r18, 0x034D
    31cc:	30 91 4e 03 	lds	r19, 0x034E
    31d0:	8a 81       	ldd	r24, Y+2	; 0x02
    31d2:	9b 81       	ldd	r25, Y+3	; 0x03
    31d4:	28 17       	cp	r18, r24
    31d6:	39 07       	cpc	r19, r25
    31d8:	68 f1       	brcs	.+90     	; 0x3234 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    31da:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    31dc:	8e 01       	movw	r16, r28
    31de:	0e 5f       	subi	r16, 0xFE	; 254
    31e0:	1f 4f       	sbci	r17, 0xFF	; 255
    31e2:	c8 01       	movw	r24, r16
    31e4:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    31e8:	8c 89       	ldd	r24, Y+20	; 0x14
    31ea:	9d 89       	ldd	r25, Y+21	; 0x15
    31ec:	89 2b       	or	r24, r25
    31ee:	21 f0       	breq	.+8      	; 0x31f8 <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    31f0:	ce 01       	movw	r24, r28
    31f2:	0c 96       	adiw	r24, 0x0c	; 12
    31f4:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    31f8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    31fa:	9e 89       	ldd	r25, Y+22	; 0x16
    31fc:	80 91 48 03 	lds	r24, 0x0348
    3200:	89 17       	cp	r24, r25
    3202:	10 f4       	brcc	.+4      	; 0x3208 <vCoRoutineSchedule+0x102>
    3204:	90 93 48 03 	sts	0x0348, r25
    3208:	9f 9d       	mul	r25, r15
    320a:	c0 01       	movw	r24, r0
    320c:	11 24       	eor	r1, r1
    320e:	81 5b       	subi	r24, 0xB1	; 177
    3210:	9c 4f       	sbci	r25, 0xFC	; 252
    3212:	b8 01       	movw	r22, r16
    3214:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    3218:	e0 91 73 03 	lds	r30, 0x0373
    321c:	f0 91 74 03 	lds	r31, 0x0374
    3220:	80 81       	ld	r24, Z
    3222:	88 23       	and	r24, r24
    3224:	39 f0       	breq	.+14     	; 0x3234 <vCoRoutineSchedule+0x12e>
    3226:	05 80       	ldd	r0, Z+5	; 0x05
    3228:	f6 81       	ldd	r31, Z+6	; 0x06
    322a:	e0 2d       	mov	r30, r0
    322c:	c6 81       	ldd	r28, Z+6	; 0x06
    322e:	d7 81       	ldd	r29, Z+7	; 0x07
    3230:	20 97       	sbiw	r28, 0x00	; 0
    3232:	51 f6       	brne	.-108    	; 0x31c8 <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    3234:	20 91 4b 03 	lds	r18, 0x034B
    3238:	30 91 4c 03 	lds	r19, 0x034C
    323c:	80 91 4d 03 	lds	r24, 0x034D
    3240:	90 91 4e 03 	lds	r25, 0x034E
    3244:	21 15       	cp	r18, r1
    3246:	31 05       	cpc	r19, r1
    3248:	09 f0       	breq	.+2      	; 0x324c <vCoRoutineSchedule+0x146>
    324a:	a0 cf       	rjmp	.-192    	; 0x318c <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    324c:	90 93 4a 03 	sts	0x034A, r25
    3250:	80 93 49 03 	sts	0x0349, r24
    3254:	90 91 48 03 	lds	r25, 0x0348

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3258:	29 e0       	ldi	r18, 0x09	; 9
    325a:	06 c0       	rjmp	.+12     	; 0x3268 <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    325c:	99 23       	and	r25, r25
    325e:	19 f4       	brne	.+6      	; 0x3266 <vCoRoutineSchedule+0x160>
    3260:	10 92 48 03 	sts	0x0348, r1
    3264:	32 c0       	rjmp	.+100    	; 0x32ca <vCoRoutineSchedule+0x1c4>
    3266:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    3268:	92 9f       	mul	r25, r18
    326a:	d0 01       	movw	r26, r0
    326c:	11 24       	eor	r1, r1
    326e:	a1 5b       	subi	r26, 0xB1	; 177
    3270:	bc 4f       	sbci	r27, 0xFC	; 252
    3272:	8c 91       	ld	r24, X
    3274:	88 23       	and	r24, r24
    3276:	91 f3       	breq	.-28     	; 0x325c <vCoRoutineSchedule+0x156>
    3278:	90 93 48 03 	sts	0x0348, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    327c:	11 96       	adiw	r26, 0x01	; 1
    327e:	ed 91       	ld	r30, X+
    3280:	fc 91       	ld	r31, X
    3282:	12 97       	sbiw	r26, 0x02	; 2
    3284:	02 80       	ldd	r0, Z+2	; 0x02
    3286:	f3 81       	ldd	r31, Z+3	; 0x03
    3288:	e0 2d       	mov	r30, r0
    328a:	12 96       	adiw	r26, 0x02	; 2
    328c:	fc 93       	st	X, r31
    328e:	ee 93       	st	-X, r30
    3290:	11 97       	sbiw	r26, 0x01	; 1
    3292:	cd 01       	movw	r24, r26
    3294:	03 96       	adiw	r24, 0x03	; 3
    3296:	e8 17       	cp	r30, r24
    3298:	f9 07       	cpc	r31, r25
    329a:	31 f4       	brne	.+12     	; 0x32a8 <vCoRoutineSchedule+0x1a2>
    329c:	82 81       	ldd	r24, Z+2	; 0x02
    329e:	93 81       	ldd	r25, Z+3	; 0x03
    32a0:	12 96       	adiw	r26, 0x02	; 2
    32a2:	9c 93       	st	X, r25
    32a4:	8e 93       	st	-X, r24
    32a6:	11 97       	sbiw	r26, 0x01	; 1
    32a8:	11 96       	adiw	r26, 0x01	; 1
    32aa:	ed 91       	ld	r30, X+
    32ac:	fc 91       	ld	r31, X
    32ae:	12 97       	sbiw	r26, 0x02	; 2
    32b0:	06 80       	ldd	r0, Z+6	; 0x06
    32b2:	f7 81       	ldd	r31, Z+7	; 0x07
    32b4:	e0 2d       	mov	r30, r0
    32b6:	f0 93 47 03 	sts	0x0347, r31
    32ba:	e0 93 46 03 	sts	0x0346, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    32be:	20 81       	ld	r18, Z
    32c0:	31 81       	ldd	r19, Z+1	; 0x01
    32c2:	cf 01       	movw	r24, r30
    32c4:	67 89       	ldd	r22, Z+23	; 0x17
    32c6:	f9 01       	movw	r30, r18
    32c8:	09 95       	icall

	return;
}
    32ca:	df 91       	pop	r29
    32cc:	cf 91       	pop	r28
    32ce:	1f 91       	pop	r17
    32d0:	0f 91       	pop	r16
    32d2:	ff 90       	pop	r15
    32d4:	08 95       	ret

000032d6 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    32d6:	0f 93       	push	r16
    32d8:	1f 93       	push	r17
    32da:	cf 93       	push	r28
    32dc:	df 93       	push	r29
    32de:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    32e0:	00 91 4d 03 	lds	r16, 0x034D
    32e4:	10 91 4e 03 	lds	r17, 0x034E
    32e8:	08 0f       	add	r16, r24
    32ea:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    32ec:	80 91 46 03 	lds	r24, 0x0346
    32f0:	90 91 47 03 	lds	r25, 0x0347
    32f4:	02 96       	adiw	r24, 0x02	; 2
    32f6:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    32fa:	e0 91 46 03 	lds	r30, 0x0346
    32fe:	f0 91 47 03 	lds	r31, 0x0347
    3302:	13 83       	std	Z+3, r17	; 0x03
    3304:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    3306:	80 91 4d 03 	lds	r24, 0x034D
    330a:	90 91 4e 03 	lds	r25, 0x034E
    330e:	bf 01       	movw	r22, r30
    3310:	6e 5f       	subi	r22, 0xFE	; 254
    3312:	7f 4f       	sbci	r23, 0xFF	; 255
    3314:	08 17       	cp	r16, r24
    3316:	19 07       	cpc	r17, r25
    3318:	28 f4       	brcc	.+10     	; 0x3324 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    331a:	80 91 75 03 	lds	r24, 0x0375
    331e:	90 91 76 03 	lds	r25, 0x0376
    3322:	04 c0       	rjmp	.+8      	; 0x332c <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3324:	80 91 73 03 	lds	r24, 0x0373
    3328:	90 91 74 03 	lds	r25, 0x0374
    332c:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vListInsert>
	}

	if( pxEventList )
    3330:	20 97       	sbiw	r28, 0x00	; 0
    3332:	49 f0       	breq	.+18     	; 0x3346 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    3334:	60 91 46 03 	lds	r22, 0x0346
    3338:	70 91 47 03 	lds	r23, 0x0347
    333c:	64 5f       	subi	r22, 0xF4	; 244
    333e:	7f 4f       	sbci	r23, 0xFF	; 255
    3340:	ce 01       	movw	r24, r28
    3342:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vListInsert>
	}
}
    3346:	df 91       	pop	r29
    3348:	cf 91       	pop	r28
    334a:	1f 91       	pop	r17
    334c:	0f 91       	pop	r16
    334e:	08 95       	ret

00003350 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    3350:	af 92       	push	r10
    3352:	bf 92       	push	r11
    3354:	cf 92       	push	r12
    3356:	df 92       	push	r13
    3358:	ef 92       	push	r14
    335a:	ff 92       	push	r15
    335c:	0f 93       	push	r16
    335e:	1f 93       	push	r17
    3360:	cf 93       	push	r28
    3362:	df 93       	push	r29
    3364:	6c 01       	movw	r12, r24
    3366:	b6 2e       	mov	r11, r22
    3368:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    336a:	8a e1       	ldi	r24, 0x1A	; 26
    336c:	90 e0       	ldi	r25, 0x00	; 0
    336e:	0e 94 32 1a 	call	0x3464	; 0x3464 <pvPortMalloc>
    3372:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    3374:	00 97       	sbiw	r24, 0x00	; 0
    3376:	11 f4       	brne	.+4      	; 0x337c <xCoRoutineCreate+0x2c>
    3378:	8f ef       	ldi	r24, 0xFF	; 255
    337a:	59 c0       	rjmp	.+178    	; 0x342e <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    337c:	80 91 46 03 	lds	r24, 0x0346
    3380:	90 91 47 03 	lds	r25, 0x0347
    3384:	89 2b       	or	r24, r25
    3386:	21 f5       	brne	.+72     	; 0x33d0 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    3388:	d0 93 47 03 	sts	0x0347, r29
    338c:	c0 93 46 03 	sts	0x0346, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    3390:	8f e4       	ldi	r24, 0x4F	; 79
    3392:	93 e0       	ldi	r25, 0x03	; 3
    3394:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
    3398:	88 e5       	ldi	r24, 0x58	; 88
    339a:	93 e0       	ldi	r25, 0x03	; 3
    339c:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    33a0:	21 e6       	ldi	r18, 0x61	; 97
    33a2:	e2 2e       	mov	r14, r18
    33a4:	23 e0       	ldi	r18, 0x03	; 3
    33a6:	f2 2e       	mov	r15, r18
    33a8:	c7 01       	movw	r24, r14
    33aa:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    33ae:	0a e6       	ldi	r16, 0x6A	; 106
    33b0:	13 e0       	ldi	r17, 0x03	; 3
    33b2:	c8 01       	movw	r24, r16
    33b4:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    33b8:	87 e7       	ldi	r24, 0x77	; 119
    33ba:	93 e0       	ldi	r25, 0x03	; 3
    33bc:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    33c0:	f0 92 74 03 	sts	0x0374, r15
    33c4:	e0 92 73 03 	sts	0x0373, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    33c8:	10 93 76 03 	sts	0x0376, r17
    33cc:	00 93 75 03 	sts	0x0375, r16
    33d0:	eb 2c       	mov	r14, r11
    33d2:	bb 20       	and	r11, r11
    33d4:	11 f0       	breq	.+4      	; 0x33da <xCoRoutineCreate+0x8a>
    33d6:	ee 24       	eor	r14, r14
    33d8:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    33da:	19 8e       	std	Y+25, r1	; 0x19
    33dc:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    33de:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    33e0:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    33e2:	fe 01       	movw	r30, r28
    33e4:	c1 92       	st	Z+, r12
    33e6:	d1 92       	st	Z+, r13
    33e8:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    33ea:	cf 01       	movw	r24, r30
    33ec:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    33f0:	ce 01       	movw	r24, r28
    33f2:	0c 96       	adiw	r24, 0x0c	; 12
    33f4:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    33f8:	d9 87       	std	Y+9, r29	; 0x09
    33fa:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    33fc:	db 8b       	std	Y+19, r29	; 0x13
    33fe:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3400:	84 e0       	ldi	r24, 0x04	; 4
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	8e 19       	sub	r24, r14
    3406:	91 09       	sbc	r25, r1
    3408:	9d 87       	std	Y+13, r25	; 0x0d
    340a:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    340c:	9e 89       	ldd	r25, Y+22	; 0x16
    340e:	80 91 48 03 	lds	r24, 0x0348
    3412:	89 17       	cp	r24, r25
    3414:	10 f4       	brcc	.+4      	; 0x341a <xCoRoutineCreate+0xca>
    3416:	90 93 48 03 	sts	0x0348, r25
    341a:	89 e0       	ldi	r24, 0x09	; 9
    341c:	98 9f       	mul	r25, r24
    341e:	c0 01       	movw	r24, r0
    3420:	11 24       	eor	r1, r1
    3422:	81 5b       	subi	r24, 0xB1	; 177
    3424:	9c 4f       	sbci	r25, 0xFC	; 252
    3426:	b8 01       	movw	r22, r16
    3428:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <vListInsertEnd>
    342c:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    342e:	df 91       	pop	r29
    3430:	cf 91       	pop	r28
    3432:	1f 91       	pop	r17
    3434:	0f 91       	pop	r16
    3436:	ff 90       	pop	r15
    3438:	ef 90       	pop	r14
    343a:	df 90       	pop	r13
    343c:	cf 90       	pop	r12
    343e:	bf 90       	pop	r11
    3440:	af 90       	pop	r10
    3442:	08 95       	ret

00003444 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    3444:	08 95       	ret

00003446 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    3446:	10 92 81 03 	sts	0x0381, r1
    344a:	10 92 80 03 	sts	0x0380, r1
}
    344e:	08 95       	ret

00003450 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    3450:	28 eb       	ldi	r18, 0xB8	; 184
    3452:	3b e0       	ldi	r19, 0x0B	; 11
    3454:	80 91 80 03 	lds	r24, 0x0380
    3458:	90 91 81 03 	lds	r25, 0x0381
    345c:	28 1b       	sub	r18, r24
    345e:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    3460:	c9 01       	movw	r24, r18
    3462:	08 95       	ret

00003464 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3464:	0f 93       	push	r16
    3466:	1f 93       	push	r17
    3468:	cf 93       	push	r28
    346a:	df 93       	push	r29
    346c:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    346e:	0e 94 92 12 	call	0x2524	; 0x2524 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3472:	80 91 80 03 	lds	r24, 0x0380
    3476:	90 91 81 03 	lds	r25, 0x0381
    347a:	98 01       	movw	r18, r16
    347c:	28 0f       	add	r18, r24
    347e:	39 1f       	adc	r19, r25
    3480:	4b e0       	ldi	r20, 0x0B	; 11
    3482:	28 3b       	cpi	r18, 0xB8	; 184
    3484:	34 07       	cpc	r19, r20
    3486:	58 f4       	brcc	.+22     	; 0x349e <pvPortMalloc+0x3a>
    3488:	82 17       	cp	r24, r18
    348a:	93 07       	cpc	r25, r19
    348c:	40 f4       	brcc	.+16     	; 0x349e <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    348e:	ec 01       	movw	r28, r24
    3490:	ce 57       	subi	r28, 0x7E	; 126
    3492:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    3494:	30 93 81 03 	sts	0x0381, r19
    3498:	20 93 80 03 	sts	0x0380, r18
    349c:	02 c0       	rjmp	.+4      	; 0x34a2 <pvPortMalloc+0x3e>
    349e:	c0 e0       	ldi	r28, 0x00	; 0
    34a0:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    34a2:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    34a6:	ce 01       	movw	r24, r28
    34a8:	df 91       	pop	r29
    34aa:	cf 91       	pop	r28
    34ac:	1f 91       	pop	r17
    34ae:	0f 91       	pop	r16
    34b0:	08 95       	ret

000034b2 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    34b2:	e8 2f       	mov	r30, r24
    34b4:	f0 e0       	ldi	r31, 0x00	; 0
    34b6:	e7 70       	andi	r30, 0x07	; 7
    34b8:	f0 70       	andi	r31, 0x00	; 0
    34ba:	ee 0f       	add	r30, r30
    34bc:	ff 1f       	adc	r31, r31
    34be:	e7 55       	subi	r30, 0x57	; 87
    34c0:	fe 4f       	sbci	r31, 0xFE	; 254
    34c2:	25 91       	lpm	r18, Z+
    34c4:	34 91       	lpm	r19, Z+
}
    34c6:	c9 01       	movw	r24, r18
    34c8:	08 95       	ret

000034ca <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    34ca:	e8 2f       	mov	r30, r24
    34cc:	f0 e0       	ldi	r31, 0x00	; 0
    34ce:	e7 70       	andi	r30, 0x07	; 7
    34d0:	f0 70       	andi	r31, 0x00	; 0
    34d2:	ee 0f       	add	r30, r30
    34d4:	ff 1f       	adc	r31, r31
    34d6:	eb 54       	subi	r30, 0x4B	; 75
    34d8:	fe 4f       	sbci	r31, 0xFE	; 254
    34da:	25 91       	lpm	r18, Z+
    34dc:	34 91       	lpm	r19, Z+
}
    34de:	c9 01       	movw	r24, r18
    34e0:	08 95       	ret

000034e2 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    34e2:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    34e4:	e8 2f       	mov	r30, r24
    34e6:	f0 e0       	ldi	r31, 0x00	; 0
    34e8:	e7 70       	andi	r30, 0x07	; 7
    34ea:	f0 70       	andi	r31, 0x00	; 0
    34ec:	ee 0f       	add	r30, r30
    34ee:	ff 1f       	adc	r31, r31
    34f0:	e7 55       	subi	r30, 0x57	; 87
    34f2:	fe 4f       	sbci	r31, 0xFE	; 254
    34f4:	25 91       	lpm	r18, Z+
    34f6:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    34f8:	c9 01       	movw	r24, r18
    34fa:	08 95       	ret

000034fc <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    34fc:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3500:	e8 2f       	mov	r30, r24
    3502:	f0 e0       	ldi	r31, 0x00	; 0
    3504:	e7 70       	andi	r30, 0x07	; 7
    3506:	f0 70       	andi	r31, 0x00	; 0
    3508:	ee 0f       	add	r30, r30
    350a:	ff 1f       	adc	r31, r31
    350c:	e7 55       	subi	r30, 0x57	; 87
    350e:	fe 4f       	sbci	r31, 0xFE	; 254
    3510:	25 91       	lpm	r18, Z+
    3512:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    3514:	c9 01       	movw	r24, r18
    3516:	08 95       	ret

00003518 <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    3518:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    351c:	e8 2f       	mov	r30, r24
    351e:	f0 e0       	ldi	r31, 0x00	; 0
    3520:	e7 70       	andi	r30, 0x07	; 7
    3522:	f0 70       	andi	r31, 0x00	; 0
    3524:	ee 0f       	add	r30, r30
    3526:	ff 1f       	adc	r31, r31
    3528:	eb 54       	subi	r30, 0x4B	; 75
    352a:	fe 4f       	sbci	r31, 0xFE	; 254
    352c:	25 91       	lpm	r18, Z+
    352e:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    3530:	c9 01       	movw	r24, r18
    3532:	08 95       	ret

00003534 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    3534:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3538:	e8 2f       	mov	r30, r24
    353a:	f0 e0       	ldi	r31, 0x00	; 0
    353c:	e7 70       	andi	r30, 0x07	; 7
    353e:	f0 70       	andi	r31, 0x00	; 0
    3540:	ee 0f       	add	r30, r30
    3542:	ff 1f       	adc	r31, r31
    3544:	e7 55       	subi	r30, 0x57	; 87
    3546:	fe 4f       	sbci	r31, 0xFE	; 254
    3548:	25 91       	lpm	r18, Z+
    354a:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    354c:	c9 01       	movw	r24, r18
    354e:	08 95       	ret

00003550 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    3550:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3554:	e8 2f       	mov	r30, r24
    3556:	f0 e0       	ldi	r31, 0x00	; 0
    3558:	e7 70       	andi	r30, 0x07	; 7
    355a:	f0 70       	andi	r31, 0x00	; 0
    355c:	ee 0f       	add	r30, r30
    355e:	ff 1f       	adc	r31, r31
    3560:	e7 55       	subi	r30, 0x57	; 87
    3562:	fe 4f       	sbci	r31, 0xFE	; 254
    3564:	25 91       	lpm	r18, Z+
    3566:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    3568:	c9 01       	movw	r24, r18
    356a:	08 95       	ret

0000356c <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    356c:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    3570:	e8 2f       	mov	r30, r24
    3572:	f0 e0       	ldi	r31, 0x00	; 0
    3574:	e7 70       	andi	r30, 0x07	; 7
    3576:	f0 70       	andi	r31, 0x00	; 0
    3578:	ee 0f       	add	r30, r30
    357a:	ff 1f       	adc	r31, r31
    357c:	e7 55       	subi	r30, 0x57	; 87
    357e:	fe 4f       	sbci	r31, 0xFE	; 254
    3580:	25 91       	lpm	r18, Z+
    3582:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    3584:	c9 01       	movw	r24, r18
    3586:	08 95       	ret

00003588 <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    3588:	20 91 1e 12 	lds	r18, 0x121E
    358c:	30 91 1f 12 	lds	r19, 0x121F
    3590:	40 91 20 12 	lds	r20, 0x1220
    3594:	50 91 21 12 	lds	r21, 0x1221
}
    3598:	b9 01       	movw	r22, r18
    359a:	ca 01       	movw	r24, r20
    359c:	08 95       	ret

0000359e <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    359e:	20 91 1a 12 	lds	r18, 0x121A
    35a2:	30 91 1b 12 	lds	r19, 0x121B
    35a6:	40 91 1c 12 	lds	r20, 0x121C
    35aa:	50 91 1d 12 	lds	r21, 0x121D
}
    35ae:	b9 01       	movw	r22, r18
    35b0:	ca 01       	movw	r24, r20
    35b2:	08 95       	ret

000035b4 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    35b4:	20 91 22 12 	lds	r18, 0x1222
    35b8:	30 91 23 12 	lds	r19, 0x1223
    35bc:	40 91 24 12 	lds	r20, 0x1224
    35c0:	50 91 25 12 	lds	r21, 0x1225
}
    35c4:	b9 01       	movw	r22, r18
    35c6:	ca 01       	movw	r24, r20
    35c8:	08 95       	ret

000035ca <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    35ca:	20 91 2a 12 	lds	r18, 0x122A
    35ce:	30 91 2b 12 	lds	r19, 0x122B
    35d2:	40 91 2c 12 	lds	r20, 0x122C
    35d6:	50 91 2d 12 	lds	r21, 0x122D
}
    35da:	b9 01       	movw	r22, r18
    35dc:	ca 01       	movw	r24, r20
    35de:	08 95       	ret

000035e0 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    35e0:	20 91 16 12 	lds	r18, 0x1216
    35e4:	30 91 17 12 	lds	r19, 0x1217
    35e8:	40 91 18 12 	lds	r20, 0x1218
    35ec:	50 91 19 12 	lds	r21, 0x1219
}
    35f0:	b9 01       	movw	r22, r18
    35f2:	ca 01       	movw	r24, r20
    35f4:	08 95       	ret

000035f6 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    35f6:	20 91 2e 12 	lds	r18, 0x122E
    35fa:	30 91 2f 12 	lds	r19, 0x122F
    35fe:	40 91 30 12 	lds	r20, 0x1230
    3602:	50 91 31 12 	lds	r21, 0x1231
}
    3606:	b9 01       	movw	r22, r18
    3608:	ca 01       	movw	r24, r20
    360a:	08 95       	ret

0000360c <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    360c:	86 b5       	in	r24, 0x26	; 38
}
    360e:	08 95       	ret

00003610 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    3610:	20 91 84 00 	lds	r18, 0x0084
    3614:	30 91 85 00 	lds	r19, 0x0085
}
    3618:	c9 01       	movw	r24, r18
    361a:	08 95       	ret

0000361c <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    361c:	80 91 b2 00 	lds	r24, 0x00B2
}
    3620:	08 95       	ret

00003622 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    3622:	20 91 94 00 	lds	r18, 0x0094
    3626:	30 91 95 00 	lds	r19, 0x0095
}
    362a:	c9 01       	movw	r24, r18
    362c:	08 95       	ret

0000362e <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    362e:	20 91 a4 00 	lds	r18, 0x00A4
    3632:	30 91 a5 00 	lds	r19, 0x00A5
}
    3636:	c9 01       	movw	r24, r18
    3638:	08 95       	ret

0000363a <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    363a:	20 91 24 01 	lds	r18, 0x0124
    363e:	30 91 25 01 	lds	r19, 0x0125
}
    3642:	c9 01       	movw	r24, r18
    3644:	08 95       	ret

00003646 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    3646:	10 92 1e 12 	sts	0x121E, r1
    364a:	10 92 1f 12 	sts	0x121F, r1
    364e:	10 92 20 12 	sts	0x1220, r1
    3652:	10 92 21 12 	sts	0x1221, r1
    3656:	16 bc       	out	0x26, r1	; 38
}
    3658:	08 95       	ret

0000365a <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    365a:	10 92 1a 12 	sts	0x121A, r1
    365e:	10 92 1b 12 	sts	0x121B, r1
    3662:	10 92 1c 12 	sts	0x121C, r1
    3666:	10 92 1d 12 	sts	0x121D, r1
    366a:	10 92 85 00 	sts	0x0085, r1
    366e:	10 92 84 00 	sts	0x0084, r1
}
    3672:	08 95       	ret

00003674 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    3674:	10 92 22 12 	sts	0x1222, r1
    3678:	10 92 23 12 	sts	0x1223, r1
    367c:	10 92 24 12 	sts	0x1224, r1
    3680:	10 92 25 12 	sts	0x1225, r1
    3684:	10 92 b2 00 	sts	0x00B2, r1
}
    3688:	08 95       	ret

0000368a <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    368a:	10 92 2a 12 	sts	0x122A, r1
    368e:	10 92 2b 12 	sts	0x122B, r1
    3692:	10 92 2c 12 	sts	0x122C, r1
    3696:	10 92 2d 12 	sts	0x122D, r1
    369a:	10 92 95 00 	sts	0x0095, r1
    369e:	10 92 94 00 	sts	0x0094, r1
}
    36a2:	08 95       	ret

000036a4 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    36a4:	10 92 16 12 	sts	0x1216, r1
    36a8:	10 92 17 12 	sts	0x1217, r1
    36ac:	10 92 18 12 	sts	0x1218, r1
    36b0:	10 92 19 12 	sts	0x1219, r1
    36b4:	10 92 a5 00 	sts	0x00A5, r1
    36b8:	10 92 a4 00 	sts	0x00A4, r1
}
    36bc:	08 95       	ret

000036be <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    36be:	10 92 2e 12 	sts	0x122E, r1
    36c2:	10 92 2f 12 	sts	0x122F, r1
    36c6:	10 92 30 12 	sts	0x1230, r1
    36ca:	10 92 31 12 	sts	0x1231, r1
    36ce:	10 92 25 01 	sts	0x0125, r1
    36d2:	10 92 24 01 	sts	0x0124, r1
}
    36d6:	08 95       	ret

000036d8 <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    36d8:	08 95       	ret

000036da <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    36da:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    36dc:	81 e0       	ldi	r24, 0x01	; 1
    36de:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    36e2:	10 92 1e 12 	sts	0x121E, r1
    36e6:	10 92 1f 12 	sts	0x121F, r1
    36ea:	10 92 20 12 	sts	0x1220, r1
    36ee:	10 92 21 12 	sts	0x1221, r1
    36f2:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    36f4:	08 95       	ret

000036f6 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    36f6:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    36fa:	81 e0       	ldi	r24, 0x01	; 1
    36fc:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    3700:	10 92 1a 12 	sts	0x121A, r1
    3704:	10 92 1b 12 	sts	0x121B, r1
    3708:	10 92 1c 12 	sts	0x121C, r1
    370c:	10 92 1d 12 	sts	0x121D, r1
    3710:	10 92 85 00 	sts	0x0085, r1
    3714:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    3718:	08 95       	ret

0000371a <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    371a:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    371e:	81 e0       	ldi	r24, 0x01	; 1
    3720:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    3724:	10 92 22 12 	sts	0x1222, r1
    3728:	10 92 23 12 	sts	0x1223, r1
    372c:	10 92 24 12 	sts	0x1224, r1
    3730:	10 92 25 12 	sts	0x1225, r1
    3734:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    3738:	08 95       	ret

0000373a <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    373a:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    373e:	81 e0       	ldi	r24, 0x01	; 1
    3740:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    3744:	10 92 2a 12 	sts	0x122A, r1
    3748:	10 92 2b 12 	sts	0x122B, r1
    374c:	10 92 2c 12 	sts	0x122C, r1
    3750:	10 92 2d 12 	sts	0x122D, r1
    3754:	10 92 95 00 	sts	0x0095, r1
    3758:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    375c:	08 95       	ret

0000375e <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    375e:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    3762:	81 e0       	ldi	r24, 0x01	; 1
    3764:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    3768:	10 92 16 12 	sts	0x1216, r1
    376c:	10 92 17 12 	sts	0x1217, r1
    3770:	10 92 18 12 	sts	0x1218, r1
    3774:	10 92 19 12 	sts	0x1219, r1
    3778:	10 92 a5 00 	sts	0x00A5, r1
    377c:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    3780:	08 95       	ret

00003782 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    3782:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    3786:	81 e0       	ldi	r24, 0x01	; 1
    3788:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    378c:	10 92 2e 12 	sts	0x122E, r1
    3790:	10 92 2f 12 	sts	0x122F, r1
    3794:	10 92 30 12 	sts	0x1230, r1
    3798:	10 92 31 12 	sts	0x1231, r1
    379c:	10 92 25 01 	sts	0x0125, r1
    37a0:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    37a4:	08 95       	ret

000037a6 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    37a6:	e8 2f       	mov	r30, r24
    37a8:	f0 e0       	ldi	r31, 0x00	; 0
    37aa:	ee 0f       	add	r30, r30
    37ac:	ff 1f       	adc	r31, r31
    37ae:	e6 5c       	subi	r30, 0xC6	; 198
    37b0:	f0 4f       	sbci	r31, 0xF0	; 240
    37b2:	71 83       	std	Z+1, r23	; 0x01
    37b4:	60 83       	st	Z, r22
}
    37b6:	08 95       	ret

000037b8 <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    37b8:	e8 2f       	mov	r30, r24
    37ba:	f0 e0       	ldi	r31, 0x00	; 0
    37bc:	ee 0f       	add	r30, r30
    37be:	ff 1f       	adc	r31, r31
    37c0:	e6 5c       	subi	r30, 0xC6	; 198
    37c2:	f0 4f       	sbci	r31, 0xF0	; 240
    37c4:	11 82       	std	Z+1, r1	; 0x01
    37c6:	10 82       	st	Z, r1
}
    37c8:	08 95       	ret

000037ca <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    37ca:	01 97       	sbiw	r24, 0x01	; 1
    37cc:	f1 f7       	brne	.-4      	; 0x37ca <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    37ce:	08 95       	ret

000037d0 <sleep>:

void sleep(uint16_t time_ms)
{
    37d0:	af 92       	push	r10
    37d2:	bf 92       	push	r11
    37d4:	cf 92       	push	r12
    37d6:	df 92       	push	r13
    37d8:	ef 92       	push	r14
    37da:	ff 92       	push	r15
    37dc:	0f 93       	push	r16
    37de:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    37e0:	a0 e0       	ldi	r26, 0x00	; 0
    37e2:	b0 e0       	ldi	r27, 0x00	; 0
    37e4:	bc 01       	movw	r22, r24
    37e6:	cd 01       	movw	r24, r26
    37e8:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <__floatunsisf>
    37ec:	5b 01       	movw	r10, r22
    37ee:	6c 01       	movw	r12, r24
    37f0:	20 e0       	ldi	r18, 0x00	; 0
    37f2:	30 e0       	ldi	r19, 0x00	; 0
    37f4:	4a e7       	ldi	r20, 0x7A	; 122
    37f6:	55 e4       	ldi	r21, 0x45	; 69
    37f8:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    37fc:	7b 01       	movw	r14, r22
    37fe:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3800:	20 e0       	ldi	r18, 0x00	; 0
    3802:	30 e0       	ldi	r19, 0x00	; 0
    3804:	40 e8       	ldi	r20, 0x80	; 128
    3806:	5f e3       	ldi	r21, 0x3F	; 63
    3808:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    380c:	88 23       	and	r24, r24
    380e:	1c f4       	brge	.+6      	; 0x3816 <sleep+0x46>
    3810:	61 e0       	ldi	r22, 0x01	; 1
    3812:	70 e0       	ldi	r23, 0x00	; 0
    3814:	24 c0       	rjmp	.+72     	; 0x385e <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    3816:	c8 01       	movw	r24, r16
    3818:	b7 01       	movw	r22, r14
    381a:	20 e0       	ldi	r18, 0x00	; 0
    381c:	3f ef       	ldi	r19, 0xFF	; 255
    381e:	4f e7       	ldi	r20, 0x7F	; 127
    3820:	57 e4       	ldi	r21, 0x47	; 71
    3822:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    3826:	18 16       	cp	r1, r24
    3828:	b4 f4       	brge	.+44     	; 0x3856 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    382a:	c6 01       	movw	r24, r12
    382c:	b5 01       	movw	r22, r10
    382e:	20 e0       	ldi	r18, 0x00	; 0
    3830:	30 e0       	ldi	r19, 0x00	; 0
    3832:	40 e2       	ldi	r20, 0x20	; 32
    3834:	51 e4       	ldi	r21, 0x41	; 65
    3836:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    383a:	0e 94 fe 2c 	call	0x59fc	; 0x59fc <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    383e:	80 e9       	ldi	r24, 0x90	; 144
    3840:	91 e0       	ldi	r25, 0x01	; 1
    3842:	05 c0       	rjmp	.+10     	; 0x384e <sleep+0x7e>
    3844:	fc 01       	movw	r30, r24
    3846:	31 97       	sbiw	r30, 0x01	; 1
    3848:	f1 f7       	brne	.-4      	; 0x3846 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    384a:	61 50       	subi	r22, 0x01	; 1
    384c:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    384e:	61 15       	cp	r22, r1
    3850:	71 05       	cpc	r23, r1
    3852:	c1 f7       	brne	.-16     	; 0x3844 <sleep+0x74>
    3854:	07 c0       	rjmp	.+14     	; 0x3864 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3856:	c8 01       	movw	r24, r16
    3858:	b7 01       	movw	r22, r14
    385a:	0e 94 fe 2c 	call	0x59fc	; 0x59fc <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    385e:	cb 01       	movw	r24, r22
    3860:	01 97       	sbiw	r24, 0x01	; 1
    3862:	f1 f7       	brne	.-4      	; 0x3860 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    3864:	1f 91       	pop	r17
    3866:	0f 91       	pop	r16
    3868:	ff 90       	pop	r15
    386a:	ef 90       	pop	r14
    386c:	df 90       	pop	r13
    386e:	cf 90       	pop	r12
    3870:	bf 90       	pop	r11
    3872:	af 90       	pop	r10
    3874:	08 95       	ret

00003876 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    3876:	1f 92       	push	r1
    3878:	0f 92       	push	r0
    387a:	0f b6       	in	r0, 0x3f	; 63
    387c:	0f 92       	push	r0
    387e:	11 24       	eor	r1, r1
    3880:	2f 93       	push	r18
    3882:	3f 93       	push	r19
    3884:	4f 93       	push	r20
    3886:	5f 93       	push	r21
    3888:	6f 93       	push	r22
    388a:	7f 93       	push	r23
    388c:	8f 93       	push	r24
    388e:	9f 93       	push	r25
    3890:	af 93       	push	r26
    3892:	bf 93       	push	r27
    3894:	ef 93       	push	r30
    3896:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    3898:	80 91 1e 12 	lds	r24, 0x121E
    389c:	90 91 1f 12 	lds	r25, 0x121F
    38a0:	a0 91 20 12 	lds	r26, 0x1220
    38a4:	b0 91 21 12 	lds	r27, 0x1221
    38a8:	01 96       	adiw	r24, 0x01	; 1
    38aa:	a1 1d       	adc	r26, r1
    38ac:	b1 1d       	adc	r27, r1
    38ae:	80 93 1e 12 	sts	0x121E, r24
    38b2:	90 93 1f 12 	sts	0x121F, r25
    38b6:	a0 93 20 12 	sts	0x1220, r26
    38ba:	b0 93 21 12 	sts	0x1221, r27
  timer_sleep_cnt++;
    38be:	80 91 26 12 	lds	r24, 0x1226
    38c2:	90 91 27 12 	lds	r25, 0x1227
    38c6:	a0 91 28 12 	lds	r26, 0x1228
    38ca:	b0 91 29 12 	lds	r27, 0x1229
    38ce:	01 96       	adiw	r24, 0x01	; 1
    38d0:	a1 1d       	adc	r26, r1
    38d2:	b1 1d       	adc	r27, r1
    38d4:	80 93 26 12 	sts	0x1226, r24
    38d8:	90 93 27 12 	sts	0x1227, r25
    38dc:	a0 93 28 12 	sts	0x1228, r26
    38e0:	b0 93 29 12 	sts	0x1229, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    38e4:	80 91 3e 0f 	lds	r24, 0x0F3E
    38e8:	90 91 3f 0f 	lds	r25, 0x0F3F
    38ec:	89 2b       	or	r24, r25
    38ee:	29 f0       	breq	.+10     	; 0x38fa <__vector_23+0x84>
    38f0:	e0 91 3e 0f 	lds	r30, 0x0F3E
    38f4:	f0 91 3f 0f 	lds	r31, 0x0F3F
    38f8:	09 95       	icall
}
    38fa:	ff 91       	pop	r31
    38fc:	ef 91       	pop	r30
    38fe:	bf 91       	pop	r27
    3900:	af 91       	pop	r26
    3902:	9f 91       	pop	r25
    3904:	8f 91       	pop	r24
    3906:	7f 91       	pop	r23
    3908:	6f 91       	pop	r22
    390a:	5f 91       	pop	r21
    390c:	4f 91       	pop	r20
    390e:	3f 91       	pop	r19
    3910:	2f 91       	pop	r18
    3912:	0f 90       	pop	r0
    3914:	0f be       	out	0x3f, r0	; 63
    3916:	0f 90       	pop	r0
    3918:	1f 90       	pop	r1
    391a:	18 95       	reti

0000391c <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    391c:	1f 92       	push	r1
    391e:	0f 92       	push	r0
    3920:	0f b6       	in	r0, 0x3f	; 63
    3922:	0f 92       	push	r0
    3924:	11 24       	eor	r1, r1
    3926:	2f 93       	push	r18
    3928:	3f 93       	push	r19
    392a:	4f 93       	push	r20
    392c:	5f 93       	push	r21
    392e:	6f 93       	push	r22
    3930:	7f 93       	push	r23
    3932:	8f 93       	push	r24
    3934:	9f 93       	push	r25
    3936:	af 93       	push	r26
    3938:	bf 93       	push	r27
    393a:	ef 93       	push	r30
    393c:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    393e:	80 91 1a 12 	lds	r24, 0x121A
    3942:	90 91 1b 12 	lds	r25, 0x121B
    3946:	a0 91 1c 12 	lds	r26, 0x121C
    394a:	b0 91 1d 12 	lds	r27, 0x121D
    394e:	01 96       	adiw	r24, 0x01	; 1
    3950:	a1 1d       	adc	r26, r1
    3952:	b1 1d       	adc	r27, r1
    3954:	80 93 1a 12 	sts	0x121A, r24
    3958:	90 93 1b 12 	sts	0x121B, r25
    395c:	a0 93 1c 12 	sts	0x121C, r26
    3960:	b0 93 1d 12 	sts	0x121D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    3964:	80 91 48 0f 	lds	r24, 0x0F48
    3968:	90 91 49 0f 	lds	r25, 0x0F49
    396c:	89 2b       	or	r24, r25
    396e:	29 f0       	breq	.+10     	; 0x397a <__vector_20+0x5e>
    3970:	e0 91 48 0f 	lds	r30, 0x0F48
    3974:	f0 91 49 0f 	lds	r31, 0x0F49
    3978:	09 95       	icall
}
    397a:	ff 91       	pop	r31
    397c:	ef 91       	pop	r30
    397e:	bf 91       	pop	r27
    3980:	af 91       	pop	r26
    3982:	9f 91       	pop	r25
    3984:	8f 91       	pop	r24
    3986:	7f 91       	pop	r23
    3988:	6f 91       	pop	r22
    398a:	5f 91       	pop	r21
    398c:	4f 91       	pop	r20
    398e:	3f 91       	pop	r19
    3990:	2f 91       	pop	r18
    3992:	0f 90       	pop	r0
    3994:	0f be       	out	0x3f, r0	; 63
    3996:	0f 90       	pop	r0
    3998:	1f 90       	pop	r1
    399a:	18 95       	reti

0000399c <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    399c:	1f 92       	push	r1
    399e:	0f 92       	push	r0
    39a0:	0f b6       	in	r0, 0x3f	; 63
    39a2:	0f 92       	push	r0
    39a4:	11 24       	eor	r1, r1
    39a6:	2f 93       	push	r18
    39a8:	3f 93       	push	r19
    39aa:	4f 93       	push	r20
    39ac:	5f 93       	push	r21
    39ae:	6f 93       	push	r22
    39b0:	7f 93       	push	r23
    39b2:	8f 93       	push	r24
    39b4:	9f 93       	push	r25
    39b6:	af 93       	push	r26
    39b8:	bf 93       	push	r27
    39ba:	ef 93       	push	r30
    39bc:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    39be:	80 91 22 12 	lds	r24, 0x1222
    39c2:	90 91 23 12 	lds	r25, 0x1223
    39c6:	a0 91 24 12 	lds	r26, 0x1224
    39ca:	b0 91 25 12 	lds	r27, 0x1225
    39ce:	01 96       	adiw	r24, 0x01	; 1
    39d0:	a1 1d       	adc	r26, r1
    39d2:	b1 1d       	adc	r27, r1
    39d4:	80 93 22 12 	sts	0x1222, r24
    39d8:	90 93 23 12 	sts	0x1223, r25
    39dc:	a0 93 24 12 	sts	0x1224, r26
    39e0:	b0 93 25 12 	sts	0x1225, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    39e4:	80 91 4e 0f 	lds	r24, 0x0F4E
    39e8:	90 91 4f 0f 	lds	r25, 0x0F4F
    39ec:	89 2b       	or	r24, r25
    39ee:	29 f0       	breq	.+10     	; 0x39fa <__vector_15+0x5e>
    39f0:	e0 91 4e 0f 	lds	r30, 0x0F4E
    39f4:	f0 91 4f 0f 	lds	r31, 0x0F4F
    39f8:	09 95       	icall
}
    39fa:	ff 91       	pop	r31
    39fc:	ef 91       	pop	r30
    39fe:	bf 91       	pop	r27
    3a00:	af 91       	pop	r26
    3a02:	9f 91       	pop	r25
    3a04:	8f 91       	pop	r24
    3a06:	7f 91       	pop	r23
    3a08:	6f 91       	pop	r22
    3a0a:	5f 91       	pop	r21
    3a0c:	4f 91       	pop	r20
    3a0e:	3f 91       	pop	r19
    3a10:	2f 91       	pop	r18
    3a12:	0f 90       	pop	r0
    3a14:	0f be       	out	0x3f, r0	; 63
    3a16:	0f 90       	pop	r0
    3a18:	1f 90       	pop	r1
    3a1a:	18 95       	reti

00003a1c <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    3a1c:	1f 92       	push	r1
    3a1e:	0f 92       	push	r0
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	0f 92       	push	r0
    3a24:	11 24       	eor	r1, r1
    3a26:	2f 93       	push	r18
    3a28:	3f 93       	push	r19
    3a2a:	4f 93       	push	r20
    3a2c:	5f 93       	push	r21
    3a2e:	6f 93       	push	r22
    3a30:	7f 93       	push	r23
    3a32:	8f 93       	push	r24
    3a34:	9f 93       	push	r25
    3a36:	af 93       	push	r26
    3a38:	bf 93       	push	r27
    3a3a:	ef 93       	push	r30
    3a3c:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    3a3e:	80 91 2a 12 	lds	r24, 0x122A
    3a42:	90 91 2b 12 	lds	r25, 0x122B
    3a46:	a0 91 2c 12 	lds	r26, 0x122C
    3a4a:	b0 91 2d 12 	lds	r27, 0x122D
    3a4e:	01 96       	adiw	r24, 0x01	; 1
    3a50:	a1 1d       	adc	r26, r1
    3a52:	b1 1d       	adc	r27, r1
    3a54:	80 93 2a 12 	sts	0x122A, r24
    3a58:	90 93 2b 12 	sts	0x122B, r25
    3a5c:	a0 93 2c 12 	sts	0x122C, r26
    3a60:	b0 93 2d 12 	sts	0x122D, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    3a64:	80 91 58 0f 	lds	r24, 0x0F58
    3a68:	90 91 59 0f 	lds	r25, 0x0F59
    3a6c:	89 2b       	or	r24, r25
    3a6e:	29 f0       	breq	.+10     	; 0x3a7a <__vector_35+0x5e>
    3a70:	e0 91 58 0f 	lds	r30, 0x0F58
    3a74:	f0 91 59 0f 	lds	r31, 0x0F59
    3a78:	09 95       	icall
}
    3a7a:	ff 91       	pop	r31
    3a7c:	ef 91       	pop	r30
    3a7e:	bf 91       	pop	r27
    3a80:	af 91       	pop	r26
    3a82:	9f 91       	pop	r25
    3a84:	8f 91       	pop	r24
    3a86:	7f 91       	pop	r23
    3a88:	6f 91       	pop	r22
    3a8a:	5f 91       	pop	r21
    3a8c:	4f 91       	pop	r20
    3a8e:	3f 91       	pop	r19
    3a90:	2f 91       	pop	r18
    3a92:	0f 90       	pop	r0
    3a94:	0f be       	out	0x3f, r0	; 63
    3a96:	0f 90       	pop	r0
    3a98:	1f 90       	pop	r1
    3a9a:	18 95       	reti

00003a9c <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    3a9c:	1f 92       	push	r1
    3a9e:	0f 92       	push	r0
    3aa0:	0f b6       	in	r0, 0x3f	; 63
    3aa2:	0f 92       	push	r0
    3aa4:	11 24       	eor	r1, r1
    3aa6:	2f 93       	push	r18
    3aa8:	3f 93       	push	r19
    3aaa:	4f 93       	push	r20
    3aac:	5f 93       	push	r21
    3aae:	6f 93       	push	r22
    3ab0:	7f 93       	push	r23
    3ab2:	8f 93       	push	r24
    3ab4:	9f 93       	push	r25
    3ab6:	af 93       	push	r26
    3ab8:	bf 93       	push	r27
    3aba:	ef 93       	push	r30
    3abc:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    3abe:	80 91 16 12 	lds	r24, 0x1216
    3ac2:	90 91 17 12 	lds	r25, 0x1217
    3ac6:	a0 91 18 12 	lds	r26, 0x1218
    3aca:	b0 91 19 12 	lds	r27, 0x1219
    3ace:	01 96       	adiw	r24, 0x01	; 1
    3ad0:	a1 1d       	adc	r26, r1
    3ad2:	b1 1d       	adc	r27, r1
    3ad4:	80 93 16 12 	sts	0x1216, r24
    3ad8:	90 93 17 12 	sts	0x1217, r25
    3adc:	a0 93 18 12 	sts	0x1218, r26
    3ae0:	b0 93 19 12 	sts	0x1219, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    3ae4:	80 91 62 0f 	lds	r24, 0x0F62
    3ae8:	90 91 63 0f 	lds	r25, 0x0F63
    3aec:	89 2b       	or	r24, r25
    3aee:	29 f0       	breq	.+10     	; 0x3afa <__vector_45+0x5e>
    3af0:	e0 91 62 0f 	lds	r30, 0x0F62
    3af4:	f0 91 63 0f 	lds	r31, 0x0F63
    3af8:	09 95       	icall
}
    3afa:	ff 91       	pop	r31
    3afc:	ef 91       	pop	r30
    3afe:	bf 91       	pop	r27
    3b00:	af 91       	pop	r26
    3b02:	9f 91       	pop	r25
    3b04:	8f 91       	pop	r24
    3b06:	7f 91       	pop	r23
    3b08:	6f 91       	pop	r22
    3b0a:	5f 91       	pop	r21
    3b0c:	4f 91       	pop	r20
    3b0e:	3f 91       	pop	r19
    3b10:	2f 91       	pop	r18
    3b12:	0f 90       	pop	r0
    3b14:	0f be       	out	0x3f, r0	; 63
    3b16:	0f 90       	pop	r0
    3b18:	1f 90       	pop	r1
    3b1a:	18 95       	reti

00003b1c <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    3b1c:	1f 92       	push	r1
    3b1e:	0f 92       	push	r0
    3b20:	0f b6       	in	r0, 0x3f	; 63
    3b22:	0f 92       	push	r0
    3b24:	11 24       	eor	r1, r1
    3b26:	2f 93       	push	r18
    3b28:	3f 93       	push	r19
    3b2a:	4f 93       	push	r20
    3b2c:	5f 93       	push	r21
    3b2e:	6f 93       	push	r22
    3b30:	7f 93       	push	r23
    3b32:	8f 93       	push	r24
    3b34:	9f 93       	push	r25
    3b36:	af 93       	push	r26
    3b38:	bf 93       	push	r27
    3b3a:	ef 93       	push	r30
    3b3c:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    3b3e:	80 91 2e 12 	lds	r24, 0x122E
    3b42:	90 91 2f 12 	lds	r25, 0x122F
    3b46:	a0 91 30 12 	lds	r26, 0x1230
    3b4a:	b0 91 31 12 	lds	r27, 0x1231
    3b4e:	01 96       	adiw	r24, 0x01	; 1
    3b50:	a1 1d       	adc	r26, r1
    3b52:	b1 1d       	adc	r27, r1
    3b54:	80 93 2e 12 	sts	0x122E, r24
    3b58:	90 93 2f 12 	sts	0x122F, r25
    3b5c:	a0 93 30 12 	sts	0x1230, r26
    3b60:	b0 93 31 12 	sts	0x1231, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    3b64:	80 91 6c 0f 	lds	r24, 0x0F6C
    3b68:	90 91 6d 0f 	lds	r25, 0x0F6D
    3b6c:	89 2b       	or	r24, r25
    3b6e:	29 f0       	breq	.+10     	; 0x3b7a <__vector_50+0x5e>
    3b70:	e0 91 6c 0f 	lds	r30, 0x0F6C
    3b74:	f0 91 6d 0f 	lds	r31, 0x0F6D
    3b78:	09 95       	icall
}
    3b7a:	ff 91       	pop	r31
    3b7c:	ef 91       	pop	r30
    3b7e:	bf 91       	pop	r27
    3b80:	af 91       	pop	r26
    3b82:	9f 91       	pop	r25
    3b84:	8f 91       	pop	r24
    3b86:	7f 91       	pop	r23
    3b88:	6f 91       	pop	r22
    3b8a:	5f 91       	pop	r21
    3b8c:	4f 91       	pop	r20
    3b8e:	3f 91       	pop	r19
    3b90:	2f 91       	pop	r18
    3b92:	0f 90       	pop	r0
    3b94:	0f be       	out	0x3f, r0	; 63
    3b96:	0f 90       	pop	r0
    3b98:	1f 90       	pop	r1
    3b9a:	18 95       	reti

00003b9c <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    3b9c:	1f 92       	push	r1
    3b9e:	0f 92       	push	r0
    3ba0:	0f b6       	in	r0, 0x3f	; 63
    3ba2:	0f 92       	push	r0
    3ba4:	11 24       	eor	r1, r1
    3ba6:	2f 93       	push	r18
    3ba8:	3f 93       	push	r19
    3baa:	4f 93       	push	r20
    3bac:	5f 93       	push	r21
    3bae:	6f 93       	push	r22
    3bb0:	7f 93       	push	r23
    3bb2:	8f 93       	push	r24
    3bb4:	9f 93       	push	r25
    3bb6:	af 93       	push	r26
    3bb8:	bf 93       	push	r27
    3bba:	ef 93       	push	r30
    3bbc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    3bbe:	80 91 3a 0f 	lds	r24, 0x0F3A
    3bc2:	90 91 3b 0f 	lds	r25, 0x0F3B
    3bc6:	89 2b       	or	r24, r25
    3bc8:	29 f0       	breq	.+10     	; 0x3bd4 <__vector_21+0x38>
    3bca:	e0 91 3a 0f 	lds	r30, 0x0F3A
    3bce:	f0 91 3b 0f 	lds	r31, 0x0F3B
    3bd2:	09 95       	icall
}
    3bd4:	ff 91       	pop	r31
    3bd6:	ef 91       	pop	r30
    3bd8:	bf 91       	pop	r27
    3bda:	af 91       	pop	r26
    3bdc:	9f 91       	pop	r25
    3bde:	8f 91       	pop	r24
    3be0:	7f 91       	pop	r23
    3be2:	6f 91       	pop	r22
    3be4:	5f 91       	pop	r21
    3be6:	4f 91       	pop	r20
    3be8:	3f 91       	pop	r19
    3bea:	2f 91       	pop	r18
    3bec:	0f 90       	pop	r0
    3bee:	0f be       	out	0x3f, r0	; 63
    3bf0:	0f 90       	pop	r0
    3bf2:	1f 90       	pop	r1
    3bf4:	18 95       	reti

00003bf6 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    3bf6:	1f 92       	push	r1
    3bf8:	0f 92       	push	r0
    3bfa:	0f b6       	in	r0, 0x3f	; 63
    3bfc:	0f 92       	push	r0
    3bfe:	11 24       	eor	r1, r1
    3c00:	2f 93       	push	r18
    3c02:	3f 93       	push	r19
    3c04:	4f 93       	push	r20
    3c06:	5f 93       	push	r21
    3c08:	6f 93       	push	r22
    3c0a:	7f 93       	push	r23
    3c0c:	8f 93       	push	r24
    3c0e:	9f 93       	push	r25
    3c10:	af 93       	push	r26
    3c12:	bf 93       	push	r27
    3c14:	ef 93       	push	r30
    3c16:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    3c18:	80 91 3c 0f 	lds	r24, 0x0F3C
    3c1c:	90 91 3d 0f 	lds	r25, 0x0F3D
    3c20:	89 2b       	or	r24, r25
    3c22:	29 f0       	breq	.+10     	; 0x3c2e <__vector_22+0x38>
    3c24:	e0 91 3c 0f 	lds	r30, 0x0F3C
    3c28:	f0 91 3d 0f 	lds	r31, 0x0F3D
    3c2c:	09 95       	icall
}
    3c2e:	ff 91       	pop	r31
    3c30:	ef 91       	pop	r30
    3c32:	bf 91       	pop	r27
    3c34:	af 91       	pop	r26
    3c36:	9f 91       	pop	r25
    3c38:	8f 91       	pop	r24
    3c3a:	7f 91       	pop	r23
    3c3c:	6f 91       	pop	r22
    3c3e:	5f 91       	pop	r21
    3c40:	4f 91       	pop	r20
    3c42:	3f 91       	pop	r19
    3c44:	2f 91       	pop	r18
    3c46:	0f 90       	pop	r0
    3c48:	0f be       	out	0x3f, r0	; 63
    3c4a:	0f 90       	pop	r0
    3c4c:	1f 90       	pop	r1
    3c4e:	18 95       	reti

00003c50 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    3c50:	1f 92       	push	r1
    3c52:	0f 92       	push	r0
    3c54:	0f b6       	in	r0, 0x3f	; 63
    3c56:	0f 92       	push	r0
    3c58:	11 24       	eor	r1, r1
    3c5a:	2f 93       	push	r18
    3c5c:	3f 93       	push	r19
    3c5e:	4f 93       	push	r20
    3c60:	5f 93       	push	r21
    3c62:	6f 93       	push	r22
    3c64:	7f 93       	push	r23
    3c66:	8f 93       	push	r24
    3c68:	9f 93       	push	r25
    3c6a:	af 93       	push	r26
    3c6c:	bf 93       	push	r27
    3c6e:	ef 93       	push	r30
    3c70:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    3c72:	80 91 40 0f 	lds	r24, 0x0F40
    3c76:	90 91 41 0f 	lds	r25, 0x0F41
    3c7a:	89 2b       	or	r24, r25
    3c7c:	29 f0       	breq	.+10     	; 0x3c88 <__vector_16+0x38>
    3c7e:	e0 91 40 0f 	lds	r30, 0x0F40
    3c82:	f0 91 41 0f 	lds	r31, 0x0F41
    3c86:	09 95       	icall
}
    3c88:	ff 91       	pop	r31
    3c8a:	ef 91       	pop	r30
    3c8c:	bf 91       	pop	r27
    3c8e:	af 91       	pop	r26
    3c90:	9f 91       	pop	r25
    3c92:	8f 91       	pop	r24
    3c94:	7f 91       	pop	r23
    3c96:	6f 91       	pop	r22
    3c98:	5f 91       	pop	r21
    3c9a:	4f 91       	pop	r20
    3c9c:	3f 91       	pop	r19
    3c9e:	2f 91       	pop	r18
    3ca0:	0f 90       	pop	r0
    3ca2:	0f be       	out	0x3f, r0	; 63
    3ca4:	0f 90       	pop	r0
    3ca6:	1f 90       	pop	r1
    3ca8:	18 95       	reti

00003caa <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    3caa:	1f 92       	push	r1
    3cac:	0f 92       	push	r0
    3cae:	0f b6       	in	r0, 0x3f	; 63
    3cb0:	0f 92       	push	r0
    3cb2:	11 24       	eor	r1, r1
    3cb4:	2f 93       	push	r18
    3cb6:	3f 93       	push	r19
    3cb8:	4f 93       	push	r20
    3cba:	5f 93       	push	r21
    3cbc:	6f 93       	push	r22
    3cbe:	7f 93       	push	r23
    3cc0:	8f 93       	push	r24
    3cc2:	9f 93       	push	r25
    3cc4:	af 93       	push	r26
    3cc6:	bf 93       	push	r27
    3cc8:	ef 93       	push	r30
    3cca:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    3ccc:	80 91 44 0f 	lds	r24, 0x0F44
    3cd0:	90 91 45 0f 	lds	r25, 0x0F45
    3cd4:	89 2b       	or	r24, r25
    3cd6:	29 f0       	breq	.+10     	; 0x3ce2 <__vector_18+0x38>
    3cd8:	e0 91 44 0f 	lds	r30, 0x0F44
    3cdc:	f0 91 45 0f 	lds	r31, 0x0F45
    3ce0:	09 95       	icall
}
    3ce2:	ff 91       	pop	r31
    3ce4:	ef 91       	pop	r30
    3ce6:	bf 91       	pop	r27
    3ce8:	af 91       	pop	r26
    3cea:	9f 91       	pop	r25
    3cec:	8f 91       	pop	r24
    3cee:	7f 91       	pop	r23
    3cf0:	6f 91       	pop	r22
    3cf2:	5f 91       	pop	r21
    3cf4:	4f 91       	pop	r20
    3cf6:	3f 91       	pop	r19
    3cf8:	2f 91       	pop	r18
    3cfa:	0f 90       	pop	r0
    3cfc:	0f be       	out	0x3f, r0	; 63
    3cfe:	0f 90       	pop	r0
    3d00:	1f 90       	pop	r1
    3d02:	18 95       	reti

00003d04 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    3d04:	1f 92       	push	r1
    3d06:	0f 92       	push	r0
    3d08:	0f b6       	in	r0, 0x3f	; 63
    3d0a:	0f 92       	push	r0
    3d0c:	11 24       	eor	r1, r1
    3d0e:	2f 93       	push	r18
    3d10:	3f 93       	push	r19
    3d12:	4f 93       	push	r20
    3d14:	5f 93       	push	r21
    3d16:	6f 93       	push	r22
    3d18:	7f 93       	push	r23
    3d1a:	8f 93       	push	r24
    3d1c:	9f 93       	push	r25
    3d1e:	af 93       	push	r26
    3d20:	bf 93       	push	r27
    3d22:	ef 93       	push	r30
    3d24:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    3d26:	80 91 46 0f 	lds	r24, 0x0F46
    3d2a:	90 91 47 0f 	lds	r25, 0x0F47
    3d2e:	89 2b       	or	r24, r25
    3d30:	29 f0       	breq	.+10     	; 0x3d3c <__vector_19+0x38>
    3d32:	e0 91 46 0f 	lds	r30, 0x0F46
    3d36:	f0 91 47 0f 	lds	r31, 0x0F47
    3d3a:	09 95       	icall
}
    3d3c:	ff 91       	pop	r31
    3d3e:	ef 91       	pop	r30
    3d40:	bf 91       	pop	r27
    3d42:	af 91       	pop	r26
    3d44:	9f 91       	pop	r25
    3d46:	8f 91       	pop	r24
    3d48:	7f 91       	pop	r23
    3d4a:	6f 91       	pop	r22
    3d4c:	5f 91       	pop	r21
    3d4e:	4f 91       	pop	r20
    3d50:	3f 91       	pop	r19
    3d52:	2f 91       	pop	r18
    3d54:	0f 90       	pop	r0
    3d56:	0f be       	out	0x3f, r0	; 63
    3d58:	0f 90       	pop	r0
    3d5a:	1f 90       	pop	r1
    3d5c:	18 95       	reti

00003d5e <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    3d5e:	1f 92       	push	r1
    3d60:	0f 92       	push	r0
    3d62:	0f b6       	in	r0, 0x3f	; 63
    3d64:	0f 92       	push	r0
    3d66:	11 24       	eor	r1, r1
    3d68:	2f 93       	push	r18
    3d6a:	3f 93       	push	r19
    3d6c:	4f 93       	push	r20
    3d6e:	5f 93       	push	r21
    3d70:	6f 93       	push	r22
    3d72:	7f 93       	push	r23
    3d74:	8f 93       	push	r24
    3d76:	9f 93       	push	r25
    3d78:	af 93       	push	r26
    3d7a:	bf 93       	push	r27
    3d7c:	ef 93       	push	r30
    3d7e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    3d80:	80 91 4a 0f 	lds	r24, 0x0F4A
    3d84:	90 91 4b 0f 	lds	r25, 0x0F4B
    3d88:	89 2b       	or	r24, r25
    3d8a:	29 f0       	breq	.+10     	; 0x3d96 <__vector_13+0x38>
    3d8c:	e0 91 4a 0f 	lds	r30, 0x0F4A
    3d90:	f0 91 4b 0f 	lds	r31, 0x0F4B
    3d94:	09 95       	icall
}
    3d96:	ff 91       	pop	r31
    3d98:	ef 91       	pop	r30
    3d9a:	bf 91       	pop	r27
    3d9c:	af 91       	pop	r26
    3d9e:	9f 91       	pop	r25
    3da0:	8f 91       	pop	r24
    3da2:	7f 91       	pop	r23
    3da4:	6f 91       	pop	r22
    3da6:	5f 91       	pop	r21
    3da8:	4f 91       	pop	r20
    3daa:	3f 91       	pop	r19
    3dac:	2f 91       	pop	r18
    3dae:	0f 90       	pop	r0
    3db0:	0f be       	out	0x3f, r0	; 63
    3db2:	0f 90       	pop	r0
    3db4:	1f 90       	pop	r1
    3db6:	18 95       	reti

00003db8 <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    3db8:	1f 92       	push	r1
    3dba:	0f 92       	push	r0
    3dbc:	0f b6       	in	r0, 0x3f	; 63
    3dbe:	0f 92       	push	r0
    3dc0:	11 24       	eor	r1, r1
    3dc2:	2f 93       	push	r18
    3dc4:	3f 93       	push	r19
    3dc6:	4f 93       	push	r20
    3dc8:	5f 93       	push	r21
    3dca:	6f 93       	push	r22
    3dcc:	7f 93       	push	r23
    3dce:	8f 93       	push	r24
    3dd0:	9f 93       	push	r25
    3dd2:	af 93       	push	r26
    3dd4:	bf 93       	push	r27
    3dd6:	ef 93       	push	r30
    3dd8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    3dda:	80 91 4c 0f 	lds	r24, 0x0F4C
    3dde:	90 91 4d 0f 	lds	r25, 0x0F4D
    3de2:	89 2b       	or	r24, r25
    3de4:	29 f0       	breq	.+10     	; 0x3df0 <__vector_14+0x38>
    3de6:	e0 91 4c 0f 	lds	r30, 0x0F4C
    3dea:	f0 91 4d 0f 	lds	r31, 0x0F4D
    3dee:	09 95       	icall
}
    3df0:	ff 91       	pop	r31
    3df2:	ef 91       	pop	r30
    3df4:	bf 91       	pop	r27
    3df6:	af 91       	pop	r26
    3df8:	9f 91       	pop	r25
    3dfa:	8f 91       	pop	r24
    3dfc:	7f 91       	pop	r23
    3dfe:	6f 91       	pop	r22
    3e00:	5f 91       	pop	r21
    3e02:	4f 91       	pop	r20
    3e04:	3f 91       	pop	r19
    3e06:	2f 91       	pop	r18
    3e08:	0f 90       	pop	r0
    3e0a:	0f be       	out	0x3f, r0	; 63
    3e0c:	0f 90       	pop	r0
    3e0e:	1f 90       	pop	r1
    3e10:	18 95       	reti

00003e12 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    3e12:	1f 92       	push	r1
    3e14:	0f 92       	push	r0
    3e16:	0f b6       	in	r0, 0x3f	; 63
    3e18:	0f 92       	push	r0
    3e1a:	11 24       	eor	r1, r1
    3e1c:	2f 93       	push	r18
    3e1e:	3f 93       	push	r19
    3e20:	4f 93       	push	r20
    3e22:	5f 93       	push	r21
    3e24:	6f 93       	push	r22
    3e26:	7f 93       	push	r23
    3e28:	8f 93       	push	r24
    3e2a:	9f 93       	push	r25
    3e2c:	af 93       	push	r26
    3e2e:	bf 93       	push	r27
    3e30:	ef 93       	push	r30
    3e32:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    3e34:	80 91 50 0f 	lds	r24, 0x0F50
    3e38:	90 91 51 0f 	lds	r25, 0x0F51
    3e3c:	89 2b       	or	r24, r25
    3e3e:	29 f0       	breq	.+10     	; 0x3e4a <__vector_31+0x38>
    3e40:	e0 91 50 0f 	lds	r30, 0x0F50
    3e44:	f0 91 51 0f 	lds	r31, 0x0F51
    3e48:	09 95       	icall
}
    3e4a:	ff 91       	pop	r31
    3e4c:	ef 91       	pop	r30
    3e4e:	bf 91       	pop	r27
    3e50:	af 91       	pop	r26
    3e52:	9f 91       	pop	r25
    3e54:	8f 91       	pop	r24
    3e56:	7f 91       	pop	r23
    3e58:	6f 91       	pop	r22
    3e5a:	5f 91       	pop	r21
    3e5c:	4f 91       	pop	r20
    3e5e:	3f 91       	pop	r19
    3e60:	2f 91       	pop	r18
    3e62:	0f 90       	pop	r0
    3e64:	0f be       	out	0x3f, r0	; 63
    3e66:	0f 90       	pop	r0
    3e68:	1f 90       	pop	r1
    3e6a:	18 95       	reti

00003e6c <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    3e6c:	1f 92       	push	r1
    3e6e:	0f 92       	push	r0
    3e70:	0f b6       	in	r0, 0x3f	; 63
    3e72:	0f 92       	push	r0
    3e74:	11 24       	eor	r1, r1
    3e76:	2f 93       	push	r18
    3e78:	3f 93       	push	r19
    3e7a:	4f 93       	push	r20
    3e7c:	5f 93       	push	r21
    3e7e:	6f 93       	push	r22
    3e80:	7f 93       	push	r23
    3e82:	8f 93       	push	r24
    3e84:	9f 93       	push	r25
    3e86:	af 93       	push	r26
    3e88:	bf 93       	push	r27
    3e8a:	ef 93       	push	r30
    3e8c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    3e8e:	80 91 52 0f 	lds	r24, 0x0F52
    3e92:	90 91 53 0f 	lds	r25, 0x0F53
    3e96:	89 2b       	or	r24, r25
    3e98:	29 f0       	breq	.+10     	; 0x3ea4 <__vector_32+0x38>
    3e9a:	e0 91 52 0f 	lds	r30, 0x0F52
    3e9e:	f0 91 53 0f 	lds	r31, 0x0F53
    3ea2:	09 95       	icall
}
    3ea4:	ff 91       	pop	r31
    3ea6:	ef 91       	pop	r30
    3ea8:	bf 91       	pop	r27
    3eaa:	af 91       	pop	r26
    3eac:	9f 91       	pop	r25
    3eae:	8f 91       	pop	r24
    3eb0:	7f 91       	pop	r23
    3eb2:	6f 91       	pop	r22
    3eb4:	5f 91       	pop	r21
    3eb6:	4f 91       	pop	r20
    3eb8:	3f 91       	pop	r19
    3eba:	2f 91       	pop	r18
    3ebc:	0f 90       	pop	r0
    3ebe:	0f be       	out	0x3f, r0	; 63
    3ec0:	0f 90       	pop	r0
    3ec2:	1f 90       	pop	r1
    3ec4:	18 95       	reti

00003ec6 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    3ec6:	1f 92       	push	r1
    3ec8:	0f 92       	push	r0
    3eca:	0f b6       	in	r0, 0x3f	; 63
    3ecc:	0f 92       	push	r0
    3ece:	11 24       	eor	r1, r1
    3ed0:	2f 93       	push	r18
    3ed2:	3f 93       	push	r19
    3ed4:	4f 93       	push	r20
    3ed6:	5f 93       	push	r21
    3ed8:	6f 93       	push	r22
    3eda:	7f 93       	push	r23
    3edc:	8f 93       	push	r24
    3ede:	9f 93       	push	r25
    3ee0:	af 93       	push	r26
    3ee2:	bf 93       	push	r27
    3ee4:	ef 93       	push	r30
    3ee6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    3ee8:	80 91 54 0f 	lds	r24, 0x0F54
    3eec:	90 91 55 0f 	lds	r25, 0x0F55
    3ef0:	89 2b       	or	r24, r25
    3ef2:	29 f0       	breq	.+10     	; 0x3efe <__vector_33+0x38>
    3ef4:	e0 91 54 0f 	lds	r30, 0x0F54
    3ef8:	f0 91 55 0f 	lds	r31, 0x0F55
    3efc:	09 95       	icall
}
    3efe:	ff 91       	pop	r31
    3f00:	ef 91       	pop	r30
    3f02:	bf 91       	pop	r27
    3f04:	af 91       	pop	r26
    3f06:	9f 91       	pop	r25
    3f08:	8f 91       	pop	r24
    3f0a:	7f 91       	pop	r23
    3f0c:	6f 91       	pop	r22
    3f0e:	5f 91       	pop	r21
    3f10:	4f 91       	pop	r20
    3f12:	3f 91       	pop	r19
    3f14:	2f 91       	pop	r18
    3f16:	0f 90       	pop	r0
    3f18:	0f be       	out	0x3f, r0	; 63
    3f1a:	0f 90       	pop	r0
    3f1c:	1f 90       	pop	r1
    3f1e:	18 95       	reti

00003f20 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    3f20:	1f 92       	push	r1
    3f22:	0f 92       	push	r0
    3f24:	0f b6       	in	r0, 0x3f	; 63
    3f26:	0f 92       	push	r0
    3f28:	11 24       	eor	r1, r1
    3f2a:	2f 93       	push	r18
    3f2c:	3f 93       	push	r19
    3f2e:	4f 93       	push	r20
    3f30:	5f 93       	push	r21
    3f32:	6f 93       	push	r22
    3f34:	7f 93       	push	r23
    3f36:	8f 93       	push	r24
    3f38:	9f 93       	push	r25
    3f3a:	af 93       	push	r26
    3f3c:	bf 93       	push	r27
    3f3e:	ef 93       	push	r30
    3f40:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    3f42:	80 91 56 0f 	lds	r24, 0x0F56
    3f46:	90 91 57 0f 	lds	r25, 0x0F57
    3f4a:	89 2b       	or	r24, r25
    3f4c:	29 f0       	breq	.+10     	; 0x3f58 <__vector_34+0x38>
    3f4e:	e0 91 56 0f 	lds	r30, 0x0F56
    3f52:	f0 91 57 0f 	lds	r31, 0x0F57
    3f56:	09 95       	icall
}
    3f58:	ff 91       	pop	r31
    3f5a:	ef 91       	pop	r30
    3f5c:	bf 91       	pop	r27
    3f5e:	af 91       	pop	r26
    3f60:	9f 91       	pop	r25
    3f62:	8f 91       	pop	r24
    3f64:	7f 91       	pop	r23
    3f66:	6f 91       	pop	r22
    3f68:	5f 91       	pop	r21
    3f6a:	4f 91       	pop	r20
    3f6c:	3f 91       	pop	r19
    3f6e:	2f 91       	pop	r18
    3f70:	0f 90       	pop	r0
    3f72:	0f be       	out	0x3f, r0	; 63
    3f74:	0f 90       	pop	r0
    3f76:	1f 90       	pop	r1
    3f78:	18 95       	reti

00003f7a <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    3f7a:	1f 92       	push	r1
    3f7c:	0f 92       	push	r0
    3f7e:	0f b6       	in	r0, 0x3f	; 63
    3f80:	0f 92       	push	r0
    3f82:	11 24       	eor	r1, r1
    3f84:	2f 93       	push	r18
    3f86:	3f 93       	push	r19
    3f88:	4f 93       	push	r20
    3f8a:	5f 93       	push	r21
    3f8c:	6f 93       	push	r22
    3f8e:	7f 93       	push	r23
    3f90:	8f 93       	push	r24
    3f92:	9f 93       	push	r25
    3f94:	af 93       	push	r26
    3f96:	bf 93       	push	r27
    3f98:	ef 93       	push	r30
    3f9a:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    3f9c:	80 91 5a 0f 	lds	r24, 0x0F5A
    3fa0:	90 91 5b 0f 	lds	r25, 0x0F5B
    3fa4:	89 2b       	or	r24, r25
    3fa6:	29 f0       	breq	.+10     	; 0x3fb2 <__vector_41+0x38>
    3fa8:	e0 91 5a 0f 	lds	r30, 0x0F5A
    3fac:	f0 91 5b 0f 	lds	r31, 0x0F5B
    3fb0:	09 95       	icall
}
    3fb2:	ff 91       	pop	r31
    3fb4:	ef 91       	pop	r30
    3fb6:	bf 91       	pop	r27
    3fb8:	af 91       	pop	r26
    3fba:	9f 91       	pop	r25
    3fbc:	8f 91       	pop	r24
    3fbe:	7f 91       	pop	r23
    3fc0:	6f 91       	pop	r22
    3fc2:	5f 91       	pop	r21
    3fc4:	4f 91       	pop	r20
    3fc6:	3f 91       	pop	r19
    3fc8:	2f 91       	pop	r18
    3fca:	0f 90       	pop	r0
    3fcc:	0f be       	out	0x3f, r0	; 63
    3fce:	0f 90       	pop	r0
    3fd0:	1f 90       	pop	r1
    3fd2:	18 95       	reti

00003fd4 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    3fd4:	1f 92       	push	r1
    3fd6:	0f 92       	push	r0
    3fd8:	0f b6       	in	r0, 0x3f	; 63
    3fda:	0f 92       	push	r0
    3fdc:	11 24       	eor	r1, r1
    3fde:	2f 93       	push	r18
    3fe0:	3f 93       	push	r19
    3fe2:	4f 93       	push	r20
    3fe4:	5f 93       	push	r21
    3fe6:	6f 93       	push	r22
    3fe8:	7f 93       	push	r23
    3fea:	8f 93       	push	r24
    3fec:	9f 93       	push	r25
    3fee:	af 93       	push	r26
    3ff0:	bf 93       	push	r27
    3ff2:	ef 93       	push	r30
    3ff4:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    3ff6:	80 91 5c 0f 	lds	r24, 0x0F5C
    3ffa:	90 91 5d 0f 	lds	r25, 0x0F5D
    3ffe:	89 2b       	or	r24, r25
    4000:	29 f0       	breq	.+10     	; 0x400c <__vector_42+0x38>
    4002:	e0 91 5c 0f 	lds	r30, 0x0F5C
    4006:	f0 91 5d 0f 	lds	r31, 0x0F5D
    400a:	09 95       	icall
}
    400c:	ff 91       	pop	r31
    400e:	ef 91       	pop	r30
    4010:	bf 91       	pop	r27
    4012:	af 91       	pop	r26
    4014:	9f 91       	pop	r25
    4016:	8f 91       	pop	r24
    4018:	7f 91       	pop	r23
    401a:	6f 91       	pop	r22
    401c:	5f 91       	pop	r21
    401e:	4f 91       	pop	r20
    4020:	3f 91       	pop	r19
    4022:	2f 91       	pop	r18
    4024:	0f 90       	pop	r0
    4026:	0f be       	out	0x3f, r0	; 63
    4028:	0f 90       	pop	r0
    402a:	1f 90       	pop	r1
    402c:	18 95       	reti

0000402e <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    402e:	1f 92       	push	r1
    4030:	0f 92       	push	r0
    4032:	0f b6       	in	r0, 0x3f	; 63
    4034:	0f 92       	push	r0
    4036:	11 24       	eor	r1, r1
    4038:	2f 93       	push	r18
    403a:	3f 93       	push	r19
    403c:	4f 93       	push	r20
    403e:	5f 93       	push	r21
    4040:	6f 93       	push	r22
    4042:	7f 93       	push	r23
    4044:	8f 93       	push	r24
    4046:	9f 93       	push	r25
    4048:	af 93       	push	r26
    404a:	bf 93       	push	r27
    404c:	ef 93       	push	r30
    404e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    4050:	80 91 5e 0f 	lds	r24, 0x0F5E
    4054:	90 91 5f 0f 	lds	r25, 0x0F5F
    4058:	89 2b       	or	r24, r25
    405a:	29 f0       	breq	.+10     	; 0x4066 <__vector_43+0x38>
    405c:	e0 91 5e 0f 	lds	r30, 0x0F5E
    4060:	f0 91 5f 0f 	lds	r31, 0x0F5F
    4064:	09 95       	icall
}
    4066:	ff 91       	pop	r31
    4068:	ef 91       	pop	r30
    406a:	bf 91       	pop	r27
    406c:	af 91       	pop	r26
    406e:	9f 91       	pop	r25
    4070:	8f 91       	pop	r24
    4072:	7f 91       	pop	r23
    4074:	6f 91       	pop	r22
    4076:	5f 91       	pop	r21
    4078:	4f 91       	pop	r20
    407a:	3f 91       	pop	r19
    407c:	2f 91       	pop	r18
    407e:	0f 90       	pop	r0
    4080:	0f be       	out	0x3f, r0	; 63
    4082:	0f 90       	pop	r0
    4084:	1f 90       	pop	r1
    4086:	18 95       	reti

00004088 <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    4088:	1f 92       	push	r1
    408a:	0f 92       	push	r0
    408c:	0f b6       	in	r0, 0x3f	; 63
    408e:	0f 92       	push	r0
    4090:	11 24       	eor	r1, r1
    4092:	2f 93       	push	r18
    4094:	3f 93       	push	r19
    4096:	4f 93       	push	r20
    4098:	5f 93       	push	r21
    409a:	6f 93       	push	r22
    409c:	7f 93       	push	r23
    409e:	8f 93       	push	r24
    40a0:	9f 93       	push	r25
    40a2:	af 93       	push	r26
    40a4:	bf 93       	push	r27
    40a6:	ef 93       	push	r30
    40a8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    40aa:	80 91 60 0f 	lds	r24, 0x0F60
    40ae:	90 91 61 0f 	lds	r25, 0x0F61
    40b2:	89 2b       	or	r24, r25
    40b4:	29 f0       	breq	.+10     	; 0x40c0 <__vector_44+0x38>
    40b6:	e0 91 60 0f 	lds	r30, 0x0F60
    40ba:	f0 91 61 0f 	lds	r31, 0x0F61
    40be:	09 95       	icall
}
    40c0:	ff 91       	pop	r31
    40c2:	ef 91       	pop	r30
    40c4:	bf 91       	pop	r27
    40c6:	af 91       	pop	r26
    40c8:	9f 91       	pop	r25
    40ca:	8f 91       	pop	r24
    40cc:	7f 91       	pop	r23
    40ce:	6f 91       	pop	r22
    40d0:	5f 91       	pop	r21
    40d2:	4f 91       	pop	r20
    40d4:	3f 91       	pop	r19
    40d6:	2f 91       	pop	r18
    40d8:	0f 90       	pop	r0
    40da:	0f be       	out	0x3f, r0	; 63
    40dc:	0f 90       	pop	r0
    40de:	1f 90       	pop	r1
    40e0:	18 95       	reti

000040e2 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    40e2:	1f 92       	push	r1
    40e4:	0f 92       	push	r0
    40e6:	0f b6       	in	r0, 0x3f	; 63
    40e8:	0f 92       	push	r0
    40ea:	11 24       	eor	r1, r1
    40ec:	2f 93       	push	r18
    40ee:	3f 93       	push	r19
    40f0:	4f 93       	push	r20
    40f2:	5f 93       	push	r21
    40f4:	6f 93       	push	r22
    40f6:	7f 93       	push	r23
    40f8:	8f 93       	push	r24
    40fa:	9f 93       	push	r25
    40fc:	af 93       	push	r26
    40fe:	bf 93       	push	r27
    4100:	ef 93       	push	r30
    4102:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    4104:	80 91 64 0f 	lds	r24, 0x0F64
    4108:	90 91 65 0f 	lds	r25, 0x0F65
    410c:	89 2b       	or	r24, r25
    410e:	29 f0       	breq	.+10     	; 0x411a <__vector_46+0x38>
    4110:	e0 91 64 0f 	lds	r30, 0x0F64
    4114:	f0 91 65 0f 	lds	r31, 0x0F65
    4118:	09 95       	icall
}
    411a:	ff 91       	pop	r31
    411c:	ef 91       	pop	r30
    411e:	bf 91       	pop	r27
    4120:	af 91       	pop	r26
    4122:	9f 91       	pop	r25
    4124:	8f 91       	pop	r24
    4126:	7f 91       	pop	r23
    4128:	6f 91       	pop	r22
    412a:	5f 91       	pop	r21
    412c:	4f 91       	pop	r20
    412e:	3f 91       	pop	r19
    4130:	2f 91       	pop	r18
    4132:	0f 90       	pop	r0
    4134:	0f be       	out	0x3f, r0	; 63
    4136:	0f 90       	pop	r0
    4138:	1f 90       	pop	r1
    413a:	18 95       	reti

0000413c <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    413c:	1f 92       	push	r1
    413e:	0f 92       	push	r0
    4140:	0f b6       	in	r0, 0x3f	; 63
    4142:	0f 92       	push	r0
    4144:	11 24       	eor	r1, r1
    4146:	2f 93       	push	r18
    4148:	3f 93       	push	r19
    414a:	4f 93       	push	r20
    414c:	5f 93       	push	r21
    414e:	6f 93       	push	r22
    4150:	7f 93       	push	r23
    4152:	8f 93       	push	r24
    4154:	9f 93       	push	r25
    4156:	af 93       	push	r26
    4158:	bf 93       	push	r27
    415a:	ef 93       	push	r30
    415c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    415e:	80 91 66 0f 	lds	r24, 0x0F66
    4162:	90 91 67 0f 	lds	r25, 0x0F67
    4166:	89 2b       	or	r24, r25
    4168:	29 f0       	breq	.+10     	; 0x4174 <__vector_47+0x38>
    416a:	e0 91 66 0f 	lds	r30, 0x0F66
    416e:	f0 91 67 0f 	lds	r31, 0x0F67
    4172:	09 95       	icall
}
    4174:	ff 91       	pop	r31
    4176:	ef 91       	pop	r30
    4178:	bf 91       	pop	r27
    417a:	af 91       	pop	r26
    417c:	9f 91       	pop	r25
    417e:	8f 91       	pop	r24
    4180:	7f 91       	pop	r23
    4182:	6f 91       	pop	r22
    4184:	5f 91       	pop	r21
    4186:	4f 91       	pop	r20
    4188:	3f 91       	pop	r19
    418a:	2f 91       	pop	r18
    418c:	0f 90       	pop	r0
    418e:	0f be       	out	0x3f, r0	; 63
    4190:	0f 90       	pop	r0
    4192:	1f 90       	pop	r1
    4194:	18 95       	reti

00004196 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    4196:	1f 92       	push	r1
    4198:	0f 92       	push	r0
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	0f 92       	push	r0
    419e:	11 24       	eor	r1, r1
    41a0:	2f 93       	push	r18
    41a2:	3f 93       	push	r19
    41a4:	4f 93       	push	r20
    41a6:	5f 93       	push	r21
    41a8:	6f 93       	push	r22
    41aa:	7f 93       	push	r23
    41ac:	8f 93       	push	r24
    41ae:	9f 93       	push	r25
    41b0:	af 93       	push	r26
    41b2:	bf 93       	push	r27
    41b4:	ef 93       	push	r30
    41b6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    41b8:	80 91 68 0f 	lds	r24, 0x0F68
    41bc:	90 91 69 0f 	lds	r25, 0x0F69
    41c0:	89 2b       	or	r24, r25
    41c2:	29 f0       	breq	.+10     	; 0x41ce <__vector_48+0x38>
    41c4:	e0 91 68 0f 	lds	r30, 0x0F68
    41c8:	f0 91 69 0f 	lds	r31, 0x0F69
    41cc:	09 95       	icall
}
    41ce:	ff 91       	pop	r31
    41d0:	ef 91       	pop	r30
    41d2:	bf 91       	pop	r27
    41d4:	af 91       	pop	r26
    41d6:	9f 91       	pop	r25
    41d8:	8f 91       	pop	r24
    41da:	7f 91       	pop	r23
    41dc:	6f 91       	pop	r22
    41de:	5f 91       	pop	r21
    41e0:	4f 91       	pop	r20
    41e2:	3f 91       	pop	r19
    41e4:	2f 91       	pop	r18
    41e6:	0f 90       	pop	r0
    41e8:	0f be       	out	0x3f, r0	; 63
    41ea:	0f 90       	pop	r0
    41ec:	1f 90       	pop	r1
    41ee:	18 95       	reti

000041f0 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    41f0:	1f 92       	push	r1
    41f2:	0f 92       	push	r0
    41f4:	0f b6       	in	r0, 0x3f	; 63
    41f6:	0f 92       	push	r0
    41f8:	11 24       	eor	r1, r1
    41fa:	2f 93       	push	r18
    41fc:	3f 93       	push	r19
    41fe:	4f 93       	push	r20
    4200:	5f 93       	push	r21
    4202:	6f 93       	push	r22
    4204:	7f 93       	push	r23
    4206:	8f 93       	push	r24
    4208:	9f 93       	push	r25
    420a:	af 93       	push	r26
    420c:	bf 93       	push	r27
    420e:	ef 93       	push	r30
    4210:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    4212:	80 91 6a 0f 	lds	r24, 0x0F6A
    4216:	90 91 6b 0f 	lds	r25, 0x0F6B
    421a:	89 2b       	or	r24, r25
    421c:	29 f0       	breq	.+10     	; 0x4228 <__vector_49+0x38>
    421e:	e0 91 6a 0f 	lds	r30, 0x0F6A
    4222:	f0 91 6b 0f 	lds	r31, 0x0F6B
    4226:	09 95       	icall
}
    4228:	ff 91       	pop	r31
    422a:	ef 91       	pop	r30
    422c:	bf 91       	pop	r27
    422e:	af 91       	pop	r26
    4230:	9f 91       	pop	r25
    4232:	8f 91       	pop	r24
    4234:	7f 91       	pop	r23
    4236:	6f 91       	pop	r22
    4238:	5f 91       	pop	r21
    423a:	4f 91       	pop	r20
    423c:	3f 91       	pop	r19
    423e:	2f 91       	pop	r18
    4240:	0f 90       	pop	r0
    4242:	0f be       	out	0x3f, r0	; 63
    4244:	0f 90       	pop	r0
    4246:	1f 90       	pop	r1
    4248:	18 95       	reti

0000424a <__vector_default>:

ISR(BADISR_vect)
{
    424a:	1f 92       	push	r1
    424c:	0f 92       	push	r0
    424e:	0f b6       	in	r0, 0x3f	; 63
    4250:	0f 92       	push	r0
    4252:	11 24       	eor	r1, r1
    4254:	2f 93       	push	r18
    4256:	3f 93       	push	r19
    4258:	4f 93       	push	r20
    425a:	5f 93       	push	r21
    425c:	6f 93       	push	r22
    425e:	7f 93       	push	r23
    4260:	8f 93       	push	r24
    4262:	9f 93       	push	r25
    4264:	af 93       	push	r26
    4266:	bf 93       	push	r27
    4268:	ef 93       	push	r30
    426a:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    426c:	00 d0       	rcall	.+0      	; 0x426e <__vector_default+0x24>
    426e:	0f 92       	push	r0
    4270:	81 e0       	ldi	r24, 0x01	; 1
    4272:	ed b7       	in	r30, 0x3d	; 61
    4274:	fe b7       	in	r31, 0x3e	; 62
    4276:	81 83       	std	Z+1, r24	; 0x01
    4278:	85 ec       	ldi	r24, 0xC5	; 197
    427a:	91 e0       	ldi	r25, 0x01	; 1
    427c:	93 83       	std	Z+3, r25	; 0x03
    427e:	82 83       	std	Z+2, r24	; 0x02
    4280:	0e 94 ef 28 	call	0x51de	; 0x51de <rprintf1RamRom>
    4284:	0f 90       	pop	r0
    4286:	0f 90       	pop	r0
    4288:	0f 90       	pop	r0
}
    428a:	ff 91       	pop	r31
    428c:	ef 91       	pop	r30
    428e:	bf 91       	pop	r27
    4290:	af 91       	pop	r26
    4292:	9f 91       	pop	r25
    4294:	8f 91       	pop	r24
    4296:	7f 91       	pop	r23
    4298:	6f 91       	pop	r22
    429a:	5f 91       	pop	r21
    429c:	4f 91       	pop	r20
    429e:	3f 91       	pop	r19
    42a0:	2f 91       	pop	r18
    42a2:	0f 90       	pop	r0
    42a4:	0f be       	out	0x3f, r0	; 63
    42a6:	0f 90       	pop	r0
    42a8:	1f 90       	pop	r1
    42aa:	18 95       	reti

000042ac <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    42ac:	84 30       	cpi	r24, 0x04	; 4
    42ae:	40 f4       	brcc	.+16     	; 0x42c0 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    42b0:	e8 2f       	mov	r30, r24
    42b2:	f0 e0       	ldi	r31, 0x00	; 0
    42b4:	ee 0f       	add	r30, r30
    42b6:	ff 1f       	adc	r31, r31
    42b8:	e2 55       	subi	r30, 0x52	; 82
    42ba:	fe 4e       	sbci	r31, 0xEE	; 238
    42bc:	71 83       	std	Z+1, r23	; 0x01
    42be:	60 83       	st	Z, r22
    42c0:	08 95       	ret

000042c2 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    42c2:	1f 93       	push	r17
    42c4:	18 2f       	mov	r17, r24
    42c6:	9a 01       	movw	r18, r20
    42c8:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    42ca:	ca 01       	movw	r24, r20
    42cc:	b9 01       	movw	r22, r18
    42ce:	60 58       	subi	r22, 0x80	; 128
    42d0:	7b 47       	sbci	r23, 0x7B	; 123
    42d2:	81 4e       	sbci	r24, 0xE1	; 225
    42d4:	9f 4f       	sbci	r25, 0xFF	; 255
    42d6:	f3 e0       	ldi	r31, 0x03	; 3
    42d8:	66 0f       	add	r22, r22
    42da:	77 1f       	adc	r23, r23
    42dc:	88 1f       	adc	r24, r24
    42de:	99 1f       	adc	r25, r25
    42e0:	fa 95       	dec	r31
    42e2:	d1 f7       	brne	.-12     	; 0x42d8 <uartSetBaudRate+0x16>
    42e4:	e4 e0       	ldi	r30, 0x04	; 4
    42e6:	22 0f       	add	r18, r18
    42e8:	33 1f       	adc	r19, r19
    42ea:	44 1f       	adc	r20, r20
    42ec:	55 1f       	adc	r21, r21
    42ee:	ea 95       	dec	r30
    42f0:	d1 f7       	brne	.-12     	; 0x42e6 <uartSetBaudRate+0x24>
    42f2:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodsi4>
    42f6:	21 50       	subi	r18, 0x01	; 1
    42f8:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    42fa:	13 30       	cpi	r17, 0x03	; 3
    42fc:	29 f4       	brne	.+10     	; 0x4308 <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    42fe:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    4302:	30 93 35 01 	sts	0x0135, r19
    4306:	12 c0       	rjmp	.+36     	; 0x432c <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    4308:	12 30       	cpi	r17, 0x02	; 2
    430a:	29 f4       	brne	.+10     	; 0x4316 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    430c:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    4310:	30 93 d5 00 	sts	0x00D5, r19
    4314:	0b c0       	rjmp	.+22     	; 0x432c <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    4316:	11 30       	cpi	r17, 0x01	; 1
    4318:	29 f4       	brne	.+10     	; 0x4324 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    431a:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    431e:	30 93 cd 00 	sts	0x00CD, r19
    4322:	04 c0       	rjmp	.+8      	; 0x432c <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    4324:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    4328:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    432c:	1f 91       	pop	r17
    432e:	08 95       	ret

00004330 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    4330:	28 2f       	mov	r18, r24
    4332:	30 e0       	ldi	r19, 0x00	; 0
    4334:	a3 e0       	ldi	r26, 0x03	; 3
    4336:	22 0f       	add	r18, r18
    4338:	33 1f       	adc	r19, r19
    433a:	aa 95       	dec	r26
    433c:	e1 f7       	brne	.-8      	; 0x4336 <uartGetRxBuffer+0x6>
    433e:	2a 5c       	subi	r18, 0xCA	; 202
    4340:	3d 4e       	sbci	r19, 0xED	; 237
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    4342:	c9 01       	movw	r24, r18
    4344:	08 95       	ret

00004346 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    4346:	28 2f       	mov	r18, r24
    4348:	30 e0       	ldi	r19, 0x00	; 0
    434a:	b3 e0       	ldi	r27, 0x03	; 3
    434c:	22 0f       	add	r18, r18
    434e:	33 1f       	adc	r19, r19
    4350:	ba 95       	dec	r27
    4352:	e1 f7       	brne	.-8      	; 0x434c <uartGetTxBuffer+0x6>
    4354:	26 5a       	subi	r18, 0xA6	; 166
    4356:	3d 4e       	sbci	r19, 0xED	; 237
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    4358:	c9 01       	movw	r24, r18
    435a:	08 95       	ret

0000435c <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    435c:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    435e:	83 30       	cpi	r24, 0x03	; 3
    4360:	39 f4       	brne	.+14     	; 0x4370 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    4362:	80 91 30 01 	lds	r24, 0x0130
    4366:	85 ff       	sbrs	r24, 5
    4368:	fc cf       	rjmp	.-8      	; 0x4362 <uartSendByte+0x6>
		outb(UDR3, txData);
    436a:	60 93 36 01 	sts	0x0136, r22
    436e:	18 c0       	rjmp	.+48     	; 0x43a0 <uartSendByte+0x44>
	}
	else if(nUart==2)
    4370:	82 30       	cpi	r24, 0x02	; 2
    4372:	39 f4       	brne	.+14     	; 0x4382 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    4374:	80 91 d0 00 	lds	r24, 0x00D0
    4378:	85 ff       	sbrs	r24, 5
    437a:	fc cf       	rjmp	.-8      	; 0x4374 <uartSendByte+0x18>
		outb(UDR2, txData);
    437c:	60 93 d6 00 	sts	0x00D6, r22
    4380:	0f c0       	rjmp	.+30     	; 0x43a0 <uartSendByte+0x44>
	}
	else if(nUart==1)
    4382:	81 30       	cpi	r24, 0x01	; 1
    4384:	39 f4       	brne	.+14     	; 0x4394 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    4386:	80 91 c8 00 	lds	r24, 0x00C8
    438a:	85 ff       	sbrs	r24, 5
    438c:	fc cf       	rjmp	.-8      	; 0x4386 <uartSendByte+0x2a>
		outb(UDR1, txData);
    438e:	60 93 ce 00 	sts	0x00CE, r22
    4392:	06 c0       	rjmp	.+12     	; 0x43a0 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    4394:	80 91 c0 00 	lds	r24, 0x00C0
    4398:	85 ff       	sbrs	r24, 5
    439a:	fc cf       	rjmp	.-8      	; 0x4394 <uartSendByte+0x38>
		outb(UDR0, txData);
    439c:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    43a0:	f0 e0       	ldi	r31, 0x00	; 0
    43a2:	ee 5c       	subi	r30, 0xCE	; 206
    43a4:	fd 4e       	sbci	r31, 0xED	; 237
    43a6:	10 82       	st	Z, r1
}
    43a8:	08 95       	ret

000043aa <uart0SendByte>:

void uart0SendByte(u08 data)
{
    43aa:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    43ac:	80 e0       	ldi	r24, 0x00	; 0
    43ae:	0e 94 ae 21 	call	0x435c	; 0x435c <uartSendByte>
}
    43b2:	08 95       	ret

000043b4 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    43b4:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    43b6:	81 e0       	ldi	r24, 0x01	; 1
    43b8:	0e 94 ae 21 	call	0x435c	; 0x435c <uartSendByte>
}
    43bc:	08 95       	ret

000043be <uart2SendByte>:

void uart2SendByte(u08 data)
{
    43be:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    43c0:	82 e0       	ldi	r24, 0x02	; 2
    43c2:	0e 94 ae 21 	call	0x435c	; 0x435c <uartSendByte>
}
    43c6:	08 95       	ret

000043c8 <uart3SendByte>:

void uart3SendByte(u08 data)
{
    43c8:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    43ca:	83 e0       	ldi	r24, 0x03	; 3
    43cc:	0e 94 ae 21 	call	0x435c	; 0x435c <uartSendByte>
}
    43d0:	08 95       	ret

000043d2 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    43d2:	20 e0       	ldi	r18, 0x00	; 0
    43d4:	e8 2f       	mov	r30, r24
    43d6:	f0 e0       	ldi	r31, 0x00	; 0
    43d8:	83 e0       	ldi	r24, 0x03	; 3
    43da:	ee 0f       	add	r30, r30
    43dc:	ff 1f       	adc	r31, r31
    43de:	8a 95       	dec	r24
    43e0:	e1 f7       	brne	.-8      	; 0x43da <uartReceiveBufferIsEmpty+0x8>
    43e2:	e6 5c       	subi	r30, 0xC6	; 198
    43e4:	fd 4e       	sbci	r31, 0xED	; 237
    43e6:	80 81       	ld	r24, Z
    43e8:	91 81       	ldd	r25, Z+1	; 0x01
    43ea:	89 2b       	or	r24, r25
    43ec:	09 f4       	brne	.+2      	; 0x43f0 <uartReceiveBufferIsEmpty+0x1e>
    43ee:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    43f0:	82 2f       	mov	r24, r18
    43f2:	08 95       	ret

000043f4 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    43f4:	cf 93       	push	r28
    43f6:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    43f8:	83 30       	cpi	r24, 0x03	; 3
    43fa:	19 f4       	brne	.+6      	; 0x4402 <uartReceiveService+0xe>
		c = inb(UDR3);
    43fc:	60 91 36 01 	lds	r22, 0x0136
    4400:	0c c0       	rjmp	.+24     	; 0x441a <uartReceiveService+0x26>
	else if(nUart==2)
    4402:	82 30       	cpi	r24, 0x02	; 2
    4404:	19 f4       	brne	.+6      	; 0x440c <uartReceiveService+0x18>
		c = inb(UDR2);
    4406:	60 91 d6 00 	lds	r22, 0x00D6
    440a:	07 c0       	rjmp	.+14     	; 0x441a <uartReceiveService+0x26>
	else if(nUart==1)
    440c:	81 30       	cpi	r24, 0x01	; 1
    440e:	19 f4       	brne	.+6      	; 0x4416 <uartReceiveService+0x22>
		c = inb(UDR1);
    4410:	60 91 ce 00 	lds	r22, 0x00CE
    4414:	02 c0       	rjmp	.+4      	; 0x441a <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    4416:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    441a:	28 2f       	mov	r18, r24
    441c:	30 e0       	ldi	r19, 0x00	; 0
    441e:	e9 01       	movw	r28, r18
    4420:	cc 0f       	add	r28, r28
    4422:	dd 1f       	adc	r29, r29
    4424:	fe 01       	movw	r30, r28
    4426:	e2 55       	subi	r30, 0x52	; 82
    4428:	fe 4e       	sbci	r31, 0xEE	; 238
    442a:	80 81       	ld	r24, Z
    442c:	91 81       	ldd	r25, Z+1	; 0x01
    442e:	89 2b       	or	r24, r25
    4430:	31 f0       	breq	.+12     	; 0x443e <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    4432:	01 90       	ld	r0, Z+
    4434:	f0 81       	ld	r31, Z
    4436:	e0 2d       	mov	r30, r0
    4438:	86 2f       	mov	r24, r22
    443a:	09 95       	icall
    443c:	14 c0       	rjmp	.+40     	; 0x4466 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    443e:	93 e0       	ldi	r25, 0x03	; 3
    4440:	22 0f       	add	r18, r18
    4442:	33 1f       	adc	r19, r19
    4444:	9a 95       	dec	r25
    4446:	e1 f7       	brne	.-8      	; 0x4440 <uartReceiveService+0x4c>
    4448:	c9 01       	movw	r24, r18
    444a:	8a 5c       	subi	r24, 0xCA	; 202
    444c:	9d 4e       	sbci	r25, 0xED	; 237
    444e:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
    4452:	88 23       	and	r24, r24
    4454:	41 f4       	brne	.+16     	; 0x4466 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    4456:	fe 01       	movw	r30, r28
    4458:	e6 58       	subi	r30, 0x86	; 134
    445a:	fd 4e       	sbci	r31, 0xED	; 237
    445c:	80 81       	ld	r24, Z
    445e:	91 81       	ldd	r25, Z+1	; 0x01
    4460:	01 96       	adiw	r24, 0x01	; 1
    4462:	91 83       	std	Z+1, r25	; 0x01
    4464:	80 83       	st	Z, r24
		}
	}
}
    4466:	df 91       	pop	r29
    4468:	cf 91       	pop	r28
    446a:	08 95       	ret

0000446c <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    446c:	1f 92       	push	r1
    446e:	0f 92       	push	r0
    4470:	0f b6       	in	r0, 0x3f	; 63
    4472:	0f 92       	push	r0
    4474:	11 24       	eor	r1, r1
    4476:	2f 93       	push	r18
    4478:	3f 93       	push	r19
    447a:	4f 93       	push	r20
    447c:	5f 93       	push	r21
    447e:	6f 93       	push	r22
    4480:	7f 93       	push	r23
    4482:	8f 93       	push	r24
    4484:	9f 93       	push	r25
    4486:	af 93       	push	r26
    4488:	bf 93       	push	r27
    448a:	ef 93       	push	r30
    448c:	ff 93       	push	r31
	uartReceiveService(3);
    448e:	83 e0       	ldi	r24, 0x03	; 3
    4490:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <uartReceiveService>
}
    4494:	ff 91       	pop	r31
    4496:	ef 91       	pop	r30
    4498:	bf 91       	pop	r27
    449a:	af 91       	pop	r26
    449c:	9f 91       	pop	r25
    449e:	8f 91       	pop	r24
    44a0:	7f 91       	pop	r23
    44a2:	6f 91       	pop	r22
    44a4:	5f 91       	pop	r21
    44a6:	4f 91       	pop	r20
    44a8:	3f 91       	pop	r19
    44aa:	2f 91       	pop	r18
    44ac:	0f 90       	pop	r0
    44ae:	0f be       	out	0x3f, r0	; 63
    44b0:	0f 90       	pop	r0
    44b2:	1f 90       	pop	r1
    44b4:	18 95       	reti

000044b6 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    44b6:	1f 92       	push	r1
    44b8:	0f 92       	push	r0
    44ba:	0f b6       	in	r0, 0x3f	; 63
    44bc:	0f 92       	push	r0
    44be:	11 24       	eor	r1, r1
    44c0:	2f 93       	push	r18
    44c2:	3f 93       	push	r19
    44c4:	4f 93       	push	r20
    44c6:	5f 93       	push	r21
    44c8:	6f 93       	push	r22
    44ca:	7f 93       	push	r23
    44cc:	8f 93       	push	r24
    44ce:	9f 93       	push	r25
    44d0:	af 93       	push	r26
    44d2:	bf 93       	push	r27
    44d4:	ef 93       	push	r30
    44d6:	ff 93       	push	r31
	uartReceiveService(2);
    44d8:	82 e0       	ldi	r24, 0x02	; 2
    44da:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <uartReceiveService>
}
    44de:	ff 91       	pop	r31
    44e0:	ef 91       	pop	r30
    44e2:	bf 91       	pop	r27
    44e4:	af 91       	pop	r26
    44e6:	9f 91       	pop	r25
    44e8:	8f 91       	pop	r24
    44ea:	7f 91       	pop	r23
    44ec:	6f 91       	pop	r22
    44ee:	5f 91       	pop	r21
    44f0:	4f 91       	pop	r20
    44f2:	3f 91       	pop	r19
    44f4:	2f 91       	pop	r18
    44f6:	0f 90       	pop	r0
    44f8:	0f be       	out	0x3f, r0	; 63
    44fa:	0f 90       	pop	r0
    44fc:	1f 90       	pop	r1
    44fe:	18 95       	reti

00004500 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    4500:	1f 92       	push	r1
    4502:	0f 92       	push	r0
    4504:	0f b6       	in	r0, 0x3f	; 63
    4506:	0f 92       	push	r0
    4508:	11 24       	eor	r1, r1
    450a:	2f 93       	push	r18
    450c:	3f 93       	push	r19
    450e:	4f 93       	push	r20
    4510:	5f 93       	push	r21
    4512:	6f 93       	push	r22
    4514:	7f 93       	push	r23
    4516:	8f 93       	push	r24
    4518:	9f 93       	push	r25
    451a:	af 93       	push	r26
    451c:	bf 93       	push	r27
    451e:	ef 93       	push	r30
    4520:	ff 93       	push	r31
	uartReceiveService(1);
    4522:	81 e0       	ldi	r24, 0x01	; 1
    4524:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <uartReceiveService>
}
    4528:	ff 91       	pop	r31
    452a:	ef 91       	pop	r30
    452c:	bf 91       	pop	r27
    452e:	af 91       	pop	r26
    4530:	9f 91       	pop	r25
    4532:	8f 91       	pop	r24
    4534:	7f 91       	pop	r23
    4536:	6f 91       	pop	r22
    4538:	5f 91       	pop	r21
    453a:	4f 91       	pop	r20
    453c:	3f 91       	pop	r19
    453e:	2f 91       	pop	r18
    4540:	0f 90       	pop	r0
    4542:	0f be       	out	0x3f, r0	; 63
    4544:	0f 90       	pop	r0
    4546:	1f 90       	pop	r1
    4548:	18 95       	reti

0000454a <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    454a:	1f 92       	push	r1
    454c:	0f 92       	push	r0
    454e:	0f b6       	in	r0, 0x3f	; 63
    4550:	0f 92       	push	r0
    4552:	11 24       	eor	r1, r1
    4554:	2f 93       	push	r18
    4556:	3f 93       	push	r19
    4558:	4f 93       	push	r20
    455a:	5f 93       	push	r21
    455c:	6f 93       	push	r22
    455e:	7f 93       	push	r23
    4560:	8f 93       	push	r24
    4562:	9f 93       	push	r25
    4564:	af 93       	push	r26
    4566:	bf 93       	push	r27
    4568:	ef 93       	push	r30
    456a:	ff 93       	push	r31
	uartReceiveService(0);
    456c:	80 e0       	ldi	r24, 0x00	; 0
    456e:	0e 94 fa 21 	call	0x43f4	; 0x43f4 <uartReceiveService>
}
    4572:	ff 91       	pop	r31
    4574:	ef 91       	pop	r30
    4576:	bf 91       	pop	r27
    4578:	af 91       	pop	r26
    457a:	9f 91       	pop	r25
    457c:	8f 91       	pop	r24
    457e:	7f 91       	pop	r23
    4580:	6f 91       	pop	r22
    4582:	5f 91       	pop	r21
    4584:	4f 91       	pop	r20
    4586:	3f 91       	pop	r19
    4588:	2f 91       	pop	r18
    458a:	0f 90       	pop	r0
    458c:	0f be       	out	0x3f, r0	; 63
    458e:	0f 90       	pop	r0
    4590:	1f 90       	pop	r1
    4592:	18 95       	reti

00004594 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    4594:	8f 92       	push	r8
    4596:	9f 92       	push	r9
    4598:	af 92       	push	r10
    459a:	bf 92       	push	r11
    459c:	cf 92       	push	r12
    459e:	df 92       	push	r13
    45a0:	ef 92       	push	r14
    45a2:	ff 92       	push	r15
    45a4:	0f 93       	push	r16
    45a6:	1f 93       	push	r17
    45a8:	cf 93       	push	r28
    45aa:	df 93       	push	r29
    45ac:	88 2e       	mov	r8, r24
    45ae:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    45b0:	c8 2e       	mov	r12, r24
    45b2:	dd 24       	eor	r13, r13
    45b4:	f6 01       	movw	r30, r12
    45b6:	13 e0       	ldi	r17, 0x03	; 3
    45b8:	ee 0f       	add	r30, r30
    45ba:	ff 1f       	adc	r31, r31
    45bc:	1a 95       	dec	r17
    45be:	e1 f7       	brne	.-8      	; 0x45b8 <uartSendBuffer+0x24>
    45c0:	e2 5a       	subi	r30, 0xA2	; 162
    45c2:	fd 4e       	sbci	r31, 0xED	; 237
    45c4:	20 81       	ld	r18, Z
    45c6:	31 81       	ldd	r19, Z+1	; 0x01
    45c8:	24 0f       	add	r18, r20
    45ca:	35 1f       	adc	r19, r21
    45cc:	f6 01       	movw	r30, r12
    45ce:	73 e0       	ldi	r23, 0x03	; 3
    45d0:	ee 0f       	add	r30, r30
    45d2:	ff 1f       	adc	r31, r31
    45d4:	7a 95       	dec	r23
    45d6:	e1 f7       	brne	.-8      	; 0x45d0 <uartSendBuffer+0x3c>
    45d8:	e4 5a       	subi	r30, 0xA4	; 164
    45da:	fd 4e       	sbci	r31, 0xED	; 237
    45dc:	80 81       	ld	r24, Z
    45de:	91 81       	ldd	r25, Z+1	; 0x01
    45e0:	28 17       	cp	r18, r24
    45e2:	39 07       	cpc	r19, r25
    45e4:	70 f5       	brcc	.+92     	; 0x4642 <uartSendBuffer+0xae>
    45e6:	41 15       	cp	r20, r1
    45e8:	51 05       	cpc	r21, r1
    45ea:	59 f1       	breq	.+86     	; 0x4642 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    45ec:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    45ee:	76 01       	movw	r14, r12
    45f0:	63 e0       	ldi	r22, 0x03	; 3
    45f2:	ee 0c       	add	r14, r14
    45f4:	ff 1c       	adc	r15, r15
    45f6:	6a 95       	dec	r22
    45f8:	e1 f7       	brne	.-8      	; 0x45f2 <uartSendBuffer+0x5e>
    45fa:	8a e5       	ldi	r24, 0x5A	; 90
    45fc:	92 e1       	ldi	r25, 0x12	; 18
    45fe:	e8 0e       	add	r14, r24
    4600:	f9 1e       	adc	r15, r25
    4602:	8d 01       	movw	r16, r26
    4604:	c0 e0       	ldi	r28, 0x00	; 0
    4606:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    4608:	5a 01       	movw	r10, r20
    460a:	08 94       	sec
    460c:	a1 08       	sbc	r10, r1
    460e:	b1 08       	sbc	r11, r1
    4610:	06 c0       	rjmp	.+12     	; 0x461e <uartSendBuffer+0x8a>
    4612:	c7 01       	movw	r24, r14
    4614:	f8 01       	movw	r30, r16
    4616:	60 81       	ld	r22, Z
    4618:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
    461c:	21 96       	adiw	r28, 0x01	; 1
    461e:	0f 5f       	subi	r16, 0xFF	; 255
    4620:	1f 4f       	sbci	r17, 0xFF	; 255
    4622:	ca 15       	cp	r28, r10
    4624:	db 05       	cpc	r29, r11
    4626:	a8 f3       	brcs	.-22     	; 0x4612 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    4628:	86 e5       	ldi	r24, 0x56	; 86
    462a:	92 e1       	ldi	r25, 0x12	; 18
    462c:	c8 0e       	add	r12, r24
    462e:	d9 1e       	adc	r13, r25
    4630:	8f ef       	ldi	r24, 0xFF	; 255
    4632:	f6 01       	movw	r30, r12
    4634:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    4636:	88 2d       	mov	r24, r8
    4638:	69 2d       	mov	r22, r9
    463a:	0e 94 ae 21 	call	0x435c	; 0x435c <uartSendByte>
    463e:	8f ef       	ldi	r24, 0xFF	; 255
    4640:	01 c0       	rjmp	.+2      	; 0x4644 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    4642:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    4644:	df 91       	pop	r29
    4646:	cf 91       	pop	r28
    4648:	1f 91       	pop	r17
    464a:	0f 91       	pop	r16
    464c:	ff 90       	pop	r15
    464e:	ef 90       	pop	r14
    4650:	df 90       	pop	r13
    4652:	cf 90       	pop	r12
    4654:	bf 90       	pop	r11
    4656:	af 90       	pop	r10
    4658:	9f 90       	pop	r9
    465a:	8f 90       	pop	r8
    465c:	08 95       	ret

0000465e <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    465e:	90 e0       	ldi	r25, 0x00	; 0
    4660:	23 e0       	ldi	r18, 0x03	; 3
    4662:	88 0f       	add	r24, r24
    4664:	99 1f       	adc	r25, r25
    4666:	2a 95       	dec	r18
    4668:	e1 f7       	brne	.-8      	; 0x4662 <uartAddToTxBuffer+0x4>
    466a:	86 5a       	subi	r24, 0xA6	; 166
    466c:	9d 4e       	sbci	r25, 0xED	; 237
    466e:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
}
    4672:	08 95       	ret

00004674 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    4674:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4676:	82 e7       	ldi	r24, 0x72	; 114
    4678:	92 e1       	ldi	r25, 0x12	; 18
    467a:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    467e:	08 95       	ret

00004680 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    4680:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    4682:	8a e6       	ldi	r24, 0x6A	; 106
    4684:	92 e1       	ldi	r25, 0x12	; 18
    4686:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    468a:	08 95       	ret

0000468c <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    468c:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    468e:	82 e6       	ldi	r24, 0x62	; 98
    4690:	92 e1       	ldi	r25, 0x12	; 18
    4692:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    4696:	08 95       	ret

00004698 <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    4698:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    469a:	8a e5       	ldi	r24, 0x5A	; 90
    469c:	92 e1       	ldi	r25, 0x12	; 18
    469e:	0e 94 06 26 	call	0x4c0c	; 0x4c0c <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    46a2:	08 95       	ret

000046a4 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    46a4:	cf 93       	push	r28
    46a6:	df 93       	push	r29
    46a8:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    46aa:	a8 2f       	mov	r26, r24
    46ac:	b0 e0       	ldi	r27, 0x00	; 0
    46ae:	ed 01       	movw	r28, r26
    46b0:	ca 5a       	subi	r28, 0xAA	; 170
    46b2:	dd 4e       	sbci	r29, 0xED	; 237
    46b4:	88 81       	ld	r24, Y
    46b6:	88 23       	and	r24, r24
    46b8:	79 f1       	breq	.+94     	; 0x4718 <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    46ba:	fd 01       	movw	r30, r26
    46bc:	33 e0       	ldi	r19, 0x03	; 3
    46be:	ee 0f       	add	r30, r30
    46c0:	ff 1f       	adc	r31, r31
    46c2:	3a 95       	dec	r19
    46c4:	e1 f7       	brne	.-8      	; 0x46be <uartTransmitService+0x1a>
    46c6:	e2 5a       	subi	r30, 0xA2	; 162
    46c8:	fd 4e       	sbci	r31, 0xED	; 237
    46ca:	80 81       	ld	r24, Z
    46cc:	91 81       	ldd	r25, Z+1	; 0x01
    46ce:	89 2b       	or	r24, r25
    46d0:	11 f1       	breq	.+68     	; 0x4716 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    46d2:	23 30       	cpi	r18, 0x03	; 3
    46d4:	39 f4       	brne	.+14     	; 0x46e4 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    46d6:	82 e7       	ldi	r24, 0x72	; 114
    46d8:	92 e1       	ldi	r25, 0x12	; 18
    46da:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <bufferGetFromFront>
    46de:	80 93 36 01 	sts	0x0136, r24
    46e2:	1e c0       	rjmp	.+60     	; 0x4720 <uartTransmitService+0x7c>
			else if(nUart==2)
    46e4:	22 30       	cpi	r18, 0x02	; 2
    46e6:	39 f4       	brne	.+14     	; 0x46f6 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    46e8:	8a e6       	ldi	r24, 0x6A	; 106
    46ea:	92 e1       	ldi	r25, 0x12	; 18
    46ec:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <bufferGetFromFront>
    46f0:	80 93 d6 00 	sts	0x00D6, r24
    46f4:	15 c0       	rjmp	.+42     	; 0x4720 <uartTransmitService+0x7c>
			else if(nUart==1)
    46f6:	21 30       	cpi	r18, 0x01	; 1
    46f8:	39 f4       	brne	.+14     	; 0x4708 <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    46fa:	82 e6       	ldi	r24, 0x62	; 98
    46fc:	92 e1       	ldi	r25, 0x12	; 18
    46fe:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <bufferGetFromFront>
    4702:	80 93 ce 00 	sts	0x00CE, r24
    4706:	0c c0       	rjmp	.+24     	; 0x4720 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    4708:	8a e5       	ldi	r24, 0x5A	; 90
    470a:	92 e1       	ldi	r25, 0x12	; 18
    470c:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <bufferGetFromFront>
    4710:	80 93 c6 00 	sts	0x00C6, r24
    4714:	05 c0       	rjmp	.+10     	; 0x4720 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    4716:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    4718:	ae 5c       	subi	r26, 0xCE	; 206
    471a:	bd 4e       	sbci	r27, 0xED	; 237
    471c:	8f ef       	ldi	r24, 0xFF	; 255
    471e:	8c 93       	st	X, r24
	}
}
    4720:	df 91       	pop	r29
    4722:	cf 91       	pop	r28
    4724:	08 95       	ret

00004726 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    4726:	1f 92       	push	r1
    4728:	0f 92       	push	r0
    472a:	0f b6       	in	r0, 0x3f	; 63
    472c:	0f 92       	push	r0
    472e:	11 24       	eor	r1, r1
    4730:	2f 93       	push	r18
    4732:	3f 93       	push	r19
    4734:	4f 93       	push	r20
    4736:	5f 93       	push	r21
    4738:	6f 93       	push	r22
    473a:	7f 93       	push	r23
    473c:	8f 93       	push	r24
    473e:	9f 93       	push	r25
    4740:	af 93       	push	r26
    4742:	bf 93       	push	r27
    4744:	ef 93       	push	r30
    4746:	ff 93       	push	r31
	uartTransmitService(3);
    4748:	83 e0       	ldi	r24, 0x03	; 3
    474a:	0e 94 52 23 	call	0x46a4	; 0x46a4 <uartTransmitService>
}
    474e:	ff 91       	pop	r31
    4750:	ef 91       	pop	r30
    4752:	bf 91       	pop	r27
    4754:	af 91       	pop	r26
    4756:	9f 91       	pop	r25
    4758:	8f 91       	pop	r24
    475a:	7f 91       	pop	r23
    475c:	6f 91       	pop	r22
    475e:	5f 91       	pop	r21
    4760:	4f 91       	pop	r20
    4762:	3f 91       	pop	r19
    4764:	2f 91       	pop	r18
    4766:	0f 90       	pop	r0
    4768:	0f be       	out	0x3f, r0	; 63
    476a:	0f 90       	pop	r0
    476c:	1f 90       	pop	r1
    476e:	18 95       	reti

00004770 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    4770:	1f 92       	push	r1
    4772:	0f 92       	push	r0
    4774:	0f b6       	in	r0, 0x3f	; 63
    4776:	0f 92       	push	r0
    4778:	11 24       	eor	r1, r1
    477a:	2f 93       	push	r18
    477c:	3f 93       	push	r19
    477e:	4f 93       	push	r20
    4780:	5f 93       	push	r21
    4782:	6f 93       	push	r22
    4784:	7f 93       	push	r23
    4786:	8f 93       	push	r24
    4788:	9f 93       	push	r25
    478a:	af 93       	push	r26
    478c:	bf 93       	push	r27
    478e:	ef 93       	push	r30
    4790:	ff 93       	push	r31
	uartTransmitService(2);
    4792:	82 e0       	ldi	r24, 0x02	; 2
    4794:	0e 94 52 23 	call	0x46a4	; 0x46a4 <uartTransmitService>
}
    4798:	ff 91       	pop	r31
    479a:	ef 91       	pop	r30
    479c:	bf 91       	pop	r27
    479e:	af 91       	pop	r26
    47a0:	9f 91       	pop	r25
    47a2:	8f 91       	pop	r24
    47a4:	7f 91       	pop	r23
    47a6:	6f 91       	pop	r22
    47a8:	5f 91       	pop	r21
    47aa:	4f 91       	pop	r20
    47ac:	3f 91       	pop	r19
    47ae:	2f 91       	pop	r18
    47b0:	0f 90       	pop	r0
    47b2:	0f be       	out	0x3f, r0	; 63
    47b4:	0f 90       	pop	r0
    47b6:	1f 90       	pop	r1
    47b8:	18 95       	reti

000047ba <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    47ba:	1f 92       	push	r1
    47bc:	0f 92       	push	r0
    47be:	0f b6       	in	r0, 0x3f	; 63
    47c0:	0f 92       	push	r0
    47c2:	11 24       	eor	r1, r1
    47c4:	2f 93       	push	r18
    47c6:	3f 93       	push	r19
    47c8:	4f 93       	push	r20
    47ca:	5f 93       	push	r21
    47cc:	6f 93       	push	r22
    47ce:	7f 93       	push	r23
    47d0:	8f 93       	push	r24
    47d2:	9f 93       	push	r25
    47d4:	af 93       	push	r26
    47d6:	bf 93       	push	r27
    47d8:	ef 93       	push	r30
    47da:	ff 93       	push	r31
	uartTransmitService(1);
    47dc:	81 e0       	ldi	r24, 0x01	; 1
    47de:	0e 94 52 23 	call	0x46a4	; 0x46a4 <uartTransmitService>
}
    47e2:	ff 91       	pop	r31
    47e4:	ef 91       	pop	r30
    47e6:	bf 91       	pop	r27
    47e8:	af 91       	pop	r26
    47ea:	9f 91       	pop	r25
    47ec:	8f 91       	pop	r24
    47ee:	7f 91       	pop	r23
    47f0:	6f 91       	pop	r22
    47f2:	5f 91       	pop	r21
    47f4:	4f 91       	pop	r20
    47f6:	3f 91       	pop	r19
    47f8:	2f 91       	pop	r18
    47fa:	0f 90       	pop	r0
    47fc:	0f be       	out	0x3f, r0	; 63
    47fe:	0f 90       	pop	r0
    4800:	1f 90       	pop	r1
    4802:	18 95       	reti

00004804 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    4804:	1f 92       	push	r1
    4806:	0f 92       	push	r0
    4808:	0f b6       	in	r0, 0x3f	; 63
    480a:	0f 92       	push	r0
    480c:	11 24       	eor	r1, r1
    480e:	2f 93       	push	r18
    4810:	3f 93       	push	r19
    4812:	4f 93       	push	r20
    4814:	5f 93       	push	r21
    4816:	6f 93       	push	r22
    4818:	7f 93       	push	r23
    481a:	8f 93       	push	r24
    481c:	9f 93       	push	r25
    481e:	af 93       	push	r26
    4820:	bf 93       	push	r27
    4822:	ef 93       	push	r30
    4824:	ff 93       	push	r31
	uartTransmitService(0);
    4826:	80 e0       	ldi	r24, 0x00	; 0
    4828:	0e 94 52 23 	call	0x46a4	; 0x46a4 <uartTransmitService>
}
    482c:	ff 91       	pop	r31
    482e:	ef 91       	pop	r30
    4830:	bf 91       	pop	r27
    4832:	af 91       	pop	r26
    4834:	9f 91       	pop	r25
    4836:	8f 91       	pop	r24
    4838:	7f 91       	pop	r23
    483a:	6f 91       	pop	r22
    483c:	5f 91       	pop	r21
    483e:	4f 91       	pop	r20
    4840:	3f 91       	pop	r19
    4842:	2f 91       	pop	r18
    4844:	0f 90       	pop	r0
    4846:	0f be       	out	0x3f, r0	; 63
    4848:	0f 90       	pop	r0
    484a:	1f 90       	pop	r1
    484c:	18 95       	reti

0000484e <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    484e:	1f 93       	push	r17
    4850:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    4852:	90 e0       	ldi	r25, 0x00	; 0
    4854:	fc 01       	movw	r30, r24
    4856:	ea 5a       	subi	r30, 0xAA	; 170
    4858:	fd 4e       	sbci	r31, 0xED	; 237
    485a:	2f ef       	ldi	r18, 0xFF	; 255
    485c:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    485e:	43 e0       	ldi	r20, 0x03	; 3
    4860:	88 0f       	add	r24, r24
    4862:	99 1f       	adc	r25, r25
    4864:	4a 95       	dec	r20
    4866:	e1 f7       	brne	.-8      	; 0x4860 <uartSendTxBuffer+0x12>
    4868:	86 5a       	subi	r24, 0xA6	; 166
    486a:	9d 4e       	sbci	r25, 0xED	; 237
    486c:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <bufferGetFromFront>
    4870:	68 2f       	mov	r22, r24
    4872:	81 2f       	mov	r24, r17
    4874:	0e 94 ae 21 	call	0x435c	; 0x435c <uartSendByte>
}
    4878:	1f 91       	pop	r17
    487a:	08 95       	ret

0000487c <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    487c:	cf 93       	push	r28
    487e:	df 93       	push	r29
    4880:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    4882:	28 2f       	mov	r18, r24
    4884:	30 e0       	ldi	r19, 0x00	; 0
    4886:	f9 01       	movw	r30, r18
    4888:	73 e0       	ldi	r23, 0x03	; 3
    488a:	ee 0f       	add	r30, r30
    488c:	ff 1f       	adc	r31, r31
    488e:	7a 95       	dec	r23
    4890:	e1 f7       	brne	.-8      	; 0x488a <uartReceiveByte+0xe>
    4892:	e8 5c       	subi	r30, 0xC8	; 200
    4894:	fd 4e       	sbci	r31, 0xED	; 237
    4896:	80 81       	ld	r24, Z
    4898:	91 81       	ldd	r25, Z+1	; 0x01
    489a:	89 2b       	or	r24, r25
    489c:	c9 f0       	breq	.+50     	; 0x48d0 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    489e:	f9 01       	movw	r30, r18
    48a0:	63 e0       	ldi	r22, 0x03	; 3
    48a2:	ee 0f       	add	r30, r30
    48a4:	ff 1f       	adc	r31, r31
    48a6:	6a 95       	dec	r22
    48a8:	e1 f7       	brne	.-8      	; 0x48a2 <uartReceiveByte+0x26>
    48aa:	e6 5c       	subi	r30, 0xC6	; 198
    48ac:	fd 4e       	sbci	r31, 0xED	; 237
    48ae:	80 81       	ld	r24, Z
    48b0:	91 81       	ldd	r25, Z+1	; 0x01
    48b2:	89 2b       	or	r24, r25
    48b4:	69 f0       	breq	.+26     	; 0x48d0 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    48b6:	53 e0       	ldi	r21, 0x03	; 3
    48b8:	22 0f       	add	r18, r18
    48ba:	33 1f       	adc	r19, r19
    48bc:	5a 95       	dec	r21
    48be:	e1 f7       	brne	.-8      	; 0x48b8 <uartReceiveByte+0x3c>
    48c0:	c9 01       	movw	r24, r18
    48c2:	8a 5c       	subi	r24, 0xCA	; 202
    48c4:	9d 4e       	sbci	r25, 0xED	; 237
    48c6:	0e 94 9d 25 	call	0x4b3a	; 0x4b3a <bufferGetFromFront>
    48ca:	88 83       	st	Y, r24
    48cc:	8f ef       	ldi	r24, 0xFF	; 255
    48ce:	01 c0       	rjmp	.+2      	; 0x48d2 <uartReceiveByte+0x56>
			return TRUE;
    48d0:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    48d2:	df 91       	pop	r29
    48d4:	cf 91       	pop	r28
    48d6:	08 95       	ret

000048d8 <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    48d8:	df 93       	push	r29
    48da:	cf 93       	push	r28
    48dc:	0f 92       	push	r0
    48de:	cd b7       	in	r28, 0x3d	; 61
    48e0:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    48e2:	83 e0       	ldi	r24, 0x03	; 3
    48e4:	be 01       	movw	r22, r28
    48e6:	6f 5f       	subi	r22, 0xFF	; 255
    48e8:	7f 4f       	sbci	r23, 0xFF	; 255
    48ea:	0e 94 3e 24 	call	0x487c	; 0x487c <uartReceiveByte>
    48ee:	88 23       	and	r24, r24
    48f0:	19 f4       	brne	.+6      	; 0x48f8 <uart3GetByte+0x20>
    48f2:	2f ef       	ldi	r18, 0xFF	; 255
    48f4:	3f ef       	ldi	r19, 0xFF	; 255
    48f6:	03 c0       	rjmp	.+6      	; 0x48fe <uart3GetByte+0x26>
		return c;
    48f8:	89 81       	ldd	r24, Y+1	; 0x01
    48fa:	28 2f       	mov	r18, r24
    48fc:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    48fe:	c9 01       	movw	r24, r18
    4900:	0f 90       	pop	r0
    4902:	cf 91       	pop	r28
    4904:	df 91       	pop	r29
    4906:	08 95       	ret

00004908 <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    4908:	df 93       	push	r29
    490a:	cf 93       	push	r28
    490c:	0f 92       	push	r0
    490e:	cd b7       	in	r28, 0x3d	; 61
    4910:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    4912:	82 e0       	ldi	r24, 0x02	; 2
    4914:	be 01       	movw	r22, r28
    4916:	6f 5f       	subi	r22, 0xFF	; 255
    4918:	7f 4f       	sbci	r23, 0xFF	; 255
    491a:	0e 94 3e 24 	call	0x487c	; 0x487c <uartReceiveByte>
    491e:	88 23       	and	r24, r24
    4920:	19 f4       	brne	.+6      	; 0x4928 <uart2GetByte+0x20>
    4922:	2f ef       	ldi	r18, 0xFF	; 255
    4924:	3f ef       	ldi	r19, 0xFF	; 255
    4926:	03 c0       	rjmp	.+6      	; 0x492e <uart2GetByte+0x26>
		return c;
    4928:	89 81       	ldd	r24, Y+1	; 0x01
    492a:	28 2f       	mov	r18, r24
    492c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    492e:	c9 01       	movw	r24, r18
    4930:	0f 90       	pop	r0
    4932:	cf 91       	pop	r28
    4934:	df 91       	pop	r29
    4936:	08 95       	ret

00004938 <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    4938:	df 93       	push	r29
    493a:	cf 93       	push	r28
    493c:	0f 92       	push	r0
    493e:	cd b7       	in	r28, 0x3d	; 61
    4940:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    4942:	81 e0       	ldi	r24, 0x01	; 1
    4944:	be 01       	movw	r22, r28
    4946:	6f 5f       	subi	r22, 0xFF	; 255
    4948:	7f 4f       	sbci	r23, 0xFF	; 255
    494a:	0e 94 3e 24 	call	0x487c	; 0x487c <uartReceiveByte>
    494e:	88 23       	and	r24, r24
    4950:	19 f4       	brne	.+6      	; 0x4958 <uart1GetByte+0x20>
    4952:	2f ef       	ldi	r18, 0xFF	; 255
    4954:	3f ef       	ldi	r19, 0xFF	; 255
    4956:	03 c0       	rjmp	.+6      	; 0x495e <uart1GetByte+0x26>
		return c;
    4958:	89 81       	ldd	r24, Y+1	; 0x01
    495a:	28 2f       	mov	r18, r24
    495c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    495e:	c9 01       	movw	r24, r18
    4960:	0f 90       	pop	r0
    4962:	cf 91       	pop	r28
    4964:	df 91       	pop	r29
    4966:	08 95       	ret

00004968 <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    4968:	df 93       	push	r29
    496a:	cf 93       	push	r28
    496c:	0f 92       	push	r0
    496e:	cd b7       	in	r28, 0x3d	; 61
    4970:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    4972:	80 e0       	ldi	r24, 0x00	; 0
    4974:	be 01       	movw	r22, r28
    4976:	6f 5f       	subi	r22, 0xFF	; 255
    4978:	7f 4f       	sbci	r23, 0xFF	; 255
    497a:	0e 94 3e 24 	call	0x487c	; 0x487c <uartReceiveByte>
    497e:	88 23       	and	r24, r24
    4980:	19 f4       	brne	.+6      	; 0x4988 <uart0GetByte+0x20>
    4982:	2f ef       	ldi	r18, 0xFF	; 255
    4984:	3f ef       	ldi	r19, 0xFF	; 255
    4986:	03 c0       	rjmp	.+6      	; 0x498e <uart0GetByte+0x26>
		return c;
    4988:	89 81       	ldd	r24, Y+1	; 0x01
    498a:	28 2f       	mov	r18, r24
    498c:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    498e:	c9 01       	movw	r24, r18
    4990:	0f 90       	pop	r0
    4992:	cf 91       	pop	r28
    4994:	df 91       	pop	r29
    4996:	08 95       	ret

00004998 <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    4998:	90 e0       	ldi	r25, 0x00	; 0
    499a:	e3 e0       	ldi	r30, 0x03	; 3
    499c:	88 0f       	add	r24, r24
    499e:	99 1f       	adc	r25, r25
    49a0:	ea 95       	dec	r30
    49a2:	e1 f7       	brne	.-8      	; 0x499c <uartFlushReceiveBuffer+0x4>
    49a4:	8a 5c       	subi	r24, 0xCA	; 202
    49a6:	9d 4e       	sbci	r25, 0xED	; 237
    49a8:	0e 94 39 26 	call	0x4c72	; 0x4c72 <bufferFlush>
}
    49ac:	08 95       	ret

000049ae <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    49ae:	8e e4       	ldi	r24, 0x4E	; 78
    49b0:	92 e1       	ldi	r25, 0x12	; 18
    49b2:	6e e1       	ldi	r22, 0x1E	; 30
    49b4:	71 e1       	ldi	r23, 0x11	; 17
    49b6:	40 e8       	ldi	r20, 0x80	; 128
    49b8:	50 e0       	ldi	r21, 0x00	; 0
    49ba:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    49be:	82 e7       	ldi	r24, 0x72	; 114
    49c0:	92 e1       	ldi	r25, 0x12	; 18
    49c2:	6e e9       	ldi	r22, 0x9E	; 158
    49c4:	71 e1       	ldi	r23, 0x11	; 17
    49c6:	40 e1       	ldi	r20, 0x10	; 16
    49c8:	50 e0       	ldi	r21, 0x00	; 0
    49ca:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    49ce:	08 95       	ret

000049d0 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    49d0:	0e 94 d7 24 	call	0x49ae	; 0x49ae <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    49d4:	10 92 b5 11 	sts	0x11B5, r1
    49d8:	10 92 b4 11 	sts	0x11B4, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    49dc:	88 ed       	ldi	r24, 0xD8	; 216
    49de:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    49e2:	83 e0       	ldi	r24, 0x03	; 3
    49e4:	40 e8       	ldi	r20, 0x80	; 128
    49e6:	55 e2       	ldi	r21, 0x25	; 37
    49e8:	60 e0       	ldi	r22, 0x00	; 0
    49ea:	70 e0       	ldi	r23, 0x00	; 0
    49ec:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    49f0:	8f ef       	ldi	r24, 0xFF	; 255
    49f2:	80 93 35 12 	sts	0x1235, r24
	uartBufferedTx[3] = FALSE;
    49f6:	10 92 59 12 	sts	0x1259, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    49fa:	10 92 81 12 	sts	0x1281, r1
    49fe:	10 92 80 12 	sts	0x1280, r1
	// enable interrupts
	sei();
    4a02:	78 94       	sei
}
    4a04:	08 95       	ret

00004a06 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    4a06:	86 e4       	ldi	r24, 0x46	; 70
    4a08:	92 e1       	ldi	r25, 0x12	; 18
    4a0a:	6e e8       	ldi	r22, 0x8E	; 142
    4a0c:	70 e1       	ldi	r23, 0x10	; 16
    4a0e:	40 e8       	ldi	r20, 0x80	; 128
    4a10:	50 e0       	ldi	r21, 0x00	; 0
    4a12:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    4a16:	8a e6       	ldi	r24, 0x6A	; 106
    4a18:	92 e1       	ldi	r25, 0x12	; 18
    4a1a:	6e e0       	ldi	r22, 0x0E	; 14
    4a1c:	71 e1       	ldi	r23, 0x11	; 17
    4a1e:	40 e1       	ldi	r20, 0x10	; 16
    4a20:	50 e0       	ldi	r21, 0x00	; 0
    4a22:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    4a26:	08 95       	ret

00004a28 <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    4a28:	0e 94 03 25 	call	0x4a06	; 0x4a06 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    4a2c:	10 92 b3 11 	sts	0x11B3, r1
    4a30:	10 92 b2 11 	sts	0x11B2, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4a34:	88 ed       	ldi	r24, 0xD8	; 216
    4a36:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    4a3a:	82 e0       	ldi	r24, 0x02	; 2
    4a3c:	40 e8       	ldi	r20, 0x80	; 128
    4a3e:	55 e2       	ldi	r21, 0x25	; 37
    4a40:	60 e0       	ldi	r22, 0x00	; 0
    4a42:	70 e0       	ldi	r23, 0x00	; 0
    4a44:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    4a48:	8f ef       	ldi	r24, 0xFF	; 255
    4a4a:	80 93 34 12 	sts	0x1234, r24
	uartBufferedTx[2] = FALSE;
    4a4e:	10 92 58 12 	sts	0x1258, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    4a52:	10 92 7f 12 	sts	0x127F, r1
    4a56:	10 92 7e 12 	sts	0x127E, r1
	// enable interrupts
	sei();
    4a5a:	78 94       	sei
}
    4a5c:	08 95       	ret

00004a5e <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    4a5e:	8e e3       	ldi	r24, 0x3E	; 62
    4a60:	92 e1       	ldi	r25, 0x12	; 18
    4a62:	6e ef       	ldi	r22, 0xFE	; 254
    4a64:	7f e0       	ldi	r23, 0x0F	; 15
    4a66:	40 e8       	ldi	r20, 0x80	; 128
    4a68:	50 e0       	ldi	r21, 0x00	; 0
    4a6a:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    4a6e:	82 e6       	ldi	r24, 0x62	; 98
    4a70:	92 e1       	ldi	r25, 0x12	; 18
    4a72:	6e e7       	ldi	r22, 0x7E	; 126
    4a74:	70 e1       	ldi	r23, 0x10	; 16
    4a76:	40 e1       	ldi	r20, 0x10	; 16
    4a78:	50 e0       	ldi	r21, 0x00	; 0
    4a7a:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    4a7e:	08 95       	ret

00004a80 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    4a80:	0e 94 2f 25 	call	0x4a5e	; 0x4a5e <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    4a84:	10 92 b1 11 	sts	0x11B1, r1
    4a88:	10 92 b0 11 	sts	0x11B0, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4a8c:	88 ed       	ldi	r24, 0xD8	; 216
    4a8e:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    4a92:	81 e0       	ldi	r24, 0x01	; 1
    4a94:	40 e8       	ldi	r20, 0x80	; 128
    4a96:	55 e2       	ldi	r21, 0x25	; 37
    4a98:	60 e0       	ldi	r22, 0x00	; 0
    4a9a:	70 e0       	ldi	r23, 0x00	; 0
    4a9c:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    4aa0:	8f ef       	ldi	r24, 0xFF	; 255
    4aa2:	80 93 33 12 	sts	0x1233, r24
	uartBufferedTx[1] = FALSE;
    4aa6:	10 92 57 12 	sts	0x1257, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    4aaa:	10 92 7d 12 	sts	0x127D, r1
    4aae:	10 92 7c 12 	sts	0x127C, r1
	// enable interrupts
	sei();
    4ab2:	78 94       	sei
}
    4ab4:	08 95       	ret

00004ab6 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    4ab6:	86 e3       	ldi	r24, 0x36	; 54
    4ab8:	92 e1       	ldi	r25, 0x12	; 18
    4aba:	6e e6       	ldi	r22, 0x6E	; 110
    4abc:	7f e0       	ldi	r23, 0x0F	; 15
    4abe:	40 e8       	ldi	r20, 0x80	; 128
    4ac0:	50 e0       	ldi	r21, 0x00	; 0
    4ac2:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    4ac6:	8a e5       	ldi	r24, 0x5A	; 90
    4ac8:	92 e1       	ldi	r25, 0x12	; 18
    4aca:	6e ee       	ldi	r22, 0xEE	; 238
    4acc:	7f e0       	ldi	r23, 0x0F	; 15
    4ace:	40 e1       	ldi	r20, 0x10	; 16
    4ad0:	50 e0       	ldi	r21, 0x00	; 0
    4ad2:	0e 94 90 25 	call	0x4b20	; 0x4b20 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    4ad6:	08 95       	ret

00004ad8 <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    4ad8:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    4adc:	10 92 af 11 	sts	0x11AF, r1
    4ae0:	10 92 ae 11 	sts	0x11AE, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    4ae4:	88 ed       	ldi	r24, 0xD8	; 216
    4ae6:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    4aea:	80 e0       	ldi	r24, 0x00	; 0
    4aec:	40 e8       	ldi	r20, 0x80	; 128
    4aee:	55 e2       	ldi	r21, 0x25	; 37
    4af0:	60 e0       	ldi	r22, 0x00	; 0
    4af2:	70 e0       	ldi	r23, 0x00	; 0
    4af4:	0e 94 61 21 	call	0x42c2	; 0x42c2 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    4af8:	8f ef       	ldi	r24, 0xFF	; 255
    4afa:	80 93 32 12 	sts	0x1232, r24
	uartBufferedTx[0] = FALSE;
    4afe:	10 92 56 12 	sts	0x1256, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    4b02:	10 92 7b 12 	sts	0x127B, r1
    4b06:	10 92 7a 12 	sts	0x127A, r1
	// enable interrupts
	sei();
    4b0a:	78 94       	sei
}
    4b0c:	08 95       	ret

00004b0e <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    4b0e:	0e 94 6c 25 	call	0x4ad8	; 0x4ad8 <uart0Init>
	uart1Init();
    4b12:	0e 94 40 25 	call	0x4a80	; 0x4a80 <uart1Init>
	uart2Init();
    4b16:	0e 94 14 25 	call	0x4a28	; 0x4a28 <uart2Init>
	uart3Init();
    4b1a:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <uart3Init>
}
    4b1e:	08 95       	ret

00004b20 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    4b20:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4b22:	8f b7       	in	r24, 0x3f	; 63
    4b24:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    4b26:	71 83       	std	Z+1, r23	; 0x01
    4b28:	60 83       	st	Z, r22
	buffer->size = size;
    4b2a:	53 83       	std	Z+3, r21	; 0x03
    4b2c:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    4b2e:	17 82       	std	Z+7, r1	; 0x07
    4b30:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    4b32:	15 82       	std	Z+5, r1	; 0x05
    4b34:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4b36:	8f bf       	out	0x3f, r24	; 63
}
    4b38:	08 95       	ret

00004b3a <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    4b3a:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    4b3c:	4f b7       	in	r20, 0x3f	; 63
    4b3e:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    4b40:	14 96       	adiw	r26, 0x04	; 4
    4b42:	8d 91       	ld	r24, X+
    4b44:	9c 91       	ld	r25, X
    4b46:	15 97       	sbiw	r26, 0x05	; 5
    4b48:	89 2b       	or	r24, r25
    4b4a:	11 f4       	brne	.+4      	; 0x4b50 <bufferGetFromFront+0x16>
    4b4c:	e0 e0       	ldi	r30, 0x00	; 0
    4b4e:	25 c0       	rjmp	.+74     	; 0x4b9a <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    4b50:	16 96       	adiw	r26, 0x06	; 6
    4b52:	8d 91       	ld	r24, X+
    4b54:	9c 91       	ld	r25, X
    4b56:	17 97       	sbiw	r26, 0x07	; 7
    4b58:	ed 91       	ld	r30, X+
    4b5a:	fc 91       	ld	r31, X
    4b5c:	11 97       	sbiw	r26, 0x01	; 1
    4b5e:	e8 0f       	add	r30, r24
    4b60:	f9 1f       	adc	r31, r25
    4b62:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    4b64:	01 96       	adiw	r24, 0x01	; 1
    4b66:	17 96       	adiw	r26, 0x07	; 7
    4b68:	9c 93       	st	X, r25
    4b6a:	8e 93       	st	-X, r24
    4b6c:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    4b6e:	12 96       	adiw	r26, 0x02	; 2
    4b70:	2d 91       	ld	r18, X+
    4b72:	3c 91       	ld	r19, X
    4b74:	13 97       	sbiw	r26, 0x03	; 3
    4b76:	82 17       	cp	r24, r18
    4b78:	93 07       	cpc	r25, r19
    4b7a:	30 f0       	brcs	.+12     	; 0x4b88 <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    4b7c:	82 1b       	sub	r24, r18
    4b7e:	93 0b       	sbc	r25, r19
    4b80:	17 96       	adiw	r26, 0x07	; 7
    4b82:	9c 93       	st	X, r25
    4b84:	8e 93       	st	-X, r24
    4b86:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    4b88:	14 96       	adiw	r26, 0x04	; 4
    4b8a:	8d 91       	ld	r24, X+
    4b8c:	9c 91       	ld	r25, X
    4b8e:	15 97       	sbiw	r26, 0x05	; 5
    4b90:	01 97       	sbiw	r24, 0x01	; 1
    4b92:	15 96       	adiw	r26, 0x05	; 5
    4b94:	9c 93       	st	X, r25
    4b96:	8e 93       	st	-X, r24
    4b98:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    4b9a:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    4b9c:	8e 2f       	mov	r24, r30
    4b9e:	08 95       	ret

00004ba0 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    4ba0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4ba2:	4f b7       	in	r20, 0x3f	; 63
    4ba4:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    4ba6:	84 81       	ldd	r24, Z+4	; 0x04
    4ba8:	95 81       	ldd	r25, Z+5	; 0x05
    4baa:	68 17       	cp	r22, r24
    4bac:	79 07       	cpc	r23, r25
    4bae:	b0 f4       	brcc	.+44     	; 0x4bdc <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    4bb0:	86 81       	ldd	r24, Z+6	; 0x06
    4bb2:	97 81       	ldd	r25, Z+7	; 0x07
    4bb4:	86 0f       	add	r24, r22
    4bb6:	97 1f       	adc	r25, r23
    4bb8:	97 83       	std	Z+7, r25	; 0x07
    4bba:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    4bbc:	22 81       	ldd	r18, Z+2	; 0x02
    4bbe:	33 81       	ldd	r19, Z+3	; 0x03
    4bc0:	82 17       	cp	r24, r18
    4bc2:	93 07       	cpc	r25, r19
    4bc4:	20 f0       	brcs	.+8      	; 0x4bce <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    4bc6:	82 1b       	sub	r24, r18
    4bc8:	93 0b       	sbc	r25, r19
    4bca:	97 83       	std	Z+7, r25	; 0x07
    4bcc:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    4bce:	84 81       	ldd	r24, Z+4	; 0x04
    4bd0:	95 81       	ldd	r25, Z+5	; 0x05
    4bd2:	86 1b       	sub	r24, r22
    4bd4:	97 0b       	sbc	r25, r23
    4bd6:	95 83       	std	Z+5, r25	; 0x05
    4bd8:	84 83       	std	Z+4, r24	; 0x04
    4bda:	02 c0       	rjmp	.+4      	; 0x4be0 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    4bdc:	15 82       	std	Z+5, r1	; 0x05
    4bde:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    4be0:	4f bf       	out	0x3f, r20	; 63
}
    4be2:	08 95       	ret

00004be4 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    4be4:	fc 01       	movw	r30, r24
    4be6:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4be8:	2f b7       	in	r18, 0x3f	; 63
    4bea:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    4bec:	2f bf       	out	0x3f, r18	; 63
    4bee:	26 81       	ldd	r18, Z+6	; 0x06
    4bf0:	37 81       	ldd	r19, Z+7	; 0x07
    4bf2:	62 81       	ldd	r22, Z+2	; 0x02
    4bf4:	73 81       	ldd	r23, Z+3	; 0x03
    4bf6:	82 0f       	add	r24, r18
    4bf8:	93 1f       	adc	r25, r19
    4bfa:	0e 94 1e 30 	call	0x603c	; 0x603c <__udivmodhi4>
    4bfe:	01 90       	ld	r0, Z+
    4c00:	f0 81       	ld	r31, Z
    4c02:	e0 2d       	mov	r30, r0
    4c04:	e8 0f       	add	r30, r24
    4c06:	f9 1f       	adc	r31, r25
	return data;
}
    4c08:	80 81       	ld	r24, Z
    4c0a:	08 95       	ret

00004c0c <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    4c0c:	1f 93       	push	r17
    4c0e:	cf 93       	push	r28
    4c10:	df 93       	push	r29
    4c12:	ec 01       	movw	r28, r24
    4c14:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    4c16:	4f b7       	in	r20, 0x3f	; 63
    4c18:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    4c1a:	2c 81       	ldd	r18, Y+4	; 0x04
    4c1c:	3d 81       	ldd	r19, Y+5	; 0x05
    4c1e:	6a 81       	ldd	r22, Y+2	; 0x02
    4c20:	7b 81       	ldd	r23, Y+3	; 0x03
    4c22:	26 17       	cp	r18, r22
    4c24:	37 07       	cpc	r19, r23
    4c26:	98 f4       	brcc	.+38     	; 0x4c4e <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    4c28:	8e 81       	ldd	r24, Y+6	; 0x06
    4c2a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c2c:	82 0f       	add	r24, r18
    4c2e:	93 1f       	adc	r25, r19
    4c30:	0e 94 1e 30 	call	0x603c	; 0x603c <__udivmodhi4>
    4c34:	e8 81       	ld	r30, Y
    4c36:	f9 81       	ldd	r31, Y+1	; 0x01
    4c38:	e8 0f       	add	r30, r24
    4c3a:	f9 1f       	adc	r31, r25
    4c3c:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    4c3e:	8c 81       	ldd	r24, Y+4	; 0x04
    4c40:	9d 81       	ldd	r25, Y+5	; 0x05
    4c42:	01 96       	adiw	r24, 0x01	; 1
    4c44:	9d 83       	std	Y+5, r25	; 0x05
    4c46:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    4c48:	4f bf       	out	0x3f, r20	; 63
    4c4a:	8f ef       	ldi	r24, 0xFF	; 255
    4c4c:	02 c0       	rjmp	.+4      	; 0x4c52 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    4c4e:	4f bf       	out	0x3f, r20	; 63
    4c50:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    4c52:	df 91       	pop	r29
    4c54:	cf 91       	pop	r28
    4c56:	1f 91       	pop	r17
    4c58:	08 95       	ret

00004c5a <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    4c5a:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4c5c:	8f b7       	in	r24, 0x3f	; 63
    4c5e:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    4c60:	8f bf       	out	0x3f, r24	; 63
    4c62:	22 81       	ldd	r18, Z+2	; 0x02
    4c64:	33 81       	ldd	r19, Z+3	; 0x03
    4c66:	84 81       	ldd	r24, Z+4	; 0x04
    4c68:	95 81       	ldd	r25, Z+5	; 0x05
    4c6a:	28 1b       	sub	r18, r24
    4c6c:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    4c6e:	c9 01       	movw	r24, r18
    4c70:	08 95       	ret

00004c72 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    4c72:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    4c74:	8f b7       	in	r24, 0x3f	; 63
    4c76:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    4c78:	15 82       	std	Z+5, r1	; 0x05
    4c7a:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    4c7c:	8f bf       	out	0x3f, r24	; 63
}
    4c7e:	08 95       	ret

00004c80 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    4c80:	aa e7       	ldi	r26, 0x7A	; 122
    4c82:	b0 e0       	ldi	r27, 0x00	; 0
    4c84:	8c 91       	ld	r24, X
    4c86:	80 68       	ori	r24, 0x80	; 128
    4c88:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    4c8a:	8c 91       	ld	r24, X
    4c8c:	8f 7d       	andi	r24, 0xDF	; 223
    4c8e:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4c90:	8c 91       	ld	r24, X
    4c92:	88 7f       	andi	r24, 0xF8	; 248
    4c94:	86 60       	ori	r24, 0x06	; 6
    4c96:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4c98:	ec e7       	ldi	r30, 0x7C	; 124
    4c9a:	f0 e0       	ldi	r31, 0x00	; 0
    4c9c:	80 81       	ld	r24, Z
    4c9e:	8f 73       	andi	r24, 0x3F	; 63
    4ca0:	80 64       	ori	r24, 0x40	; 64
    4ca2:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    4ca4:	80 81       	ld	r24, Z
    4ca6:	8f 7d       	andi	r24, 0xDF	; 223
    4ca8:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    4caa:	8c 91       	ld	r24, X
    4cac:	88 60       	ori	r24, 0x08	; 8
    4cae:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    4cb0:	10 92 82 12 	sts	0x1282, r1
	sei();							// turn on interrupts (if not already on)
    4cb4:	78 94       	sei
}
    4cb6:	08 95       	ret

00004cb8 <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    4cb8:	ea e7       	ldi	r30, 0x7A	; 122
    4cba:	f0 e0       	ldi	r31, 0x00	; 0
    4cbc:	80 81       	ld	r24, Z
    4cbe:	87 7f       	andi	r24, 0xF7	; 247
    4cc0:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    4cc2:	80 81       	ld	r24, Z
    4cc4:	8f 77       	andi	r24, 0x7F	; 127
    4cc6:	80 83       	st	Z, r24
}
    4cc8:	08 95       	ret

00004cca <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    4cca:	ea e7       	ldi	r30, 0x7A	; 122
    4ccc:	f0 e0       	ldi	r31, 0x00	; 0
    4cce:	90 81       	ld	r25, Z
    4cd0:	98 7f       	andi	r25, 0xF8	; 248
    4cd2:	98 2b       	or	r25, r24
    4cd4:	90 83       	st	Z, r25
}
    4cd6:	08 95       	ret

00004cd8 <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    4cd8:	ec e7       	ldi	r30, 0x7C	; 124
    4cda:	f0 e0       	ldi	r31, 0x00	; 0
    4cdc:	90 81       	ld	r25, Z
    4cde:	82 95       	swap	r24
    4ce0:	88 0f       	add	r24, r24
    4ce2:	88 0f       	add	r24, r24
    4ce4:	80 7c       	andi	r24, 0xC0	; 192
    4ce6:	9f 73       	andi	r25, 0x3F	; 63
    4ce8:	98 2b       	or	r25, r24
    4cea:	90 83       	st	Z, r25
}
    4cec:	08 95       	ret

00004cee <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    4cee:	ec e7       	ldi	r30, 0x7C	; 124
    4cf0:	f0 e0       	ldi	r31, 0x00	; 0
    4cf2:	90 81       	ld	r25, Z
    4cf4:	8f 71       	andi	r24, 0x1F	; 31
    4cf6:	90 7e       	andi	r25, 0xE0	; 224
    4cf8:	89 2b       	or	r24, r25
    4cfa:	80 83       	st	Z, r24
}
    4cfc:	08 95       	ret

00004cfe <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    4cfe:	ea e7       	ldi	r30, 0x7A	; 122
    4d00:	f0 e0       	ldi	r31, 0x00	; 0
    4d02:	80 81       	ld	r24, Z
    4d04:	80 61       	ori	r24, 0x10	; 16
    4d06:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    4d08:	80 81       	ld	r24, Z
    4d0a:	80 64       	ori	r24, 0x40	; 64
    4d0c:	80 83       	st	Z, r24
}
    4d0e:	08 95       	ret

00004d10 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    4d10:	80 91 7a 00 	lds	r24, 0x007A
}
    4d14:	80 74       	andi	r24, 0x40	; 64
    4d16:	08 95       	ret

00004d18 <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    4d18:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    4d1a:	10 92 82 12 	sts	0x1282, r1

if (ch >= 8)
    4d1e:	88 30       	cpi	r24, 0x08	; 8
    4d20:	20 f0       	brcs	.+8      	; 0x4d2a <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    4d22:	80 91 7b 00 	lds	r24, 0x007B
    4d26:	88 60       	ori	r24, 0x08	; 8
    4d28:	03 c0       	rjmp	.+6      	; 0x4d30 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    4d2a:	80 91 7b 00 	lds	r24, 0x007B
    4d2e:	87 7f       	andi	r24, 0xF7	; 247
    4d30:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    4d34:	80 91 7c 00 	lds	r24, 0x007C
    4d38:	97 70       	andi	r25, 0x07	; 7
    4d3a:	88 7f       	andi	r24, 0xF8	; 248
    4d3c:	89 2b       	or	r24, r25
    4d3e:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    4d42:	80 91 7a 00 	lds	r24, 0x007A
    4d46:	80 61       	ori	r24, 0x10	; 16
    4d48:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    4d4c:	80 91 7a 00 	lds	r24, 0x007A
    4d50:	80 64       	ori	r24, 0x40	; 64
    4d52:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    4d56:	80 91 7a 00 	lds	r24, 0x007A
    4d5a:	86 fd       	sbrc	r24, 6
    4d5c:	fc cf       	rjmp	.-8      	; 0x4d56 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    4d5e:	20 91 78 00 	lds	r18, 0x0078
    4d62:	30 91 79 00 	lds	r19, 0x0079
}
    4d66:	c9 01       	movw	r24, r18
    4d68:	08 95       	ret

00004d6a <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    4d6a:	0e 94 8c 26 	call	0x4d18	; 0x4d18 <a2dConvert10bit>
    4d6e:	96 95       	lsr	r25
    4d70:	87 95       	ror	r24
    4d72:	96 95       	lsr	r25
    4d74:	87 95       	ror	r24
}
    4d76:	08 95       	ret

00004d78 <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    4d78:	1f 92       	push	r1
    4d7a:	0f 92       	push	r0
    4d7c:	0f b6       	in	r0, 0x3f	; 63
    4d7e:	0f 92       	push	r0
    4d80:	11 24       	eor	r1, r1
    4d82:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    4d84:	8f ef       	ldi	r24, 0xFF	; 255
    4d86:	80 93 82 12 	sts	0x1282, r24
}
    4d8a:	8f 91       	pop	r24
    4d8c:	0f 90       	pop	r0
    4d8e:	0f be       	out	0x3f, r0	; 63
    4d90:	0f 90       	pop	r0
    4d92:	1f 90       	pop	r1
    4d94:	18 95       	reti

00004d96 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    4d96:	90 93 b7 11 	sts	0x11B7, r25
    4d9a:	80 93 b6 11 	sts	0x11B6, r24
}
    4d9e:	08 95       	ret

00004da0 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    4da0:	1f 93       	push	r17
    4da2:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    4da4:	8a 30       	cpi	r24, 0x0A	; 10
    4da6:	31 f4       	brne	.+12     	; 0x4db4 <rprintfChar+0x14>
		rputchar('\r');
    4da8:	e0 91 b6 11 	lds	r30, 0x11B6
    4dac:	f0 91 b7 11 	lds	r31, 0x11B7
    4db0:	8d e0       	ldi	r24, 0x0D	; 13
    4db2:	09 95       	icall
	// send character
	rputchar(c);
    4db4:	e0 91 b6 11 	lds	r30, 0x11B6
    4db8:	f0 91 b7 11 	lds	r31, 0x11B7
    4dbc:	81 2f       	mov	r24, r17
    4dbe:	09 95       	icall
}
    4dc0:	1f 91       	pop	r17
    4dc2:	08 95       	ret

00004dc4 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    4dc4:	cf 93       	push	r28
    4dc6:	df 93       	push	r29
    4dc8:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    4dca:	00 97       	sbiw	r24, 0x00	; 0
    4dcc:	21 f4       	brne	.+8      	; 0x4dd6 <rprintfStr+0x12>
    4dce:	06 c0       	rjmp	.+12     	; 0x4ddc <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    4dd0:	21 96       	adiw	r28, 0x01	; 1
    4dd2:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    4dd6:	88 81       	ld	r24, Y
    4dd8:	88 23       	and	r24, r24
    4dda:	d1 f7       	brne	.-12     	; 0x4dd0 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    4ddc:	df 91       	pop	r29
    4dde:	cf 91       	pop	r28
    4de0:	08 95       	ret

00004de2 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    4de2:	ef 92       	push	r14
    4de4:	ff 92       	push	r15
    4de6:	0f 93       	push	r16
    4de8:	1f 93       	push	r17
    4dea:	cf 93       	push	r28
    4dec:	df 93       	push	r29
    4dee:	8c 01       	movw	r16, r24
    4df0:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    4df2:	00 97       	sbiw	r24, 0x00	; 0
    4df4:	e9 f0       	breq	.+58     	; 0x4e30 <rprintfStrLen+0x4e>
    4df6:	20 e0       	ldi	r18, 0x00	; 0
    4df8:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    4dfa:	26 17       	cp	r18, r22
    4dfc:	37 07       	cpc	r19, r23
    4dfe:	38 f4       	brcc	.+14     	; 0x4e0e <rprintfStrLen+0x2c>
    4e00:	f8 01       	movw	r30, r16
    4e02:	81 91       	ld	r24, Z+
    4e04:	8f 01       	movw	r16, r30
    4e06:	2f 5f       	subi	r18, 0xFF	; 255
    4e08:	3f 4f       	sbci	r19, 0xFF	; 255
    4e0a:	88 23       	and	r24, r24
    4e0c:	b1 f7       	brne	.-20     	; 0x4dfa <rprintfStrLen+0x18>
    4e0e:	c0 e0       	ldi	r28, 0x00	; 0
    4e10:	d0 e0       	ldi	r29, 0x00	; 0
    4e12:	0b c0       	rjmp	.+22     	; 0x4e2a <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    4e14:	f8 01       	movw	r30, r16
    4e16:	80 81       	ld	r24, Z
    4e18:	88 23       	and	r24, r24
    4e1a:	19 f0       	breq	.+6      	; 0x4e22 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    4e1c:	0f 5f       	subi	r16, 0xFF	; 255
    4e1e:	1f 4f       	sbci	r17, 0xFF	; 255
    4e20:	01 c0       	rjmp	.+2      	; 0x4e24 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    4e22:	80 e2       	ldi	r24, 0x20	; 32
    4e24:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    4e28:	21 96       	adiw	r28, 0x01	; 1
    4e2a:	ce 15       	cp	r28, r14
    4e2c:	df 05       	cpc	r29, r15
    4e2e:	90 f3       	brcs	.-28     	; 0x4e14 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    4e30:	df 91       	pop	r29
    4e32:	cf 91       	pop	r28
    4e34:	1f 91       	pop	r17
    4e36:	0f 91       	pop	r16
    4e38:	ff 90       	pop	r15
    4e3a:	ef 90       	pop	r14
    4e3c:	08 95       	ret

00004e3e <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    4e3e:	cf 93       	push	r28
    4e40:	df 93       	push	r29
    4e42:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    4e44:	00 97       	sbiw	r24, 0x00	; 0
    4e46:	19 f4       	brne	.+6      	; 0x4e4e <rprintfProgStr+0x10>
    4e48:	07 c0       	rjmp	.+14     	; 0x4e58 <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    4e4a:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    4e4e:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    4e50:	21 96       	adiw	r28, 0x01	; 1
    4e52:	84 91       	lpm	r24, Z+
    4e54:	88 23       	and	r24, r24
    4e56:	c9 f7       	brne	.-14     	; 0x4e4a <rprintfProgStr+0xc>
		rprintfChar(c);
}
    4e58:	df 91       	pop	r29
    4e5a:	cf 91       	pop	r28
    4e5c:	08 95       	ret

00004e5e <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    4e5e:	8a e0       	ldi	r24, 0x0A	; 10
    4e60:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
}
    4e64:	08 95       	ret

00004e66 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    4e66:	e8 2f       	mov	r30, r24
    4e68:	f0 e0       	ldi	r31, 0x00	; 0
    4e6a:	ef 70       	andi	r30, 0x0F	; 15
    4e6c:	f0 70       	andi	r31, 0x00	; 0
    4e6e:	ea 52       	subi	r30, 0x2A	; 42
    4e70:	fe 4f       	sbci	r31, 0xFE	; 254
    4e72:	e4 91       	lpm	r30, Z+
    4e74:	8e 2f       	mov	r24, r30
    4e76:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
}
    4e7a:	08 95       	ret

00004e7c <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    4e7c:	1f 93       	push	r17
    4e7e:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    4e80:	82 95       	swap	r24
    4e82:	8f 70       	andi	r24, 0x0F	; 15
    4e84:	0e 94 33 27 	call	0x4e66	; 0x4e66 <rprintfu04>
	rprintfu04(data);
    4e88:	81 2f       	mov	r24, r17
    4e8a:	0e 94 33 27 	call	0x4e66	; 0x4e66 <rprintfu04>
}
    4e8e:	1f 91       	pop	r17
    4e90:	08 95       	ret

00004e92 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    4e92:	1f 93       	push	r17
    4e94:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    4e96:	89 2f       	mov	r24, r25
    4e98:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <rprintfu08>
	rprintfu08(data);
    4e9c:	81 2f       	mov	r24, r17
    4e9e:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <rprintfu08>
}
    4ea2:	1f 91       	pop	r17
    4ea4:	08 95       	ret

00004ea6 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    4ea6:	ef 92       	push	r14
    4ea8:	ff 92       	push	r15
    4eaa:	0f 93       	push	r16
    4eac:	1f 93       	push	r17
    4eae:	7b 01       	movw	r14, r22
    4eb0:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    4eb2:	c8 01       	movw	r24, r16
    4eb4:	aa 27       	eor	r26, r26
    4eb6:	bb 27       	eor	r27, r27
    4eb8:	0e 94 49 27 	call	0x4e92	; 0x4e92 <rprintfu16>
	rprintfu16(data);
    4ebc:	c7 01       	movw	r24, r14
    4ebe:	0e 94 49 27 	call	0x4e92	; 0x4e92 <rprintfu16>
}
    4ec2:	1f 91       	pop	r17
    4ec4:	0f 91       	pop	r16
    4ec6:	ff 90       	pop	r15
    4ec8:	ef 90       	pop	r14
    4eca:	08 95       	ret

00004ecc <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    4ecc:	2f 92       	push	r2
    4ece:	3f 92       	push	r3
    4ed0:	4f 92       	push	r4
    4ed2:	5f 92       	push	r5
    4ed4:	6f 92       	push	r6
    4ed6:	7f 92       	push	r7
    4ed8:	8f 92       	push	r8
    4eda:	9f 92       	push	r9
    4edc:	af 92       	push	r10
    4ede:	bf 92       	push	r11
    4ee0:	cf 92       	push	r12
    4ee2:	df 92       	push	r13
    4ee4:	ef 92       	push	r14
    4ee6:	ff 92       	push	r15
    4ee8:	0f 93       	push	r16
    4eea:	1f 93       	push	r17
    4eec:	df 93       	push	r29
    4eee:	cf 93       	push	r28
    4ef0:	cd b7       	in	r28, 0x3d	; 61
    4ef2:	de b7       	in	r29, 0x3e	; 62
    4ef4:	a3 97       	sbiw	r28, 0x23	; 35
    4ef6:	0f b6       	in	r0, 0x3f	; 63
    4ef8:	f8 94       	cli
    4efa:	de bf       	out	0x3e, r29	; 62
    4efc:	0f be       	out	0x3f, r0	; 63
    4efe:	cd bf       	out	0x3d, r28	; 61
    4f00:	6a a3       	std	Y+34, r22	; 0x22
    4f02:	24 2e       	mov	r2, r20
    4f04:	2b a3       	std	Y+35, r18	; 0x23
    4f06:	37 01       	movw	r6, r14
    4f08:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    4f0a:	44 23       	and	r20, r20
    4f0c:	51 f0       	breq	.+20     	; 0x4f22 <rprintfNum+0x56>
    4f0e:	17 ff       	sbrs	r17, 7
    4f10:	08 c0       	rjmp	.+16     	; 0x4f22 <rprintfNum+0x56>
	{
		x = -n;
    4f12:	ee 24       	eor	r14, r14
    4f14:	ff 24       	eor	r15, r15
    4f16:	87 01       	movw	r16, r14
    4f18:	e6 18       	sub	r14, r6
    4f1a:	f7 08       	sbc	r15, r7
    4f1c:	08 09       	sbc	r16, r8
    4f1e:	19 09       	sbc	r17, r9
    4f20:	02 c0       	rjmp	.+4      	; 0x4f26 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    4f22:	84 01       	movw	r16, r8
    4f24:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    4f26:	2a a1       	ldd	r18, Y+34	; 0x22
    4f28:	21 50       	subi	r18, 0x01	; 1
    4f2a:	90 e0       	ldi	r25, 0x00	; 0
    4f2c:	21 10       	cpse	r2, r1
    4f2e:	91 e0       	ldi	r25, 0x01	; 1
    4f30:	29 1b       	sub	r18, r25
    4f32:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    4f34:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    4f36:	a8 2e       	mov	r10, r24
    4f38:	bb 24       	eor	r11, r11
    4f3a:	cc 24       	eor	r12, r12
    4f3c:	dd 24       	eor	r13, r13
    4f3e:	c8 01       	movw	r24, r16
    4f40:	b7 01       	movw	r22, r14
    4f42:	a6 01       	movw	r20, r12
    4f44:	95 01       	movw	r18, r10
    4f46:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodsi4>
    4f4a:	fb 01       	movw	r30, r22
    4f4c:	ef 70       	andi	r30, 0x0F	; 15
    4f4e:	f0 70       	andi	r31, 0x00	; 0
    4f50:	ea 52       	subi	r30, 0x2A	; 42
    4f52:	fe 4f       	sbci	r31, 0xFE	; 254
    4f54:	64 91       	lpm	r22, Z+
    4f56:	6f 8f       	std	Y+31, r22	; 0x1f
    4f58:	c8 01       	movw	r24, r16
    4f5a:	b7 01       	movw	r22, r14
    4f5c:	a6 01       	movw	r20, r12
    4f5e:	95 01       	movw	r18, r10
    4f60:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodsi4>
    4f64:	c9 01       	movw	r24, r18
    4f66:	da 01       	movw	r26, r20
    4f68:	7c 01       	movw	r14, r24
    4f6a:	8d 01       	movw	r16, r26
    4f6c:	9e e1       	ldi	r25, 0x1E	; 30
    4f6e:	49 2e       	mov	r4, r25
    4f70:	51 2c       	mov	r5, r1
    4f72:	4c 0e       	add	r4, r28
    4f74:	5d 1e       	adc	r5, r29
    4f76:	39 a0       	ldd	r3, Y+33	; 0x21
    4f78:	25 c0       	rjmp	.+74     	; 0x4fc4 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    4f7a:	e1 14       	cp	r14, r1
    4f7c:	f1 04       	cpc	r15, r1
    4f7e:	01 05       	cpc	r16, r1
    4f80:	11 05       	cpc	r17, r1
    4f82:	c9 f0       	breq	.+50     	; 0x4fb6 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    4f84:	c8 01       	movw	r24, r16
    4f86:	b7 01       	movw	r22, r14
    4f88:	a6 01       	movw	r20, r12
    4f8a:	95 01       	movw	r18, r10
    4f8c:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodsi4>
    4f90:	fb 01       	movw	r30, r22
    4f92:	ef 70       	andi	r30, 0x0F	; 15
    4f94:	f0 70       	andi	r31, 0x00	; 0
    4f96:	ea 52       	subi	r30, 0x2A	; 42
    4f98:	fe 4f       	sbci	r31, 0xFE	; 254
    4f9a:	64 91       	lpm	r22, Z+
    4f9c:	f2 01       	movw	r30, r4
    4f9e:	60 83       	st	Z, r22
    4fa0:	c8 01       	movw	r24, r16
    4fa2:	b7 01       	movw	r22, r14
    4fa4:	a6 01       	movw	r20, r12
    4fa6:	95 01       	movw	r18, r10
    4fa8:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodsi4>
    4fac:	c9 01       	movw	r24, r18
    4fae:	da 01       	movw	r26, r20
    4fb0:	7c 01       	movw	r14, r24
    4fb2:	8d 01       	movw	r16, r26
    4fb4:	03 c0       	rjmp	.+6      	; 0x4fbc <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    4fb6:	2b a1       	ldd	r18, Y+35	; 0x23
    4fb8:	f2 01       	movw	r30, r4
    4fba:	20 83       	st	Z, r18
    4fbc:	3a 94       	dec	r3
    4fbe:	08 94       	sec
    4fc0:	41 08       	sbc	r4, r1
    4fc2:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    4fc4:	33 20       	and	r3, r3
    4fc6:	c9 f6       	brne	.-78     	; 0x4f7a <rprintfNum+0xae>
    4fc8:	ce 01       	movw	r24, r28
    4fca:	4f 96       	adiw	r24, 0x1f	; 31
    4fcc:	8c 01       	movw	r16, r24
    4fce:	e9 a1       	ldd	r30, Y+33	; 0x21
    4fd0:	0e 1b       	sub	r16, r30
    4fd2:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    4fd4:	22 20       	and	r2, r2
    4fd6:	f1 f0       	breq	.+60     	; 0x5014 <rprintfNum+0x148>
	{
		if(n < 0)
    4fd8:	97 fe       	sbrs	r9, 7
    4fda:	05 c0       	rjmp	.+10     	; 0x4fe6 <rprintfNum+0x11a>
		{
   			*--p = '-';
    4fdc:	8d e2       	ldi	r24, 0x2D	; 45
    4fde:	f8 01       	movw	r30, r16
    4fe0:	82 93       	st	-Z, r24
    4fe2:	8f 01       	movw	r16, r30
    4fe4:	17 c0       	rjmp	.+46     	; 0x5014 <rprintfNum+0x148>
    4fe6:	c8 01       	movw	r24, r16
    4fe8:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    4fea:	61 14       	cp	r6, r1
    4fec:	71 04       	cpc	r7, r1
    4fee:	81 04       	cpc	r8, r1
    4ff0:	91 04       	cpc	r9, r1
    4ff2:	19 f0       	breq	.+6      	; 0x4ffa <rprintfNum+0x12e>
		{
	   		*--p = '+';
    4ff4:	8c 01       	movw	r16, r24
    4ff6:	8b e2       	ldi	r24, 0x2B	; 43
    4ff8:	02 c0       	rjmp	.+4      	; 0x4ffe <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    4ffa:	8c 01       	movw	r16, r24
    4ffc:	80 e2       	ldi	r24, 0x20	; 32
    4ffe:	f8 01       	movw	r30, r16
    5000:	80 83       	st	Z, r24
    5002:	08 c0       	rjmp	.+16     	; 0x5014 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    5004:	f8 01       	movw	r30, r16
    5006:	81 91       	ld	r24, Z+
    5008:	8f 01       	movw	r16, r30
    500a:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    500e:	fa a1       	ldd	r31, Y+34	; 0x22
    5010:	f1 50       	subi	r31, 0x01	; 1
    5012:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    5014:	2a a1       	ldd	r18, Y+34	; 0x22
    5016:	22 23       	and	r18, r18
    5018:	a9 f7       	brne	.-22     	; 0x5004 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    501a:	a3 96       	adiw	r28, 0x23	; 35
    501c:	0f b6       	in	r0, 0x3f	; 63
    501e:	f8 94       	cli
    5020:	de bf       	out	0x3e, r29	; 62
    5022:	0f be       	out	0x3f, r0	; 63
    5024:	cd bf       	out	0x3d, r28	; 61
    5026:	cf 91       	pop	r28
    5028:	df 91       	pop	r29
    502a:	1f 91       	pop	r17
    502c:	0f 91       	pop	r16
    502e:	ff 90       	pop	r15
    5030:	ef 90       	pop	r14
    5032:	df 90       	pop	r13
    5034:	cf 90       	pop	r12
    5036:	bf 90       	pop	r11
    5038:	af 90       	pop	r10
    503a:	9f 90       	pop	r9
    503c:	8f 90       	pop	r8
    503e:	7f 90       	pop	r7
    5040:	6f 90       	pop	r6
    5042:	5f 90       	pop	r5
    5044:	4f 90       	pop	r4
    5046:	3f 90       	pop	r3
    5048:	2f 90       	pop	r2
    504a:	08 95       	ret

0000504c <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    504c:	4f 92       	push	r4
    504e:	5f 92       	push	r5
    5050:	6f 92       	push	r6
    5052:	7f 92       	push	r7
    5054:	8f 92       	push	r8
    5056:	9f 92       	push	r9
    5058:	af 92       	push	r10
    505a:	bf 92       	push	r11
    505c:	cf 92       	push	r12
    505e:	df 92       	push	r13
    5060:	ef 92       	push	r14
    5062:	ff 92       	push	r15
    5064:	0f 93       	push	r16
    5066:	1f 93       	push	r17
    5068:	cf 93       	push	r28
    506a:	df 93       	push	r29
    506c:	48 2e       	mov	r4, r24
    506e:	5a 01       	movw	r10, r20
    5070:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    5072:	cb 01       	movw	r24, r22
    5074:	ba 01       	movw	r22, r20
    5076:	20 e0       	ldi	r18, 0x00	; 0
    5078:	30 e0       	ldi	r19, 0x00	; 0
    507a:	40 e0       	ldi	r20, 0x00	; 0
    507c:	50 e0       	ldi	r21, 0x00	; 0
    507e:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <__gesf2>
    5082:	18 16       	cp	r1, r24
    5084:	1c f4       	brge	.+6      	; 0x508c <rprintfFloat+0x40>
    5086:	35 01       	movw	r6, r10
    5088:	46 01       	movw	r8, r12
    508a:	06 c0       	rjmp	.+12     	; 0x5098 <rprintfFloat+0x4c>
    508c:	35 01       	movw	r6, r10
    508e:	46 01       	movw	r8, r12
    5090:	97 fa       	bst	r9, 7
    5092:	90 94       	com	r9
    5094:	97 f8       	bld	r9, 7
    5096:	90 94       	com	r9
    5098:	0f 2e       	mov	r0, r31
    509a:	f0 e0       	ldi	r31, 0x00	; 0
    509c:	ef 2e       	mov	r14, r31
    509e:	f0 e0       	ldi	r31, 0x00	; 0
    50a0:	ff 2e       	mov	r15, r31
    50a2:	f0 e8       	ldi	r31, 0x80	; 128
    50a4:	0f 2f       	mov	r16, r31
    50a6:	ff e3       	ldi	r31, 0x3F	; 63
    50a8:	1f 2f       	mov	r17, r31
    50aa:	f0 2d       	mov	r31, r0
    50ac:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    50ae:	c4 01       	movw	r24, r8
    50b0:	b3 01       	movw	r22, r6
    50b2:	a8 01       	movw	r20, r16
    50b4:	97 01       	movw	r18, r14
    50b6:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    50ba:	20 e0       	ldi	r18, 0x00	; 0
    50bc:	30 e0       	ldi	r19, 0x00	; 0
    50be:	40 e2       	ldi	r20, 0x20	; 32
    50c0:	51 e4       	ldi	r21, 0x41	; 65
    50c2:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    50c6:	87 fd       	sbrc	r24, 7
    50c8:	0e c0       	rjmp	.+28     	; 0x50e6 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    50ca:	c8 01       	movw	r24, r16
    50cc:	b7 01       	movw	r22, r14
    50ce:	20 e0       	ldi	r18, 0x00	; 0
    50d0:	30 e0       	ldi	r19, 0x00	; 0
    50d2:	40 e2       	ldi	r20, 0x20	; 32
    50d4:	51 e4       	ldi	r21, 0x41	; 65
    50d6:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    50da:	7b 01       	movw	r14, r22
    50dc:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    50de:	53 94       	inc	r5
    50e0:	8f e0       	ldi	r24, 0x0F	; 15
    50e2:	58 16       	cp	r5, r24
    50e4:	21 f7       	brne	.-56     	; 0x50ae <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    50e6:	c6 01       	movw	r24, r12
    50e8:	b5 01       	movw	r22, r10
    50ea:	20 e0       	ldi	r18, 0x00	; 0
    50ec:	30 e0       	ldi	r19, 0x00	; 0
    50ee:	40 e0       	ldi	r20, 0x00	; 0
    50f0:	50 e0       	ldi	r21, 0x00	; 0
    50f2:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    50f6:	88 23       	and	r24, r24
    50f8:	14 f4       	brge	.+4      	; 0x50fe <rprintfFloat+0xb2>
		rprintfChar('-');
    50fa:	8d e2       	ldi	r24, 0x2D	; 45
    50fc:	01 c0       	rjmp	.+2      	; 0x5100 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    50fe:	8b e2       	ldi	r24, 0x2B	; 43
    5100:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    5104:	dd 24       	eor	r13, r13
    5106:	aa 24       	eor	r10, r10
    5108:	56 c0       	rjmp	.+172    	; 0x51b6 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    510a:	c4 01       	movw	r24, r8
    510c:	b3 01       	movw	r22, r6
    510e:	a8 01       	movw	r20, r16
    5110:	97 01       	movw	r18, r14
    5112:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    5116:	0e 94 fe 2c 	call	0x59fc	; 0x59fc <__fixunssfsi>
    511a:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    511c:	d6 2a       	or	r13, r22
    511e:	cd 2d       	mov	r28, r13
    5120:	d0 e0       	ldi	r29, 0x00	; 0
    5122:	cc 24       	eor	r12, r12
    5124:	dd 24       	eor	r13, r13
    5126:	c8 01       	movw	r24, r16
    5128:	b7 01       	movw	r22, r14
    512a:	20 e0       	ldi	r18, 0x00	; 0
    512c:	30 e0       	ldi	r19, 0x00	; 0
    512e:	40 e8       	ldi	r20, 0x80	; 128
    5130:	5f e3       	ldi	r21, 0x3F	; 63
    5132:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    5136:	88 23       	and	r24, r24
    5138:	19 f4       	brne	.+6      	; 0x5140 <rprintfFloat+0xf4>
    513a:	21 e0       	ldi	r18, 0x01	; 1
    513c:	c2 2e       	mov	r12, r18
    513e:	d1 2c       	mov	r13, r1
    5140:	cc 29       	or	r28, r12
    5142:	dd 29       	or	r29, r13
    5144:	cd 2b       	or	r28, r29
    5146:	39 f0       	breq	.+14     	; 0x5156 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    5148:	8b 2d       	mov	r24, r11
    514a:	80 5d       	subi	r24, 0xD0	; 208
    514c:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    5150:	dd 24       	eor	r13, r13
    5152:	da 94       	dec	r13
    5154:	04 c0       	rjmp	.+8      	; 0x515e <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    5156:	80 e2       	ldi	r24, 0x20	; 32
    5158:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    515c:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    515e:	c8 01       	movw	r24, r16
    5160:	b7 01       	movw	r22, r14
    5162:	20 e0       	ldi	r18, 0x00	; 0
    5164:	30 e0       	ldi	r19, 0x00	; 0
    5166:	40 e8       	ldi	r20, 0x80	; 128
    5168:	5f e3       	ldi	r21, 0x3F	; 63
    516a:	0e 94 8d 2c 	call	0x591a	; 0x591a <__cmpsf2>
    516e:	88 23       	and	r24, r24
    5170:	19 f4       	brne	.+6      	; 0x5178 <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    5172:	8e e2       	ldi	r24, 0x2E	; 46
    5174:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
		}
		
		x -= (digit*place);
    5178:	6b 2d       	mov	r22, r11
    517a:	70 e0       	ldi	r23, 0x00	; 0
    517c:	88 27       	eor	r24, r24
    517e:	77 fd       	sbrc	r23, 7
    5180:	80 95       	com	r24
    5182:	98 2f       	mov	r25, r24
    5184:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <__floatsisf>
    5188:	a8 01       	movw	r20, r16
    518a:	97 01       	movw	r18, r14
    518c:	0e 94 e0 2d 	call	0x5bc0	; 0x5bc0 <__mulsf3>
    5190:	9b 01       	movw	r18, r22
    5192:	ac 01       	movw	r20, r24
    5194:	c4 01       	movw	r24, r8
    5196:	b3 01       	movw	r22, r6
    5198:	0e 94 28 2c 	call	0x5850	; 0x5850 <__subsf3>
    519c:	3b 01       	movw	r6, r22
    519e:	4c 01       	movw	r8, r24
		place /= 10.0;
    51a0:	c8 01       	movw	r24, r16
    51a2:	b7 01       	movw	r22, r14
    51a4:	20 e0       	ldi	r18, 0x00	; 0
    51a6:	30 e0       	ldi	r19, 0x00	; 0
    51a8:	40 e2       	ldi	r20, 0x20	; 32
    51aa:	51 e4       	ldi	r21, 0x41	; 65
    51ac:	0e 94 91 2c 	call	0x5922	; 0x5922 <__divsf3>
    51b0:	7b 01       	movw	r14, r22
    51b2:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    51b4:	a3 94       	inc	r10
    51b6:	a4 14       	cp	r10, r4
    51b8:	08 f4       	brcc	.+2      	; 0x51bc <rprintfFloat+0x170>
    51ba:	a7 cf       	rjmp	.-178    	; 0x510a <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    51bc:	df 91       	pop	r29
    51be:	cf 91       	pop	r28
    51c0:	1f 91       	pop	r17
    51c2:	0f 91       	pop	r16
    51c4:	ff 90       	pop	r15
    51c6:	ef 90       	pop	r14
    51c8:	df 90       	pop	r13
    51ca:	cf 90       	pop	r12
    51cc:	bf 90       	pop	r11
    51ce:	af 90       	pop	r10
    51d0:	9f 90       	pop	r9
    51d2:	8f 90       	pop	r8
    51d4:	7f 90       	pop	r7
    51d6:	6f 90       	pop	r6
    51d8:	5f 90       	pop	r5
    51da:	4f 90       	pop	r4
    51dc:	08 95       	ret

000051de <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    51de:	7f 92       	push	r7
    51e0:	8f 92       	push	r8
    51e2:	9f 92       	push	r9
    51e4:	af 92       	push	r10
    51e6:	bf 92       	push	r11
    51e8:	cf 92       	push	r12
    51ea:	df 92       	push	r13
    51ec:	ef 92       	push	r14
    51ee:	ff 92       	push	r15
    51f0:	0f 93       	push	r16
    51f2:	1f 93       	push	r17
    51f4:	df 93       	push	r29
    51f6:	cf 93       	push	r28
    51f8:	cd b7       	in	r28, 0x3d	; 61
    51fa:	de b7       	in	r29, 0x3e	; 62
    51fc:	78 88       	ldd	r7, Y+16	; 0x10
    51fe:	c9 88       	ldd	r12, Y+17	; 0x11
    5200:	da 88       	ldd	r13, Y+18	; 0x12
    5202:	63 e1       	ldi	r22, 0x13	; 19
    5204:	e6 2e       	mov	r14, r22
    5206:	f1 2c       	mov	r15, r1
    5208:	ec 0e       	add	r14, r28
    520a:	fd 1e       	adc	r15, r29
    520c:	14 c0       	rjmp	.+40     	; 0x5236 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    520e:	88 23       	and	r24, r24
    5210:	81 f4       	brne	.+32     	; 0x5232 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    5212:	80 e0       	ldi	r24, 0x00	; 0
    5214:	90 e0       	ldi	r25, 0x00	; 0
    5216:	cf 91       	pop	r28
    5218:	df 91       	pop	r29
    521a:	1f 91       	pop	r17
    521c:	0f 91       	pop	r16
    521e:	ff 90       	pop	r15
    5220:	ef 90       	pop	r14
    5222:	df 90       	pop	r13
    5224:	cf 90       	pop	r12
    5226:	bf 90       	pop	r11
    5228:	af 90       	pop	r10
    522a:	9f 90       	pop	r9
    522c:	8f 90       	pop	r8
    522e:	7f 90       	pop	r7
    5230:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    5232:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    5236:	96 01       	movw	r18, r12
    5238:	2f 5f       	subi	r18, 0xFF	; 255
    523a:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    523c:	77 20       	and	r7, r7
    523e:	21 f0       	breq	.+8      	; 0x5248 <rprintf1RamRom+0x6a>
    5240:	f6 01       	movw	r30, r12
    5242:	69 01       	movw	r12, r18
    5244:	84 91       	lpm	r24, Z+
    5246:	03 c0       	rjmp	.+6      	; 0x524e <rprintf1RamRom+0x70>
    5248:	f6 01       	movw	r30, r12
    524a:	80 81       	ld	r24, Z
    524c:	69 01       	movw	r12, r18
    524e:	85 32       	cpi	r24, 0x25	; 37
    5250:	f1 f6       	brne	.-68     	; 0x520e <rprintf1RamRom+0x30>
    5252:	2f 5f       	subi	r18, 0xFF	; 255
    5254:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    5256:	77 20       	and	r7, r7
    5258:	21 f0       	breq	.+8      	; 0x5262 <rprintf1RamRom+0x84>
    525a:	f6 01       	movw	r30, r12
    525c:	69 01       	movw	r12, r18
    525e:	84 91       	lpm	r24, Z+
    5260:	03 c0       	rjmp	.+6      	; 0x5268 <rprintf1RamRom+0x8a>
    5262:	f6 01       	movw	r30, r12
    5264:	80 81       	ld	r24, Z
    5266:	69 01       	movw	r12, r18
    5268:	84 36       	cpi	r24, 0x64	; 100
    526a:	29 f0       	breq	.+10     	; 0x5276 <rprintf1RamRom+0x98>
    526c:	88 37       	cpi	r24, 0x78	; 120
    526e:	81 f0       	breq	.+32     	; 0x5290 <rprintf1RamRom+0xb2>
    5270:	83 36       	cpi	r24, 0x63	; 99
    5272:	f9 f6       	brne	.-66     	; 0x5232 <rprintf1RamRom+0x54>
    5274:	06 c0       	rjmp	.+12     	; 0x5282 <rprintf1RamRom+0xa4>
    5276:	00 e1       	ldi	r16, 0x10	; 16
    5278:	17 e2       	ldi	r17, 0x27	; 39
    527a:	5a e0       	ldi	r21, 0x0A	; 10
    527c:	a5 2e       	mov	r10, r21
    527e:	b1 2c       	mov	r11, r1
    5280:	0c c0       	rjmp	.+24     	; 0x529a <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    5282:	f7 01       	movw	r30, r14
    5284:	80 81       	ld	r24, Z
    5286:	22 e0       	ldi	r18, 0x02	; 2
    5288:	30 e0       	ldi	r19, 0x00	; 0
    528a:	e2 0e       	add	r14, r18
    528c:	f3 1e       	adc	r15, r19
    528e:	d1 cf       	rjmp	.-94     	; 0x5232 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    5290:	00 e0       	ldi	r16, 0x00	; 0
    5292:	10 e1       	ldi	r17, 0x10	; 16
    5294:	40 e1       	ldi	r20, 0x10	; 16
    5296:	a4 2e       	mov	r10, r20
    5298:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    529a:	32 e0       	ldi	r19, 0x02	; 2
    529c:	83 2e       	mov	r8, r19
    529e:	91 2c       	mov	r9, r1
    52a0:	8e 0c       	add	r8, r14
    52a2:	9f 1c       	adc	r9, r15
    52a4:	f7 01       	movw	r30, r14
    52a6:	e0 80       	ld	r14, Z
    52a8:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    52aa:	84 36       	cpi	r24, 0x64	; 100
    52ac:	b1 f4       	brne	.+44     	; 0x52da <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    52ae:	f7 fe       	sbrs	r15, 7
    52b0:	11 c0       	rjmp	.+34     	; 0x52d4 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    52b2:	f0 94       	com	r15
    52b4:	e1 94       	neg	r14
    52b6:	f1 08       	sbc	r15, r1
    52b8:	f3 94       	inc	r15
					rprintfChar('-');
    52ba:	8d e2       	ldi	r24, 0x2D	; 45
    52bc:	0e 94 d0 26 	call	0x4da0	; 0x4da0 <rprintfChar>
    52c0:	09 c0       	rjmp	.+18     	; 0x52d4 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    52c2:	c8 01       	movw	r24, r16
    52c4:	6a e0       	ldi	r22, 0x0A	; 10
    52c6:	70 e0       	ldi	r23, 0x00	; 0
    52c8:	0e 94 1e 30 	call	0x603c	; 0x603c <__udivmodhi4>
    52cc:	8b 01       	movw	r16, r22
    52ce:	62 30       	cpi	r22, 0x02	; 2
    52d0:	71 05       	cpc	r23, r1
    52d2:	18 f0       	brcs	.+6      	; 0x52da <rprintf1RamRom+0xfc>
    52d4:	e0 16       	cp	r14, r16
    52d6:	f1 06       	cpc	r15, r17
    52d8:	a0 f3       	brcs	.-24     	; 0x52c2 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    52da:	c7 01       	movw	r24, r14
    52dc:	b8 01       	movw	r22, r16
    52de:	0e 94 1e 30 	call	0x603c	; 0x603c <__udivmodhi4>
    52e2:	86 2f       	mov	r24, r22
    52e4:	0e 94 33 27 	call	0x4e66	; 0x4e66 <rprintfu04>
				u_val %= div_val;
    52e8:	c7 01       	movw	r24, r14
    52ea:	b8 01       	movw	r22, r16
    52ec:	0e 94 1e 30 	call	0x603c	; 0x603c <__udivmodhi4>
    52f0:	7c 01       	movw	r14, r24
				div_val /= base;
    52f2:	c8 01       	movw	r24, r16
    52f4:	b5 01       	movw	r22, r10
    52f6:	0e 94 1e 30 	call	0x603c	; 0x603c <__udivmodhi4>
    52fa:	8b 01       	movw	r16, r22
			} while (div_val);
    52fc:	61 15       	cp	r22, r1
    52fe:	71 05       	cpc	r23, r1
    5300:	61 f7       	brne	.-40     	; 0x52da <rprintf1RamRom+0xfc>
    5302:	74 01       	movw	r14, r8
    5304:	98 cf       	rjmp	.-208    	; 0x5236 <rprintf1RamRom+0x58>

00005306 <i2cSetBitrate>:
	// SCL freq = F_CPU/(16+2*TWBR))
	#ifdef TWPS0
		// for processors with additional bitrate division (mega128)
		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
		// set TWPS to zero
		cbi(TWSR, TWPS0);
    5306:	20 91 b9 00 	lds	r18, 0x00B9
    530a:	2e 7f       	andi	r18, 0xFE	; 254
    530c:	20 93 b9 00 	sts	0x00B9, r18
		cbi(TWSR, TWPS1);
    5310:	20 91 b9 00 	lds	r18, 0x00B9
    5314:	2d 7f       	andi	r18, 0xFD	; 253
    5316:	20 93 b9 00 	sts	0x00B9, r18
	#endif
	// calculate bitrate division	
	bitrate_div = ((F_CPU/1000l)/bitrateKHz);
    531a:	9c 01       	movw	r18, r24
    531c:	40 e0       	ldi	r20, 0x00	; 0
    531e:	50 e0       	ldi	r21, 0x00	; 0
    5320:	60 e8       	ldi	r22, 0x80	; 128
    5322:	7e e3       	ldi	r23, 0x3E	; 62
    5324:	80 e0       	ldi	r24, 0x00	; 0
    5326:	90 e0       	ldi	r25, 0x00	; 0
    5328:	0e 94 67 30 	call	0x60ce	; 0x60ce <__divmodsi4>
	if(bitrate_div >= 16)
    532c:	20 31       	cpi	r18, 0x10	; 16
    532e:	30 f0       	brcs	.+12     	; 0x533c <i2cSetBitrate+0x36>
		bitrate_div = (bitrate_div-16)/2;
    5330:	82 2f       	mov	r24, r18
    5332:	90 e0       	ldi	r25, 0x00	; 0
    5334:	40 97       	sbiw	r24, 0x10	; 16
    5336:	95 95       	asr	r25
    5338:	87 95       	ror	r24
    533a:	28 2f       	mov	r18, r24
	outb(TWBR, bitrate_div);
    533c:	20 93 b8 00 	sts	0x00B8, r18
}
    5340:	08 95       	ret

00005342 <i2cInit>:

// functions
void i2cInit(void)
{
	// set pull-up resistors on I2C bus pins
	sbi(PORTD, 0);	// i2c SCL on 640
    5342:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, 1);	// i2c SDA on 640
    5344:	59 9a       	sbi	0x0b, 1	; 11

	// clear SlaveReceive and SlaveTransmit handler to null
	i2cSlaveReceive = 0;
    5346:	10 92 ff 11 	sts	0x11FF, r1
    534a:	10 92 fe 11 	sts	0x11FE, r1
	i2cSlaveTransmit = 0;
    534e:	10 92 01 12 	sts	0x1201, r1
    5352:	10 92 00 12 	sts	0x1200, r1
	// set i2c bit rate to 100KHz
	i2cSetBitrate(100);
    5356:	84 e6       	ldi	r24, 0x64	; 100
    5358:	90 e0       	ldi	r25, 0x00	; 0
    535a:	0e 94 83 29 	call	0x5306	; 0x5306 <i2cSetBitrate>
	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
    535e:	ec eb       	ldi	r30, 0xBC	; 188
    5360:	f0 e0       	ldi	r31, 0x00	; 0
    5362:	80 81       	ld	r24, Z
    5364:	84 60       	ori	r24, 0x04	; 4
    5366:	80 83       	st	Z, r24
	// set state
	I2cState = I2C_IDLE;
    5368:	10 92 b8 11 	sts	0x11B8, r1
	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
    536c:	80 81       	ld	r24, Z
    536e:	81 60       	ori	r24, 0x01	; 1
    5370:	80 83       	st	Z, r24
	sbi(TWCR, TWEA);
    5372:	80 81       	ld	r24, Z
    5374:	80 64       	ori	r24, 0x40	; 64
    5376:	80 83       	st	Z, r24
	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	// enable interrupts
	sei();
    5378:	78 94       	sei
}
    537a:	08 95       	ret

0000537c <i2cSetLocalDeviceAddr>:
}

void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
{
	// set local device address (used in slave mode only)
	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
    537c:	90 e0       	ldi	r25, 0x00	; 0
    537e:	61 11       	cpse	r22, r1
    5380:	91 e0       	ldi	r25, 0x01	; 1
    5382:	8e 7f       	andi	r24, 0xFE	; 254
    5384:	98 2b       	or	r25, r24
    5386:	90 93 ba 00 	sts	0x00BA, r25
}
    538a:	08 95       	ret

0000538c <i2cSetSlaveReceiveHandler>:

void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
{
	i2cSlaveReceive = i2cSlaveRx_func;
    538c:	90 93 ff 11 	sts	0x11FF, r25
    5390:	80 93 fe 11 	sts	0x11FE, r24
}
    5394:	08 95       	ret

00005396 <i2cSetSlaveTransmitHandler>:

void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData))
{
	i2cSlaveTransmit = i2cSlaveTx_func;
    5396:	90 93 01 12 	sts	0x1201, r25
    539a:	80 93 00 12 	sts	0x1200, r24
}
    539e:	08 95       	ret

000053a0 <i2cSendStart>:

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    53a0:	ec eb       	ldi	r30, 0xBC	; 188
    53a2:	f0 e0       	ldi	r31, 0x00	; 0
    53a4:	80 81       	ld	r24, Z
    53a6:	8f 70       	andi	r24, 0x0F	; 15
    53a8:	80 6a       	ori	r24, 0xA0	; 160
    53aa:	80 83       	st	Z, r24
}
    53ac:	08 95       	ret

000053ae <i2cSendStop>:

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    53ae:	ec eb       	ldi	r30, 0xBC	; 188
    53b0:	f0 e0       	ldi	r31, 0x00	; 0
    53b2:	80 81       	ld	r24, Z
    53b4:	8f 70       	andi	r24, 0x0F	; 15
    53b6:	80 6d       	ori	r24, 0xD0	; 208
    53b8:	80 83       	st	Z, r24
}
    53ba:	08 95       	ret

000053bc <i2cWaitForComplete>:

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    53bc:	80 91 bc 00 	lds	r24, 0x00BC
    53c0:	87 ff       	sbrs	r24, 7
    53c2:	fc cf       	rjmp	.-8      	; 0x53bc <i2cWaitForComplete>
}
    53c4:	08 95       	ret

000053c6 <i2cSendByte>:

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    53c6:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    53ca:	ec eb       	ldi	r30, 0xBC	; 188
    53cc:	f0 e0       	ldi	r31, 0x00	; 0
    53ce:	80 81       	ld	r24, Z
    53d0:	8f 70       	andi	r24, 0x0F	; 15
    53d2:	80 68       	ori	r24, 0x80	; 128
    53d4:	80 83       	st	Z, r24
}
    53d6:	08 95       	ret

000053d8 <i2cReceiveByte>:

inline void i2cReceiveByte(u08 ackFlag)
{
	// begin receive over i2c
	if( ackFlag )
    53d8:	88 23       	and	r24, r24
    53da:	29 f0       	breq	.+10     	; 0x53e6 <i2cReceiveByte+0xe>
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    53dc:	80 91 bc 00 	lds	r24, 0x00BC
    53e0:	8f 70       	andi	r24, 0x0F	; 15
    53e2:	80 6c       	ori	r24, 0xC0	; 192
    53e4:	04 c0       	rjmp	.+8      	; 0x53ee <i2cReceiveByte+0x16>
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    53e6:	80 91 bc 00 	lds	r24, 0x00BC
    53ea:	8f 70       	andi	r24, 0x0F	; 15
    53ec:	80 68       	ori	r24, 0x80	; 128
    53ee:	80 93 bc 00 	sts	0x00BC, r24
    53f2:	08 95       	ret

000053f4 <i2cGetReceivedByte>:
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    53f4:	80 91 bb 00 	lds	r24, 0x00BB
}
    53f8:	08 95       	ret

000053fa <i2cGetStatus>:

inline u08 i2cGetStatus(void)
{
	// retieve current i2c status from i2c TWSR
	return( inb(TWSR) );
    53fa:	80 91 b9 00 	lds	r24, 0x00B9
}
    53fe:	08 95       	ret

00005400 <i2cMasterSend>:

void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
{
    5400:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    5402:	80 91 b8 11 	lds	r24, 0x11B8
    5406:	88 23       	and	r24, r24
    5408:	e1 f7       	brne	.-8      	; 0x5402 <i2cMasterSend+0x2>
	// set state
	I2cState = I2C_MASTER_TX;
    540a:	82 e0       	ldi	r24, 0x02	; 2
    540c:	80 93 b8 11 	sts	0x11B8, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
    5410:	9e 7f       	andi	r25, 0xFE	; 254
    5412:	90 93 b9 11 	sts	0x11B9, r25
    5416:	aa eb       	ldi	r26, 0xBA	; 186
    5418:	b1 e1       	ldi	r27, 0x11	; 17
    541a:	fa 01       	movw	r30, r20
    541c:	02 c0       	rjmp	.+4      	; 0x5422 <i2cMasterSend+0x22>
	for(i=0; i<length; i++)
		I2cSendData[i] = *data++;
    541e:	81 91       	ld	r24, Z+
    5420:	8d 93       	st	X+, r24
	while(I2cState);
	// set state
	I2cState = I2C_MASTER_TX;
	// save data
	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
	for(i=0; i<length; i++)
    5422:	8e 2f       	mov	r24, r30
    5424:	84 1b       	sub	r24, r20
    5426:	86 17       	cp	r24, r22
    5428:	d0 f3       	brcs	.-12     	; 0x541e <i2cMasterSend+0x1e>
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
    542a:	10 92 da 11 	sts	0x11DA, r1
	I2cSendDataLength = length;
    542e:	60 93 db 11 	sts	0x11DB, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5432:	80 91 bc 00 	lds	r24, 0x00BC
    5436:	8f 70       	andi	r24, 0x0F	; 15
    5438:	80 6a       	ori	r24, 0xA0	; 160
    543a:	80 93 bc 00 	sts	0x00BC, r24
		I2cSendData[i] = *data++;
	I2cSendDataIndex = 0;
	I2cSendDataLength = length;
	// send start condition
	i2cSendStart();
}
    543e:	08 95       	ret

00005440 <i2cMasterReceive>:

void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
{
    5440:	98 2f       	mov	r25, r24
	u08 i;
	// wait for interface to be ready
	while(I2cState);
    5442:	80 91 b8 11 	lds	r24, 0x11B8
    5446:	88 23       	and	r24, r24
    5448:	e1 f7       	brne	.-8      	; 0x5442 <i2cMasterReceive+0x2>
	// set state
	I2cState = I2C_MASTER_RX;
    544a:	83 e0       	ldi	r24, 0x03	; 3
    544c:	80 93 b8 11 	sts	0x11B8, r24
	// save data
	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
    5450:	91 60       	ori	r25, 0x01	; 1
    5452:	90 93 b9 11 	sts	0x11B9, r25
	I2cReceiveDataIndex = 0;
    5456:	10 92 fc 11 	sts	0x11FC, r1
	I2cReceiveDataLength = length;
    545a:	60 93 fd 11 	sts	0x11FD, r22
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    545e:	80 91 bc 00 	lds	r24, 0x00BC
    5462:	8f 70       	andi	r24, 0x0F	; 15
    5464:	80 6a       	ori	r24, 0xA0	; 160
    5466:	80 93 bc 00 	sts	0x00BC, r24
	I2cReceiveDataIndex = 0;
	I2cReceiveDataLength = length;
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
    546a:	80 91 b8 11 	lds	r24, 0x11B8
    546e:	88 23       	and	r24, r24
    5470:	e1 f7       	brne	.-8      	; 0x546a <i2cMasterReceive+0x2a>
    5472:	ac ed       	ldi	r26, 0xDC	; 220
    5474:	b1 e1       	ldi	r27, 0x11	; 17
    5476:	fa 01       	movw	r30, r20
    5478:	02 c0       	rjmp	.+4      	; 0x547e <i2cMasterReceive+0x3e>
	// return data
	for(i=0; i<length; i++)
		*data++ = I2cReceiveData[i];
    547a:	8d 91       	ld	r24, X+
    547c:	81 93       	st	Z+, r24
	// send start condition
	i2cSendStart();
	// wait for data
	while(I2cState);
	// return data
	for(i=0; i<length; i++)
    547e:	8e 2f       	mov	r24, r30
    5480:	84 1b       	sub	r24, r20
    5482:	86 17       	cp	r24, r22
    5484:	d0 f3       	brcs	.-12     	; 0x547a <i2cMasterReceive+0x3a>
		*data++ = I2cReceiveData[i];
}
    5486:	08 95       	ret

00005488 <i2cMasterSendNI>:

u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
{
    5488:	98 2f       	mov	r25, r24
    548a:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    548c:	80 91 bc 00 	lds	r24, 0x00BC
    5490:	8e 7f       	andi	r24, 0xFE	; 254
    5492:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5496:	80 91 bc 00 	lds	r24, 0x00BC
    549a:	8f 70       	andi	r24, 0x0F	; 15
    549c:	80 6a       	ori	r24, 0xA0	; 160
    549e:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    54a2:	80 91 bc 00 	lds	r24, 0x00BC
    54a6:	87 ff       	sbrs	r24, 7
    54a8:	fc cf       	rjmp	.-8      	; 0x54a2 <i2cMasterSendNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
    54aa:	9e 7f       	andi	r25, 0xFE	; 254
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    54ac:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    54b0:	80 91 bc 00 	lds	r24, 0x00BC
    54b4:	8f 70       	andi	r24, 0x0F	; 15
    54b6:	80 68       	ori	r24, 0x80	; 128
    54b8:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    54bc:	80 91 bc 00 	lds	r24, 0x00BC
    54c0:	87 ff       	sbrs	r24, 7
    54c2:	fc cf       	rjmp	.-8      	; 0x54bc <i2cMasterSendNI+0x34>
	// send device address with write
	i2cSendByte( deviceAddr & 0xFE );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
    54c4:	80 91 b9 00 	lds	r24, 0x00B9
    54c8:	88 31       	cpi	r24, 0x18	; 24
    54ca:	89 f0       	breq	.+34     	; 0x54ee <i2cMasterSendNI+0x66>
    54cc:	91 e0       	ldi	r25, 0x01	; 1
    54ce:	12 c0       	rjmp	.+36     	; 0x54f4 <i2cMasterSendNI+0x6c>
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    54d0:	80 81       	ld	r24, Z
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    54d2:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    54d6:	80 91 bc 00 	lds	r24, 0x00BC
    54da:	8f 70       	andi	r24, 0x0F	; 15
    54dc:	80 68       	ori	r24, 0x80	; 128
    54de:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    54e2:	80 91 bc 00 	lds	r24, 0x00BC
    54e6:	87 ff       	sbrs	r24, 7
    54e8:	fc cf       	rjmp	.-8      	; 0x54e2 <i2cMasterSendNI+0x5a>
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
		{
			i2cSendByte( *data++ );
    54ea:	31 96       	adiw	r30, 0x01	; 1
			i2cWaitForComplete();
			length--;
    54ec:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MT_SLA_ACK)
	{
		// send data
		while(length)
    54ee:	66 23       	and	r22, r22
    54f0:	79 f7       	brne	.-34     	; 0x54d0 <i2cMasterSendNI+0x48>
    54f2:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    54f4:	80 91 bc 00 	lds	r24, 0x00BC
    54f8:	8f 70       	andi	r24, 0x0F	; 15
    54fa:	80 6d       	ori	r24, 0xD0	; 208
    54fc:	80 93 bc 00 	sts	0x00BC, r24
	}

	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();
	while( !(inb(TWCR) & BV(TWSTO)) );
    5500:	80 91 bc 00 	lds	r24, 0x00BC
    5504:	84 ff       	sbrs	r24, 4
    5506:	fc cf       	rjmp	.-8      	; 0x5500 <i2cMasterSendNI+0x78>

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    5508:	80 91 bc 00 	lds	r24, 0x00BC
    550c:	81 60       	ori	r24, 0x01	; 1
    550e:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    5512:	89 2f       	mov	r24, r25
    5514:	08 95       	ret

00005516 <i2cMasterReceiveNI>:

u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
{
    5516:	98 2f       	mov	r25, r24
    5518:	fa 01       	movw	r30, r20
	u08 retval = I2C_OK;

	// disable TWI interrupt
	cbi(TWCR, TWIE);
    551a:	80 91 bc 00 	lds	r24, 0x00BC
    551e:	8e 7f       	andi	r24, 0xFE	; 254
    5520:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cSendStart(void)
{
	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
    5524:	80 91 bc 00 	lds	r24, 0x00BC
    5528:	8f 70       	andi	r24, 0x0F	; 15
    552a:	80 6a       	ori	r24, 0xA0	; 160
    552c:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    5530:	80 91 bc 00 	lds	r24, 0x00BC
    5534:	87 ff       	sbrs	r24, 7
    5536:	fc cf       	rjmp	.-8      	; 0x5530 <i2cMasterReceiveNI+0x1a>
	// send start condition
	i2cSendStart();
	i2cWaitForComplete();

	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
    5538:	91 60       	ori	r25, 0x01	; 1
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    553a:	90 93 bb 00 	sts	0x00BB, r25
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    553e:	80 91 bc 00 	lds	r24, 0x00BC
    5542:	8f 70       	andi	r24, 0x0F	; 15
    5544:	80 68       	ori	r24, 0x80	; 128
    5546:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    554a:	80 91 bc 00 	lds	r24, 0x00BC
    554e:	87 ff       	sbrs	r24, 7
    5550:	fc cf       	rjmp	.-8      	; 0x554a <i2cMasterReceiveNI+0x34>
	// send device address with read
	i2cSendByte( deviceAddr | 0x01 );
	i2cWaitForComplete();

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
    5552:	80 91 b9 00 	lds	r24, 0x00B9
    5556:	80 34       	cpi	r24, 0x40	; 64
    5558:	81 f0       	breq	.+32     	; 0x557a <i2cMasterReceiveNI+0x64>
    555a:	91 e0       	ldi	r25, 0x01	; 1
    555c:	1e c0       	rjmp	.+60     	; 0x559a <i2cMasterReceiveNI+0x84>
{
	// begin receive over i2c
	if( ackFlag )
	{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    555e:	80 91 bc 00 	lds	r24, 0x00BC
    5562:	8f 70       	andi	r24, 0x0F	; 15
    5564:	80 6c       	ori	r24, 0xC0	; 192
    5566:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    556a:	80 91 bc 00 	lds	r24, 0x00BC
    556e:	87 ff       	sbrs	r24, 7
    5570:	fc cf       	rjmp	.-8      	; 0x556a <i2cMasterReceiveNI+0x54>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5572:	80 91 bb 00 	lds	r24, 0x00BB
		// accept receive data and ack it
		while(length > 1)
		{
			i2cReceiveByte(TRUE);
			i2cWaitForComplete();
			*data++ = i2cGetReceivedByte();
    5576:	81 93       	st	Z+, r24
			// decrement length
			length--;
    5578:	61 50       	subi	r22, 0x01	; 1

	// check if device is present and live
	if( inb(TWSR) == TW_MR_SLA_ACK)
	{
		// accept receive data and ack it
		while(length > 1)
    557a:	62 30       	cpi	r22, 0x02	; 2
    557c:	80 f7       	brcc	.-32     	; 0x555e <i2cMasterReceiveNI+0x48>
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
	}
	else
	{
		// ackFlag = FALSE: NACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    557e:	80 91 bc 00 	lds	r24, 0x00BC
    5582:	8f 70       	andi	r24, 0x0F	; 15
    5584:	80 68       	ori	r24, 0x80	; 128
    5586:	80 93 bc 00 	sts	0x00BC, r24
}

inline void i2cWaitForComplete(void)
{
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
    558a:	80 91 bc 00 	lds	r24, 0x00BC
    558e:	87 ff       	sbrs	r24, 7
    5590:	fc cf       	rjmp	.-8      	; 0x558a <i2cMasterReceiveNI+0x74>
}

inline u08 i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return( inb(TWDR) );
    5592:	80 91 bb 00 	lds	r24, 0x00BB
		}

		// accept receive data and nack it (last-byte signal)
		i2cReceiveByte(FALSE);
		i2cWaitForComplete();
		*data++ = i2cGetReceivedByte();
    5596:	80 83       	st	Z, r24
    5598:	90 e0       	ldi	r25, 0x00	; 0

inline void i2cSendStop(void)
{
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
    559a:	80 91 bc 00 	lds	r24, 0x00BC
    559e:	8f 70       	andi	r24, 0x0F	; 15
    55a0:	80 6d       	ori	r24, 0xD0	; 208
    55a2:	80 93 bc 00 	sts	0x00BC, r24
	// transmit stop condition
	// leave with TWEA on for slave receiving
	i2cSendStop();

	// enable TWI interrupt
	sbi(TWCR, TWIE);
    55a6:	80 91 bc 00 	lds	r24, 0x00BC
    55aa:	81 60       	ori	r24, 0x01	; 1
    55ac:	80 93 bc 00 	sts	0x00BC, r24

	return retval;
}
    55b0:	89 2f       	mov	r24, r25
    55b2:	08 95       	ret

000055b4 <__vector_39>:
}
*/

//! I2C (TWI) interrupt service routine
SIGNAL(SIG_2WIRE_SERIAL)
{
    55b4:	1f 92       	push	r1
    55b6:	0f 92       	push	r0
    55b8:	0f b6       	in	r0, 0x3f	; 63
    55ba:	0f 92       	push	r0
    55bc:	11 24       	eor	r1, r1
    55be:	2f 93       	push	r18
    55c0:	3f 93       	push	r19
    55c2:	4f 93       	push	r20
    55c4:	5f 93       	push	r21
    55c6:	6f 93       	push	r22
    55c8:	7f 93       	push	r23
    55ca:	8f 93       	push	r24
    55cc:	9f 93       	push	r25
    55ce:	af 93       	push	r26
    55d0:	bf 93       	push	r27
    55d2:	ef 93       	push	r30
    55d4:	ff 93       	push	r31
	// read status bits
	u08 status = inb(TWSR) & TWSR_STATUS_MASK;
    55d6:	80 91 b9 00 	lds	r24, 0x00B9

	switch(status)
    55da:	88 7f       	andi	r24, 0xF8	; 248
    55dc:	80 36       	cpi	r24, 0x60	; 96
    55de:	09 f4       	brne	.+2      	; 0x55e2 <__vector_39+0x2e>
    55e0:	a0 c0       	rjmp	.+320    	; 0x5722 <__vector_39+0x16e>
    55e2:	81 36       	cpi	r24, 0x61	; 97
    55e4:	70 f5       	brcc	.+92     	; 0x5642 <__vector_39+0x8e>
    55e6:	88 32       	cpi	r24, 0x28	; 40
    55e8:	09 f4       	brne	.+2      	; 0x55ec <__vector_39+0x38>
    55ea:	5f c0       	rjmp	.+190    	; 0x56aa <__vector_39+0xf6>
    55ec:	89 32       	cpi	r24, 0x29	; 41
    55ee:	98 f4       	brcc	.+38     	; 0x5616 <__vector_39+0x62>
    55f0:	80 31       	cpi	r24, 0x10	; 16
    55f2:	09 f4       	brne	.+2      	; 0x55f6 <__vector_39+0x42>
    55f4:	57 c0       	rjmp	.+174    	; 0x56a4 <__vector_39+0xf0>
    55f6:	81 31       	cpi	r24, 0x11	; 17
    55f8:	38 f4       	brcc	.+14     	; 0x5608 <__vector_39+0x54>
    55fa:	88 23       	and	r24, r24
    55fc:	09 f4       	brne	.+2      	; 0x5600 <__vector_39+0x4c>
    55fe:	ea c0       	rjmp	.+468    	; 0x57d4 <__vector_39+0x220>
    5600:	88 30       	cpi	r24, 0x08	; 8
    5602:	09 f0       	breq	.+2      	; 0x5606 <__vector_39+0x52>
    5604:	ef c0       	rjmp	.+478    	; 0x57e4 <__vector_39+0x230>
    5606:	4e c0       	rjmp	.+156    	; 0x56a4 <__vector_39+0xf0>
    5608:	88 31       	cpi	r24, 0x18	; 24
    560a:	09 f4       	brne	.+2      	; 0x560e <__vector_39+0x5a>
    560c:	4e c0       	rjmp	.+156    	; 0x56aa <__vector_39+0xf6>
    560e:	80 32       	cpi	r24, 0x20	; 32
    5610:	09 f0       	breq	.+2      	; 0x5614 <__vector_39+0x60>
    5612:	e8 c0       	rjmp	.+464    	; 0x57e4 <__vector_39+0x230>
    5614:	df c0       	rjmp	.+446    	; 0x57d4 <__vector_39+0x220>
    5616:	80 34       	cpi	r24, 0x40	; 64
    5618:	09 f4       	brne	.+2      	; 0x561c <__vector_39+0x68>
    561a:	77 c0       	rjmp	.+238    	; 0x570a <__vector_39+0x156>
    561c:	81 34       	cpi	r24, 0x41	; 65
    561e:	38 f4       	brcc	.+14     	; 0x562e <__vector_39+0x7a>
    5620:	80 33       	cpi	r24, 0x30	; 48
    5622:	09 f4       	brne	.+2      	; 0x5626 <__vector_39+0x72>
    5624:	d7 c0       	rjmp	.+430    	; 0x57d4 <__vector_39+0x220>
    5626:	88 33       	cpi	r24, 0x38	; 56
    5628:	09 f0       	breq	.+2      	; 0x562c <__vector_39+0x78>
    562a:	dc c0       	rjmp	.+440    	; 0x57e4 <__vector_39+0x230>
    562c:	5d c0       	rjmp	.+186    	; 0x56e8 <__vector_39+0x134>
    562e:	80 35       	cpi	r24, 0x50	; 80
    5630:	09 f4       	brne	.+2      	; 0x5634 <__vector_39+0x80>
    5632:	5f c0       	rjmp	.+190    	; 0x56f2 <__vector_39+0x13e>
    5634:	88 35       	cpi	r24, 0x58	; 88
    5636:	09 f4       	brne	.+2      	; 0x563a <__vector_39+0x86>
    5638:	4a c0       	rjmp	.+148    	; 0x56ce <__vector_39+0x11a>
    563a:	88 34       	cpi	r24, 0x48	; 72
    563c:	09 f0       	breq	.+2      	; 0x5640 <__vector_39+0x8c>
    563e:	d2 c0       	rjmp	.+420    	; 0x57e4 <__vector_39+0x230>
    5640:	c9 c0       	rjmp	.+402    	; 0x57d4 <__vector_39+0x220>
    5642:	88 39       	cpi	r24, 0x98	; 152
    5644:	09 f4       	brne	.+2      	; 0x5648 <__vector_39+0x94>
    5646:	ba c0       	rjmp	.+372    	; 0x57bc <__vector_39+0x208>
    5648:	89 39       	cpi	r24, 0x99	; 153
    564a:	b0 f4       	brcc	.+44     	; 0x5678 <__vector_39+0xc4>
    564c:	88 37       	cpi	r24, 0x78	; 120
    564e:	09 f4       	brne	.+2      	; 0x5652 <__vector_39+0x9e>
    5650:	68 c0       	rjmp	.+208    	; 0x5722 <__vector_39+0x16e>
    5652:	89 37       	cpi	r24, 0x79	; 121
    5654:	38 f4       	brcc	.+14     	; 0x5664 <__vector_39+0xb0>
    5656:	88 36       	cpi	r24, 0x68	; 104
    5658:	09 f4       	brne	.+2      	; 0x565c <__vector_39+0xa8>
    565a:	63 c0       	rjmp	.+198    	; 0x5722 <__vector_39+0x16e>
    565c:	80 37       	cpi	r24, 0x70	; 112
    565e:	09 f0       	breq	.+2      	; 0x5662 <__vector_39+0xae>
    5660:	c1 c0       	rjmp	.+386    	; 0x57e4 <__vector_39+0x230>
    5662:	5f c0       	rjmp	.+190    	; 0x5722 <__vector_39+0x16e>
    5664:	88 38       	cpi	r24, 0x88	; 136
    5666:	09 f4       	brne	.+2      	; 0x566a <__vector_39+0xb6>
    5668:	a9 c0       	rjmp	.+338    	; 0x57bc <__vector_39+0x208>
    566a:	80 39       	cpi	r24, 0x90	; 144
    566c:	09 f4       	brne	.+2      	; 0x5670 <__vector_39+0xbc>
    566e:	5f c0       	rjmp	.+190    	; 0x572e <__vector_39+0x17a>
    5670:	80 38       	cpi	r24, 0x80	; 128
    5672:	09 f0       	breq	.+2      	; 0x5676 <__vector_39+0xc2>
    5674:	b7 c0       	rjmp	.+366    	; 0x57e4 <__vector_39+0x230>
    5676:	5b c0       	rjmp	.+182    	; 0x572e <__vector_39+0x17a>
    5678:	80 3b       	cpi	r24, 0xB0	; 176
    567a:	09 f4       	brne	.+2      	; 0x567e <__vector_39+0xca>
    567c:	79 c0       	rjmp	.+242    	; 0x5770 <__vector_39+0x1bc>
    567e:	81 3b       	cpi	r24, 0xB1	; 177
    5680:	38 f4       	brcc	.+14     	; 0x5690 <__vector_39+0xdc>
    5682:	80 3a       	cpi	r24, 0xA0	; 160
    5684:	09 f4       	brne	.+2      	; 0x5688 <__vector_39+0xd4>
    5686:	62 c0       	rjmp	.+196    	; 0x574c <__vector_39+0x198>
    5688:	88 3a       	cpi	r24, 0xA8	; 168
    568a:	09 f0       	breq	.+2      	; 0x568e <__vector_39+0xda>
    568c:	ab c0       	rjmp	.+342    	; 0x57e4 <__vector_39+0x230>
    568e:	70 c0       	rjmp	.+224    	; 0x5770 <__vector_39+0x1bc>
    5690:	80 3c       	cpi	r24, 0xC0	; 192
    5692:	09 f4       	brne	.+2      	; 0x5696 <__vector_39+0xe2>
    5694:	9a c0       	rjmp	.+308    	; 0x57ca <__vector_39+0x216>
    5696:	88 3c       	cpi	r24, 0xC8	; 200
    5698:	09 f4       	brne	.+2      	; 0x569c <__vector_39+0xe8>
    569a:	97 c0       	rjmp	.+302    	; 0x57ca <__vector_39+0x216>
    569c:	88 3b       	cpi	r24, 0xB8	; 184
    569e:	09 f0       	breq	.+2      	; 0x56a2 <__vector_39+0xee>
    56a0:	a1 c0       	rjmp	.+322    	; 0x57e4 <__vector_39+0x230>
    56a2:	77 c0       	rjmp	.+238    	; 0x5792 <__vector_39+0x1de>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: M->START\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// send device address
		i2cSendByte(I2cDeviceAddrRW);
    56a4:	80 91 b9 11 	lds	r24, 0x11B9
    56a8:	0f c0       	rjmp	.+30     	; 0x56c8 <__vector_39+0x114>
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->SLA_ACK or DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cSendDataIndex < I2cSendDataLength)
    56aa:	90 91 da 11 	lds	r25, 0x11DA
    56ae:	80 91 db 11 	lds	r24, 0x11DB
    56b2:	98 17       	cp	r25, r24
    56b4:	08 f0       	brcs	.+2      	; 0x56b8 <__vector_39+0x104>
    56b6:	8e c0       	rjmp	.+284    	; 0x57d4 <__vector_39+0x220>
		{
			// send data
			i2cSendByte( I2cSendData[I2cSendDataIndex++] );
    56b8:	e9 2f       	mov	r30, r25
    56ba:	f0 e0       	ldi	r31, 0x00	; 0
    56bc:	e6 54       	subi	r30, 0x46	; 70
    56be:	fe 4e       	sbci	r31, 0xEE	; 238
    56c0:	80 81       	ld	r24, Z
    56c2:	9f 5f       	subi	r25, 0xFF	; 255
    56c4:	90 93 da 11 	sts	0x11DA, r25
}

inline void i2cSendByte(u08 data)
{
	// save data to the TWDR
	outb(TWDR, data);
    56c8:	80 93 bb 00 	sts	0x00BB, r24
    56cc:	77 c0       	rjmp	.+238    	; 0x57bc <__vector_39+0x208>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_NACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store final received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    56ce:	80 91 fc 11 	lds	r24, 0x11FC
    56d2:	90 91 bb 00 	lds	r25, 0x00BB
    56d6:	e8 2f       	mov	r30, r24
    56d8:	f0 e0       	ldi	r31, 0x00	; 0
    56da:	e4 52       	subi	r30, 0x24	; 36
    56dc:	fe 4e       	sbci	r31, 0xEE	; 238
    56de:	90 83       	st	Z, r25
    56e0:	8f 5f       	subi	r24, 0xFF	; 255
    56e2:	80 93 fc 11 	sts	0x11FC, r24
    56e6:	76 c0       	rjmp	.+236    	; 0x57d4 <__vector_39+0x220>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MT->ARB_LOST\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    56e8:	80 91 bc 00 	lds	r24, 0x00BC
    56ec:	8f 70       	andi	r24, 0x0F	; 15
    56ee:	80 68       	ori	r24, 0x80	; 128
    56f0:	75 c0       	rjmp	.+234    	; 0x57dc <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// store received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    56f2:	80 91 fc 11 	lds	r24, 0x11FC
    56f6:	90 91 bb 00 	lds	r25, 0x00BB
    56fa:	e8 2f       	mov	r30, r24
    56fc:	f0 e0       	ldi	r31, 0x00	; 0
    56fe:	e4 52       	subi	r30, 0x24	; 36
    5700:	fe 4e       	sbci	r31, 0xEE	; 238
    5702:	90 83       	st	Z, r25
    5704:	8f 5f       	subi	r24, 0xFF	; 255
    5706:	80 93 fc 11 	sts	0x11FC, r24
		#ifdef I2C_DEBUG
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: MR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		if(I2cReceiveDataIndex < (I2cReceiveDataLength-1))
    570a:	20 91 fc 11 	lds	r18, 0x11FC
    570e:	30 e0       	ldi	r19, 0x00	; 0
    5710:	80 91 fd 11 	lds	r24, 0x11FD
    5714:	90 e0       	ldi	r25, 0x00	; 0
    5716:	01 97       	sbiw	r24, 0x01	; 1
    5718:	28 17       	cp	r18, r24
    571a:	39 07       	cpc	r19, r25
    571c:	0c f0       	brlt	.+2      	; 0x5720 <__vector_39+0x16c>
    571e:	4e c0       	rjmp	.+156    	; 0x57bc <__vector_39+0x208>
    5720:	48 c0       	rjmp	.+144    	; 0x57b2 <__vector_39+0x1fe>
		rprintf("I2C: SR->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for writing (data will be received from master)
		// set state
		I2cState = I2C_SLAVE_RX;
    5722:	85 e0       	ldi	r24, 0x05	; 5
    5724:	80 93 b8 11 	sts	0x11B8, r24
		// prepare buffer
		I2cReceiveDataIndex = 0;
    5728:	10 92 fc 11 	sts	0x11FC, r1
    572c:	42 c0       	rjmp	.+132    	; 0x57b2 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// get previously received data byte
		I2cReceiveData[I2cReceiveDataIndex++] = inb(TWDR);
    572e:	80 91 fc 11 	lds	r24, 0x11FC
    5732:	90 91 bb 00 	lds	r25, 0x00BB
    5736:	e8 2f       	mov	r30, r24
    5738:	f0 e0       	ldi	r31, 0x00	; 0
    573a:	e4 52       	subi	r30, 0x24	; 36
    573c:	fe 4e       	sbci	r31, 0xEE	; 238
    573e:	90 83       	st	Z, r25
    5740:	8f 5f       	subi	r24, 0xFF	; 255
    5742:	80 93 fc 11 	sts	0x11FC, r24
		// check receive buffer status
		if(I2cReceiveDataIndex < I2C_RECEIVE_DATA_BUFFER_SIZE)
    5746:	80 32       	cpi	r24, 0x20	; 32
    5748:	c8 f5       	brcc	.+114    	; 0x57bc <__vector_39+0x208>
    574a:	33 c0       	rjmp	.+102    	; 0x57b2 <__vector_39+0x1fe>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: SR->SR_STOP\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// switch to SR mode with SLA ACK
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    574c:	80 91 bc 00 	lds	r24, 0x00BC
    5750:	8f 70       	andi	r24, 0x0F	; 15
    5752:	80 6c       	ori	r24, 0xC0	; 192
    5754:	80 93 bc 00 	sts	0x00BC, r24
		// i2c receive is complete, call i2cSlaveReceive
		if(i2cSlaveReceive) i2cSlaveReceive(I2cReceiveDataIndex, I2cReceiveData);
    5758:	e0 91 fe 11 	lds	r30, 0x11FE
    575c:	f0 91 ff 11 	lds	r31, 0x11FF
    5760:	30 97       	sbiw	r30, 0x00	; 0
    5762:	f1 f1       	breq	.+124    	; 0x57e0 <__vector_39+0x22c>
    5764:	80 91 fc 11 	lds	r24, 0x11FC
    5768:	6c ed       	ldi	r22, 0xDC	; 220
    576a:	71 e1       	ldi	r23, 0x11	; 17
    576c:	09 95       	icall
    576e:	38 c0       	rjmp	.+112    	; 0x57e0 <__vector_39+0x22c>
		rprintf("I2C: ST->SLA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// we are being addressed as slave for reading (data must be transmitted back to master)
		// set state
		I2cState = I2C_SLAVE_TX;
    5770:	84 e0       	ldi	r24, 0x04	; 4
    5772:	80 93 b8 11 	sts	0x11B8, r24
		// request data from application
		if(i2cSlaveTransmit) I2cSendDataLength = i2cSlaveTransmit(I2C_SEND_DATA_BUFFER_SIZE, I2cSendData);
    5776:	e0 91 00 12 	lds	r30, 0x1200
    577a:	f0 91 01 12 	lds	r31, 0x1201
    577e:	30 97       	sbiw	r30, 0x00	; 0
    5780:	31 f0       	breq	.+12     	; 0x578e <__vector_39+0x1da>
    5782:	80 e2       	ldi	r24, 0x20	; 32
    5784:	6a eb       	ldi	r22, 0xBA	; 186
    5786:	71 e1       	ldi	r23, 0x11	; 17
    5788:	09 95       	icall
    578a:	80 93 db 11 	sts	0x11DB, r24
		// reset data index
		I2cSendDataIndex = 0;
    578e:	10 92 da 11 	sts	0x11DA, r1
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: ST->DATA_ACK\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// transmit data byte
		outb(TWDR, I2cSendData[I2cSendDataIndex++]);
    5792:	90 91 da 11 	lds	r25, 0x11DA
    5796:	e9 2f       	mov	r30, r25
    5798:	f0 e0       	ldi	r31, 0x00	; 0
    579a:	e6 54       	subi	r30, 0x46	; 70
    579c:	fe 4e       	sbci	r31, 0xEE	; 238
    579e:	80 81       	ld	r24, Z
    57a0:	80 93 bb 00 	sts	0x00BB, r24
    57a4:	9f 5f       	subi	r25, 0xFF	; 255
    57a6:	90 93 da 11 	sts	0x11DA, r25
		if(I2cSendDataIndex < I2cSendDataLength)
    57aa:	80 91 db 11 	lds	r24, 0x11DB
    57ae:	98 17       	cp	r25, r24
    57b0:	28 f4       	brcc	.+10     	; 0x57bc <__vector_39+0x208>
			// expect ACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    57b2:	80 91 bc 00 	lds	r24, 0x00BC
    57b6:	8f 70       	andi	r24, 0x0F	; 15
    57b8:	80 6c       	ori	r24, 0xC0	; 192
    57ba:	04 c0       	rjmp	.+8      	; 0x57c4 <__vector_39+0x210>
		else
			// expect NACK to data byte
			outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
    57bc:	80 91 bc 00 	lds	r24, 0x00BC
    57c0:	8f 70       	andi	r24, 0x0F	; 15
    57c2:	80 68       	ori	r24, 0x80	; 128
    57c4:	80 93 bc 00 	sts	0x00BC, r24
    57c8:	0d c0       	rjmp	.+26     	; 0x57e4 <__vector_39+0x230>
		rprintf("I2C: ST->DATA_NACK or LAST_DATA\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// all done
		// switch to open slave
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
    57ca:	80 91 bc 00 	lds	r24, 0x00BC
    57ce:	8f 70       	andi	r24, 0x0F	; 15
    57d0:	80 6c       	ori	r24, 0xC0	; 192
    57d2:	04 c0       	rjmp	.+8      	; 0x57dc <__vector_39+0x228>
		rprintfInit(uart1AddToTxBuffer);
		rprintf("I2C: BUS_ERROR\r\n");
		rprintfInit(uart1SendByte);
		#endif
		// reset internal hardware and release bus
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTO)|BV(TWEA));
    57d4:	80 91 bc 00 	lds	r24, 0x00BC
    57d8:	8f 70       	andi	r24, 0x0F	; 15
    57da:	80 6d       	ori	r24, 0xD0	; 208
    57dc:	80 93 bc 00 	sts	0x00BC, r24
		// set state
		I2cState = I2C_IDLE;
    57e0:	10 92 b8 11 	sts	0x11B8, r1
		break;
	}
}
    57e4:	ff 91       	pop	r31
    57e6:	ef 91       	pop	r30
    57e8:	bf 91       	pop	r27
    57ea:	af 91       	pop	r26
    57ec:	9f 91       	pop	r25
    57ee:	8f 91       	pop	r24
    57f0:	7f 91       	pop	r23
    57f2:	6f 91       	pop	r22
    57f4:	5f 91       	pop	r21
    57f6:	4f 91       	pop	r20
    57f8:	3f 91       	pop	r19
    57fa:	2f 91       	pop	r18
    57fc:	0f 90       	pop	r0
    57fe:	0f be       	out	0x3f, r0	; 63
    5800:	0f 90       	pop	r0
    5802:	1f 90       	pop	r1
    5804:	18 95       	reti

00005806 <i2cGetState>:

eI2cStateType i2cGetState(void)
{
	return I2cState;
    5806:	80 91 b8 11 	lds	r24, 0x11B8
}
    580a:	08 95       	ret

0000580c <exit>:
    580c:	f8 94       	cli
    580e:	0c 94 82 30 	jmp	0x6104	; 0x6104 <_exit>

00005812 <memcpy>:
    5812:	fb 01       	movw	r30, r22
    5814:	dc 01       	movw	r26, r24
    5816:	02 c0       	rjmp	.+4      	; 0x581c <memcpy+0xa>
    5818:	01 90       	ld	r0, Z+
    581a:	0d 92       	st	X+, r0
    581c:	41 50       	subi	r20, 0x01	; 1
    581e:	50 40       	sbci	r21, 0x00	; 0
    5820:	d8 f7       	brcc	.-10     	; 0x5818 <memcpy+0x6>
    5822:	08 95       	ret

00005824 <memset>:
    5824:	dc 01       	movw	r26, r24
    5826:	01 c0       	rjmp	.+2      	; 0x582a <memset+0x6>
    5828:	6d 93       	st	X+, r22
    582a:	41 50       	subi	r20, 0x01	; 1
    582c:	50 40       	sbci	r21, 0x00	; 0
    582e:	e0 f7       	brcc	.-8      	; 0x5828 <memset+0x4>
    5830:	08 95       	ret

00005832 <strncpy>:
    5832:	fb 01       	movw	r30, r22
    5834:	dc 01       	movw	r26, r24
    5836:	41 50       	subi	r20, 0x01	; 1
    5838:	50 40       	sbci	r21, 0x00	; 0
    583a:	48 f0       	brcs	.+18     	; 0x584e <strncpy+0x1c>
    583c:	01 90       	ld	r0, Z+
    583e:	0d 92       	st	X+, r0
    5840:	00 20       	and	r0, r0
    5842:	c9 f7       	brne	.-14     	; 0x5836 <strncpy+0x4>
    5844:	01 c0       	rjmp	.+2      	; 0x5848 <strncpy+0x16>
    5846:	1d 92       	st	X+, r1
    5848:	41 50       	subi	r20, 0x01	; 1
    584a:	50 40       	sbci	r21, 0x00	; 0
    584c:	e0 f7       	brcc	.-8      	; 0x5846 <strncpy+0x14>
    584e:	08 95       	ret

00005850 <__subsf3>:
    5850:	50 58       	subi	r21, 0x80	; 128

00005852 <__addsf3>:
    5852:	bb 27       	eor	r27, r27
    5854:	aa 27       	eor	r26, r26
    5856:	0e d0       	rcall	.+28     	; 0x5874 <__addsf3x>
    5858:	75 c1       	rjmp	.+746    	; 0x5b44 <__fp_round>
    585a:	66 d1       	rcall	.+716    	; 0x5b28 <__fp_pscA>
    585c:	30 f0       	brcs	.+12     	; 0x586a <__addsf3+0x18>
    585e:	6b d1       	rcall	.+726    	; 0x5b36 <__fp_pscB>
    5860:	20 f0       	brcs	.+8      	; 0x586a <__addsf3+0x18>
    5862:	31 f4       	brne	.+12     	; 0x5870 <__addsf3+0x1e>
    5864:	9f 3f       	cpi	r25, 0xFF	; 255
    5866:	11 f4       	brne	.+4      	; 0x586c <__addsf3+0x1a>
    5868:	1e f4       	brtc	.+6      	; 0x5870 <__addsf3+0x1e>
    586a:	5b c1       	rjmp	.+694    	; 0x5b22 <__fp_nan>
    586c:	0e f4       	brtc	.+2      	; 0x5870 <__addsf3+0x1e>
    586e:	e0 95       	com	r30
    5870:	e7 fb       	bst	r30, 7
    5872:	51 c1       	rjmp	.+674    	; 0x5b16 <__fp_inf>

00005874 <__addsf3x>:
    5874:	e9 2f       	mov	r30, r25
    5876:	77 d1       	rcall	.+750    	; 0x5b66 <__fp_split3>
    5878:	80 f3       	brcs	.-32     	; 0x585a <__addsf3+0x8>
    587a:	ba 17       	cp	r27, r26
    587c:	62 07       	cpc	r22, r18
    587e:	73 07       	cpc	r23, r19
    5880:	84 07       	cpc	r24, r20
    5882:	95 07       	cpc	r25, r21
    5884:	18 f0       	brcs	.+6      	; 0x588c <__addsf3x+0x18>
    5886:	71 f4       	brne	.+28     	; 0x58a4 <__addsf3x+0x30>
    5888:	9e f5       	brtc	.+102    	; 0x58f0 <__addsf3x+0x7c>
    588a:	8f c1       	rjmp	.+798    	; 0x5baa <__fp_zero>
    588c:	0e f4       	brtc	.+2      	; 0x5890 <__addsf3x+0x1c>
    588e:	e0 95       	com	r30
    5890:	0b 2e       	mov	r0, r27
    5892:	ba 2f       	mov	r27, r26
    5894:	a0 2d       	mov	r26, r0
    5896:	0b 01       	movw	r0, r22
    5898:	b9 01       	movw	r22, r18
    589a:	90 01       	movw	r18, r0
    589c:	0c 01       	movw	r0, r24
    589e:	ca 01       	movw	r24, r20
    58a0:	a0 01       	movw	r20, r0
    58a2:	11 24       	eor	r1, r1
    58a4:	ff 27       	eor	r31, r31
    58a6:	59 1b       	sub	r21, r25
    58a8:	99 f0       	breq	.+38     	; 0x58d0 <__addsf3x+0x5c>
    58aa:	59 3f       	cpi	r21, 0xF9	; 249
    58ac:	50 f4       	brcc	.+20     	; 0x58c2 <__addsf3x+0x4e>
    58ae:	50 3e       	cpi	r21, 0xE0	; 224
    58b0:	68 f1       	brcs	.+90     	; 0x590c <__addsf3x+0x98>
    58b2:	1a 16       	cp	r1, r26
    58b4:	f0 40       	sbci	r31, 0x00	; 0
    58b6:	a2 2f       	mov	r26, r18
    58b8:	23 2f       	mov	r18, r19
    58ba:	34 2f       	mov	r19, r20
    58bc:	44 27       	eor	r20, r20
    58be:	58 5f       	subi	r21, 0xF8	; 248
    58c0:	f3 cf       	rjmp	.-26     	; 0x58a8 <__addsf3x+0x34>
    58c2:	46 95       	lsr	r20
    58c4:	37 95       	ror	r19
    58c6:	27 95       	ror	r18
    58c8:	a7 95       	ror	r26
    58ca:	f0 40       	sbci	r31, 0x00	; 0
    58cc:	53 95       	inc	r21
    58ce:	c9 f7       	brne	.-14     	; 0x58c2 <__addsf3x+0x4e>
    58d0:	7e f4       	brtc	.+30     	; 0x58f0 <__addsf3x+0x7c>
    58d2:	1f 16       	cp	r1, r31
    58d4:	ba 0b       	sbc	r27, r26
    58d6:	62 0b       	sbc	r22, r18
    58d8:	73 0b       	sbc	r23, r19
    58da:	84 0b       	sbc	r24, r20
    58dc:	ba f0       	brmi	.+46     	; 0x590c <__addsf3x+0x98>
    58de:	91 50       	subi	r25, 0x01	; 1
    58e0:	a1 f0       	breq	.+40     	; 0x590a <__addsf3x+0x96>
    58e2:	ff 0f       	add	r31, r31
    58e4:	bb 1f       	adc	r27, r27
    58e6:	66 1f       	adc	r22, r22
    58e8:	77 1f       	adc	r23, r23
    58ea:	88 1f       	adc	r24, r24
    58ec:	c2 f7       	brpl	.-16     	; 0x58de <__addsf3x+0x6a>
    58ee:	0e c0       	rjmp	.+28     	; 0x590c <__addsf3x+0x98>
    58f0:	ba 0f       	add	r27, r26
    58f2:	62 1f       	adc	r22, r18
    58f4:	73 1f       	adc	r23, r19
    58f6:	84 1f       	adc	r24, r20
    58f8:	48 f4       	brcc	.+18     	; 0x590c <__addsf3x+0x98>
    58fa:	87 95       	ror	r24
    58fc:	77 95       	ror	r23
    58fe:	67 95       	ror	r22
    5900:	b7 95       	ror	r27
    5902:	f7 95       	ror	r31
    5904:	9e 3f       	cpi	r25, 0xFE	; 254
    5906:	08 f0       	brcs	.+2      	; 0x590a <__addsf3x+0x96>
    5908:	b3 cf       	rjmp	.-154    	; 0x5870 <__addsf3+0x1e>
    590a:	93 95       	inc	r25
    590c:	88 0f       	add	r24, r24
    590e:	08 f0       	brcs	.+2      	; 0x5912 <__addsf3x+0x9e>
    5910:	99 27       	eor	r25, r25
    5912:	ee 0f       	add	r30, r30
    5914:	97 95       	ror	r25
    5916:	87 95       	ror	r24
    5918:	08 95       	ret

0000591a <__cmpsf2>:
    591a:	d9 d0       	rcall	.+434    	; 0x5ace <__fp_cmp>
    591c:	08 f4       	brcc	.+2      	; 0x5920 <__cmpsf2+0x6>
    591e:	81 e0       	ldi	r24, 0x01	; 1
    5920:	08 95       	ret

00005922 <__divsf3>:
    5922:	0c d0       	rcall	.+24     	; 0x593c <__divsf3x>
    5924:	0f c1       	rjmp	.+542    	; 0x5b44 <__fp_round>
    5926:	07 d1       	rcall	.+526    	; 0x5b36 <__fp_pscB>
    5928:	40 f0       	brcs	.+16     	; 0x593a <__divsf3+0x18>
    592a:	fe d0       	rcall	.+508    	; 0x5b28 <__fp_pscA>
    592c:	30 f0       	brcs	.+12     	; 0x593a <__divsf3+0x18>
    592e:	21 f4       	brne	.+8      	; 0x5938 <__divsf3+0x16>
    5930:	5f 3f       	cpi	r21, 0xFF	; 255
    5932:	19 f0       	breq	.+6      	; 0x593a <__divsf3+0x18>
    5934:	f0 c0       	rjmp	.+480    	; 0x5b16 <__fp_inf>
    5936:	51 11       	cpse	r21, r1
    5938:	39 c1       	rjmp	.+626    	; 0x5bac <__fp_szero>
    593a:	f3 c0       	rjmp	.+486    	; 0x5b22 <__fp_nan>

0000593c <__divsf3x>:
    593c:	14 d1       	rcall	.+552    	; 0x5b66 <__fp_split3>
    593e:	98 f3       	brcs	.-26     	; 0x5926 <__divsf3+0x4>

00005940 <__divsf3_pse>:
    5940:	99 23       	and	r25, r25
    5942:	c9 f3       	breq	.-14     	; 0x5936 <__divsf3+0x14>
    5944:	55 23       	and	r21, r21
    5946:	b1 f3       	breq	.-20     	; 0x5934 <__divsf3+0x12>
    5948:	95 1b       	sub	r25, r21
    594a:	55 0b       	sbc	r21, r21
    594c:	bb 27       	eor	r27, r27
    594e:	aa 27       	eor	r26, r26
    5950:	62 17       	cp	r22, r18
    5952:	73 07       	cpc	r23, r19
    5954:	84 07       	cpc	r24, r20
    5956:	38 f0       	brcs	.+14     	; 0x5966 <__divsf3_pse+0x26>
    5958:	9f 5f       	subi	r25, 0xFF	; 255
    595a:	5f 4f       	sbci	r21, 0xFF	; 255
    595c:	22 0f       	add	r18, r18
    595e:	33 1f       	adc	r19, r19
    5960:	44 1f       	adc	r20, r20
    5962:	aa 1f       	adc	r26, r26
    5964:	a9 f3       	breq	.-22     	; 0x5950 <__divsf3_pse+0x10>
    5966:	33 d0       	rcall	.+102    	; 0x59ce <__divsf3_pse+0x8e>
    5968:	0e 2e       	mov	r0, r30
    596a:	3a f0       	brmi	.+14     	; 0x597a <__divsf3_pse+0x3a>
    596c:	e0 e8       	ldi	r30, 0x80	; 128
    596e:	30 d0       	rcall	.+96     	; 0x59d0 <__divsf3_pse+0x90>
    5970:	91 50       	subi	r25, 0x01	; 1
    5972:	50 40       	sbci	r21, 0x00	; 0
    5974:	e6 95       	lsr	r30
    5976:	00 1c       	adc	r0, r0
    5978:	ca f7       	brpl	.-14     	; 0x596c <__divsf3_pse+0x2c>
    597a:	29 d0       	rcall	.+82     	; 0x59ce <__divsf3_pse+0x8e>
    597c:	fe 2f       	mov	r31, r30
    597e:	27 d0       	rcall	.+78     	; 0x59ce <__divsf3_pse+0x8e>
    5980:	66 0f       	add	r22, r22
    5982:	77 1f       	adc	r23, r23
    5984:	88 1f       	adc	r24, r24
    5986:	bb 1f       	adc	r27, r27
    5988:	26 17       	cp	r18, r22
    598a:	37 07       	cpc	r19, r23
    598c:	48 07       	cpc	r20, r24
    598e:	ab 07       	cpc	r26, r27
    5990:	b0 e8       	ldi	r27, 0x80	; 128
    5992:	09 f0       	breq	.+2      	; 0x5996 <__divsf3_pse+0x56>
    5994:	bb 0b       	sbc	r27, r27
    5996:	80 2d       	mov	r24, r0
    5998:	bf 01       	movw	r22, r30
    599a:	ff 27       	eor	r31, r31
    599c:	93 58       	subi	r25, 0x83	; 131
    599e:	5f 4f       	sbci	r21, 0xFF	; 255
    59a0:	2a f0       	brmi	.+10     	; 0x59ac <__divsf3_pse+0x6c>
    59a2:	9e 3f       	cpi	r25, 0xFE	; 254
    59a4:	51 05       	cpc	r21, r1
    59a6:	68 f0       	brcs	.+26     	; 0x59c2 <__divsf3_pse+0x82>
    59a8:	b6 c0       	rjmp	.+364    	; 0x5b16 <__fp_inf>
    59aa:	00 c1       	rjmp	.+512    	; 0x5bac <__fp_szero>
    59ac:	5f 3f       	cpi	r21, 0xFF	; 255
    59ae:	ec f3       	brlt	.-6      	; 0x59aa <__divsf3_pse+0x6a>
    59b0:	98 3e       	cpi	r25, 0xE8	; 232
    59b2:	dc f3       	brlt	.-10     	; 0x59aa <__divsf3_pse+0x6a>
    59b4:	86 95       	lsr	r24
    59b6:	77 95       	ror	r23
    59b8:	67 95       	ror	r22
    59ba:	b7 95       	ror	r27
    59bc:	f7 95       	ror	r31
    59be:	9f 5f       	subi	r25, 0xFF	; 255
    59c0:	c9 f7       	brne	.-14     	; 0x59b4 <__divsf3_pse+0x74>
    59c2:	88 0f       	add	r24, r24
    59c4:	91 1d       	adc	r25, r1
    59c6:	96 95       	lsr	r25
    59c8:	87 95       	ror	r24
    59ca:	97 f9       	bld	r25, 7
    59cc:	08 95       	ret
    59ce:	e1 e0       	ldi	r30, 0x01	; 1
    59d0:	66 0f       	add	r22, r22
    59d2:	77 1f       	adc	r23, r23
    59d4:	88 1f       	adc	r24, r24
    59d6:	bb 1f       	adc	r27, r27
    59d8:	62 17       	cp	r22, r18
    59da:	73 07       	cpc	r23, r19
    59dc:	84 07       	cpc	r24, r20
    59de:	ba 07       	cpc	r27, r26
    59e0:	20 f0       	brcs	.+8      	; 0x59ea <__divsf3_pse+0xaa>
    59e2:	62 1b       	sub	r22, r18
    59e4:	73 0b       	sbc	r23, r19
    59e6:	84 0b       	sbc	r24, r20
    59e8:	ba 0b       	sbc	r27, r26
    59ea:	ee 1f       	adc	r30, r30
    59ec:	88 f7       	brcc	.-30     	; 0x59d0 <__divsf3_pse+0x90>
    59ee:	e0 95       	com	r30
    59f0:	08 95       	ret

000059f2 <__fixsfsi>:
    59f2:	04 d0       	rcall	.+8      	; 0x59fc <__fixunssfsi>
    59f4:	68 94       	set
    59f6:	b1 11       	cpse	r27, r1
    59f8:	d9 c0       	rjmp	.+434    	; 0x5bac <__fp_szero>
    59fa:	08 95       	ret

000059fc <__fixunssfsi>:
    59fc:	bc d0       	rcall	.+376    	; 0x5b76 <__fp_splitA>
    59fe:	88 f0       	brcs	.+34     	; 0x5a22 <__fixunssfsi+0x26>
    5a00:	9f 57       	subi	r25, 0x7F	; 127
    5a02:	90 f0       	brcs	.+36     	; 0x5a28 <__fixunssfsi+0x2c>
    5a04:	b9 2f       	mov	r27, r25
    5a06:	99 27       	eor	r25, r25
    5a08:	b7 51       	subi	r27, 0x17	; 23
    5a0a:	a0 f0       	brcs	.+40     	; 0x5a34 <__fixunssfsi+0x38>
    5a0c:	d1 f0       	breq	.+52     	; 0x5a42 <__fixunssfsi+0x46>
    5a0e:	66 0f       	add	r22, r22
    5a10:	77 1f       	adc	r23, r23
    5a12:	88 1f       	adc	r24, r24
    5a14:	99 1f       	adc	r25, r25
    5a16:	1a f0       	brmi	.+6      	; 0x5a1e <__fixunssfsi+0x22>
    5a18:	ba 95       	dec	r27
    5a1a:	c9 f7       	brne	.-14     	; 0x5a0e <__fixunssfsi+0x12>
    5a1c:	12 c0       	rjmp	.+36     	; 0x5a42 <__fixunssfsi+0x46>
    5a1e:	b1 30       	cpi	r27, 0x01	; 1
    5a20:	81 f0       	breq	.+32     	; 0x5a42 <__fixunssfsi+0x46>
    5a22:	c3 d0       	rcall	.+390    	; 0x5baa <__fp_zero>
    5a24:	b1 e0       	ldi	r27, 0x01	; 1
    5a26:	08 95       	ret
    5a28:	c0 c0       	rjmp	.+384    	; 0x5baa <__fp_zero>
    5a2a:	67 2f       	mov	r22, r23
    5a2c:	78 2f       	mov	r23, r24
    5a2e:	88 27       	eor	r24, r24
    5a30:	b8 5f       	subi	r27, 0xF8	; 248
    5a32:	39 f0       	breq	.+14     	; 0x5a42 <__fixunssfsi+0x46>
    5a34:	b9 3f       	cpi	r27, 0xF9	; 249
    5a36:	cc f3       	brlt	.-14     	; 0x5a2a <__fixunssfsi+0x2e>
    5a38:	86 95       	lsr	r24
    5a3a:	77 95       	ror	r23
    5a3c:	67 95       	ror	r22
    5a3e:	b3 95       	inc	r27
    5a40:	d9 f7       	brne	.-10     	; 0x5a38 <__fixunssfsi+0x3c>
    5a42:	3e f4       	brtc	.+14     	; 0x5a52 <__fixunssfsi+0x56>
    5a44:	90 95       	com	r25
    5a46:	80 95       	com	r24
    5a48:	70 95       	com	r23
    5a4a:	61 95       	neg	r22
    5a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    5a4e:	8f 4f       	sbci	r24, 0xFF	; 255
    5a50:	9f 4f       	sbci	r25, 0xFF	; 255
    5a52:	08 95       	ret

00005a54 <__floatunsisf>:
    5a54:	e8 94       	clt
    5a56:	09 c0       	rjmp	.+18     	; 0x5a6a <__floatsisf+0x12>

00005a58 <__floatsisf>:
    5a58:	97 fb       	bst	r25, 7
    5a5a:	3e f4       	brtc	.+14     	; 0x5a6a <__floatsisf+0x12>
    5a5c:	90 95       	com	r25
    5a5e:	80 95       	com	r24
    5a60:	70 95       	com	r23
    5a62:	61 95       	neg	r22
    5a64:	7f 4f       	sbci	r23, 0xFF	; 255
    5a66:	8f 4f       	sbci	r24, 0xFF	; 255
    5a68:	9f 4f       	sbci	r25, 0xFF	; 255
    5a6a:	99 23       	and	r25, r25
    5a6c:	a9 f0       	breq	.+42     	; 0x5a98 <__floatsisf+0x40>
    5a6e:	f9 2f       	mov	r31, r25
    5a70:	96 e9       	ldi	r25, 0x96	; 150
    5a72:	bb 27       	eor	r27, r27
    5a74:	93 95       	inc	r25
    5a76:	f6 95       	lsr	r31
    5a78:	87 95       	ror	r24
    5a7a:	77 95       	ror	r23
    5a7c:	67 95       	ror	r22
    5a7e:	b7 95       	ror	r27
    5a80:	f1 11       	cpse	r31, r1
    5a82:	f8 cf       	rjmp	.-16     	; 0x5a74 <__floatsisf+0x1c>
    5a84:	fa f4       	brpl	.+62     	; 0x5ac4 <__floatsisf+0x6c>
    5a86:	bb 0f       	add	r27, r27
    5a88:	11 f4       	brne	.+4      	; 0x5a8e <__floatsisf+0x36>
    5a8a:	60 ff       	sbrs	r22, 0
    5a8c:	1b c0       	rjmp	.+54     	; 0x5ac4 <__floatsisf+0x6c>
    5a8e:	6f 5f       	subi	r22, 0xFF	; 255
    5a90:	7f 4f       	sbci	r23, 0xFF	; 255
    5a92:	8f 4f       	sbci	r24, 0xFF	; 255
    5a94:	9f 4f       	sbci	r25, 0xFF	; 255
    5a96:	16 c0       	rjmp	.+44     	; 0x5ac4 <__floatsisf+0x6c>
    5a98:	88 23       	and	r24, r24
    5a9a:	11 f0       	breq	.+4      	; 0x5aa0 <__floatsisf+0x48>
    5a9c:	96 e9       	ldi	r25, 0x96	; 150
    5a9e:	11 c0       	rjmp	.+34     	; 0x5ac2 <__floatsisf+0x6a>
    5aa0:	77 23       	and	r23, r23
    5aa2:	21 f0       	breq	.+8      	; 0x5aac <__floatsisf+0x54>
    5aa4:	9e e8       	ldi	r25, 0x8E	; 142
    5aa6:	87 2f       	mov	r24, r23
    5aa8:	76 2f       	mov	r23, r22
    5aaa:	05 c0       	rjmp	.+10     	; 0x5ab6 <__floatsisf+0x5e>
    5aac:	66 23       	and	r22, r22
    5aae:	71 f0       	breq	.+28     	; 0x5acc <__floatsisf+0x74>
    5ab0:	96 e8       	ldi	r25, 0x86	; 134
    5ab2:	86 2f       	mov	r24, r22
    5ab4:	70 e0       	ldi	r23, 0x00	; 0
    5ab6:	60 e0       	ldi	r22, 0x00	; 0
    5ab8:	2a f0       	brmi	.+10     	; 0x5ac4 <__floatsisf+0x6c>
    5aba:	9a 95       	dec	r25
    5abc:	66 0f       	add	r22, r22
    5abe:	77 1f       	adc	r23, r23
    5ac0:	88 1f       	adc	r24, r24
    5ac2:	da f7       	brpl	.-10     	; 0x5aba <__floatsisf+0x62>
    5ac4:	88 0f       	add	r24, r24
    5ac6:	96 95       	lsr	r25
    5ac8:	87 95       	ror	r24
    5aca:	97 f9       	bld	r25, 7
    5acc:	08 95       	ret

00005ace <__fp_cmp>:
    5ace:	99 0f       	add	r25, r25
    5ad0:	00 08       	sbc	r0, r0
    5ad2:	55 0f       	add	r21, r21
    5ad4:	aa 0b       	sbc	r26, r26
    5ad6:	e0 e8       	ldi	r30, 0x80	; 128
    5ad8:	fe ef       	ldi	r31, 0xFE	; 254
    5ada:	16 16       	cp	r1, r22
    5adc:	17 06       	cpc	r1, r23
    5ade:	e8 07       	cpc	r30, r24
    5ae0:	f9 07       	cpc	r31, r25
    5ae2:	c0 f0       	brcs	.+48     	; 0x5b14 <__fp_cmp+0x46>
    5ae4:	12 16       	cp	r1, r18
    5ae6:	13 06       	cpc	r1, r19
    5ae8:	e4 07       	cpc	r30, r20
    5aea:	f5 07       	cpc	r31, r21
    5aec:	98 f0       	brcs	.+38     	; 0x5b14 <__fp_cmp+0x46>
    5aee:	62 1b       	sub	r22, r18
    5af0:	73 0b       	sbc	r23, r19
    5af2:	84 0b       	sbc	r24, r20
    5af4:	95 0b       	sbc	r25, r21
    5af6:	39 f4       	brne	.+14     	; 0x5b06 <__fp_cmp+0x38>
    5af8:	0a 26       	eor	r0, r26
    5afa:	61 f0       	breq	.+24     	; 0x5b14 <__fp_cmp+0x46>
    5afc:	23 2b       	or	r18, r19
    5afe:	24 2b       	or	r18, r20
    5b00:	25 2b       	or	r18, r21
    5b02:	21 f4       	brne	.+8      	; 0x5b0c <__fp_cmp+0x3e>
    5b04:	08 95       	ret
    5b06:	0a 26       	eor	r0, r26
    5b08:	09 f4       	brne	.+2      	; 0x5b0c <__fp_cmp+0x3e>
    5b0a:	a1 40       	sbci	r26, 0x01	; 1
    5b0c:	a6 95       	lsr	r26
    5b0e:	8f ef       	ldi	r24, 0xFF	; 255
    5b10:	81 1d       	adc	r24, r1
    5b12:	81 1d       	adc	r24, r1
    5b14:	08 95       	ret

00005b16 <__fp_inf>:
    5b16:	97 f9       	bld	r25, 7
    5b18:	9f 67       	ori	r25, 0x7F	; 127
    5b1a:	80 e8       	ldi	r24, 0x80	; 128
    5b1c:	70 e0       	ldi	r23, 0x00	; 0
    5b1e:	60 e0       	ldi	r22, 0x00	; 0
    5b20:	08 95       	ret

00005b22 <__fp_nan>:
    5b22:	9f ef       	ldi	r25, 0xFF	; 255
    5b24:	80 ec       	ldi	r24, 0xC0	; 192
    5b26:	08 95       	ret

00005b28 <__fp_pscA>:
    5b28:	00 24       	eor	r0, r0
    5b2a:	0a 94       	dec	r0
    5b2c:	16 16       	cp	r1, r22
    5b2e:	17 06       	cpc	r1, r23
    5b30:	18 06       	cpc	r1, r24
    5b32:	09 06       	cpc	r0, r25
    5b34:	08 95       	ret

00005b36 <__fp_pscB>:
    5b36:	00 24       	eor	r0, r0
    5b38:	0a 94       	dec	r0
    5b3a:	12 16       	cp	r1, r18
    5b3c:	13 06       	cpc	r1, r19
    5b3e:	14 06       	cpc	r1, r20
    5b40:	05 06       	cpc	r0, r21
    5b42:	08 95       	ret

00005b44 <__fp_round>:
    5b44:	09 2e       	mov	r0, r25
    5b46:	03 94       	inc	r0
    5b48:	00 0c       	add	r0, r0
    5b4a:	11 f4       	brne	.+4      	; 0x5b50 <__fp_round+0xc>
    5b4c:	88 23       	and	r24, r24
    5b4e:	52 f0       	brmi	.+20     	; 0x5b64 <__fp_round+0x20>
    5b50:	bb 0f       	add	r27, r27
    5b52:	40 f4       	brcc	.+16     	; 0x5b64 <__fp_round+0x20>
    5b54:	bf 2b       	or	r27, r31
    5b56:	11 f4       	brne	.+4      	; 0x5b5c <__fp_round+0x18>
    5b58:	60 ff       	sbrs	r22, 0
    5b5a:	04 c0       	rjmp	.+8      	; 0x5b64 <__fp_round+0x20>
    5b5c:	6f 5f       	subi	r22, 0xFF	; 255
    5b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    5b60:	8f 4f       	sbci	r24, 0xFF	; 255
    5b62:	9f 4f       	sbci	r25, 0xFF	; 255
    5b64:	08 95       	ret

00005b66 <__fp_split3>:
    5b66:	57 fd       	sbrc	r21, 7
    5b68:	90 58       	subi	r25, 0x80	; 128
    5b6a:	44 0f       	add	r20, r20
    5b6c:	55 1f       	adc	r21, r21
    5b6e:	59 f0       	breq	.+22     	; 0x5b86 <__fp_splitA+0x10>
    5b70:	5f 3f       	cpi	r21, 0xFF	; 255
    5b72:	71 f0       	breq	.+28     	; 0x5b90 <__fp_splitA+0x1a>
    5b74:	47 95       	ror	r20

00005b76 <__fp_splitA>:
    5b76:	88 0f       	add	r24, r24
    5b78:	97 fb       	bst	r25, 7
    5b7a:	99 1f       	adc	r25, r25
    5b7c:	61 f0       	breq	.+24     	; 0x5b96 <__fp_splitA+0x20>
    5b7e:	9f 3f       	cpi	r25, 0xFF	; 255
    5b80:	79 f0       	breq	.+30     	; 0x5ba0 <__fp_splitA+0x2a>
    5b82:	87 95       	ror	r24
    5b84:	08 95       	ret
    5b86:	12 16       	cp	r1, r18
    5b88:	13 06       	cpc	r1, r19
    5b8a:	14 06       	cpc	r1, r20
    5b8c:	55 1f       	adc	r21, r21
    5b8e:	f2 cf       	rjmp	.-28     	; 0x5b74 <__fp_split3+0xe>
    5b90:	46 95       	lsr	r20
    5b92:	f1 df       	rcall	.-30     	; 0x5b76 <__fp_splitA>
    5b94:	08 c0       	rjmp	.+16     	; 0x5ba6 <__fp_splitA+0x30>
    5b96:	16 16       	cp	r1, r22
    5b98:	17 06       	cpc	r1, r23
    5b9a:	18 06       	cpc	r1, r24
    5b9c:	99 1f       	adc	r25, r25
    5b9e:	f1 cf       	rjmp	.-30     	; 0x5b82 <__fp_splitA+0xc>
    5ba0:	86 95       	lsr	r24
    5ba2:	71 05       	cpc	r23, r1
    5ba4:	61 05       	cpc	r22, r1
    5ba6:	08 94       	sec
    5ba8:	08 95       	ret

00005baa <__fp_zero>:
    5baa:	e8 94       	clt

00005bac <__fp_szero>:
    5bac:	bb 27       	eor	r27, r27
    5bae:	66 27       	eor	r22, r22
    5bb0:	77 27       	eor	r23, r23
    5bb2:	cb 01       	movw	r24, r22
    5bb4:	97 f9       	bld	r25, 7
    5bb6:	08 95       	ret

00005bb8 <__gesf2>:
    5bb8:	8a df       	rcall	.-236    	; 0x5ace <__fp_cmp>
    5bba:	08 f4       	brcc	.+2      	; 0x5bbe <__gesf2+0x6>
    5bbc:	8f ef       	ldi	r24, 0xFF	; 255
    5bbe:	08 95       	ret

00005bc0 <__mulsf3>:
    5bc0:	0b d0       	rcall	.+22     	; 0x5bd8 <__mulsf3x>
    5bc2:	c0 cf       	rjmp	.-128    	; 0x5b44 <__fp_round>
    5bc4:	b1 df       	rcall	.-158    	; 0x5b28 <__fp_pscA>
    5bc6:	28 f0       	brcs	.+10     	; 0x5bd2 <__mulsf3+0x12>
    5bc8:	b6 df       	rcall	.-148    	; 0x5b36 <__fp_pscB>
    5bca:	18 f0       	brcs	.+6      	; 0x5bd2 <__mulsf3+0x12>
    5bcc:	95 23       	and	r25, r21
    5bce:	09 f0       	breq	.+2      	; 0x5bd2 <__mulsf3+0x12>
    5bd0:	a2 cf       	rjmp	.-188    	; 0x5b16 <__fp_inf>
    5bd2:	a7 cf       	rjmp	.-178    	; 0x5b22 <__fp_nan>
    5bd4:	11 24       	eor	r1, r1
    5bd6:	ea cf       	rjmp	.-44     	; 0x5bac <__fp_szero>

00005bd8 <__mulsf3x>:
    5bd8:	c6 df       	rcall	.-116    	; 0x5b66 <__fp_split3>
    5bda:	a0 f3       	brcs	.-24     	; 0x5bc4 <__mulsf3+0x4>

00005bdc <__mulsf3_pse>:
    5bdc:	95 9f       	mul	r25, r21
    5bde:	d1 f3       	breq	.-12     	; 0x5bd4 <__mulsf3+0x14>
    5be0:	95 0f       	add	r25, r21
    5be2:	50 e0       	ldi	r21, 0x00	; 0
    5be4:	55 1f       	adc	r21, r21
    5be6:	62 9f       	mul	r22, r18
    5be8:	f0 01       	movw	r30, r0
    5bea:	72 9f       	mul	r23, r18
    5bec:	bb 27       	eor	r27, r27
    5bee:	f0 0d       	add	r31, r0
    5bf0:	b1 1d       	adc	r27, r1
    5bf2:	63 9f       	mul	r22, r19
    5bf4:	aa 27       	eor	r26, r26
    5bf6:	f0 0d       	add	r31, r0
    5bf8:	b1 1d       	adc	r27, r1
    5bfa:	aa 1f       	adc	r26, r26
    5bfc:	64 9f       	mul	r22, r20
    5bfe:	66 27       	eor	r22, r22
    5c00:	b0 0d       	add	r27, r0
    5c02:	a1 1d       	adc	r26, r1
    5c04:	66 1f       	adc	r22, r22
    5c06:	82 9f       	mul	r24, r18
    5c08:	22 27       	eor	r18, r18
    5c0a:	b0 0d       	add	r27, r0
    5c0c:	a1 1d       	adc	r26, r1
    5c0e:	62 1f       	adc	r22, r18
    5c10:	73 9f       	mul	r23, r19
    5c12:	b0 0d       	add	r27, r0
    5c14:	a1 1d       	adc	r26, r1
    5c16:	62 1f       	adc	r22, r18
    5c18:	83 9f       	mul	r24, r19
    5c1a:	a0 0d       	add	r26, r0
    5c1c:	61 1d       	adc	r22, r1
    5c1e:	22 1f       	adc	r18, r18
    5c20:	74 9f       	mul	r23, r20
    5c22:	33 27       	eor	r19, r19
    5c24:	a0 0d       	add	r26, r0
    5c26:	61 1d       	adc	r22, r1
    5c28:	23 1f       	adc	r18, r19
    5c2a:	84 9f       	mul	r24, r20
    5c2c:	60 0d       	add	r22, r0
    5c2e:	21 1d       	adc	r18, r1
    5c30:	82 2f       	mov	r24, r18
    5c32:	76 2f       	mov	r23, r22
    5c34:	6a 2f       	mov	r22, r26
    5c36:	11 24       	eor	r1, r1
    5c38:	9f 57       	subi	r25, 0x7F	; 127
    5c3a:	50 40       	sbci	r21, 0x00	; 0
    5c3c:	8a f0       	brmi	.+34     	; 0x5c60 <__mulsf3_pse+0x84>
    5c3e:	e1 f0       	breq	.+56     	; 0x5c78 <__mulsf3_pse+0x9c>
    5c40:	88 23       	and	r24, r24
    5c42:	4a f0       	brmi	.+18     	; 0x5c56 <__mulsf3_pse+0x7a>
    5c44:	ee 0f       	add	r30, r30
    5c46:	ff 1f       	adc	r31, r31
    5c48:	bb 1f       	adc	r27, r27
    5c4a:	66 1f       	adc	r22, r22
    5c4c:	77 1f       	adc	r23, r23
    5c4e:	88 1f       	adc	r24, r24
    5c50:	91 50       	subi	r25, 0x01	; 1
    5c52:	50 40       	sbci	r21, 0x00	; 0
    5c54:	a9 f7       	brne	.-22     	; 0x5c40 <__mulsf3_pse+0x64>
    5c56:	9e 3f       	cpi	r25, 0xFE	; 254
    5c58:	51 05       	cpc	r21, r1
    5c5a:	70 f0       	brcs	.+28     	; 0x5c78 <__mulsf3_pse+0x9c>
    5c5c:	5c cf       	rjmp	.-328    	; 0x5b16 <__fp_inf>
    5c5e:	a6 cf       	rjmp	.-180    	; 0x5bac <__fp_szero>
    5c60:	5f 3f       	cpi	r21, 0xFF	; 255
    5c62:	ec f3       	brlt	.-6      	; 0x5c5e <__mulsf3_pse+0x82>
    5c64:	98 3e       	cpi	r25, 0xE8	; 232
    5c66:	dc f3       	brlt	.-10     	; 0x5c5e <__mulsf3_pse+0x82>
    5c68:	86 95       	lsr	r24
    5c6a:	77 95       	ror	r23
    5c6c:	67 95       	ror	r22
    5c6e:	b7 95       	ror	r27
    5c70:	f7 95       	ror	r31
    5c72:	e7 95       	ror	r30
    5c74:	9f 5f       	subi	r25, 0xFF	; 255
    5c76:	c1 f7       	brne	.-16     	; 0x5c68 <__mulsf3_pse+0x8c>
    5c78:	fe 2b       	or	r31, r30
    5c7a:	88 0f       	add	r24, r24
    5c7c:	91 1d       	adc	r25, r1
    5c7e:	96 95       	lsr	r25
    5c80:	87 95       	ror	r24
    5c82:	97 f9       	bld	r25, 7
    5c84:	08 95       	ret

00005c86 <pow>:
    5c86:	fa 01       	movw	r30, r20
    5c88:	ee 0f       	add	r30, r30
    5c8a:	ff 1f       	adc	r31, r31
    5c8c:	30 96       	adiw	r30, 0x00	; 0
    5c8e:	21 05       	cpc	r18, r1
    5c90:	31 05       	cpc	r19, r1
    5c92:	99 f1       	breq	.+102    	; 0x5cfa <pow+0x74>
    5c94:	61 15       	cp	r22, r1
    5c96:	71 05       	cpc	r23, r1
    5c98:	61 f4       	brne	.+24     	; 0x5cb2 <pow+0x2c>
    5c9a:	80 38       	cpi	r24, 0x80	; 128
    5c9c:	bf e3       	ldi	r27, 0x3F	; 63
    5c9e:	9b 07       	cpc	r25, r27
    5ca0:	49 f1       	breq	.+82     	; 0x5cf4 <pow+0x6e>
    5ca2:	68 94       	set
    5ca4:	90 38       	cpi	r25, 0x80	; 128
    5ca6:	81 05       	cpc	r24, r1
    5ca8:	61 f0       	breq	.+24     	; 0x5cc2 <pow+0x3c>
    5caa:	80 38       	cpi	r24, 0x80	; 128
    5cac:	bf ef       	ldi	r27, 0xFF	; 255
    5cae:	9b 07       	cpc	r25, r27
    5cb0:	41 f0       	breq	.+16     	; 0x5cc2 <pow+0x3c>
    5cb2:	99 23       	and	r25, r25
    5cb4:	42 f5       	brpl	.+80     	; 0x5d06 <pow+0x80>
    5cb6:	ff 3f       	cpi	r31, 0xFF	; 255
    5cb8:	e1 05       	cpc	r30, r1
    5cba:	31 05       	cpc	r19, r1
    5cbc:	21 05       	cpc	r18, r1
    5cbe:	11 f1       	breq	.+68     	; 0x5d04 <pow+0x7e>
    5cc0:	e8 94       	clt
    5cc2:	08 94       	sec
    5cc4:	e7 95       	ror	r30
    5cc6:	d9 01       	movw	r26, r18
    5cc8:	aa 23       	and	r26, r26
    5cca:	29 f4       	brne	.+10     	; 0x5cd6 <pow+0x50>
    5ccc:	ab 2f       	mov	r26, r27
    5cce:	be 2f       	mov	r27, r30
    5cd0:	f8 5f       	subi	r31, 0xF8	; 248
    5cd2:	d0 f3       	brcs	.-12     	; 0x5cc8 <pow+0x42>
    5cd4:	10 c0       	rjmp	.+32     	; 0x5cf6 <pow+0x70>
    5cd6:	ff 5f       	subi	r31, 0xFF	; 255
    5cd8:	70 f4       	brcc	.+28     	; 0x5cf6 <pow+0x70>
    5cda:	a6 95       	lsr	r26
    5cdc:	e0 f7       	brcc	.-8      	; 0x5cd6 <pow+0x50>
    5cde:	f7 39       	cpi	r31, 0x97	; 151
    5ce0:	50 f0       	brcs	.+20     	; 0x5cf6 <pow+0x70>
    5ce2:	19 f0       	breq	.+6      	; 0x5cea <pow+0x64>
    5ce4:	ff 3a       	cpi	r31, 0xAF	; 175
    5ce6:	38 f4       	brcc	.+14     	; 0x5cf6 <pow+0x70>
    5ce8:	9f 77       	andi	r25, 0x7F	; 127
    5cea:	9f 93       	push	r25
    5cec:	0c d0       	rcall	.+24     	; 0x5d06 <pow+0x80>
    5cee:	0f 90       	pop	r0
    5cf0:	07 fc       	sbrc	r0, 7
    5cf2:	90 58       	subi	r25, 0x80	; 128
    5cf4:	08 95       	ret
    5cf6:	3e f0       	brts	.+14     	; 0x5d06 <pow+0x80>
    5cf8:	14 cf       	rjmp	.-472    	; 0x5b22 <__fp_nan>
    5cfa:	60 e0       	ldi	r22, 0x00	; 0
    5cfc:	70 e0       	ldi	r23, 0x00	; 0
    5cfe:	80 e8       	ldi	r24, 0x80	; 128
    5d00:	9f e3       	ldi	r25, 0x3F	; 63
    5d02:	08 95       	ret
    5d04:	4f e7       	ldi	r20, 0x7F	; 127
    5d06:	9f 77       	andi	r25, 0x7F	; 127
    5d08:	5f 93       	push	r21
    5d0a:	4f 93       	push	r20
    5d0c:	3f 93       	push	r19
    5d0e:	2f 93       	push	r18
    5d10:	03 d1       	rcall	.+518    	; 0x5f18 <log>
    5d12:	2f 91       	pop	r18
    5d14:	3f 91       	pop	r19
    5d16:	4f 91       	pop	r20
    5d18:	5f 91       	pop	r21
    5d1a:	52 df       	rcall	.-348    	; 0x5bc0 <__mulsf3>
    5d1c:	53 c0       	rjmp	.+166    	; 0x5dc4 <exp>
    5d1e:	11 f4       	brne	.+4      	; 0x5d24 <pow+0x9e>
    5d20:	0e f4       	brtc	.+2      	; 0x5d24 <pow+0x9e>
    5d22:	ff ce       	rjmp	.-514    	; 0x5b22 <__fp_nan>
    5d24:	7b c0       	rjmp	.+246    	; 0x5e1c <__fp_mpack>

00005d26 <sqrt>:
    5d26:	27 df       	rcall	.-434    	; 0x5b76 <__fp_splitA>
    5d28:	d0 f3       	brcs	.-12     	; 0x5d1e <pow+0x98>
    5d2a:	99 23       	and	r25, r25
    5d2c:	d9 f3       	breq	.-10     	; 0x5d24 <pow+0x9e>
    5d2e:	ce f3       	brts	.-14     	; 0x5d22 <pow+0x9c>
    5d30:	9f 57       	subi	r25, 0x7F	; 127
    5d32:	55 0b       	sbc	r21, r21
    5d34:	87 ff       	sbrs	r24, 7
    5d36:	82 d0       	rcall	.+260    	; 0x5e3c <__fp_norm2>
    5d38:	56 95       	lsr	r21
    5d3a:	97 95       	ror	r25
    5d3c:	b0 e0       	ldi	r27, 0x00	; 0
    5d3e:	20 f4       	brcc	.+8      	; 0x5d48 <sqrt+0x22>
    5d40:	66 0f       	add	r22, r22
    5d42:	77 1f       	adc	r23, r23
    5d44:	88 1f       	adc	r24, r24
    5d46:	bb 1f       	adc	r27, r27
    5d48:	1f 93       	push	r17
    5d4a:	0f 93       	push	r16
    5d4c:	00 24       	eor	r0, r0
    5d4e:	90 01       	movw	r18, r0
    5d50:	a0 01       	movw	r20, r0
    5d52:	80 01       	movw	r16, r0
    5d54:	f0 01       	movw	r30, r0
    5d56:	a0 e8       	ldi	r26, 0x80	; 128
    5d58:	0e 0f       	add	r16, r30
    5d5a:	1f 1f       	adc	r17, r31
    5d5c:	0a 1e       	adc	r0, r26
    5d5e:	51 1d       	adc	r21, r1
    5d60:	60 1b       	sub	r22, r16
    5d62:	71 0b       	sbc	r23, r17
    5d64:	80 09       	sbc	r24, r0
    5d66:	b5 0b       	sbc	r27, r21
    5d68:	48 f4       	brcc	.+18     	; 0x5d7c <sqrt+0x56>
    5d6a:	60 0f       	add	r22, r16
    5d6c:	71 1f       	adc	r23, r17
    5d6e:	80 1d       	adc	r24, r0
    5d70:	b5 1f       	adc	r27, r21
    5d72:	0e 1b       	sub	r16, r30
    5d74:	1f 0b       	sbc	r17, r31
    5d76:	0a 0a       	sbc	r0, r26
    5d78:	51 09       	sbc	r21, r1
    5d7a:	07 c0       	rjmp	.+14     	; 0x5d8a <sqrt+0x64>
    5d7c:	2e 0f       	add	r18, r30
    5d7e:	3f 1f       	adc	r19, r31
    5d80:	4a 1f       	adc	r20, r26
    5d82:	0e 0f       	add	r16, r30
    5d84:	1f 1f       	adc	r17, r31
    5d86:	0a 1e       	adc	r0, r26
    5d88:	51 1d       	adc	r21, r1
    5d8a:	66 0f       	add	r22, r22
    5d8c:	77 1f       	adc	r23, r23
    5d8e:	88 1f       	adc	r24, r24
    5d90:	bb 1f       	adc	r27, r27
    5d92:	a6 95       	lsr	r26
    5d94:	f7 95       	ror	r31
    5d96:	e7 95       	ror	r30
    5d98:	f8 f6       	brcc	.-66     	; 0x5d58 <sqrt+0x32>
    5d9a:	06 17       	cp	r16, r22
    5d9c:	17 07       	cpc	r17, r23
    5d9e:	08 06       	cpc	r0, r24
    5da0:	5b 07       	cpc	r21, r27
    5da2:	21 1d       	adc	r18, r1
    5da4:	31 1d       	adc	r19, r1
    5da6:	41 1d       	adc	r20, r1
    5da8:	0f 91       	pop	r16
    5daa:	1f 91       	pop	r17
    5dac:	b9 01       	movw	r22, r18
    5dae:	84 2f       	mov	r24, r20
    5db0:	91 58       	subi	r25, 0x81	; 129
    5db2:	88 0f       	add	r24, r24
    5db4:	96 95       	lsr	r25
    5db6:	87 95       	ror	r24
    5db8:	08 95       	ret
    5dba:	19 f4       	brne	.+6      	; 0x5dc2 <sqrt+0x9c>
    5dbc:	0e f0       	brts	.+2      	; 0x5dc0 <sqrt+0x9a>
    5dbe:	ab ce       	rjmp	.-682    	; 0x5b16 <__fp_inf>
    5dc0:	f4 ce       	rjmp	.-536    	; 0x5baa <__fp_zero>
    5dc2:	af ce       	rjmp	.-674    	; 0x5b22 <__fp_nan>

00005dc4 <exp>:
    5dc4:	d8 de       	rcall	.-592    	; 0x5b76 <__fp_splitA>
    5dc6:	c8 f3       	brcs	.-14     	; 0x5dba <sqrt+0x94>
    5dc8:	96 38       	cpi	r25, 0x86	; 134
    5dca:	c0 f7       	brcc	.-16     	; 0x5dbc <sqrt+0x96>
    5dcc:	07 f8       	bld	r0, 7
    5dce:	0f 92       	push	r0
    5dd0:	e8 94       	clt
    5dd2:	2b e3       	ldi	r18, 0x3B	; 59
    5dd4:	3a ea       	ldi	r19, 0xAA	; 170
    5dd6:	48 eb       	ldi	r20, 0xB8	; 184
    5dd8:	5f e7       	ldi	r21, 0x7F	; 127
    5dda:	00 df       	rcall	.-512    	; 0x5bdc <__mulsf3_pse>
    5ddc:	0f 92       	push	r0
    5dde:	0f 92       	push	r0
    5de0:	0f 92       	push	r0
    5de2:	4d b7       	in	r20, 0x3d	; 61
    5de4:	5e b7       	in	r21, 0x3e	; 62
    5de6:	0f 92       	push	r0
    5de8:	d7 d0       	rcall	.+430    	; 0x5f98 <modf>
    5dea:	e4 ee       	ldi	r30, 0xE4	; 228
    5dec:	f0 e0       	ldi	r31, 0x00	; 0
    5dee:	2d d0       	rcall	.+90     	; 0x5e4a <__fp_powser>
    5df0:	4f 91       	pop	r20
    5df2:	5f 91       	pop	r21
    5df4:	ef 91       	pop	r30
    5df6:	ff 91       	pop	r31
    5df8:	e5 95       	asr	r30
    5dfa:	ee 1f       	adc	r30, r30
    5dfc:	ff 1f       	adc	r31, r31
    5dfe:	49 f0       	breq	.+18     	; 0x5e12 <exp+0x4e>
    5e00:	fe 57       	subi	r31, 0x7E	; 126
    5e02:	e0 68       	ori	r30, 0x80	; 128
    5e04:	44 27       	eor	r20, r20
    5e06:	ee 0f       	add	r30, r30
    5e08:	44 1f       	adc	r20, r20
    5e0a:	fa 95       	dec	r31
    5e0c:	e1 f7       	brne	.-8      	; 0x5e06 <exp+0x42>
    5e0e:	41 95       	neg	r20
    5e10:	55 0b       	sbc	r21, r21
    5e12:	49 d0       	rcall	.+146    	; 0x5ea6 <ldexp>
    5e14:	0f 90       	pop	r0
    5e16:	07 fe       	sbrs	r0, 7
    5e18:	3d c0       	rjmp	.+122    	; 0x5e94 <inverse>
    5e1a:	08 95       	ret

00005e1c <__fp_mpack>:
    5e1c:	9f 3f       	cpi	r25, 0xFF	; 255
    5e1e:	49 f0       	breq	.+18     	; 0x5e32 <__fp_mpack+0x16>
    5e20:	91 50       	subi	r25, 0x01	; 1
    5e22:	28 f4       	brcc	.+10     	; 0x5e2e <__fp_mpack+0x12>
    5e24:	86 95       	lsr	r24
    5e26:	77 95       	ror	r23
    5e28:	67 95       	ror	r22
    5e2a:	b7 95       	ror	r27
    5e2c:	9f 5f       	subi	r25, 0xFF	; 255
    5e2e:	80 38       	cpi	r24, 0x80	; 128
    5e30:	9f 4f       	sbci	r25, 0xFF	; 255
    5e32:	88 0f       	add	r24, r24
    5e34:	96 95       	lsr	r25
    5e36:	87 95       	ror	r24
    5e38:	97 f9       	bld	r25, 7
    5e3a:	08 95       	ret

00005e3c <__fp_norm2>:
    5e3c:	91 50       	subi	r25, 0x01	; 1
    5e3e:	50 40       	sbci	r21, 0x00	; 0
    5e40:	66 0f       	add	r22, r22
    5e42:	77 1f       	adc	r23, r23
    5e44:	88 1f       	adc	r24, r24
    5e46:	d2 f7       	brpl	.-12     	; 0x5e3c <__fp_norm2>
    5e48:	08 95       	ret

00005e4a <__fp_powser>:
    5e4a:	df 93       	push	r29
    5e4c:	cf 93       	push	r28
    5e4e:	1f 93       	push	r17
    5e50:	0f 93       	push	r16
    5e52:	ff 92       	push	r15
    5e54:	ef 92       	push	r14
    5e56:	df 92       	push	r13
    5e58:	7b 01       	movw	r14, r22
    5e5a:	8c 01       	movw	r16, r24
    5e5c:	68 94       	set
    5e5e:	05 c0       	rjmp	.+10     	; 0x5e6a <__fp_powser+0x20>
    5e60:	da 2e       	mov	r13, r26
    5e62:	ef 01       	movw	r28, r30
    5e64:	b9 de       	rcall	.-654    	; 0x5bd8 <__mulsf3x>
    5e66:	fe 01       	movw	r30, r28
    5e68:	e8 94       	clt
    5e6a:	a5 91       	lpm	r26, Z+
    5e6c:	25 91       	lpm	r18, Z+
    5e6e:	35 91       	lpm	r19, Z+
    5e70:	45 91       	lpm	r20, Z+
    5e72:	55 91       	lpm	r21, Z+
    5e74:	ae f3       	brts	.-22     	; 0x5e60 <__fp_powser+0x16>
    5e76:	ef 01       	movw	r28, r30
    5e78:	fd dc       	rcall	.-1542   	; 0x5874 <__addsf3x>
    5e7a:	fe 01       	movw	r30, r28
    5e7c:	97 01       	movw	r18, r14
    5e7e:	a8 01       	movw	r20, r16
    5e80:	da 94       	dec	r13
    5e82:	79 f7       	brne	.-34     	; 0x5e62 <__fp_powser+0x18>
    5e84:	df 90       	pop	r13
    5e86:	ef 90       	pop	r14
    5e88:	ff 90       	pop	r15
    5e8a:	0f 91       	pop	r16
    5e8c:	1f 91       	pop	r17
    5e8e:	cf 91       	pop	r28
    5e90:	df 91       	pop	r29
    5e92:	08 95       	ret

00005e94 <inverse>:
    5e94:	9b 01       	movw	r18, r22
    5e96:	ac 01       	movw	r20, r24
    5e98:	60 e0       	ldi	r22, 0x00	; 0
    5e9a:	70 e0       	ldi	r23, 0x00	; 0
    5e9c:	80 e8       	ldi	r24, 0x80	; 128
    5e9e:	9f e3       	ldi	r25, 0x3F	; 63
    5ea0:	40 cd       	rjmp	.-1408   	; 0x5922 <__divsf3>
    5ea2:	39 ce       	rjmp	.-910    	; 0x5b16 <__fp_inf>
    5ea4:	bb cf       	rjmp	.-138    	; 0x5e1c <__fp_mpack>

00005ea6 <ldexp>:
    5ea6:	67 de       	rcall	.-818    	; 0x5b76 <__fp_splitA>
    5ea8:	e8 f3       	brcs	.-6      	; 0x5ea4 <inverse+0x10>
    5eaa:	99 23       	and	r25, r25
    5eac:	d9 f3       	breq	.-10     	; 0x5ea4 <inverse+0x10>
    5eae:	94 0f       	add	r25, r20
    5eb0:	51 1d       	adc	r21, r1
    5eb2:	bb f3       	brvs	.-18     	; 0x5ea2 <inverse+0xe>
    5eb4:	91 50       	subi	r25, 0x01	; 1
    5eb6:	50 40       	sbci	r21, 0x00	; 0
    5eb8:	94 f0       	brlt	.+36     	; 0x5ede <ldexp+0x38>
    5eba:	59 f0       	breq	.+22     	; 0x5ed2 <ldexp+0x2c>
    5ebc:	88 23       	and	r24, r24
    5ebe:	32 f0       	brmi	.+12     	; 0x5ecc <ldexp+0x26>
    5ec0:	66 0f       	add	r22, r22
    5ec2:	77 1f       	adc	r23, r23
    5ec4:	88 1f       	adc	r24, r24
    5ec6:	91 50       	subi	r25, 0x01	; 1
    5ec8:	50 40       	sbci	r21, 0x00	; 0
    5eca:	c1 f7       	brne	.-16     	; 0x5ebc <ldexp+0x16>
    5ecc:	9e 3f       	cpi	r25, 0xFE	; 254
    5ece:	51 05       	cpc	r21, r1
    5ed0:	44 f7       	brge	.-48     	; 0x5ea2 <inverse+0xe>
    5ed2:	88 0f       	add	r24, r24
    5ed4:	91 1d       	adc	r25, r1
    5ed6:	96 95       	lsr	r25
    5ed8:	87 95       	ror	r24
    5eda:	97 f9       	bld	r25, 7
    5edc:	08 95       	ret
    5ede:	5f 3f       	cpi	r21, 0xFF	; 255
    5ee0:	ac f0       	brlt	.+42     	; 0x5f0c <ldexp+0x66>
    5ee2:	98 3e       	cpi	r25, 0xE8	; 232
    5ee4:	9c f0       	brlt	.+38     	; 0x5f0c <ldexp+0x66>
    5ee6:	bb 27       	eor	r27, r27
    5ee8:	86 95       	lsr	r24
    5eea:	77 95       	ror	r23
    5eec:	67 95       	ror	r22
    5eee:	b7 95       	ror	r27
    5ef0:	08 f4       	brcc	.+2      	; 0x5ef4 <ldexp+0x4e>
    5ef2:	b1 60       	ori	r27, 0x01	; 1
    5ef4:	93 95       	inc	r25
    5ef6:	c1 f7       	brne	.-16     	; 0x5ee8 <ldexp+0x42>
    5ef8:	bb 0f       	add	r27, r27
    5efa:	58 f7       	brcc	.-42     	; 0x5ed2 <ldexp+0x2c>
    5efc:	11 f4       	brne	.+4      	; 0x5f02 <ldexp+0x5c>
    5efe:	60 ff       	sbrs	r22, 0
    5f00:	e8 cf       	rjmp	.-48     	; 0x5ed2 <ldexp+0x2c>
    5f02:	6f 5f       	subi	r22, 0xFF	; 255
    5f04:	7f 4f       	sbci	r23, 0xFF	; 255
    5f06:	8f 4f       	sbci	r24, 0xFF	; 255
    5f08:	9f 4f       	sbci	r25, 0xFF	; 255
    5f0a:	e3 cf       	rjmp	.-58     	; 0x5ed2 <ldexp+0x2c>
    5f0c:	4f ce       	rjmp	.-866    	; 0x5bac <__fp_szero>
    5f0e:	0e f0       	brts	.+2      	; 0x5f12 <ldexp+0x6c>
    5f10:	85 cf       	rjmp	.-246    	; 0x5e1c <__fp_mpack>
    5f12:	07 ce       	rjmp	.-1010   	; 0x5b22 <__fp_nan>
    5f14:	68 94       	set
    5f16:	ff cd       	rjmp	.-1026   	; 0x5b16 <__fp_inf>

00005f18 <log>:
    5f18:	2e de       	rcall	.-932    	; 0x5b76 <__fp_splitA>
    5f1a:	c8 f3       	brcs	.-14     	; 0x5f0e <ldexp+0x68>
    5f1c:	99 23       	and	r25, r25
    5f1e:	d1 f3       	breq	.-12     	; 0x5f14 <ldexp+0x6e>
    5f20:	c6 f3       	brts	.-16     	; 0x5f12 <ldexp+0x6c>
    5f22:	df 93       	push	r29
    5f24:	cf 93       	push	r28
    5f26:	1f 93       	push	r17
    5f28:	0f 93       	push	r16
    5f2a:	ff 92       	push	r15
    5f2c:	c9 2f       	mov	r28, r25
    5f2e:	dd 27       	eor	r29, r29
    5f30:	88 23       	and	r24, r24
    5f32:	2a f0       	brmi	.+10     	; 0x5f3e <log+0x26>
    5f34:	21 97       	sbiw	r28, 0x01	; 1
    5f36:	66 0f       	add	r22, r22
    5f38:	77 1f       	adc	r23, r23
    5f3a:	88 1f       	adc	r24, r24
    5f3c:	da f7       	brpl	.-10     	; 0x5f34 <log+0x1c>
    5f3e:	20 e0       	ldi	r18, 0x00	; 0
    5f40:	30 e0       	ldi	r19, 0x00	; 0
    5f42:	40 e8       	ldi	r20, 0x80	; 128
    5f44:	5f eb       	ldi	r21, 0xBF	; 191
    5f46:	9f e3       	ldi	r25, 0x3F	; 63
    5f48:	88 39       	cpi	r24, 0x98	; 152
    5f4a:	20 f0       	brcs	.+8      	; 0x5f54 <log+0x3c>
    5f4c:	80 3e       	cpi	r24, 0xE0	; 224
    5f4e:	30 f0       	brcs	.+12     	; 0x5f5c <log+0x44>
    5f50:	21 96       	adiw	r28, 0x01	; 1
    5f52:	8f 77       	andi	r24, 0x7F	; 127
    5f54:	7e dc       	rcall	.-1796   	; 0x5852 <__addsf3>
    5f56:	ec e0       	ldi	r30, 0x0C	; 12
    5f58:	f1 e0       	ldi	r31, 0x01	; 1
    5f5a:	03 c0       	rjmp	.+6      	; 0x5f62 <log+0x4a>
    5f5c:	7a dc       	rcall	.-1804   	; 0x5852 <__addsf3>
    5f5e:	e9 e3       	ldi	r30, 0x39	; 57
    5f60:	f1 e0       	ldi	r31, 0x01	; 1
    5f62:	73 df       	rcall	.-282    	; 0x5e4a <__fp_powser>
    5f64:	8b 01       	movw	r16, r22
    5f66:	be 01       	movw	r22, r28
    5f68:	ec 01       	movw	r28, r24
    5f6a:	fb 2e       	mov	r15, r27
    5f6c:	6f 57       	subi	r22, 0x7F	; 127
    5f6e:	71 09       	sbc	r23, r1
    5f70:	75 95       	asr	r23
    5f72:	77 1f       	adc	r23, r23
    5f74:	88 0b       	sbc	r24, r24
    5f76:	99 0b       	sbc	r25, r25
    5f78:	6f dd       	rcall	.-1314   	; 0x5a58 <__floatsisf>
    5f7a:	28 e1       	ldi	r18, 0x18	; 24
    5f7c:	32 e7       	ldi	r19, 0x72	; 114
    5f7e:	41 e3       	ldi	r20, 0x31	; 49
    5f80:	5f e3       	ldi	r21, 0x3F	; 63
    5f82:	2a de       	rcall	.-940    	; 0x5bd8 <__mulsf3x>
    5f84:	af 2d       	mov	r26, r15
    5f86:	98 01       	movw	r18, r16
    5f88:	ae 01       	movw	r20, r28
    5f8a:	ff 90       	pop	r15
    5f8c:	0f 91       	pop	r16
    5f8e:	1f 91       	pop	r17
    5f90:	cf 91       	pop	r28
    5f92:	df 91       	pop	r29
    5f94:	6f dc       	rcall	.-1826   	; 0x5874 <__addsf3x>
    5f96:	d6 cd       	rjmp	.-1108   	; 0x5b44 <__fp_round>

00005f98 <modf>:
    5f98:	fa 01       	movw	r30, r20
    5f9a:	dc 01       	movw	r26, r24
    5f9c:	aa 0f       	add	r26, r26
    5f9e:	bb 1f       	adc	r27, r27
    5fa0:	9b 01       	movw	r18, r22
    5fa2:	ac 01       	movw	r20, r24
    5fa4:	bf 57       	subi	r27, 0x7F	; 127
    5fa6:	28 f4       	brcc	.+10     	; 0x5fb2 <modf+0x1a>
    5fa8:	22 27       	eor	r18, r18
    5faa:	33 27       	eor	r19, r19
    5fac:	44 27       	eor	r20, r20
    5fae:	50 78       	andi	r21, 0x80	; 128
    5fb0:	1f c0       	rjmp	.+62     	; 0x5ff0 <modf+0x58>
    5fb2:	b7 51       	subi	r27, 0x17	; 23
    5fb4:	88 f4       	brcc	.+34     	; 0x5fd8 <modf+0x40>
    5fb6:	ab 2f       	mov	r26, r27
    5fb8:	00 24       	eor	r0, r0
    5fba:	46 95       	lsr	r20
    5fbc:	37 95       	ror	r19
    5fbe:	27 95       	ror	r18
    5fc0:	01 1c       	adc	r0, r1
    5fc2:	a3 95       	inc	r26
    5fc4:	d2 f3       	brmi	.-12     	; 0x5fba <modf+0x22>
    5fc6:	00 20       	and	r0, r0
    5fc8:	69 f0       	breq	.+26     	; 0x5fe4 <modf+0x4c>
    5fca:	22 0f       	add	r18, r18
    5fcc:	33 1f       	adc	r19, r19
    5fce:	44 1f       	adc	r20, r20
    5fd0:	b3 95       	inc	r27
    5fd2:	da f3       	brmi	.-10     	; 0x5fca <modf+0x32>
    5fd4:	0d d0       	rcall	.+26     	; 0x5ff0 <modf+0x58>
    5fd6:	3c cc       	rjmp	.-1928   	; 0x5850 <__subsf3>
    5fd8:	61 30       	cpi	r22, 0x01	; 1
    5fda:	71 05       	cpc	r23, r1
    5fdc:	a0 e8       	ldi	r26, 0x80	; 128
    5fde:	8a 07       	cpc	r24, r26
    5fe0:	b9 46       	sbci	r27, 0x69	; 105
    5fe2:	30 f4       	brcc	.+12     	; 0x5ff0 <modf+0x58>
    5fe4:	9b 01       	movw	r18, r22
    5fe6:	ac 01       	movw	r20, r24
    5fe8:	66 27       	eor	r22, r22
    5fea:	77 27       	eor	r23, r23
    5fec:	88 27       	eor	r24, r24
    5fee:	90 78       	andi	r25, 0x80	; 128
    5ff0:	30 96       	adiw	r30, 0x00	; 0
    5ff2:	21 f0       	breq	.+8      	; 0x5ffc <modf+0x64>
    5ff4:	20 83       	st	Z, r18
    5ff6:	31 83       	std	Z+1, r19	; 0x01
    5ff8:	42 83       	std	Z+2, r20	; 0x02
    5ffa:	53 83       	std	Z+3, r21	; 0x03
    5ffc:	08 95       	ret

00005ffe <__mulsi3>:
    5ffe:	62 9f       	mul	r22, r18
    6000:	d0 01       	movw	r26, r0
    6002:	73 9f       	mul	r23, r19
    6004:	f0 01       	movw	r30, r0
    6006:	82 9f       	mul	r24, r18
    6008:	e0 0d       	add	r30, r0
    600a:	f1 1d       	adc	r31, r1
    600c:	64 9f       	mul	r22, r20
    600e:	e0 0d       	add	r30, r0
    6010:	f1 1d       	adc	r31, r1
    6012:	92 9f       	mul	r25, r18
    6014:	f0 0d       	add	r31, r0
    6016:	83 9f       	mul	r24, r19
    6018:	f0 0d       	add	r31, r0
    601a:	74 9f       	mul	r23, r20
    601c:	f0 0d       	add	r31, r0
    601e:	65 9f       	mul	r22, r21
    6020:	f0 0d       	add	r31, r0
    6022:	99 27       	eor	r25, r25
    6024:	72 9f       	mul	r23, r18
    6026:	b0 0d       	add	r27, r0
    6028:	e1 1d       	adc	r30, r1
    602a:	f9 1f       	adc	r31, r25
    602c:	63 9f       	mul	r22, r19
    602e:	b0 0d       	add	r27, r0
    6030:	e1 1d       	adc	r30, r1
    6032:	f9 1f       	adc	r31, r25
    6034:	bd 01       	movw	r22, r26
    6036:	cf 01       	movw	r24, r30
    6038:	11 24       	eor	r1, r1
    603a:	08 95       	ret

0000603c <__udivmodhi4>:
    603c:	aa 1b       	sub	r26, r26
    603e:	bb 1b       	sub	r27, r27
    6040:	51 e1       	ldi	r21, 0x11	; 17
    6042:	07 c0       	rjmp	.+14     	; 0x6052 <__udivmodhi4_ep>

00006044 <__udivmodhi4_loop>:
    6044:	aa 1f       	adc	r26, r26
    6046:	bb 1f       	adc	r27, r27
    6048:	a6 17       	cp	r26, r22
    604a:	b7 07       	cpc	r27, r23
    604c:	10 f0       	brcs	.+4      	; 0x6052 <__udivmodhi4_ep>
    604e:	a6 1b       	sub	r26, r22
    6050:	b7 0b       	sbc	r27, r23

00006052 <__udivmodhi4_ep>:
    6052:	88 1f       	adc	r24, r24
    6054:	99 1f       	adc	r25, r25
    6056:	5a 95       	dec	r21
    6058:	a9 f7       	brne	.-22     	; 0x6044 <__udivmodhi4_loop>
    605a:	80 95       	com	r24
    605c:	90 95       	com	r25
    605e:	bc 01       	movw	r22, r24
    6060:	cd 01       	movw	r24, r26
    6062:	08 95       	ret

00006064 <__divmodhi4>:
    6064:	97 fb       	bst	r25, 7
    6066:	09 2e       	mov	r0, r25
    6068:	07 26       	eor	r0, r23
    606a:	0a d0       	rcall	.+20     	; 0x6080 <__divmodhi4_neg1>
    606c:	77 fd       	sbrc	r23, 7
    606e:	04 d0       	rcall	.+8      	; 0x6078 <__divmodhi4_neg2>
    6070:	e5 df       	rcall	.-54     	; 0x603c <__udivmodhi4>
    6072:	06 d0       	rcall	.+12     	; 0x6080 <__divmodhi4_neg1>
    6074:	00 20       	and	r0, r0
    6076:	1a f4       	brpl	.+6      	; 0x607e <__divmodhi4_exit>

00006078 <__divmodhi4_neg2>:
    6078:	70 95       	com	r23
    607a:	61 95       	neg	r22
    607c:	7f 4f       	sbci	r23, 0xFF	; 255

0000607e <__divmodhi4_exit>:
    607e:	08 95       	ret

00006080 <__divmodhi4_neg1>:
    6080:	f6 f7       	brtc	.-4      	; 0x607e <__divmodhi4_exit>
    6082:	90 95       	com	r25
    6084:	81 95       	neg	r24
    6086:	9f 4f       	sbci	r25, 0xFF	; 255
    6088:	08 95       	ret

0000608a <__udivmodsi4>:
    608a:	a1 e2       	ldi	r26, 0x21	; 33
    608c:	1a 2e       	mov	r1, r26
    608e:	aa 1b       	sub	r26, r26
    6090:	bb 1b       	sub	r27, r27
    6092:	fd 01       	movw	r30, r26
    6094:	0d c0       	rjmp	.+26     	; 0x60b0 <__udivmodsi4_ep>

00006096 <__udivmodsi4_loop>:
    6096:	aa 1f       	adc	r26, r26
    6098:	bb 1f       	adc	r27, r27
    609a:	ee 1f       	adc	r30, r30
    609c:	ff 1f       	adc	r31, r31
    609e:	a2 17       	cp	r26, r18
    60a0:	b3 07       	cpc	r27, r19
    60a2:	e4 07       	cpc	r30, r20
    60a4:	f5 07       	cpc	r31, r21
    60a6:	20 f0       	brcs	.+8      	; 0x60b0 <__udivmodsi4_ep>
    60a8:	a2 1b       	sub	r26, r18
    60aa:	b3 0b       	sbc	r27, r19
    60ac:	e4 0b       	sbc	r30, r20
    60ae:	f5 0b       	sbc	r31, r21

000060b0 <__udivmodsi4_ep>:
    60b0:	66 1f       	adc	r22, r22
    60b2:	77 1f       	adc	r23, r23
    60b4:	88 1f       	adc	r24, r24
    60b6:	99 1f       	adc	r25, r25
    60b8:	1a 94       	dec	r1
    60ba:	69 f7       	brne	.-38     	; 0x6096 <__udivmodsi4_loop>
    60bc:	60 95       	com	r22
    60be:	70 95       	com	r23
    60c0:	80 95       	com	r24
    60c2:	90 95       	com	r25
    60c4:	9b 01       	movw	r18, r22
    60c6:	ac 01       	movw	r20, r24
    60c8:	bd 01       	movw	r22, r26
    60ca:	cf 01       	movw	r24, r30
    60cc:	08 95       	ret

000060ce <__divmodsi4>:
    60ce:	97 fb       	bst	r25, 7
    60d0:	09 2e       	mov	r0, r25
    60d2:	05 26       	eor	r0, r21
    60d4:	0e d0       	rcall	.+28     	; 0x60f2 <__divmodsi4_neg1>
    60d6:	57 fd       	sbrc	r21, 7
    60d8:	04 d0       	rcall	.+8      	; 0x60e2 <__divmodsi4_neg2>
    60da:	d7 df       	rcall	.-82     	; 0x608a <__udivmodsi4>
    60dc:	0a d0       	rcall	.+20     	; 0x60f2 <__divmodsi4_neg1>
    60de:	00 1c       	adc	r0, r0
    60e0:	38 f4       	brcc	.+14     	; 0x60f0 <__divmodsi4_exit>

000060e2 <__divmodsi4_neg2>:
    60e2:	50 95       	com	r21
    60e4:	40 95       	com	r20
    60e6:	30 95       	com	r19
    60e8:	21 95       	neg	r18
    60ea:	3f 4f       	sbci	r19, 0xFF	; 255
    60ec:	4f 4f       	sbci	r20, 0xFF	; 255
    60ee:	5f 4f       	sbci	r21, 0xFF	; 255

000060f0 <__divmodsi4_exit>:
    60f0:	08 95       	ret

000060f2 <__divmodsi4_neg1>:
    60f2:	f6 f7       	brtc	.-4      	; 0x60f0 <__divmodsi4_exit>
    60f4:	90 95       	com	r25
    60f6:	80 95       	com	r24
    60f8:	70 95       	com	r23
    60fa:	61 95       	neg	r22
    60fc:	7f 4f       	sbci	r23, 0xFF	; 255
    60fe:	8f 4f       	sbci	r24, 0xFF	; 255
    6100:	9f 4f       	sbci	r25, 0xFF	; 255
    6102:	08 95       	ret

00006104 <_exit>:
    6104:	f8 94       	cli

00006106 <__stop_program>:
    6106:	ff cf       	rjmp	.-2      	; 0x6106 <__stop_program>
